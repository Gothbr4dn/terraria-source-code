using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Xna.Framework;
using ReLogic.Utilities;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Biomes;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Events;
using Terraria.GameContent.Generation;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI.States;
using Terraria.Graphics.Capture;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.Map;
using Terraria.ObjectData;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria
{
	public class WorldGen
	{
		public static class WorldSize
		{
			public const int Small = 0;

			public const int Medium = 1;

			public const int Large = 2;
		}

		public static class SavedOreTiers
		{
			public static int Copper = 7;

			public static int Iron = 6;

			public static int Silver = 9;

			public static int Gold = 8;

			public static int Cobalt = 107;

			public static int Mythril = 108;

			public static int Adamantite = 111;
		}

		public static class Hooks
		{
			public delegate void WorldGenConfigProcessEvent(ref WorldGenConfiguration config);

			public static event WorldGenConfigProcessEvent OnWorldGenConfigProcess;

			public static event Action OnWorldLoad;

			public static void Initialize()
			{
				Player.Hooks.OnEnterWorld += delegate(Player player)
				{
					if (player.whoAmI == Main.myPlayer)
					{
						WorldLoaded();
						if (Main.netMode != 1)
						{
							Main.FixUIScale();
						}
					}
				};
				OnWorldLoad += mysticLogsEvent.StartWorld;
				OnWorldLoad += Main.checkHalloween;
				OnWorldLoad += Main.checkXMas;
			}

			public static void WorldLoaded()
			{
				if (Hooks.OnWorldLoad != null)
				{
					Hooks.OnWorldLoad();
				}
			}

			public static void ClearWorld()
			{
				PressurePlateHelper.Reset();
				TownManager.Clear();
				NPC.ResetKillCount();
				Main.instance.ClearCachedTileDraws();
				MapHelper.ResetMapData();
			}

			public static void ProcessWorldGenConfig(ref WorldGenConfiguration config)
			{
				if (Hooks.OnWorldGenConfigProcess != null)
				{
					Hooks.OnWorldGenConfigProcess(ref config);
				}
			}
		}

		public static class Spread
		{
			public static void Wall(int x, int y, int wallType)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort wall = (ushort)wallType;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active() && tile.wall == 0)
							{
								tile.wall = wall;
							}
							continue;
						}
						tile.wall = wall;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}

			public static void Wall2(int x, int y, int wallType)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort num = (ushort)wallType;
				int num2 = 0;
				int maxWallOut = maxWallOut2;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (!SolidTile(item.X, item.Y) && tile.wall != num && tile.wall != 4 && tile.wall != 40 && tile.wall != 3 && tile.wall != 87 && tile.wall != 34)
						{
							bool flag = num == 63 || num == 62;
							if (flag && tile.wall == 0)
							{
								list.Remove(item);
								continue;
							}
							num2++;
							if (num2 >= maxWallOut)
							{
								list.Remove(item);
								continue;
							}
							tile.wall = num;
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							if (flag)
							{
								item2 = new Point(item.X - 1, item.Y - 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X + 1, item.Y - 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X - 1, item.Y + 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X + 1, item.Y + 1);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X - 2, item.Y);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
								item2 = new Point(item.X + 2, item.Y);
								if (!hashSet.Contains(item2))
								{
									list2.Add(item2);
								}
							}
						}
						else if (tile.active() && tile.wall != num && tile.wall != 4 && tile.wall != 40 && tile.wall != 3 && tile.wall != 87 && tile.wall != 34)
						{
							tile.wall = num;
						}
					}
				}
			}

			public static void Moss(int x, int y)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort mossWall = GenVars.mossWall;
				ushort mossTile = GenVars.mossTile;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active())
							{
								if (tile.wall == 0)
								{
									tile.wall = mossWall;
								}
								if (tile.type == 1)
								{
									tile.type = mossTile;
								}
							}
							continue;
						}
						tile.wall = mossWall;
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}

			public static void Gem(int x, int y)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active())
							{
								if (Gemmable(tile.type))
								{
									tile.type = randGemTile();
								}
								Tile tile2 = Main.tile[item.X - 1, item.Y];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
								tile2 = Main.tile[item.X + 1, item.Y];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
								tile2 = Main.tile[item.X, item.Y - 1];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
								tile2 = Main.tile[item.X, item.Y + 1];
								if (Gemmable(tile2.type))
								{
									tile2.type = randGemTile();
								}
							}
						}
						else
						{
							tile.wall = (ushort)(48 + randGem());
							if (!tile.active() && genRand.Next(2) == 0)
							{
								PlaceTile(item.X, item.Y, 178, mute: true, forced: false, -1, randGem());
							}
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
						}
					}
				}
			}

			public static void Spider(int x, int y)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				byte wall = 62;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (SolidTile(item.X, item.Y) || tile.wall != 0)
						{
							if (tile.active() && tile.wall == 0)
							{
								tile.wall = wall;
							}
							continue;
						}
						tile.wall = wall;
						SquareWallFrame(item.X, item.Y);
						if (!tile.active())
						{
							tile.liquid = 0;
							tile.lava(lava: false);
							if (SolidTile(item.X, item.Y + 1) && genRand.Next(3) == 0)
							{
								if (genRand.Next(15) == 0)
								{
									AddBuriedChest(item.X, item.Y, 939, notNearOtherChests: true, 15, trySlope: false, 0);
								}
								else
								{
									PlacePot(item.X, item.Y, 28, genRand.Next(19, 21));
								}
							}
							if (!tile.active())
							{
								if (SolidTile(item.X, item.Y - 1) && genRand.Next(3) == 0)
								{
									PlaceTight(item.X, item.Y, spiders: true);
								}
								else if (SolidTile(item.X, item.Y + 1))
								{
									PlaceTile(item.X, item.Y, 187, mute: true, forced: false, -1, 9 + genRand.Next(5));
									if (genRand.Next(3) == 0)
									{
										if (!tile.active())
										{
											PlaceSmallPile(item.X, item.Y, 34 + genRand.Next(4), 1, 185);
										}
										if (!tile.active())
										{
											PlaceSmallPile(item.X, item.Y, 48 + genRand.Next(6), 0, 185);
										}
									}
								}
							}
						}
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}

			public static void WallDungeon(int x, int y, int wallType)
			{
				if (!InWorld(x, y))
				{
					return;
				}
				ushort num = (ushort)wallType;
				List<Point> list = new List<Point>();
				List<Point> list2 = new List<Point>();
				HashSet<Point> hashSet = new HashSet<Point>();
				list2.Add(new Point(x, y));
				while (list2.Count > 0)
				{
					list.Clear();
					list.AddRange(list2);
					list2.Clear();
					while (list.Count > 0)
					{
						Point item = list[0];
						if (!InWorld(item.X, item.Y, 1))
						{
							list.Remove(item);
							continue;
						}
						hashSet.Add(item);
						list.Remove(item);
						Tile tile = Main.tile[item.X, item.Y];
						if (!SolidTile(item.X, item.Y) && tile.wall != num && tile.wall > 0 && tile.wall != 244)
						{
							tile.wall = num;
							Point item2 = new Point(item.X - 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X + 1, item.Y);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y - 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
							item2 = new Point(item.X, item.Y + 1);
							if (!hashSet.Contains(item2))
							{
								list2.Add(item2);
							}
						}
						else if (tile.active())
						{
							tile.wall = num;
						}
					}
				}
			}

			private static bool Gemmable(int type)
			{
				if (type != 0 && type != 1 && type != 40 && type != 59 && type != 60 && type != 70 && type != 147)
				{
					return type == 161;
				}
				return true;
			}
		}

		public static class TenthAnniversaryWorldInfo
		{
			public static int[] GoodPrefixIdsForAccessory = new int[4] { 65, 68, 72, 76 };

			public static int[] GoodPrefixIdsForMeleeWeapon = new int[3] { 81, 59, 57 };

			public static int[] GoodPrefixIdsForRangedWeapon = new int[3] { 82, 57, 60 };

			public static int[] GoodPrefixIdsForMagicWeapon = new int[3] { 83, 57, 60 };

			public static int[] GoodPrefixIdsForSummonerWeapon = new int[3] { 83, 57, 60 };
		}

		public struct GrowTreeSettings
		{
			public delegate bool IsTileFitForTreeGroundTest(int tileType);

			public delegate bool IsWallTypeFitForTreeBack(int wallType);

			public static class Profiles
			{
				public static GrowTreeSettings GemTree_Ruby = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 587,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings GemTree_Diamond = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 588,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings GemTree_Topaz = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 583,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings GemTree_Amethyst = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 584,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings GemTree_Sappphire = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 585,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings GemTree_Emerald = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 586,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings GemTree_Amber = new GrowTreeSettings
				{
					GroundTest = GemTreeGroundTest,
					WallTest = GemTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 589,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 590
				};

				public static GrowTreeSettings VanityTree_Sakura = new GrowTreeSettings
				{
					GroundTest = VanityTreeGroundTest,
					WallTest = DefaultTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 596,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 595
				};

				public static GrowTreeSettings VanityTree_Willow = new GrowTreeSettings
				{
					GroundTest = VanityTreeGroundTest,
					WallTest = DefaultTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 616,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 615
				};

				public static GrowTreeSettings Tree_Ash = new GrowTreeSettings
				{
					GroundTest = AshTreeGroundTest,
					WallTest = DefaultTreeWallTest,
					TreeHeightMax = 12,
					TreeHeightMin = 7,
					TreeTileType = 634,
					TreeTopPaddingNeeded = 4,
					SaplingTileType = 20
				};

				public static bool TryGetFromItemId(int itemType, out GrowTreeSettings profile)
				{
					switch (itemType)
					{
					default:
						profile = default(GrowTreeSettings);
						return false;
					case 4857:
						profile = GemTree_Amber;
						return true;
					case 4852:
						profile = GemTree_Amethyst;
						return true;
					case 4856:
						profile = GemTree_Diamond;
						return true;
					case 4854:
						profile = GemTree_Emerald;
						return true;
					case 4855:
						profile = GemTree_Ruby;
						return true;
					case 4853:
						profile = GemTree_Sappphire;
						return true;
					case 4851:
						profile = GemTree_Topaz;
						return true;
					case 4907:
						profile = VanityTree_Willow;
						return true;
					case 4871:
						profile = VanityTree_Sakura;
						return true;
					}
				}
			}

			public ushort TreeTileType;

			public int TreeHeightMin;

			public int TreeHeightMax;

			public int TreeTopPaddingNeeded;

			public IsTileFitForTreeGroundTest GroundTest;

			public IsWallTypeFitForTreeBack WallTest;

			public ushort SaplingTileType;
		}

		public struct CheckTreeSettings
		{
			public delegate bool GroundValidTest(int groundTileType);

			public GroundValidTest IsGroundValid;
		}

		public enum SpecialKillTileContext
		{
			None,
			MowingTheGrass
		}

		public delegate bool GetTreeFoliageDataMethod(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight);

		public struct TileMergeCullCache
		{
			public bool CullTop;

			public bool CullBottom;

			public bool CullLeft;

			public bool CullRight;

			public bool CullTopLeft;

			public bool CullTopRight;

			public bool CullBottomLeft;

			public bool CullBottomRight;

			public void Cull(ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
			{
				if (CullTop)
				{
					up = -1;
				}
				if (CullBottom)
				{
					down = -1;
				}
				if (CullLeft)
				{
					left = -1;
				}
				if (CullRight)
				{
					right = -1;
				}
				if (CullTopLeft)
				{
					upLeft = -1;
				}
				if (CullTopRight)
				{
					upRight = -1;
				}
				if (CullBottomLeft)
				{
					downLeft = -1;
				}
				if (CullBottomRight)
				{
					downRight = -1;
				}
			}
		}

		public static TownRoomManager TownManager = new TownRoomManager();

		private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();

		public static int tileReframeCount;

		public static bool noMapUpdate;

		public static int treeBG1;

		public static int treeBG2;

		public static int treeBG3;

		public static int treeBG4;

		public static int corruptBG;

		public static int jungleBG;

		public static int snowBG;

		public static int hallowBG;

		public static int crimsonBG;

		public static int desertBG;

		public static int oceanBG;

		public static int mushroomBG;

		public static int underworldBG;

		public static readonly int oceanDistance = 250;

		public static readonly int beachDistance = 380;

		public static readonly int shimmerSafetyDistance = 150;

		public static bool crimson;

		public static int[] tileCounts = new int[693];

		public static int totalEvil;

		public static int totalBlood;

		public static int totalGood;

		public static int totalSolid;

		public static int totalEvil2;

		public static int totalBlood2;

		public static int totalGood2;

		public static int totalSolid2;

		public static byte tEvil;

		public static byte tBlood;

		public static byte tGood;

		public static string currentWorldSeed;

		public static int totalX;

		public static int totalD;

		public static bool IsGeneratingHardMode;

		public static bool noTileActions;

		public static bool spawnEye;

		public static int spawnHardBoss;

		public static volatile bool gen;

		public static bool shadowOrbSmashed;

		public static int shadowOrbCount;

		public static int altarCount;

		public static bool spawnMeteor;

		public static bool loadFailed = false;

		public static bool loadSuccess = false;

		public static bool worldCleared;

		public static bool worldBackup;

		public static bool loadBackup = false;

		private static int lastMaxTilesX;

		private static int lastMaxTilesY;

		private static bool mergeUp;

		private static bool mergeDown;

		private static bool mergeLeft;

		private static bool mergeRight;

		private static bool stopDrops;

		public static bool noLiquidCheck;

		public static bool AllowedToSpreadInfections = true;

		[ThreadStatic]
		public static UnifiedRandom _genRand;

		[ThreadStatic]
		public static int _genRandSeed = -2;

		public static int _lastSeed;

		public static string statusText = "";

		public static bool destroyObject;

		public static int spawnDelay;

		public static int prioritizedTownNPCType;

		public static int numTileCount;

		public static int maxTileCount = 3500;

		public static int maxWallOut2 = 5000;

		public static Dictionary<Point, bool> CountedTiles = new Dictionary<Point, bool>(maxTileCount);

		public static int lavaCount;

		public static int iceCount;

		public static int sandCount;

		public static int rockCount;

		public static int shroomCount;

		public static int maxRoomTiles = 750;

		public static int numRoomTiles;

		public static int[] roomX = new int[maxRoomTiles];

		public static int[] roomY = new int[maxRoomTiles];

		public static int roomCeilingsCount;

		public static int[] roomCeilingX = new int[maxRoomTiles];

		public static int[] roomCeilingY = new int[maxRoomTiles];

		public static int roomX1;

		public static int roomX2;

		public static int roomY1;

		public static int roomY2;

		public static bool canSpawn;

		public static bool[] houseTile = new bool[693];

		public static int bestX;

		public static int bestY;

		public static int hiScore;

		private static bool roomTorch;

		private static bool roomDoor;

		private static bool roomChair;

		private static bool roomTable;

		private static bool roomOccupied;

		private static bool roomEvil;

		private static bool roomHasStinkbug;

		private static bool roomHasEchoStinkbug;

		public static int WorldGenParam_Evil = -1;

		public static readonly int cactusWaterWidth = 50;

		public static readonly int cactusWaterHeight = 25;

		public static readonly int cactusWaterLimit = 25;

		public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();

		private static bool currentlyTryingToUseAlternateHousingSpot;

		private static int sharedRoomX;

		public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;

		public const int WorldSizeSmallX = 4200;

		public const int WorldSizeSmallY = 1200;

		public const int WorldSizeMediumX = 6400;

		public const int WorldSizeMediumY = 1800;

		public const int WorldSizeLargeX = 8400;

		public const int WorldSizeLargeY = 2400;

		public static bool generatingWorld = false;

		private static int[,] trapDiag = new int[4, 2];

		private static bool[] gem = new bool[6];

		private static int[] mossType = new int[3];

		private static ushort neonMossType;

		private static int tileCounterNum;

		private static int tileCounterMax = 20;

		private static int[] tileCounterX = new int[tileCounterMax];

		private static int[] tileCounterY = new int[tileCounterMax];

		private static WorldGenerator _generator;

		public static int SmallConsecutivesFound = 0;

		public static int SmallConsecutivesEliminated = 0;

		public static bool tempRemixWorldGen = false;

		public static bool remixWorldGen = false;

		public static bool everythingWorldGen = false;

		public static bool noTrapsWorldGen = false;

		public static bool drunkWorldGen = false;

		public static bool getGoodWorldGen = false;

		public static bool tempTenthAnniversaryWorldGen = false;

		public static bool tenthAnniversaryWorldGen = false;

		public static bool dontStarveWorldGen = false;

		public static bool notTheBees = false;

		public static bool drunkWorldGenText = false;

		public static bool placingTraps = false;

		public const bool USE_FRAMING_SKIP_FOR_UNIMPORTANT_TILES_IN_WORLDGEN = false;

		private static List<Color> _coatingColors = new List<Color>();

		private static int catTailDistance = 8;

		public static TreeTopsInfo TreeTops = new TreeTopsInfo();

		public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();

		private static int maxTreeShakes = 500;

		private static int numTreeShakes = 0;

		private static int[] treeShakeX = new int[maxTreeShakes];

		private static int[] treeShakeY = new int[maxTreeShakes];

		private static bool fossilBreak = false;

		public static Queue<Point> ExploitDestroyQueue = new Queue<Point>();

		private static bool growGrassUnderground = false;

		public const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;

		public static int grassSpread;

		private static Point[] heartPos = new Point[100];

		private static int heartCount;

		private const int strip_w = 200;

		private const int strip_h = 50;

		private static readonly Vertical64BitStrips bitStrip = new Vertical64BitStrips(202);

		public static bool noMapUpdateRefresh = false;

		private static bool skipFramingDuringGen = false;

		public static UnifiedRandom genRand
		{
			get
			{
				if (_lastSeed != _genRandSeed)
				{
					_genRand = new UnifiedRandom(_lastSeed);
					_genRandSeed = _lastSeed;
				}
				if (_genRand == null)
				{
					_genRand = new UnifiedRandom(_lastSeed);
					_genRandSeed = _lastSeed;
				}
				return _genRand;
			}
		}

		public static double oceanLevel => (Main.worldSurface + Main.rockLayer) / 2.0 + 40.0;

		public static bool SkipFramingBecauseOfGen
		{
			get
			{
				if (generatingWorld)
				{
					return skipFramingDuringGen;
				}
				return false;
			}
		}

		public static void SetupStatueList()
		{
			List<Point16> list = new List<Point16>();
			for (int i = 0; i < 44; i++)
			{
				list.Add(new Point16(105, i));
			}
			list[34] = new Point16(349, 0);
			list[43] = new Point16(105, 50);
			list.Add(new Point16(105, 63));
			list.Add(new Point16(105, 64));
			list.Add(new Point16(105, 65));
			list.Add(new Point16(105, 66));
			list.Add(new Point16(105, 68));
			list.Add(new Point16(105, 69));
			list.Add(new Point16(105, 70));
			list.Add(new Point16(105, 71));
			list.Add(new Point16(105, 72));
			list.Add(new Point16(105, 73));
			list.Add(new Point16(105, 75));
			list.Add(new Point16(105, 51));
			list.Add(new Point16(105, 52));
			list.Add(new Point16(105, 53));
			list.Add(new Point16(105, 54));
			list.Add(new Point16(105, 55));
			list.Add(new Point16(105, 56));
			list.Add(new Point16(105, 57));
			list.Add(new Point16(105, 58));
			list.Add(new Point16(105, 59));
			list.Add(new Point16(105, 60));
			list.Add(new Point16(105, 61));
			list.Add(new Point16(105, 62));
			list.Add(new Point16(105, 77));
			list.Add(new Point16(105, 78));
			list.Add(new Point16(105, 67));
			list.Add(new Point16(105, 74));
			list.Add(new Point16(105, 37));
			list.Add(new Point16(105, 2));
			GenVars.statueList = list.ToArray();
		}

		public static void PlaceStatueTrap(int x, int y)
		{
			for (int i = -10; i <= 10; i++)
			{
				for (int j = -10; j <= 10; j++)
				{
					Tile tile = Main.tile[x + i, y + j + 1];
					Tile tile2 = Main.tile[x + i, y + j];
					if (!tile2.active() && SolidTile2(tile) && tile.type != 162)
					{
						PlaceTile(x + i, y + j, 135, mute: true);
						if (tile2.active() && tile2.type == 135)
						{
							WorldUtils.WireLine(new Point(x, y), new Point(x + i, y + j));
							return;
						}
					}
				}
			}
		}

		private static EntitySource_TileBreak GetProjectileSource_TileBreak(int x, int y)
		{
			return new EntitySource_TileBreak(x, y);
		}

		private static EntitySource_TileBreak GetNPCSource_TileBreak(int x, int y)
		{
			return new EntitySource_TileBreak(x, y);
		}

		public static EntitySource_ShakeTree GetNPCSource_ShakeTree(int x, int y)
		{
			return new EntitySource_ShakeTree(x, y);
		}

		private static EntitySource_ShakeTree GetProjectileSource_ShakeTree(int x, int y)
		{
			return new EntitySource_ShakeTree(x, y);
		}

		private static EntitySource_ShakeTree GetItemSource_ShakeTree(int x, int y)
		{
			return new EntitySource_ShakeTree(x, y);
		}

		private static IEntitySource GetProjectileSource_PlayerOrWires(int x, int y, bool fromWiring, Player player)
		{
			if (fromWiring)
			{
				return new EntitySource_Wiring(x, y);
			}
			return new EntitySource_TileInteraction(player, x, y);
		}

		public static bool EmptyLiquid(int x, int y)
		{
			if (!InWorld(x, y))
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile == null)
			{
				return false;
			}
			tile.liquidType();
			if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return false;
			}
			tile.Clear(TileDataType.Liquid);
			SquareTileFrame(x, y, resetFrame: false);
			if (Main.netMode != 0)
			{
				NetMessage.sendWater(x, y);
			}
			else
			{
				Liquid.AddWater(x, y);
			}
			return true;
		}

		public static bool PlaceLiquid(int x, int y, byte liquidType, byte amount)
		{
			if (!InWorld(x, y))
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile == null)
			{
				return false;
			}
			byte b = tile.liquidType();
			if (tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return false;
			}
			if (tile.liquid == 0 || liquidType == b)
			{
				tile.liquidType(liquidType);
				if (amount + tile.liquid > 255)
				{
					amount = (byte)(255 - tile.liquid);
				}
				tile.liquid += amount;
				SquareTileFrame(x, y);
				if (Main.netMode != 0)
				{
					NetMessage.sendWater(x, y);
				}
				return true;
			}
			int liquidMergeTileType = 0;
			bool waterNearby = b == 0;
			bool lavaNearby = b == 1;
			bool honeyNearby = b == 2;
			bool shimmerNearby = b == 3;
			int liquidMergeType = 0;
			Liquid.GetLiquidMergeTypes(liquidType, out liquidMergeTileType, out liquidMergeType, waterNearby, lavaNearby, honeyNearby, shimmerNearby);
			if (liquidMergeTileType != 0)
			{
				tile.liquid = 0;
				tile.liquidType(0);
				PlaceTile(x, y, liquidMergeTileType, mute: true);
				SquareTileFrame(x, y);
				if (Main.netMode != 0)
				{
					NetMessage.SendTileSquare(-1, x - 1, y - 1, GetLiquidChangeType(liquidType, b));
				}
				return true;
			}
			return false;
		}

		public static void PlayLiquidChangeSound(TileChangeType eventType, int x, int y, int count = 1)
		{
			switch (eventType)
			{
			case TileChangeType.LavaWater:
				SoundEngine.PlaySound(SoundID.LiquidsWaterLava, x * 16 + count * 8, y * 16 + count * 8);
				break;
			case TileChangeType.HoneyWater:
				SoundEngine.PlaySound(SoundID.LiquidsHoneyWater, x * 16 + count * 8, y * 16 + count * 8);
				break;
			case TileChangeType.HoneyLava:
				SoundEngine.PlaySound(SoundID.LiquidsHoneyLava, x * 16 + count * 8, y * 16 + count * 8);
				break;
			case TileChangeType.ShimmerWater:
				SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
				break;
			case TileChangeType.ShimmerLava:
				SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
				break;
			case TileChangeType.ShimmerHoney:
				SoundEngine.PlaySound(19, x * 16 + count * 8, y * 16 + count * 8, 4);
				break;
			}
		}

		public static TileChangeType GetLiquidChangeType(int liquidType, int otherLiquidType)
		{
			if ((liquidType == 0 && otherLiquidType == 1) || (liquidType == 1 && otherLiquidType == 0))
			{
				return TileChangeType.LavaWater;
			}
			if ((liquidType == 0 && otherLiquidType == 2) || (liquidType == 2 && otherLiquidType == 0))
			{
				return TileChangeType.HoneyWater;
			}
			if ((liquidType == 1 && otherLiquidType == 2) || (liquidType == 2 && otherLiquidType == 1))
			{
				return TileChangeType.HoneyLava;
			}
			if ((liquidType == 0 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 0))
			{
				return TileChangeType.ShimmerWater;
			}
			if ((liquidType == 1 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 1))
			{
				return TileChangeType.ShimmerLava;
			}
			if ((liquidType == 2 && otherLiquidType == 3) || (liquidType == 3 && otherLiquidType == 2))
			{
				return TileChangeType.ShimmerHoney;
			}
			return TileChangeType.None;
		}

		public static bool MoveTownNPC(int x, int y, int n)
		{
			if (!StartRoomCheck(x, y))
			{
				string newText = Lang.inter[40].Value;
				switch (roomCheckFailureReason)
				{
				case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
					break;
				case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
					break;
				case TownNPCRoomCheckFailureReason.RoomIsTooBig:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
					break;
				case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
					break;
				case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
					newText = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
					break;
				}
				Main.NewText(newText, byte.MaxValue, 240, 20);
				return false;
			}
			if (!RoomNeeds(prioritizedTownNPCType))
			{
				int num = 0;
				int num2 = ((!roomTorch) ? 1 : 0) + ((!roomDoor) ? 1 : 0) + ((!roomTable) ? 1 : 0) + ((!roomChair) ? 1 : 0);
				string[] array = new string[num2];
				if (!roomTorch)
				{
					array[num] = Language.GetTextValue("Game.HouseLightSource");
					num++;
				}
				if (!roomDoor)
				{
					array[num] = Language.GetTextValue("Game.HouseDoor");
					num++;
				}
				if (!roomTable)
				{
					array[num] = Language.GetTextValue("Game.HouseTable");
					num++;
				}
				if (!roomChair)
				{
					array[num] = Language.GetTextValue("Game.HouseChair");
					num++;
				}
				string key = "Game.HouseMissing_" + num2;
				object[] args = array;
				Main.NewText(Language.GetTextValue(key, args), byte.MaxValue, 240, 20);
				return false;
			}
			int type = prioritizedTownNPCType;
			if (n >= 0)
			{
				type = Main.npc[n].type;
			}
			bool flag = NPCID.Sets.IsTownPet[type];
			if (roomHasStinkbug && !flag)
			{
				Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAStinkbug"), byte.MaxValue, 240, 20);
				return false;
			}
			if (roomHasEchoStinkbug && !flag)
			{
				Main.NewText(Language.GetTextValue("TownNPCHousingFailureReasons.RoomHasAnEchoStinkbug"), byte.MaxValue, 240, 20);
				return false;
			}
			ScoreRoom(-1, type);
			if (hiScore <= 0)
			{
				if (roomOccupied)
				{
					Main.NewText(Lang.inter[41].Value, byte.MaxValue, 240, 20);
				}
				else if (roomEvil)
				{
					Main.NewText(Lang.inter[42].Value, byte.MaxValue, 240, 20);
				}
				else
				{
					Main.NewText(Lang.inter[40].Value, byte.MaxValue, 240, 20);
				}
				return false;
			}
			if (n >= 0 && !CheckSpecialTownNPCSpawningConditions(Main.npc[n].type))
			{
				Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, byte.MaxValue, 240, 20);
				return false;
			}
			return true;
		}

		public static void moveRoom(int x, int y, int n)
		{
			if (Main.netMode == 1)
			{
				NetMessage.SendData(60, -1, -1, null, n, x, y);
				return;
			}
			prioritizedTownNPCType = Main.npc[n].type;
			Main.npc[n].homeless = true;
			SpawnTownNPC(x, y);
			TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
		}

		public static bool IsNPCEvictable(int n)
		{
			if (n < 0)
			{
				return false;
			}
			Rectangle hitbox = Main.LocalPlayer.Hitbox;
			hitbox.Inflate(Main.LogicCheckScreenWidth / 2, Main.LogicCheckScreenHeight / 2);
			NPC nPC = Main.npc[n];
			Rectangle value = new Rectangle(nPC.homeTileX * 16, nPC.homeTileY * 16, 16, 16);
			return hitbox.Intersects(value);
		}

		public static void kickOut(int n)
		{
			if (Main.netMode == 1)
			{
				NetMessage.SendData(60, -1, -1, null, n, 0f, 0f, 1f);
				return;
			}
			Main.npc[n].homeless = true;
			TownManager.KickOut(Main.npc[n]);
		}

		public static bool IsThereASpawnablePrioritizedTownNPC(int x, int y, ref bool canSpawnNewTownNPC)
		{
			if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
			{
				canSpawnNewTownNPC = false;
				return true;
			}
			List<int> list = new List<int>();
			TownManager.AddOccupantsToList(x, y, list);
			for (int i = 0; i < list.Count; i++)
			{
				int num = list[i];
				if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
				{
					prioritizedTownNPCType = num;
					canSpawnNewTownNPC = true;
					return true;
				}
			}
			for (int j = 0; j < 688; j++)
			{
				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
				{
					continue;
				}
				if (NPC.AnyNPCs(j))
				{
					Main.townNPCCanSpawn[j] = false;
					continue;
				}
				if (TownManager.HasRoomQuick(j))
				{
					prioritizedTownNPCType = j;
					canSpawnNewTownNPC = true;
					return true;
				}
				if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
				{
					prioritizedTownNPCType = j;
					canSpawnNewTownNPC = true;
					return true;
				}
			}
			return false;
		}

		public static bool IsThereASpawnablePrioritizedTownNPC_Old(int x, int y)
		{
			if (CheckSpecialTownNPCSpawningConditions(prioritizedTownNPCType) && NPC.AnyNPCs(prioritizedTownNPCType))
			{
				return true;
			}
			List<int> list = new List<int>();
			TownManager.AddOccupantsToList(x, y, list);
			for (int i = 0; i < list.Count; i++)
			{
				int num = list[i];
				if (Main.townNPCCanSpawn[num] && !NPC.AnyNPCs(num) && CheckSpecialTownNPCSpawningConditions(num))
				{
					prioritizedTownNPCType = num;
					return true;
				}
			}
			int num2 = -1;
			for (int j = 0; j < 688; j++)
			{
				if (!Main.townNPCCanSpawn[j] || !CheckSpecialTownNPCSpawningConditions(j))
				{
					continue;
				}
				if (NPC.AnyNPCs(j))
				{
					Main.townNPCCanSpawn[j] = false;
				}
				else if (TownManager.HasRoomQuick(j))
				{
					if (num2 == -1)
					{
						num2 = j;
					}
				}
				else if (!NPCID.Sets.IsTownPet[prioritizedTownNPCType] || NPCID.Sets.IsTownPet[j])
				{
					prioritizedTownNPCType = j;
					return true;
				}
			}
			if (num2 != -1)
			{
				prioritizedTownNPCType = num2;
				return true;
			}
			return false;
		}

		public static bool CheckSpecialTownNPCSpawningConditions(int type)
		{
			if (type == 160)
			{
				if (!NPC.unlockedTruffleSpawn && (double)roomY2 > Main.worldSurface)
				{
					return false;
				}
				Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
				int num = 0;
				for (int i = startX + 1; i < endX; i++)
				{
					for (int j = startY + 2; j < endY + 2; j++)
					{
						Tile tile = Main.tile[i, j];
						if (tile.active() && (tile.type == 70 || tile.type == 71 || tile.type == 72 || tile.type == 528))
						{
							num++;
						}
					}
				}
				if (num >= SceneMetrics.MushroomTileThreshold)
				{
					return true;
				}
				return false;
			}
			return true;
		}

		public static void UnspawnTravelNPC()
		{
			int num = -1;
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type == 368)
				{
					num = i;
					break;
				}
			}
			if (num < 0)
			{
				return;
			}
			int num2 = (int)(Main.npc[num].Center.X / 16f);
			int num3 = (int)(Main.npc[num].Center.Y / 16f);
			bool flag = true;
			Rectangle value = new Rectangle(num2 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num3 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
			for (int j = 0; j < 255; j++)
			{
				if (Main.player[j].active && new Rectangle((int)Main.player[j].position.X, (int)Main.player[j].position.Y, Main.player[j].width, Main.player[j].height).Intersects(value))
				{
					flag = false;
					break;
				}
			}
			if (flag)
			{
				string fullName = Main.npc[num].FullName;
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[35].Format(fullName), 50, 125);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, Main.npc[num].GetFullNetName()), new Color(50, 125, 255));
				}
				Main.npc[num].active = false;
				Main.npc[num].netSkip = -1;
				Main.npc[num].life = 0;
				NetMessage.SendData(23, -1, -1, null, num);
			}
		}

		public static void SpawnTravelNPC()
		{
			if (Main.eclipse || !Main.dayTime || (Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0))
			{
				return;
			}
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type == 368)
				{
					return;
				}
			}
			Chest.SetupTravelShop();
			NetMessage.SendTravelShop(-1);
			int num = 0;
			int[] array = new int[200];
			int num2 = 0;
			for (int j = 0; j < 200; j++)
			{
				if (Main.npc[j].active && Main.npc[j].townNPC && Main.npc[j].type != 37 && !Main.npc[j].homeless)
				{
					array[num2] = j;
					num2++;
				}
			}
			if (num2 == 0)
			{
				return;
			}
			num = array[Main.rand.Next(num2)];
			bestX = Main.npc[num].homeTileX;
			bestY = Main.npc[num].homeTileY;
			int minValue = bestX;
			int num3 = bestX;
			int num4 = bestY;
			int num5 = bestX;
			while (num5 > bestX - 10 && (SolidTile(num5, num4) || Main.tileSolidTop[Main.tile[num5, num4].type]) && (!Main.tile[num5, num4 - 1].active() || !Main.tileSolid[Main.tile[num5, num4 - 1].type] || Main.tileSolidTop[Main.tile[num5, num4 - 1].type]) && (!Main.tile[num5, num4 - 2].active() || !Main.tileSolid[Main.tile[num5, num4 - 2].type] || Main.tileSolidTop[Main.tile[num5, num4 - 2].type]) && (!Main.tile[num5, num4 - 3].active() || !Main.tileSolid[Main.tile[num5, num4 - 3].type] || Main.tileSolidTop[Main.tile[num5, num4 - 3].type]))
			{
				minValue = num5;
				num5--;
			}
			for (int k = bestX; k < bestX + 10 && (SolidTile(k, num4) || Main.tileSolidTop[Main.tile[k, num4].type]) && (!Main.tile[k, num4 - 1].active() || !Main.tileSolid[Main.tile[k, num4 - 1].type] || Main.tileSolidTop[Main.tile[k, num4 - 1].type]) && (!Main.tile[k, num4 - 2].active() || !Main.tileSolid[Main.tile[k, num4 - 2].type] || Main.tileSolidTop[Main.tile[k, num4 - 2].type]) && (!Main.tile[k, num4 - 3].active() || !Main.tileSolid[Main.tile[k, num4 - 3].type] || Main.tileSolidTop[Main.tile[k, num4 - 3].type]); k++)
			{
				num3 = k;
			}
			for (int l = 0; l < 30; l++)
			{
				int num6 = Main.rand.Next(minValue, num3 + 1);
				if (l < 20)
				{
					if (num6 < bestX - 1 || num6 > bestX + 1)
					{
						bestX = num6;
						break;
					}
				}
				else if (num6 != bestX)
				{
					bestX = num6;
					break;
				}
			}
			int num7 = bestX;
			int num8 = bestY;
			bool flag = false;
			if (!flag && !((double)num8 > Main.worldSurface))
			{
				for (int m = 20; m < 500; m++)
				{
					for (int n = 0; n < 2; n++)
					{
						num7 = ((n != 0) ? (bestX - m * 2) : (bestX + m * 2));
						if (num7 > 10 && num7 < Main.maxTilesX - 10)
						{
							int num9 = bestY - m;
							double num10 = bestY + m;
							if (num9 < 10)
							{
								num9 = 10;
							}
							if (num10 > Main.worldSurface)
							{
								num10 = Main.worldSurface;
							}
							for (int num11 = num9; (double)num11 < num10; num11++)
							{
								num8 = num11;
								if (!Main.tile[num7, num8].nactive() || !Main.tileSolid[Main.tile[num7, num8].type])
								{
									continue;
								}
								if (Main.tile[num7, num8 - 3].liquid != 0 || Main.tile[num7, num8 - 2].liquid != 0 || Main.tile[num7, num8 - 1].liquid != 0 || Collision.SolidTiles(num7 - 1, num7 + 1, num8 - 3, num8 - 1))
								{
									break;
								}
								flag = true;
								Rectangle value = new Rectangle(num7 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num8 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
								for (int num12 = 0; num12 < 255; num12++)
								{
									if (Main.player[num12].active && new Rectangle((int)Main.player[num12].position.X, (int)Main.player[num12].position.Y, Main.player[num12].width, Main.player[num12].height).Intersects(value))
									{
										flag = false;
										break;
									}
								}
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
			}
			int num13 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num7 * 16, num8 * 16, 368, 1);
			Main.npc[num13].homeTileX = bestX;
			Main.npc[num13].homeTileY = bestY;
			Main.npc[num13].homeless = true;
			if (num7 < bestX)
			{
				Main.npc[num13].direction = 1;
			}
			else if (num7 > bestX)
			{
				Main.npc[num13].direction = -1;
			}
			Main.npc[num13].netUpdate = true;
			string fullName = Main.npc[num13].FullName;
			if (Main.netMode == 0)
			{
				Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num13].GetFullNetName()), new Color(50, 125, 255));
			}
		}

		public static TownNPCSpawnResult SpawnTownNPC(int x, int y)
		{
			if (Main.wallHouse[Main.tile[x, y].wall])
			{
				canSpawn = true;
			}
			if (!canSpawn)
			{
				return TownNPCSpawnResult.Blocked;
			}
			if (!StartRoomCheck(x, y))
			{
				return TownNPCSpawnResult.Blocked;
			}
			if (!RoomNeeds(prioritizedTownNPCType))
			{
				return TownNPCSpawnResult.Blocked;
			}
			int num = FindAHomelessNPC();
			int type = prioritizedTownNPCType;
			if (num != -1)
			{
				type = Main.npc[num].type;
			}
			Point roomPosition = Point.Zero;
			bool flag = NPCID.Sets.IsTownPet[type] && TownManager.HasRoom(type, out roomPosition);
			if ((roomHasStinkbug || roomHasEchoStinkbug) && !flag)
			{
				return TownNPCSpawnResult.Blocked;
			}
			ScoreRoom(-1, type);
			if (hiScore <= 0)
			{
				return TownNPCSpawnResult.Blocked;
			}
			bool canSpawnNewTownNPC = true;
			if (!IsThereASpawnablePrioritizedTownNPC(bestX, bestY, ref canSpawnNewTownNPC))
			{
				return TownNPCSpawnResult.Blocked;
			}
			type = prioritizedTownNPCType;
			if (num != -1)
			{
				Main.townNPCCanSpawn[prioritizedTownNPCType] = false;
				Main.npc[num].homeTileX = bestX;
				Main.npc[num].homeTileY = bestY;
				Main.npc[num].homeless = false;
				AchievementsHelper.NotifyProgressionEvent(8);
				prioritizedTownNPCType = 0;
				return TownNPCSpawnResult.RelocatedHomeless;
			}
			if (canSpawnNewTownNPC && num == -1)
			{
				if (TownManager.HasRoom(type, out var roomPosition2) && !currentlyTryingToUseAlternateHousingSpot)
				{
					int num2 = bestX;
					int num3 = bestY;
					currentlyTryingToUseAlternateHousingSpot = true;
					TownNPCSpawnResult townNPCSpawnResult = SpawnTownNPC(roomPosition2.X, roomPosition2.Y - 2);
					currentlyTryingToUseAlternateHousingSpot = false;
					bestX = num2;
					bestY = num3;
					if (townNPCSpawnResult == TownNPCSpawnResult.Successful)
					{
						return townNPCSpawnResult;
					}
				}
				int num4 = bestX;
				int num5 = bestY;
				int npcTypeToSpawn = prioritizedTownNPCType;
				if (IsRoomConsideredAlreadyOccupied(num4, num5, npcTypeToSpawn))
				{
					return TownNPCSpawnResult.BlockedInfiHousing;
				}
				bool flag2 = false;
				if (!flag2)
				{
					flag2 = true;
					Rectangle value = new Rectangle(num4 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num5 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
					for (int i = 0; i < 255; i++)
					{
						if (Main.player[i].active && new Rectangle((int)Main.player[i].position.X, (int)Main.player[i].position.Y, Main.player[i].width, Main.player[i].height).Intersects(value))
						{
							flag2 = false;
							break;
						}
					}
				}
				if (!flag2 && !((double)num5 > Main.worldSurface))
				{
					for (int j = 1; j < 500; j++)
					{
						for (int k = 0; k < 2; k++)
						{
							num4 = ((k != 0) ? (bestX - j) : (bestX + j));
							if (num4 > 10 && num4 < Main.maxTilesX - 10)
							{
								int num6 = bestY - j;
								double num7 = bestY + j;
								if (num6 < 10)
								{
									num6 = 10;
								}
								if (num7 > Main.worldSurface)
								{
									num7 = Main.worldSurface;
								}
								for (int l = num6; (double)l < num7; l++)
								{
									num5 = l;
									if (!Main.tile[num4, num5].nactive() || !Main.tileSolid[Main.tile[num4, num5].type])
									{
										continue;
									}
									if (Collision.SolidTiles(num4 - 1, num4 + 1, num5 - 3, num5 - 1))
									{
										break;
									}
									flag2 = true;
									Rectangle value2 = new Rectangle(num4 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num5 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
									for (int m = 0; m < 255; m++)
									{
										if (Main.player[m].active && new Rectangle((int)Main.player[m].position.X, (int)Main.player[m].position.Y, Main.player[m].width, Main.player[m].height).Intersects(value2))
										{
											flag2 = false;
											break;
										}
									}
									break;
								}
							}
							if (flag2)
							{
								break;
							}
						}
						if (flag2)
						{
							break;
						}
					}
				}
				int num8 = NPC.NewNPC(NPC.GetSpawnSourceForTownSpawn(), num4 * 16, num5 * 16, type, 1);
				Main.townNPCCanSpawn[type] = false;
				Main.npc[num8].homeTileX = bestX;
				Main.npc[num8].homeTileY = bestY;
				if (num4 < bestX)
				{
					Main.npc[num8].direction = 1;
				}
				else if (num4 > bestX)
				{
					Main.npc[num8].direction = -1;
				}
				Main.npc[num8].netUpdate = true;
				string fullName = Main.npc[num8].FullName;
				if (Main.netMode == 0)
				{
					Main.NewText(Language.GetTextValue("Announcement.HasArrived", fullName), 50, 125);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", Main.npc[num8].GetFullNetName()), new Color(50, 125, 255));
				}
				AchievementsHelper.NotifyProgressionEvent(8);
				switch (Main.npc[num8].type)
				{
				case 160:
					AchievementsHelper.NotifyProgressionEvent(18);
					NPC.unlockedTruffleSpawn = true;
					break;
				case 17:
					NPC.unlockedMerchantSpawn = true;
					break;
				case 207:
					NPC.unlockedDyeTraderSpawn = true;
					break;
				case 18:
					NPC.unlockedNurseSpawn = true;
					break;
				case 19:
					NPC.unlockedArmsDealerSpawn = true;
					break;
				case 38:
					NPC.unlockedDemolitionistSpawn = true;
					break;
				case 208:
					NPC.unlockedPartyGirlSpawn = true;
					break;
				case 663:
					NPC.unlockedPrincessSpawn = true;
					break;
				case 678:
					NPC.unlockedSlimeGreenSpawn = true;
					break;
				}
				CheckAchievement_RealEstateAndTownSlimes();
				prioritizedTownNPCType = 0;
			}
			return TownNPCSpawnResult.Successful;
		}

		private static int FindAHomelessNPC()
		{
			int result = -1;
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].type == prioritizedTownNPCType && CheckSpecialTownNPCSpawningConditions(Main.npc[i].type))
				{
					result = i;
					break;
				}
			}
			return result;
		}

		private static bool IsRoomConsideredAlreadyOccupied(int spawnTileX, int spawnTileY, int npcTypeToSpawn)
		{
			bool result = false;
			for (int i = 0; i < 200; i++)
			{
				NPC nPC = Main.npc[i];
				if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == spawnTileX && nPC.homeTileY == spawnTileY && !TownManager.CanNPCsLiveWithEachOther(npcTypeToSpawn, nPC))
				{
					result = true;
					break;
				}
			}
			return result;
		}

		public static void CheckAchievement_RealEstateAndTownSlimes()
		{
			bool[] array = new bool[688];
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && Main.npc[i].type >= 0 && Main.npc[i].type < 688)
				{
					array[Main.npc[i].type] = true;
				}
			}
			if (array[38] && array[17] && array[107] && array[19] && array[22] && array[124] && array[228] && array[178] && array[18] && array[229] && array[209] && array[54] && array[108] && array[160] && array[20] && array[369] && array[207] && array[227] && array[208] && array[441] && array[353] && array[588] && array[633] && array[663])
			{
				AchievementsHelper.NotifyProgressionEvent(17);
			}
			if (array[670] && array[678] && array[679] && array[680] && array[681] && array[682] && array[683] && array[684])
			{
				AchievementsHelper.NotifyProgressionEvent(26);
			}
		}

		public static bool RoomNeeds(int npcType)
		{
			roomChair = false;
			roomDoor = false;
			roomTable = false;
			roomTorch = false;
			for (int i = 0; i < TileID.Sets.RoomNeeds.CountsAsChair.Length; i++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsChair[i]])
				{
					roomChair = true;
					break;
				}
			}
			for (int j = 0; j < TileID.Sets.RoomNeeds.CountsAsTable.Length; j++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsTable[j]])
				{
					roomTable = true;
					break;
				}
			}
			for (int k = 0; k < TileID.Sets.RoomNeeds.CountsAsTorch.Length; k++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsTorch[k]])
				{
					roomTorch = true;
					break;
				}
			}
			for (int l = 0; l < TileID.Sets.RoomNeeds.CountsAsDoor.Length; l++)
			{
				if (houseTile[TileID.Sets.RoomNeeds.CountsAsDoor[l]])
				{
					roomDoor = true;
					break;
				}
			}
			if (roomChair && roomTable && roomDoor && roomTorch)
			{
				canSpawn = true;
			}
			else
			{
				canSpawn = false;
			}
			return canSpawn;
		}

		public static void QuickFindHome(int npc)
		{
			bool flag = Main.tileSolid[379];
			Main.tileSolid[379] = true;
			if (Main.npc[npc].homeTileX > 10 && Main.npc[npc].homeTileY > 10 && Main.npc[npc].homeTileX < Main.maxTilesX - 10 && Main.npc[npc].homeTileY < Main.maxTilesY)
			{
				canSpawn = false;
				StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
				if (!canSpawn)
				{
					for (int i = Main.npc[npc].homeTileX - 1; i < Main.npc[npc].homeTileX + 2; i++)
					{
						for (int j = Main.npc[npc].homeTileY - 1; j < Main.npc[npc].homeTileY + 2 && !StartRoomCheck(i, j); j++)
						{
						}
					}
				}
				if (!canSpawn)
				{
					int num = 10;
					for (int k = Main.npc[npc].homeTileX - num; k <= Main.npc[npc].homeTileX + num; k += 2)
					{
						for (int l = Main.npc[npc].homeTileY - num; l <= Main.npc[npc].homeTileY + num && !StartRoomCheck(k, l); l += 2)
						{
						}
					}
				}
				if (canSpawn)
				{
					RoomNeeds(Main.npc[npc].type);
					if (canSpawn)
					{
						ScoreRoom(npc, Main.npc[npc].type);
					}
					if (canSpawn && hiScore > 0)
					{
						canSpawn = IsRoomConsideredOccupiedForNPCIndex(npc);
					}
					if (canSpawn && hiScore > 0)
					{
						Main.npc[npc].homeTileX = bestX;
						Main.npc[npc].homeTileY = bestY;
						Main.npc[npc].homeless = false;
						AchievementsHelper.NotifyProgressionEvent(8);
						canSpawn = false;
					}
					else
					{
						Main.npc[npc].homeless = true;
					}
				}
				else
				{
					Main.npc[npc].homeless = true;
				}
			}
			Main.tileSolid[379] = flag;
		}

		private static bool IsRoomConsideredOccupiedForNPCIndex(int npc)
		{
			bool result = true;
			for (int i = 0; i < 200; i++)
			{
				if (i != npc)
				{
					NPC nPC = Main.npc[i];
					if (nPC.active && nPC.townNPC && !nPC.homeless && nPC.homeTileX == bestX && nPC.homeTileY == bestY && !TownManager.CanNPCsLiveWithEachOther(Main.npc[npc], nPC))
					{
						result = false;
						break;
					}
				}
			}
			return result;
		}

		private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1)
		{
			for (int i = 0; i < 200; i++)
			{
				if (!Main.npc[i].active || !Main.npc[i].townNPC || ignoreNPC == i || Main.npc[i].homeless)
				{
					continue;
				}
				for (int j = 0; j < numRoomTiles; j++)
				{
					if (Main.npc[i].homeTileX != roomX[j] || Main.npc[i].homeTileY != roomY[j])
					{
						continue;
					}
					bool flag = false;
					for (int k = 0; k < numRoomTiles; k++)
					{
						if (Main.npc[i].homeTileX == roomX[k] && Main.npc[i].homeTileY - 1 == roomY[k])
						{
							if (!TownManager.CanNPCsLiveWithEachOther(npcTypeAsking, Main.npc[i]))
							{
								flag = true;
								break;
							}
							sharedRoomX = Main.npc[i].homeTileX;
						}
					}
					if (flag)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void CountTileTypesInArea(int[] tileTypeCounts, int startX, int endX, int startY, int endY)
		{
			for (int i = startX; i <= endX; i++)
			{
				for (int j = startY; j <= endY; j++)
				{
					if (Main.tile[i, j].active())
					{
						tileTypeCounts[Main.tile[i, j].type]++;
					}
				}
			}
		}

		public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group)
		{
			switch (group)
			{
			case TileScanGroup.None:
				return 0;
			case TileScanGroup.Corruption:
				return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
			case TileScanGroup.Crimson:
				return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
			case TileScanGroup.Hallow:
				return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
			case TileScanGroup.TotalGoodEvil:
			{
				int tileTypeCountByCategory = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
				int tileTypeCountByCategory2 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
				int tileTypeCountByCategory3 = GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
				int num = 5 * tileTypeCounts[27];
				int num2 = tileTypeCountByCategory2 + tileTypeCountByCategory3 + num;
				return tileTypeCountByCategory - num2;
			}
			default:
				return 0;
			}
		}

		public static void ScoreRoom(int ignoreNPC = -1, int npcTypeAskingToScoreRoom = -1)
		{
			roomOccupied = false;
			roomEvil = false;
			sharedRoomX = -1;
			if (ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC, npcTypeAskingToScoreRoom))
			{
				roomOccupied = true;
				hiScore = -1;
				return;
			}
			hiScore = 0;
			int num = 0;
			int num2 = 50;
			Housing_GetTestedRoomBounds(out var startX, out var endX, out var startY, out var endY);
			int[] tileTypeCounts = new int[693];
			CountTileTypesInArea(tileTypeCounts, startX + 1, endX - 1, startY + 2, endY + 1);
			int num3 = -GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
			if (num3 < 50)
			{
				num3 = 0;
			}
			num2 -= num3;
			if (num3 > 0)
			{
				roomEvil = true;
			}
			if (num2 <= -250)
			{
				hiScore = num2;
				return;
			}
			startX = roomX1;
			endX = roomX2;
			startY = roomY1;
			endY = roomY2;
			for (int i = startX + 1; i < endX; i++)
			{
				for (int j = startY + 2; j < endY + 2; j++)
				{
					if (!Main.tile[i, j].nactive() || !ScoreRoom_CanBeHomeSpot(i, j))
					{
						continue;
					}
					num = num2;
					if (!Main.tileSolid[Main.tile[i, j].type] || Main.tileSolidTop[Main.tile[i, j].type] || Collision.SolidTiles(i - 1, i + 1, j - 3, j - 1) || !Main.tile[i - 1, j].nactive() || !Main.tileSolid[Main.tile[i - 1, j].type] || !Main.tile[i + 1, j].nactive() || !Main.tileSolid[Main.tile[i + 1, j].type])
					{
						continue;
					}
					int num4 = 0;
					int num5 = 0;
					for (int k = i - 2; k < i + 3; k++)
					{
						for (int l = j - 4; l < j; l++)
						{
							Tile tile = Main.tile[k, l];
							if (tile.nactive() && !TileID.Sets.IgnoredInHouseScore[tile.type] && (tile.type != 11 || IsOpenDoorAnchorFrame(k, l)))
							{
								if (k == i)
								{
									num4++;
								}
								else if (TileID.Sets.BasicChest[tile.type])
								{
									num5++;
								}
								else
								{
									num = ((tile.type != 10 && tile.type != 388) ? ((!IsOpenDoorAnchorFrame(k, l) && tile.type != 389) ? ((!Main.tileSolid[tile.type]) ? (num + 5) : (num - 5)) : (num - 20)) : (num - 20));
								}
							}
						}
					}
					if (sharedRoomX >= 0 && num >= 1 && Math.Abs(sharedRoomX - i) < 3)
					{
						num = 1;
					}
					if (num > 0 && num5 > 0)
					{
						num -= 30 * num5;
						if (num < 1)
						{
							num = 1;
						}
					}
					if (num > 0 && num4 > 0)
					{
						num -= 15 * num4;
						if (num <= 0)
						{
							num = 0;
						}
					}
					if (num <= hiScore)
					{
						continue;
					}
					bool flag = Housing_CheckIfInRoom(i, j);
					bool[] array = new bool[3];
					for (int m = 1; m <= 3; m++)
					{
						if (!Main.tile[i, j - m].active() || !Main.tileSolid[Main.tile[i, j - m].type])
						{
							array[m - 1] = true;
						}
						if (!Housing_CheckIfInRoom(i, j - m))
						{
							array[m - 1] = false;
						}
					}
					bool[] array2 = array;
					for (int n = 0; n < array2.Length; n++)
					{
						if (!array2[n])
						{
							flag = false;
							break;
						}
					}
					if (flag && !Housing_CheckIfIsCeiling(i, j))
					{
						hiScore = num;
						bestX = i;
						bestY = j;
					}
				}
			}
		}

		public static void Housing_GetTestedRoomBounds(out int startX, out int endX, out int startY, out int endY)
		{
			int num = 40;
			int num2 = 5;
			int num3 = 3;
			startX = roomX1 - num2 - 1 - num;
			endX = roomX2 + num2 + 1 + num;
			startY = roomY1 - num3 - 1 - num;
			endY = roomY2 + num3 + 1 + num;
			if (startX < 5)
			{
				startX = 5;
			}
			if (endX >= Main.maxTilesX - 5)
			{
				endX = Main.maxTilesX - 6;
			}
			if (startY < 5)
			{
				startY = 5;
			}
			if (endY >= Main.maxTilesY - 5)
			{
				endY = Main.maxTilesY - 6;
			}
		}

		private static bool ScoreRoom_CanBeHomeSpot(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (tile.active())
			{
				ushort type = tile.type;
				if (type == 379)
				{
					return false;
				}
			}
			return true;
		}

		private static bool Housing_CheckIfIsCeiling(int i, int j)
		{
			bool result = false;
			for (int k = 0; k < roomCeilingsCount; k++)
			{
				if (roomCeilingX[k] == i)
				{
					if (roomCeilingY[k] == j)
					{
						result = true;
					}
					break;
				}
			}
			return result;
		}

		private static bool Housing_CheckIfInRoom(int i, int j)
		{
			bool result = false;
			for (int k = 0; k < numRoomTiles; k++)
			{
				if (roomX[k] == i && roomY[k] == j)
				{
					result = true;
					break;
				}
			}
			return result;
		}

		public static bool StartRoomCheck(int x, int y)
		{
			roomHasStinkbug = false;
			roomHasEchoStinkbug = false;
			roomX1 = x;
			roomX2 = x;
			roomY1 = y;
			roomY2 = y;
			numRoomTiles = 0;
			roomCeilingsCount = 0;
			for (int i = 0; i < 693; i++)
			{
				houseTile[i] = false;
			}
			canSpawn = true;
			if (Main.tile[x, y].nactive() && Main.tileSolid[Main.tile[x, y].type])
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
				canSpawn = false;
				return false;
			}
			roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
			CheckRoom(x, y);
			if (!canSpawn)
			{
				return false;
			}
			if (numRoomTiles < 60)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
				canSpawn = false;
				return false;
			}
			if (canSpawn)
			{
				return true;
			}
			return false;
		}

		public static void CheckRoom(int x, int y)
		{
			if (!canSpawn)
			{
				return;
			}
			if (x < 10 || y < 10 || x >= Main.maxTilesX - 10 || y >= lastMaxTilesY - 10)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
				canSpawn = false;
				return;
			}
			for (int i = 0; i < numRoomTiles; i++)
			{
				if (roomX[i] == x && roomY[i] == y)
				{
					return;
				}
			}
			roomX[numRoomTiles] = x;
			roomY[numRoomTiles] = y;
			bool flag = false;
			for (int j = 0; j < roomCeilingsCount; j++)
			{
				if (roomCeilingX[j] == x)
				{
					flag = true;
					if (roomCeilingY[j] > y)
					{
						roomCeilingY[j] = y;
					}
					break;
				}
			}
			if (!flag)
			{
				roomCeilingX[roomCeilingsCount] = x;
				roomCeilingY[roomCeilingsCount] = y;
				roomCeilingsCount++;
			}
			numRoomTiles++;
			if (numRoomTiles >= maxRoomTiles)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
				canSpawn = false;
				return;
			}
			if (Main.tile[x, y].nactive())
			{
				houseTile[Main.tile[x, y].type] = true;
				if (Main.tileSolid[Main.tile[x, y].type] || (Main.tile[x, y].type == 11 && (Main.tile[x, y].frameX == 0 || Main.tile[x, y].frameX == 54 || Main.tile[x, y].frameX == 72 || Main.tile[x, y].frameX == 126)) || Main.tile[x, y].type == 389 || (Main.tile[x, y].type == 386 && ((Main.tile[x, y].frameX < 36 && Main.tile[x, y].frameY == 18) || (Main.tile[x, y].frameX >= 36 && Main.tile[x, y].frameY == 0))))
				{
					return;
				}
			}
			if (x < roomX1)
			{
				roomX1 = x;
			}
			if (x > roomX2)
			{
				roomX2 = x;
			}
			if (y < roomY1)
			{
				roomY1 = y;
			}
			if (y > roomY2)
			{
				roomY2 = y;
			}
			if (Main.tile[x, y].type == 630)
			{
				roomHasStinkbug = true;
			}
			if (Main.tile[x, y].type == 631)
			{
				roomHasEchoStinkbug = true;
			}
			bool flag2 = false;
			bool flag3 = false;
			for (int k = -2; k < 3; k++)
			{
				if (Main.wallHouse[Main.tile[x + k, y].wall])
				{
					flag2 = true;
				}
				if (Main.tile[x + k, y].nactive() && (Main.tileSolid[Main.tile[x + k, y].type] || TileID.Sets.HousingWalls[Main.tile[x + k, y].type]))
				{
					flag2 = true;
				}
				if (Main.wallHouse[Main.tile[x, y + k].wall])
				{
					flag3 = true;
				}
				if (Main.tile[x, y + k].nactive() && (Main.tileSolid[Main.tile[x, y + k].type] || TileID.Sets.HousingWalls[Main.tile[x, y + k].type]))
				{
					flag3 = true;
				}
			}
			if (!flag2 || !flag3)
			{
				roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
				canSpawn = false;
				return;
			}
			for (int l = x - 1; l < x + 2; l++)
			{
				for (int m = y - 1; m < y + 2; m++)
				{
					if ((l != x || m != y) && canSpawn)
					{
						CheckRoom(l, m);
					}
				}
			}
		}

		public static void dropMeteor()
		{
			bool flag = true;
			if (Main.netMode == 1)
			{
				return;
			}
			for (int i = 0; i < 255; i++)
			{
				if (Main.player[i].active)
				{
					flag = false;
					break;
				}
			}
			int num = 0;
			double num2 = (double)Main.maxTilesX / 4200.0;
			int num3 = (int)(400.0 * num2);
			for (int j = 5; j < Main.maxTilesX - 5; j++)
			{
				for (int k = 5; (double)k < Main.worldSurface; k++)
				{
					if (Main.tile[j, k].active() && Main.tile[j, k].type == 37)
					{
						num++;
						if (num > num3)
						{
							return;
						}
					}
				}
			}
			double num4 = 600.0;
			int num5 = 0;
			while (!flag)
			{
				double num6 = (double)Main.maxTilesX * 0.08;
				int num7 = Main.rand.Next(150, Main.maxTilesX - 150);
				while ((double)num7 > (double)Main.spawnTileX - num6 && (double)num7 < (double)Main.spawnTileX + num6)
				{
					num7 = Main.rand.Next(150, Main.maxTilesX - 150);
				}
				for (int l = (int)(Main.worldSurface * 0.3); l < Main.maxTilesY; l++)
				{
					Tile tile = Main.tile[num7, l];
					if (!tile.active() || !Main.tileSolid[tile.type] || TileID.Sets.Platforms[tile.type])
					{
						continue;
					}
					int num8 = 0;
					int num9 = 15;
					for (int m = num7 - num9; m < num7 + num9; m++)
					{
						for (int n = l - num9; n < l + num9; n++)
						{
							if (SolidTile(m, n))
							{
								num8++;
								if (Main.tile[m, n].type == 189 || Main.tile[m, n].type == 202)
								{
									num8 -= 100;
								}
							}
							else if (Main.tile[m, n].liquid > 0)
							{
								num8--;
							}
						}
					}
					if ((double)num8 >= num4)
					{
						flag = meteor(num7, l);
						if (!flag)
						{
						}
					}
					else
					{
						num4 -= 0.5;
					}
					break;
				}
				num5++;
				if (num4 < 100.0 || num5 >= Main.maxTilesX * 5)
				{
					break;
				}
			}
		}

		public static bool meteor(int i, int j, bool ignorePlayers = false)
		{
			if (i < 50 || i > Main.maxTilesX - 50)
			{
				return false;
			}
			if (j < 50 || j > Main.maxTilesY - 50)
			{
				return false;
			}
			int num = 35;
			Rectangle rectangle = new Rectangle((i - num) * 16, (j - num) * 16, num * 2 * 16, num * 2 * 16);
			for (int k = 0; k < 255; k++)
			{
				if (Main.player[k].active && !ignorePlayers)
				{
					Rectangle value = new Rectangle((int)(Main.player[k].position.X + (float)(Main.player[k].width / 2) - (float)(NPC.sWidth / 2) - (float)NPC.safeRangeX), (int)(Main.player[k].position.Y + (float)(Main.player[k].height / 2) - (float)(NPC.sHeight / 2) - (float)NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
					if (rectangle.Intersects(value))
					{
						return false;
					}
				}
			}
			for (int l = 0; l < 200; l++)
			{
				if (Main.npc[l].active)
				{
					Rectangle value2 = new Rectangle((int)Main.npc[l].position.X, (int)Main.npc[l].position.Y, Main.npc[l].width, Main.npc[l].height);
					if (rectangle.Intersects(value2))
					{
						return false;
					}
				}
			}
			for (int m = i - num; m < i + num; m++)
			{
				for (int n = j - num; n < j + num; n++)
				{
					if (Main.tile[m, n].active())
					{
						if (TileID.Sets.BasicChest[Main.tile[m, n].type] || Main.tileDungeon[Main.tile[m, n].type])
						{
							return false;
						}
						switch (Main.tile[m, n].type)
						{
						case 226:
						case 470:
						case 475:
						case 488:
						case 597:
							return false;
						}
					}
				}
			}
			stopDrops = true;
			num = genRand.Next(17, 23);
			for (int num2 = i - num; num2 < i + num; num2++)
			{
				for (int num3 = j - num; num3 < j + num; num3++)
				{
					if (num3 <= j + Main.rand.Next(-2, 3) - 5)
					{
						continue;
					}
					double num4 = Math.Abs(i - num2);
					double num5 = Math.Abs(j - num3);
					if (Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.9 + (double)Main.rand.Next(-4, 5))
					{
						if (!Main.tileSolid[Main.tile[num2, num3].type])
						{
							Main.tile[num2, num3].active(active: false);
						}
						Main.tile[num2, num3].type = 37;
					}
				}
			}
			num = genRand.Next(8, 14);
			for (int num6 = i - num; num6 < i + num; num6++)
			{
				for (int num7 = j - num; num7 < j + num; num7++)
				{
					if (num7 > j + Main.rand.Next(-2, 3) - 4)
					{
						double num8 = Math.Abs(i - num6);
						double num9 = Math.Abs(j - num7);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < (double)num * 0.8 + (double)Main.rand.Next(-3, 4))
						{
							Main.tile[num6, num7].active(active: false);
						}
					}
				}
			}
			num = genRand.Next(25, 35);
			for (int num10 = i - num; num10 < i + num; num10++)
			{
				for (int num11 = j - num; num11 < j + num; num11++)
				{
					double num12 = Math.Abs(i - num10);
					double num13 = Math.Abs(j - num11);
					if (Math.Sqrt(num12 * num12 + num13 * num13) < (double)num * 0.7)
					{
						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num10, num11].type])
						{
							KillTile(num10, num11);
						}
						Main.tile[num10, num11].liquid = 0;
					}
					if (Main.tile[num10, num11].type == 37)
					{
						if (!SolidTile(num10 - 1, num11) && !SolidTile(num10 + 1, num11) && !SolidTile(num10, num11 - 1) && !SolidTile(num10, num11 + 1))
						{
							Main.tile[num10, num11].active(active: false);
						}
						else if ((Main.tile[num10, num11].halfBrick() || Main.tile[num10 - 1, num11].topSlope()) && !SolidTile(num10, num11 + 1))
						{
							Main.tile[num10, num11].active(active: false);
						}
					}
					SquareTileFrame(num10, num11);
					SquareWallFrame(num10, num11);
				}
			}
			num = genRand.Next(23, 32);
			for (int num14 = i - num; num14 < i + num; num14++)
			{
				for (int num15 = j - num; num15 < j + num; num15++)
				{
					if (num15 <= j + genRand.Next(-3, 4) - 3 || !Main.tile[num14, num15].active() || Main.rand.Next(10) != 0)
					{
						continue;
					}
					double num16 = Math.Abs(i - num14);
					double num17 = Math.Abs(j - num15);
					if (Math.Sqrt(num16 * num16 + num17 * num17) < (double)num * 0.8)
					{
						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num14, num15].type])
						{
							KillTile(num14, num15);
						}
						Main.tile[num14, num15].type = 37;
						SquareTileFrame(num14, num15);
					}
				}
			}
			num = genRand.Next(30, 38);
			for (int num18 = i - num; num18 < i + num; num18++)
			{
				for (int num19 = j - num; num19 < j + num; num19++)
				{
					if (num19 <= j + genRand.Next(-2, 3) || !Main.tile[num18, num19].active() || Main.rand.Next(20) != 0)
					{
						continue;
					}
					double num20 = Math.Abs(i - num18);
					double num21 = Math.Abs(j - num19);
					if (Math.Sqrt(num20 * num20 + num21 * num21) < (double)num * 0.85)
					{
						if (TileID.Sets.GetsDestroyedForMeteors[Main.tile[num18, num19].type])
						{
							KillTile(num18, num19);
						}
						Main.tile[num18, num19].type = 37;
						SquareTileFrame(num18, num19);
					}
				}
			}
			stopDrops = false;
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.gen[59].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, 255, 130));
			}
			if (Main.netMode != 1)
			{
				NetMessage.SendTileSquare(-1, i, j, 40);
			}
			return true;
		}

		public static void setWorldSize()
		{
			Main.bottomWorld = Main.maxTilesY * 16;
			Main.rightWorld = Main.maxTilesX * 16;
			Main.maxSectionsX = Main.maxTilesX / 200;
			Main.maxSectionsY = Main.maxTilesY / 150;
		}

		public static int GetWorldSize()
		{
			if (Main.maxTilesX <= 4200)
			{
				return 0;
			}
			if (Main.maxTilesX <= 6400)
			{
				return 1;
			}
			return 2;
		}

		public static void worldGenCallback(object threadContext)
		{
			SoundEngine.PlaySound(10);
			clearWorld();
			GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
			WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, resetTime: true);
			if (Main.menuMode == 10 || Main.menuMode == 888)
			{
				Main.menuMode = 6;
			}
			SoundEngine.PlaySound(10);
			generatingWorld = false;
		}

		public static Task CreateNewWorld(GenerationProgress progress = null)
		{
			generatingWorld = true;
			Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
			gen = true;
			Main.menuMode = 888;
			try
			{
				Main.MenuUI.SetState(new UIWorldLoad());
			}
			catch
			{
			}
			return Task.Factory.StartNew(worldGenCallback, progress);
		}

		public static void JustQuit()
		{
			try
			{
				SoundEngine.PlaySound(34, -1, -1, 0);
				SoundEngine.PlaySound(35, -1, -1, 0);
			}
			catch
			{
			}
			Main.invasionProgress = -1;
			Main.invasionProgressDisplayLeft = 0;
			Main.invasionProgressAlpha = 0f;
			Main.invasionProgressIcon = 0;
			Main.menuMode = 10;
			Main.gameMenu = true;
			SoundEngine.StopTrackedSounds();
			CaptureInterface.ResetFocus();
			Main.ActivePlayerFileData.StopPlayTimer();
			Main.fastForwardTimeToDawn = false;
			Main.fastForwardTimeToDusk = false;
			Main.UpdateTimeRate();
			if (Main.netMode == 0)
			{
				Main.GoToWorldSelect();
				Main.player[Main.myPlayer].position = new Vector2(0f, 0f);
			}
			else if (Main.netMode == 1)
			{
				Main.menuMode = 0;
				Netplay.Disconnect = true;
				Main.netMode = 0;
			}
		}

		public static void SaveAndQuitCallBack(object threadContext)
		{
			int netMode = Main.netMode;
			try
			{
				SoundEngine.PlaySound(34, -1, -1, 0);
				SoundEngine.PlaySound(35, -1, -1, 0);
			}
			catch
			{
			}
			if (netMode == 0)
			{
				WorldFile.CacheSaveTime();
			}
			Main.invasionProgress = -1;
			Main.invasionProgressDisplayLeft = 0;
			Main.invasionProgressAlpha = 0f;
			Main.invasionProgressIcon = 0;
			Main.menuMode = 10;
			Main.gameMenu = true;
			SoundEngine.StopTrackedSounds();
			CaptureInterface.ResetFocus();
			Main.ActivePlayerFileData.StopPlayTimer();
			Player.SavePlayer(Main.ActivePlayerFileData);
			Player.ClearPlayerTempInfo();
			Rain.ClearRain();
			if (netMode == 0)
			{
				WorldFile.SaveWorld();
				SoundEngine.PlaySound(10);
			}
			else
			{
				Netplay.Disconnect = true;
				Main.netMode = 0;
			}
			Main.fastForwardTimeToDawn = false;
			Main.fastForwardTimeToDusk = false;
			Main.UpdateTimeRate();
			Main.menuMode = 0;
			if (threadContext != null)
			{
				((Action)threadContext)();
			}
		}

		public static void SaveAndQuit(Action callback = null)
		{
			SoundEngine.PlaySound(11);
			ThreadPool.QueueUserWorkItem(SaveAndQuitCallBack, callback);
		}

		public static void RenameWorld(WorldFileData data, string newName, Action<string> callback = null)
		{
			data.SetAsActive();
			ThreadPool.QueueUserWorkItem(RenameWorldCallBack, Tuple.Create(newName, callback));
		}

		public static void RenameWorldCallBack(object threadContext)
		{
			if (threadContext != null && threadContext is Tuple<string, Action<string>> tuple)
			{
				string item = tuple.Item1;
				Action<string> item2 = tuple.Item2;
				noMapUpdate = true;
				Main.ToggleGameplayUpdates(state: false);
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				noMapUpdate = false;
				if (loadFailed || !loadSuccess)
				{
					Main.LoadWorlds();
					Main.GoToWorldSelect();
					return;
				}
				Main.sectionManager.SetAllSectionsLoaded();
				double time = Main.time;
				bool dayTime = Main.dayTime;
				WorldFile.SetOngoingToTemps();
				WorldFile.CacheSaveTime();
				Main.time = time;
				Main.dayTime = dayTime;
				Main.worldName = item;
				WorldFile.SaveWorld();
				Rain.ClearRain();
				Main.fastForwardTimeToDawn = false;
				Main.fastForwardTimeToDusk = false;
				Main.UpdateTimeRate();
				item2?.Invoke(item);
			}
		}

		public static void playWorldCallBack(object threadContext)
		{
			if (Main.rand == null)
			{
				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			}
			for (int i = 0; i < 255; i++)
			{
				if (i != Main.myPlayer)
				{
					Main.player[i].active = false;
				}
			}
			noMapUpdate = true;
			Main.ToggleGameplayUpdates(state: false);
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess)
			{
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess)
				{
					bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
					if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
					{
						worldBackup = true;
					}
					else
					{
						worldBackup = false;
					}
					if (!Main.dedServ)
					{
						if (worldBackup)
						{
							Main.menuMode = 200;
						}
						else
						{
							Main.menuMode = 201;
						}
						return;
					}
					if (!worldBackup)
					{
						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
						return;
					}
					FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave);
					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess)
					{
						WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
						if (loadFailed || !loadSuccess)
						{
							FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave);
							FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave);
							FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
							return;
						}
					}
				}
			}
			if (Main.mapEnabled)
			{
				Main.Map.Load();
			}
			if (Main.netMode != 2)
			{
				Main.sectionManager.SetAllSectionsLoaded();
			}
			while (Main.loadMapLock)
			{
				float num = (float)Main.loadMapLastX / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[68].Value + " " + (int)(num * 100f + 1f) + "%";
				Thread.Sleep(0);
				if (!Main.mapEnabled)
				{
					break;
				}
			}
			if (Main.gameMenu)
			{
				Main.gameMenu = false;
			}
			if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
			{
				Main.anglerQuestFinished = true;
			}
			Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
			_lastSeed = Main.ActiveWorldFileData.Seed;
			WorldFile.SetOngoingToTemps();
			SoundEngine.PlaySound(11);
			Main.resetClouds = true;
			noMapUpdate = false;
		}

		public static void playWorld()
		{
			ThreadPool.QueueUserWorkItem(playWorldCallBack, 1);
		}

		public static void saveAndPlayCallBack(object threadContext)
		{
			WorldFile.SaveWorld();
		}

		public static void saveAndPlay()
		{
			ThreadPool.QueueUserWorkItem(saveAndPlayCallBack, 1);
		}

		public static void saveToonWhilePlayingCallBack(object threadContext)
		{
			Player.SavePlayer(Main.ActivePlayerFileData);
		}

		public static void saveToonWhilePlaying()
		{
			ThreadPool.QueueUserWorkItem(saveToonWhilePlayingCallBack, 1);
		}

		public static void serverLoadWorldCallBack()
		{
			Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
			if (loadFailed || !loadSuccess)
			{
				WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
				if (loadFailed || !loadSuccess)
				{
					bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
					if (FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave))
					{
						worldBackup = true;
					}
					else
					{
						worldBackup = false;
					}
					if (!Main.dedServ)
					{
						if (worldBackup)
						{
							Main.menuMode = 200;
						}
						else
						{
							Main.menuMode = 201;
						}
						return;
					}
					if (!worldBackup)
					{
						Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
						return;
					}
					FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave);
					FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
					WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
					if (loadFailed || !loadSuccess)
					{
						WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
						if (loadFailed || !loadSuccess)
						{
							Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
							return;
						}
					}
				}
			}
			_lastSeed = Main.ActiveWorldFileData.Seed;
			SoundEngine.PlaySound(10);
			WorldFile.SetOngoingToTemps();
			Hooks.WorldLoaded();
		}

		public static Task serverLoadWorld()
		{
			return Task.Factory.StartNew(serverLoadWorldCallBack);
		}

		public static void clearWorld()
		{
			ResetTreeShakes();
			Main.ladyBugRainBoost = 0;
			Main.getGoodWorld = false;
			Main.drunkWorld = false;
			Main.tenthAnniversaryWorld = false;
			Main.dontStarveWorld = false;
			Main.notTheBeesWorld = false;
			Main.remixWorld = false;
			Main.noTrapsWorld = false;
			Main.zenithWorld = false;
			Main.shimmerAlpha = 0f;
			Main.shimmerDarken = 0f;
			Main.shimmerBrightenDelay = 0f;
			NPC.ResetBadgerHatTime();
			NPC.freeCake = false;
			NPC.mechQueen = -1;
			Main.mapDelay = 2;
			Main.ResetWindCounter(resetExtreme: true);
			TownManager = new TownRoomManager();
			Hooks.ClearWorld();
			TileEntity.Clear();
			Main.checkXMas();
			Main.checkHalloween();
			DontStarveDarknessDamageDealer.Reset();
			Wiring.ClearAll();
			if (Main.mapReady)
			{
				for (int i = 0; i < lastMaxTilesX; i++)
				{
					_ = (float)i / (float)lastMaxTilesX;
					Main.statusText = Lang.gen[65].Value;
				}
				if (Main.Map != null)
				{
					Main.Map.Clear();
				}
			}
			NPC.MoonLordCountdown = 0;
			Main.forceHalloweenForToday = false;
			Main.forceXMasForToday = false;
			NPC.RevengeManager.Reset();
			Main.pumpkinMoon = false;
			Main.clearMap = true;
			Main.mapTime = 0;
			Main.updateMap = false;
			Main.mapReady = false;
			Main.refreshMap = false;
			Main.eclipse = false;
			Main.slimeRain = false;
			Main.slimeRainTime = 0.0;
			Main.slimeWarningTime = 0;
			Main.sundialCooldown = 0;
			Main.moondialCooldown = 0;
			Main.fastForwardTimeToDawn = false;
			Main.fastForwardTimeToDusk = false;
			BirthdayParty.WorldClear();
			LanternNight.WorldClear();
			mysticLogsEvent.WorldClear();
			CreditsRollEvent.Reset();
			Sandstorm.WorldClear();
			Main.UpdateTimeRate();
			Main.wofNPCIndex = -1;
			NPC.waveKills = 0f;
			spawnHardBoss = 0;
			totalSolid2 = 0;
			totalGood2 = 0;
			totalEvil2 = 0;
			totalBlood2 = 0;
			totalSolid = 0;
			totalGood = 0;
			totalEvil = 0;
			totalBlood = 0;
			WorldFile.ResetTemps();
			Main.maxRaining = 0f;
			totalX = 0;
			totalD = 0;
			tEvil = 0;
			tBlood = 0;
			tGood = 0;
			spawnEye = false;
			prioritizedTownNPCType = 0;
			shadowOrbCount = 0;
			altarCount = 0;
			SavedOreTiers.Copper = -1;
			SavedOreTiers.Iron = -1;
			SavedOreTiers.Silver = -1;
			SavedOreTiers.Gold = -1;
			SavedOreTiers.Cobalt = -1;
			SavedOreTiers.Mythril = -1;
			SavedOreTiers.Adamantite = -1;
			Main.cloudBGActive = 0f;
			Main.raining = false;
			Main.hardMode = false;
			Main.helpText = 0;
			Main.BartenderHelpTextIndex = 0;
			Main.dungeonX = 0;
			Main.dungeonY = 0;
			NPC.downedBoss1 = false;
			NPC.downedBoss2 = false;
			NPC.downedBoss3 = false;
			NPC.downedQueenBee = false;
			NPC.downedSlimeKing = false;
			NPC.downedMechBossAny = false;
			NPC.downedMechBoss1 = false;
			NPC.downedMechBoss2 = false;
			NPC.downedMechBoss3 = false;
			NPC.downedFishron = false;
			NPC.downedAncientCultist = false;
			NPC.downedMoonlord = false;
			NPC.downedHalloweenKing = false;
			NPC.downedHalloweenTree = false;
			NPC.downedChristmasIceQueen = false;
			NPC.downedChristmasSantank = false;
			NPC.downedChristmasTree = false;
			NPC.downedPlantBoss = false;
			NPC.downedGolemBoss = false;
			NPC.downedEmpressOfLight = false;
			NPC.downedQueenSlime = false;
			NPC.downedDeerclops = false;
			NPC.combatBookWasUsed = false;
			NPC.combatBookVolumeTwoWasUsed = false;
			NPC.peddlersSatchelWasUsed = false;
			NPC.savedStylist = false;
			NPC.savedGoblin = false;
			NPC.savedWizard = false;
			NPC.savedMech = false;
			NPC.savedTaxCollector = false;
			NPC.savedAngler = false;
			NPC.savedBartender = false;
			NPC.savedGolfer = false;
			NPC.boughtCat = false;
			NPC.boughtDog = false;
			NPC.boughtBunny = false;
			NPC.unlockedSlimeBlueSpawn = false;
			NPC.unlockedSlimeGreenSpawn = false;
			NPC.unlockedSlimeOldSpawn = false;
			NPC.unlockedSlimePurpleSpawn = false;
			NPC.unlockedSlimeRainbowSpawn = false;
			NPC.unlockedSlimeRedSpawn = false;
			NPC.unlockedSlimeYellowSpawn = false;
			NPC.unlockedSlimeCopperSpawn = false;
			NPC.unlockedMerchantSpawn = false;
			NPC.unlockedDemolitionistSpawn = false;
			NPC.unlockedPartyGirlSpawn = false;
			NPC.unlockedDyeTraderSpawn = false;
			NPC.unlockedTruffleSpawn = false;
			NPC.unlockedArmsDealerSpawn = false;
			NPC.unlockedNurseSpawn = false;
			NPC.unlockedPrincessSpawn = false;
			NPC.ShimmeredTownNPCs.Clear();
			NPC.downedGoblins = false;
			NPC.downedClown = false;
			NPC.downedFrost = false;
			NPC.downedPirates = false;
			NPC.downedMartians = false;
			NPC.downedTowerSolar = (NPC.downedTowerVortex = (NPC.downedTowerNebula = (NPC.downedTowerStardust = (NPC.LunarApocalypseIsUp = false))));
			NPC.TowerActiveSolar = (NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveStardust = false)));
			DD2Event.ResetProgressEntirely();
			NPC.ClearFoundActiveNPCs();
			Main.BestiaryTracker.Reset();
			Main.PylonSystem.Reset();
			CreativePowerManager.Instance.Reset();
			Main.CreativeMenu.Reset();
			shadowOrbSmashed = false;
			spawnMeteor = false;
			stopDrops = false;
			Main.invasionDelay = 0;
			Main.invasionType = 0;
			Main.invasionSize = 0;
			Main.invasionWarn = 0;
			Main.invasionX = 0.0;
			Main.invasionSizeStart = 0;
			Main.treeX[0] = Main.maxTilesX;
			Main.treeX[1] = Main.maxTilesX;
			Main.treeX[2] = Main.maxTilesX;
			Main.treeStyle[0] = 0;
			Main.treeStyle[1] = 0;
			Main.treeStyle[2] = 0;
			Main.treeStyle[3] = 0;
			noLiquidCheck = false;
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
			if (Main.netMode == 1 || lastMaxTilesX > Main.maxTilesX || lastMaxTilesY > Main.maxTilesY)
			{
				for (int j = 0; j < lastMaxTilesX; j++)
				{
					float num = (float)j / (float)lastMaxTilesX;
					Main.statusText = Lang.gen[46].Value + " " + (int)(num * 100f + 1f) + "%";
					for (int k = 0; k < lastMaxTilesY; k++)
					{
						Main.tile[j, k] = null;
					}
				}
			}
			lastMaxTilesX = Main.maxTilesX;
			lastMaxTilesY = Main.maxTilesY;
			if (Main.netMode != 2)
			{
				Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
			}
			if (Main.netMode != 1)
			{
				for (int l = 0; l < Main.maxTilesX; l++)
				{
					float num2 = (float)l / (float)Main.maxTilesX;
					Main.statusText = Lang.gen[47].Value + " " + (int)(num2 * 100f + 1f) + "%";
					for (int m = 0; m < Main.maxTilesY; m++)
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						else
						{
							Main.tile[l, m].ClearEverything();
						}
					}
				}
			}
			for (int n = 0; n < Main.countsAsHostForGameplay.Length; n++)
			{
				Main.countsAsHostForGameplay[n] = false;
			}
			CombatText.clearAll();
			for (int num3 = 0; num3 < 6000; num3++)
			{
				Main.dust[num3] = new Dust();
				Main.dust[num3].dustIndex = num3;
			}
			for (int num4 = 0; num4 < 600; num4++)
			{
				Main.gore[num4] = new Gore();
			}
			for (int num5 = 0; num5 < 400; num5++)
			{
				Main.item[num5] = new Item();
				Main.timeItemSlotCannotBeReusedFor[num5] = 0;
			}
			for (int num6 = 0; num6 < 200; num6++)
			{
				Main.npc[num6] = new NPC();
			}
			for (int num7 = 0; num7 < 1000; num7++)
			{
				Main.projectile[num7] = new Projectile();
			}
			for (int num8 = 0; num8 < 8000; num8++)
			{
				Main.chest[num8] = null;
			}
			for (int num9 = 0; num9 < 1000; num9++)
			{
				Main.sign[num9] = null;
			}
			for (int num10 = 0; num10 < Liquid.maxLiquid; num10++)
			{
				Main.liquid[num10] = new Liquid();
			}
			for (int num11 = 0; num11 < 50000; num11++)
			{
				Main.liquidBuffer[num11] = new LiquidBuffer();
			}
			setWorldSize();
			Star.SpawnStars();
			worldCleared = true;
		}

		public static void setBG(int bg, int style)
		{
			switch (bg)
			{
			case 0:
				treeBG1 = style;
				SetForestBGSet(style, Main.treeMntBGSet1, Main.treeBGSet1);
				break;
			case 10:
				treeBG2 = style;
				SetForestBGSet(style, Main.treeMntBGSet2, Main.treeBGSet2);
				break;
			case 11:
				treeBG3 = style;
				SetForestBGSet(style, Main.treeMntBGSet3, Main.treeBGSet3);
				break;
			case 12:
				treeBG4 = style;
				SetForestBGSet(style, Main.treeMntBGSet4, Main.treeBGSet4);
				break;
			case 1:
				corruptBG = style;
				switch (style)
				{
				default:
					Main.corruptBG[0] = 12;
					Main.corruptBG[1] = 13;
					Main.corruptBG[2] = 14;
					break;
				case 1:
					Main.corruptBG[0] = 56;
					Main.corruptBG[1] = 57;
					Main.corruptBG[2] = 58;
					break;
				case 2:
					Main.corruptBG[0] = 211;
					Main.corruptBG[1] = 212;
					Main.corruptBG[2] = 213;
					break;
				case 3:
					Main.corruptBG[0] = 225;
					Main.corruptBG[1] = 226;
					Main.corruptBG[2] = 227;
					break;
				case 4:
					Main.corruptBG[0] = 240;
					Main.corruptBG[1] = 241;
					Main.corruptBG[2] = 242;
					break;
				}
				break;
			case 2:
				jungleBG = style;
				switch (style)
				{
				default:
					Main.jungleBG[0] = 15;
					Main.jungleBG[1] = 16;
					Main.jungleBG[2] = 17;
					break;
				case 1:
					Main.jungleBG[0] = 59;
					Main.jungleBG[1] = 60;
					Main.jungleBG[2] = 61;
					break;
				case 2:
					Main.jungleBG[0] = 222;
					Main.jungleBG[1] = 223;
					Main.jungleBG[2] = 224;
					break;
				case 3:
					Main.jungleBG[0] = 237;
					Main.jungleBG[1] = 238;
					Main.jungleBG[2] = 239;
					break;
				case 4:
					Main.jungleBG[0] = 284;
					Main.jungleBG[1] = 285;
					Main.jungleBG[2] = 286;
					break;
				case 5:
					Main.jungleBG[0] = 271;
					Main.jungleBG[1] = 272;
					Main.jungleBG[2] = 273;
					break;
				}
				break;
			case 3:
				snowBG = style;
				Main.snowMntBG[0] = 35;
				Main.snowMntBG[1] = 36;
				switch (style)
				{
				default:
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 1:
					Main.snowBG[0] = 97;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 95;
					break;
				case 2:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 99;
					Main.snowBG[0] = -1;
					Main.snowBG[1] = -1;
					Main.snowBG[2] = -1;
					break;
				case 21:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 99;
					Main.snowBG[0] = 95;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 97;
					break;
				case 22:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 99;
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 3:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 100;
					Main.snowBG[0] = -1;
					Main.snowBG[1] = -1;
					Main.snowBG[2] = -1;
					break;
				case 31:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 100;
					Main.snowBG[0] = 95;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 97;
					break;
				case 32:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 100;
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 4:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 101;
					Main.snowBG[0] = -1;
					Main.snowBG[1] = -1;
					Main.snowBG[2] = -1;
					break;
				case 41:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 101;
					Main.snowBG[0] = 95;
					Main.snowBG[1] = 96;
					Main.snowBG[2] = 97;
					break;
				case 42:
					Main.snowMntBG[0] = 98;
					Main.snowMntBG[1] = 101;
					Main.snowBG[0] = 37;
					Main.snowBG[1] = 38;
					Main.snowBG[2] = 39;
					break;
				case 5:
					Main.snowMntBG[0] = -1;
					Main.snowMntBG[1] = -1;
					Main.snowBG[0] = 258;
					Main.snowBG[1] = 259;
					Main.snowBG[2] = 260;
					break;
				case 6:
					Main.snowMntBG[0] = -1;
					Main.snowMntBG[1] = -1;
					Main.snowBG[0] = 263;
					Main.snowBG[1] = 264;
					Main.snowBG[2] = 265;
					break;
				case 7:
					Main.snowMntBG[0] = 269;
					Main.snowMntBG[1] = 270;
					Main.snowBG[0] = 267;
					Main.snowBG[1] = 266;
					Main.snowBG[2] = 268;
					break;
				}
				break;
			case 4:
				hallowBG = style;
				switch (style)
				{
				default:
					Main.hallowBG[0] = 29;
					Main.hallowBG[1] = 30;
					Main.hallowBG[2] = 31;
					break;
				case 1:
					Main.hallowBG[0] = 102;
					Main.hallowBG[1] = 103;
					Main.hallowBG[2] = 104;
					break;
				case 2:
					Main.hallowBG[0] = 219;
					Main.hallowBG[1] = 220;
					Main.hallowBG[2] = 221;
					break;
				case 3:
					Main.hallowBG[0] = 243;
					Main.hallowBG[1] = 244;
					Main.hallowBG[2] = 245;
					break;
				case 4:
					Main.hallowBG[0] = -1;
					Main.hallowBG[1] = 261;
					Main.hallowBG[2] = 262;
					break;
				}
				break;
			case 5:
				crimsonBG = style;
				switch (style)
				{
				default:
					Main.crimsonBG[0] = 43;
					Main.crimsonBG[1] = 44;
					Main.crimsonBG[2] = 45;
					break;
				case 1:
					Main.crimsonBG[0] = 105;
					Main.crimsonBG[1] = 106;
					Main.crimsonBG[2] = 107;
					break;
				case 2:
					Main.crimsonBG[0] = 174;
					Main.crimsonBG[1] = -1;
					Main.crimsonBG[2] = 175;
					break;
				case 3:
					Main.crimsonBG[0] = 214;
					Main.crimsonBG[1] = 215;
					Main.crimsonBG[2] = 216;
					break;
				case 4:
					Main.crimsonBG[0] = -1;
					Main.crimsonBG[1] = 229;
					Main.crimsonBG[2] = 230;
					break;
				case 5:
					Main.crimsonBG[0] = 255;
					Main.crimsonBG[1] = 256;
					Main.crimsonBG[2] = 257;
					break;
				}
				break;
			case 6:
				desertBG = style;
				switch (style)
				{
				default:
					Main.desertBG[0] = 21;
					Main.desertBG[1] = 20;
					Main.desertBG[2] = -1;
					break;
				case 1:
					Main.desertBG[0] = 108;
					Main.desertBG[1] = 109;
					Main.desertBG[2] = -1;
					break;
				case 2:
					Main.desertBG[0] = 207;
					Main.desertBG[1] = 208;
					Main.desertBG[2] = -1;
					break;
				case 3:
					Main.desertBG[0] = 217;
					Main.desertBG[1] = 218;
					Main.desertBG[2] = -1;
					break;
				case 4:
					Main.desertBG[0] = 248;
					Main.desertBG[1] = 249;
					Main.desertBG[2] = 250;
					break;
				}
				break;
			case 7:
				oceanBG = style;
				switch (style)
				{
				default:
					Main.oceanBG = 28;
					break;
				case 1:
					Main.oceanBG = 110;
					break;
				case 2:
					Main.oceanBG = 111;
					break;
				case 3:
					Main.oceanBG = 209;
					break;
				case 4:
					Main.oceanBG = 210;
					break;
				case 5:
					Main.oceanBG = 283;
					break;
				}
				break;
			case 8:
				mushroomBG = style;
				switch (style)
				{
				default:
					Main.mushroomBG[0] = 46;
					Main.mushroomBG[1] = 47;
					Main.mushroomBG[2] = 48;
					break;
				case 1:
					Main.mushroomBG[0] = 231;
					Main.mushroomBG[1] = 232;
					Main.mushroomBG[2] = 233;
					break;
				case 2:
					Main.mushroomBG[0] = 234;
					Main.mushroomBG[1] = 235;
					Main.mushroomBG[2] = 236;
					break;
				case 3:
					Main.mushroomBG[0] = 287;
					Main.mushroomBG[1] = 288;
					Main.mushroomBG[2] = 289;
					break;
				}
				break;
			case 9:
				underworldBG = style;
				switch (style)
				{
				default:
					Main.underworldBG[0] = 0;
					Main.underworldBG[1] = 1;
					Main.underworldBG[2] = 2;
					Main.underworldBG[3] = 3;
					Main.underworldBG[4] = 4;
					break;
				case 1:
					Main.underworldBG[0] = 5;
					Main.underworldBG[1] = 6;
					Main.underworldBG[2] = 7;
					Main.underworldBG[3] = 8;
					Main.underworldBG[4] = 9;
					break;
				case 2:
					Main.underworldBG[0] = 10;
					Main.underworldBG[1] = 11;
					Main.underworldBG[2] = 12;
					Main.underworldBG[3] = 13;
					Main.underworldBG[4] = 9;
					break;
				}
				break;
			}
		}

		private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet)
		{
			mountainSet[0] = 7;
			mountainSet[1] = 8;
			switch (style)
			{
			case 1:
				treeSet[0] = 50;
				treeSet[1] = 51;
				treeSet[2] = 52;
				break;
			case 2:
				treeSet[0] = 53;
				treeSet[1] = 54;
				treeSet[2] = 55;
				break;
			case 3:
				mountainSet[1] = 90;
				treeSet[0] = 91;
				treeSet[1] = -1;
				treeSet[2] = 92;
				break;
			case 31:
				mountainSet[1] = 90;
				treeSet[0] = 91;
				treeSet[1] = -1;
				treeSet[2] = 11;
				break;
			case 4:
				mountainSet[0] = 93;
				mountainSet[1] = 94;
				treeSet[0] = -1;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 5:
				mountainSet[0] = 93;
				mountainSet[1] = 94;
				treeSet[0] = -1;
				treeSet[1] = -1;
				treeSet[2] = 55;
				break;
			case 51:
				mountainSet[0] = 93;
				mountainSet[1] = 94;
				treeSet[0] = -1;
				treeSet[1] = -1;
				treeSet[2] = 11;
				break;
			case 6:
				mountainSet[0] = 171;
				mountainSet[1] = 172;
				treeSet[0] = 173;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 7:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 71:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = 11;
				break;
			case 72:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = 52;
				break;
			case 73:
				mountainSet[0] = 176;
				mountainSet[1] = 177;
				treeSet[0] = 178;
				treeSet[1] = -1;
				treeSet[2] = 55;
				break;
			case 8:
				mountainSet[0] = 179;
				mountainSet[1] = 180;
				treeSet[0] = 184;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 9:
				mountainSet[0] = 277;
				mountainSet[1] = 278;
				treeSet[0] = 279;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			case 10:
				mountainSet[0] = 280;
				mountainSet[1] = 281;
				treeSet[0] = 282;
				treeSet[1] = -1;
				treeSet[2] = -1;
				break;
			default:
				treeSet[0] = 9;
				treeSet[1] = 10;
				treeSet[2] = 11;
				break;
			}
		}

		public static void RandomizeWeather()
		{
			Main.numClouds = genRand.Next(10, 200);
			Main.windSpeedCurrent = 0f;
			while (Main.windSpeedCurrent == 0f)
			{
				Main.windSpeedCurrent = (float)genRand.Next(-400, 401) * 0.001f;
				Main.windSpeedTarget = Main.windSpeedCurrent;
			}
			Cloud.resetClouds();
		}

		public static void RandomizeMoonState(UnifiedRandom random, bool garenteeNewStyle = false)
		{
			int moonType = Main.moonType;
			do
			{
				Main.moonType = random.Next(9);
			}
			while (garenteeNewStyle && moonType == Main.moonType);
		}

		public static void RandomizeBackgroundBasedOnPlayer(UnifiedRandom random, Player player)
		{
			if (player.ZoneGlowshroom)
			{
				int num = mushroomBG;
				while (num == mushroomBG)
				{
					setBG(8, random.Next(4));
				}
			}
			else if (player.ZoneUnderworldHeight)
			{
				int num = underworldBG;
				while (num == underworldBG)
				{
					setBG(9, random.Next(3));
				}
			}
			else if (player.ZoneDesert)
			{
				int num = desertBG;
				while (num == desertBG)
				{
					setBG(6, random.Next(5));
				}
			}
			else if (player.ZoneHallow)
			{
				int num = hallowBG;
				while (num == hallowBG)
				{
					setBG(4, random.Next(5));
				}
			}
			else if (player.ZoneCorrupt)
			{
				int num = corruptBG;
				while (num == corruptBG)
				{
					setBG(1, random.Next(5));
				}
			}
			else if (player.ZoneCrimson)
			{
				int num = crimsonBG;
				while (num == crimsonBG)
				{
					setBG(5, random.Next(6));
				}
			}
			else if (player.ZoneJungle)
			{
				int num = jungleBG;
				while (num == jungleBG)
				{
					setBG(2, random.Next(6));
				}
			}
			else if (player.ZoneSnow)
			{
				int num = snowBG;
				while (num == snowBG)
				{
					snowBG = random.Next(8);
					if (snowBG == 2 && random.Next(2) == 0)
					{
						if (random.Next(2) == 0)
						{
							snowBG = 21;
						}
						else
						{
							snowBG = 22;
						}
					}
					if (snowBG == 3 && random.Next(2) == 0)
					{
						if (random.Next(2) == 0)
						{
							snowBG = 31;
						}
						else
						{
							snowBG = 32;
						}
					}
					if (snowBG == 4 && random.Next(2) == 0)
					{
						if (random.Next(2) == 0)
						{
							snowBG = 41;
						}
						else
						{
							snowBG = 42;
						}
					}
					setBG(3, snowBG);
				}
			}
			else if (player.ZoneBeach)
			{
				int num = oceanBG;
				while (num == oceanBG)
				{
					setBG(7, random.Next(6));
				}
			}
			else
			{
				int num2 = (int)(player.Center.X / 16f);
				if (num2 < Main.treeX[0])
				{
					int num = treeBG1;
					while (IsBackgroundConsideredTheSame(num, treeBG1))
					{
						treeBG1 = RollRandomForestBGStyle(random);
					}
					setBG(0, treeBG1);
				}
				else if (num2 < Main.treeX[1])
				{
					int num = treeBG2;
					while (IsBackgroundConsideredTheSame(num, treeBG2))
					{
						treeBG2 = RollRandomForestBGStyle(random);
					}
					setBG(10, treeBG2);
				}
				else if (num2 < Main.treeX[2])
				{
					int num = treeBG3;
					while (IsBackgroundConsideredTheSame(num, treeBG3))
					{
						treeBG3 = RollRandomForestBGStyle(random);
					}
					setBG(11, treeBG3);
				}
				else
				{
					int num = treeBG4;
					while (IsBackgroundConsideredTheSame(num, treeBG4))
					{
						treeBG4 = RollRandomForestBGStyle(random);
					}
					setBG(12, treeBG4);
				}
			}
			BackgroundsCache.UpdateCache();
		}

		public static void RandomizeBackgrounds(UnifiedRandom random)
		{
			treeBG1 = RollRandomForestBGStyle(random);
			for (treeBG2 = RollRandomForestBGStyle(random); treeBG2 == treeBG1; treeBG2 = RollRandomForestBGStyle(random))
			{
			}
			treeBG3 = RollRandomForestBGStyle(random);
			while (treeBG3 == treeBG1 || treeBG3 == treeBG2)
			{
				treeBG3 = RollRandomForestBGStyle(random);
			}
			treeBG4 = RollRandomForestBGStyle(random);
			while (treeBG4 == treeBG1 || treeBG4 == treeBG2 || treeBG4 == treeBG3)
			{
				treeBG4 = RollRandomForestBGStyle(random);
			}
			setBG(0, treeBG1);
			setBG(10, treeBG2);
			setBG(11, treeBG3);
			setBG(12, treeBG4);
			setBG(1, random.Next(5));
			setBG(2, random.Next(6));
			snowBG = random.Next(8);
			if (snowBG == 2 && random.Next(2) == 0)
			{
				if (random.Next(2) == 0)
				{
					snowBG = 21;
				}
				else
				{
					snowBG = 22;
				}
			}
			if (snowBG == 3 && random.Next(2) == 0)
			{
				if (random.Next(2) == 0)
				{
					snowBG = 31;
				}
				else
				{
					snowBG = 32;
				}
			}
			if (snowBG == 4 && random.Next(2) == 0)
			{
				if (random.Next(2) == 0)
				{
					snowBG = 41;
				}
				else
				{
					snowBG = 42;
				}
			}
			setBG(3, snowBG);
			setBG(4, random.Next(5));
			setBG(5, random.Next(6));
			setBG(6, random.Next(5));
			setBG(7, random.Next(6));
			setBG(8, random.Next(4));
			setBG(9, random.Next(3));
		}

		private static int RollRandomForestBGStyle(UnifiedRandom random)
		{
			int num = random.Next(11);
			if ((num == 1 || num == 2) && random.Next(2) == 0)
			{
				num = random.Next(11);
			}
			if (num == 0)
			{
				num = random.Next(11);
			}
			if (num == 3 && random.Next(3) == 0)
			{
				num = 31;
			}
			if (num == 5 && random.Next(2) == 0)
			{
				num = 51;
			}
			if (num == 7 && random.Next(4) == 0)
			{
				num = random.Next(71, 74);
			}
			return num;
		}

		public static bool IsBackgroundConsideredTheSame(int oldBG, int newBG)
		{
			switch (oldBG)
			{
			case 3:
			case 31:
				if (newBG != 3)
				{
					return newBG == 31;
				}
				return true;
			case 5:
			case 51:
				if (newBG != 5)
				{
					return newBG == 51;
				}
				return true;
			case 7:
			case 71:
			case 72:
			case 73:
				if (newBG != 7)
				{
					if (newBG >= 71)
					{
						return newBG <= 73;
					}
					return false;
				}
				return true;
			default:
				return oldBG == newBG;
			}
		}

		public static void RandomizeTreeStyle()
		{
			if (Main.maxTilesX == 4200)
			{
				Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.25));
				Main.treeStyle[0] = genRand.Next(6);
				Main.treeStyle[1] = genRand.Next(6);
				while (Main.treeStyle[1] == Main.treeStyle[0])
				{
					Main.treeStyle[1] = genRand.Next(6);
				}
				Main.treeX[1] = Main.maxTilesX;
				Main.treeX[2] = Main.maxTilesX;
				for (int i = 0; i < 2; i++)
				{
					if (Main.treeStyle[i] == 0 && genRand.Next(3) != 0)
					{
						Main.treeStyle[i] = 4;
					}
				}
				return;
			}
			if (Main.maxTilesX == 6400)
			{
				Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.334 + (double)Main.maxTilesX * 0.2));
				Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.667 + (double)Main.maxTilesX * 0.2));
				Main.treeStyle[0] = genRand.Next(6);
				Main.treeStyle[1] = genRand.Next(6);
				Main.treeStyle[2] = genRand.Next(6);
				while (Main.treeStyle[1] == Main.treeStyle[0])
				{
					Main.treeStyle[1] = genRand.Next(6);
				}
				while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
				{
					Main.treeStyle[2] = genRand.Next(6);
				}
				Main.treeX[2] = Main.maxTilesX;
				for (int j = 0; j < 3; j++)
				{
					if (Main.treeStyle[j] == 0 && genRand.Next(3) != 0)
					{
						Main.treeStyle[j] = 4;
					}
				}
				return;
			}
			Main.treeX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.25 + (double)Main.maxTilesX * 0.15));
			Main.treeX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.15));
			Main.treeX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.75 + (double)Main.maxTilesX * 0.15));
			Main.treeStyle[0] = genRand.Next(6);
			Main.treeStyle[1] = genRand.Next(6);
			Main.treeStyle[2] = genRand.Next(6);
			Main.treeStyle[3] = genRand.Next(6);
			while (Main.treeStyle[1] == Main.treeStyle[0])
			{
				Main.treeStyle[1] = genRand.Next(6);
			}
			while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
			{
				Main.treeStyle[2] = genRand.Next(6);
			}
			while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2])
			{
				Main.treeStyle[3] = genRand.Next(6);
			}
			for (int k = 0; k < 4; k++)
			{
				if (Main.treeStyle[k] == 0 && genRand.Next(3) != 0)
				{
					Main.treeStyle[k] = 4;
				}
			}
		}

		public static void RandomizeCaveBackgrounds()
		{
			int maxValue = 8;
			if (Main.maxTilesX == 4200)
			{
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.25));
				Main.caveBackX[1] = Main.maxTilesX;
				Main.caveBackX[2] = Main.maxTilesX;
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
				{
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
			}
			else if (Main.maxTilesX == 6400)
			{
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.334 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.334 + (double)Main.maxTilesX * 0.2));
				Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.667 - (double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.667 + (double)Main.maxTilesX * 0.2));
				Main.caveBackX[2] = Main.maxTilesX;
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				Main.caveBackStyle[2] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
				{
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
				while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
				{
					Main.caveBackStyle[2] = genRand.Next(maxValue);
				}
			}
			else
			{
				Main.caveBackX[0] = genRand.Next((int)((double)Main.maxTilesX * 0.25 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.25 + (double)Main.maxTilesX * 0.15));
				Main.caveBackX[1] = genRand.Next((int)((double)Main.maxTilesX * 0.5 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.5 + (double)Main.maxTilesX * 0.15));
				Main.caveBackX[2] = genRand.Next((int)((double)Main.maxTilesX * 0.75 - (double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.75 + (double)Main.maxTilesX * 0.15));
				Main.caveBackStyle[0] = genRand.Next(maxValue);
				Main.caveBackStyle[1] = genRand.Next(maxValue);
				Main.caveBackStyle[2] = genRand.Next(maxValue);
				Main.caveBackStyle[3] = genRand.Next(maxValue);
				while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
				{
					Main.caveBackStyle[1] = genRand.Next(maxValue);
				}
				while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
				{
					Main.caveBackStyle[2] = genRand.Next(maxValue);
				}
				while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2])
				{
					Main.caveBackStyle[3] = genRand.Next(maxValue);
				}
			}
			Main.iceBackStyle = genRand.Next(4);
			Main.hellBackStyle = genRand.Next(3);
			Main.jungleBackStyle = genRand.Next(2);
		}

		private static void ResetGenerator()
		{
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			GenVars.numOrePatch = 0;
			GenVars.numTunnels = 0;
			GenVars.numLakes = 0;
			GenVars.numMushroomBiomes = 0;
			GenVars.numOceanCaveTreasure = 0;
			GenVars.numOasis = 0;
			GenVars.mudWall = false;
			GenVars.hellChest = 0;
			GenVars.JungleX = 0;
			GenVars.numMCaves = 0;
			GenVars.numIslandHouses = 0;
			GenVars.skyIslandHouseCount = 0;
			GenVars.dEnteranceX = 0;
			GenVars.numDRooms = 0;
			GenVars.numDDoors = 0;
			GenVars.generatedShadowKey = false;
			GenVars.numDungeonPlatforms = 0;
			GenVars.numJChests = 0;
			GenVars.JungleItemCount = 0;
			GenVars.lastDungeonHall = Vector2D.get_Zero();
		}

		public static bool mayanTrap(int x2, int y2)
		{
			int num = 1;
			if (genRand.Next(3) == 0)
			{
				num = 0;
			}
			int num2 = y2;
			while (!SolidOrSlopedTile(x2, num2))
			{
				num2++;
				if (num2 >= Main.maxTilesY - 300)
				{
					return false;
				}
			}
			if (Main.tile[x2, num2].type == 232 || Main.tile[x2, num2].type == 10)
			{
				return false;
			}
			num2--;
			if (Main.tile[x2, num2].liquid > 0 && Main.tile[x2, num2].lava())
			{
				return false;
			}
			if (num == -1 && genRand.Next(20) == 0)
			{
				num = 2;
			}
			else if (num == -1)
			{
				num = genRand.Next(2);
			}
			if (Main.tile[x2, num2].nactive() || Main.tile[x2 - 1, num2].nactive() || Main.tile[x2 + 1, num2].nactive() || Main.tile[x2, num2 - 1].nactive() || Main.tile[x2 - 1, num2 - 1].nactive() || Main.tile[x2 + 1, num2 - 1].nactive() || Main.tile[x2, num2 - 2].nactive() || Main.tile[x2 - 1, num2 - 2].nactive() || Main.tile[x2 + 1, num2 - 2].nactive())
			{
				return false;
			}
			if (Main.tile[x2, num2 + 1].type == 10)
			{
				return false;
			}
			if (Main.tile[x2, num2 + 1].type == 48)
			{
				return false;
			}
			if (Main.tile[x2, num2 + 1].type == 232)
			{
				return false;
			}
			switch (num)
			{
			case 0:
			{
				int num12 = x2;
				int num13 = num2;
				num13 -= genRand.Next(3);
				while (InWorld(num12, num13, 5) && !SolidOrSlopedTile(num12, num13))
				{
					num12--;
				}
				int num14 = num12;
				for (num12 = x2; InWorld(num12, num13, 5) && !SolidOrSlopedTile(num12, num13); num12++)
				{
				}
				int num15 = num12;
				int num16 = x2 - num14;
				int num17 = num15 - x2;
				bool flag = false;
				bool flag2 = false;
				if (num16 > 5 && num16 < 50)
				{
					flag = true;
				}
				if (num17 > 5 && num17 < 50)
				{
					flag2 = true;
				}
				if (flag && !SolidOrSlopedTile(num14, num13 + 1))
				{
					flag = false;
				}
				if (flag2 && !SolidOrSlopedTile(num15, num13 + 1))
				{
					flag2 = false;
				}
				if (flag && (Main.tile[num14, num13].type == 10 || Main.tile[num14, num13].type == 48 || Main.tile[num14, num13 + 1].type == 10 || Main.tile[num14, num13 + 1].type == 48))
				{
					flag = false;
				}
				if (flag2 && (Main.tile[num15, num13].type == 10 || Main.tile[num15, num13].type == 48 || Main.tile[num15, num13 + 1].type == 10 || Main.tile[num15, num13 + 1].type == 48))
				{
					flag2 = false;
				}
				int num18 = 0;
				if (flag && flag2)
				{
					num18 = 1;
					num12 = num14;
					if (genRand.Next(2) == 0)
					{
						num12 = num15;
						num18 = -1;
					}
				}
				else if (flag2)
				{
					num12 = num15;
					num18 = -1;
				}
				else
				{
					if (!flag)
					{
						return false;
					}
					num12 = num14;
					num18 = 1;
				}
				if (Main.tile[num12, num13].wall != 87)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 190)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 135)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 137)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 232)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 237)
				{
					return false;
				}
				if (Main.tile[num12, num13].type == 10)
				{
					return false;
				}
				PlaceTile(x2, num2, 135, mute: true, forced: true, -1, 6);
				KillTile(num12, num13);
				int num19 = genRand.Next(3);
				if (Main.tile[x2, num2].wire())
				{
					num19 = 0;
				}
				if (Main.tile[x2, num2].wire2())
				{
					num19 = 1;
				}
				if (Main.tile[x2, num2].wire3())
				{
					num19 = 2;
				}
				int num20 = Math.Abs(num12 - x2);
				int style2 = 1;
				if (num20 < 10 && genRand.Next(3) != 0)
				{
					style2 = 2;
				}
				PlaceTile(num12, num13, 137, mute: true, forced: true, -1, style2);
				if (num18 == 1)
				{
					Main.tile[num12, num13].frameX += 18;
				}
				int num21 = genRand.Next(5);
				int num22 = num13;
				while (num21 > 0)
				{
					num21--;
					num22--;
					if (!SolidTile(num12, num22) || !SolidTile(num12 - num18, num22) || SolidOrSlopedTile(num12 + num18, num22))
					{
						break;
					}
					PlaceTile(num12, num22, 137, mute: true, forced: true, -1, style2);
					if (num18 == 1)
					{
						Main.tile[num12, num22].frameX += 18;
					}
					switch (num19)
					{
					case 0:
						Main.tile[num12, num22].wire(wire: true);
						break;
					case 1:
						Main.tile[num12, num22].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num12, num22].wire3(wire3: true);
						break;
					}
				}
				int num23 = x2;
				int num24 = num2;
				while (num23 != num12 || num24 != num13)
				{
					switch (num19)
					{
					case 0:
						Main.tile[num23, num24].wire(wire: true);
						break;
					case 1:
						Main.tile[num23, num24].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num23, num24].wire3(wire3: true);
						break;
					}
					if (num23 > num12)
					{
						num23--;
					}
					if (num23 < num12)
					{
						num23++;
					}
					switch (num19)
					{
					case 0:
						Main.tile[num23, num24].wire(wire: true);
						break;
					case 1:
						Main.tile[num23, num24].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num23, num24].wire3(wire3: true);
						break;
					}
					if (num24 > num13)
					{
						num24--;
					}
					if (num24 < num13)
					{
						num24++;
					}
					switch (num19)
					{
					case 0:
						Main.tile[num23, num24].wire(wire: true);
						break;
					case 1:
						Main.tile[num23, num24].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num23, num24].wire3(wire3: true);
						break;
					}
				}
				return true;
			}
			case 1:
			{
				int num3 = x2;
				int num4 = num2;
				while (!SolidOrSlopedTile(num3, num4))
				{
					num4--;
					if ((double)num4 < Main.worldSurface)
					{
						return false;
					}
				}
				int num5 = Math.Abs(num4 - num2);
				if (num5 < 3)
				{
					return false;
				}
				int num6 = genRand.Next(3);
				if (Main.tile[x2, num2].wire())
				{
					num6 = 0;
				}
				if (Main.tile[x2, num2].wire2())
				{
					num6 = 1;
				}
				if (Main.tile[x2, num2].wire3())
				{
					num6 = 2;
				}
				int style = 3;
				if (num5 < 16 && genRand.Next(3) != 0)
				{
					style = 4;
				}
				if (Main.tile[num3, num4].type == 135)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 137)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 232)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 237)
				{
					return false;
				}
				if (Main.tile[num3, num4].type == 10)
				{
					return false;
				}
				if (Main.tile[num3, num4].wall != 87)
				{
					return false;
				}
				PlaceTile(x2, num2, 135, mute: true, forced: true, -1, 6);
				PlaceTile(num3, num4, 137, mute: true, forced: true, -1, style);
				for (int i = 0; i < 2; i++)
				{
					int num7 = genRand.Next(1, 5);
					int num8 = num3;
					int num9 = -1;
					if (i == 1)
					{
						num9 = 1;
					}
					while (num7 > 0)
					{
						num7--;
						num8 += num9;
						if (!SolidTile(num8, num4 - 1) || SolidOrSlopedTile(num8, num4 + 1))
						{
							break;
						}
						PlaceTile(num8, num4, 137, mute: true, forced: true, -1, style);
						switch (num6)
						{
						case 0:
							Main.tile[num8, num4].wire(wire: true);
							break;
						case 1:
							Main.tile[num8, num4].wire2(wire2: true);
							break;
						case 2:
							Main.tile[num8, num4].wire3(wire3: true);
							break;
						}
					}
				}
				int num10 = x2;
				int num11 = num2;
				while (num10 != num3 || num11 != num4)
				{
					switch (num6)
					{
					case 0:
						Main.tile[num10, num11].wire(wire: true);
						break;
					case 1:
						Main.tile[num10, num11].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num10, num11].wire3(wire3: true);
						break;
					}
					if (num10 > num3)
					{
						num10--;
					}
					if (num10 < num3)
					{
						num10++;
					}
					switch (num6)
					{
					case 0:
						Main.tile[num10, num11].wire(wire: true);
						break;
					case 1:
						Main.tile[num10, num11].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num10, num11].wire3(wire3: true);
						break;
					}
					if (num11 > num4)
					{
						num11--;
					}
					if (num11 < num4)
					{
						num11++;
					}
					switch (num6)
					{
					case 0:
						Main.tile[num10, num11].wire(wire: true);
						break;
					case 1:
						Main.tile[num10, num11].wire2(wire2: true);
						break;
					case 2:
						Main.tile[num10, num11].wire3(wire3: true);
						break;
					}
				}
				return true;
			}
			default:
				return false;
			}
		}

		public static bool placeLavaTrap(int x, int y)
		{
			int num = 5;
			int num2 = 50;
			int num3 = 40;
			int num4 = 20;
			int num5 = 4;
			if (Main.tile[x, y].active() || Main.tile[x, y].liquid < byte.MaxValue || !Main.tile[x, y].lava())
			{
				return false;
			}
			int num6 = 0;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (Main.tile[i, j].lava() && !Main.tile[i, j].active() && Main.tile[i, j].liquid == byte.MaxValue)
					{
						num6++;
					}
				}
			}
			if (num6 < num2)
			{
				return false;
			}
			int num7 = y;
			while (!Main.tile[x, num7].active())
			{
				num7++;
				if (num7 > Main.maxTilesY - 200)
				{
					return false;
				}
			}
			if (!Main.tileSolid[Main.tile[x, num7].type] || Main.tileSolidTop[Main.tile[x, num7].type])
			{
				return false;
			}
			int num8 = num7;
			for (int k = x - num4; k <= x + num4; k++)
			{
				for (int l = num7 - num4; l <= num7 + num4; l++)
				{
					if (Main.tile[k, l].wire())
					{
						return false;
					}
				}
			}
			while (Main.tile[x, num7].active() && Main.tileSolid[Main.tile[x, num7].type] && !Main.tileSolidTop[Main.tile[x, num7].type])
			{
				num7++;
				if (num7 > Main.maxTilesY - 200)
				{
					return false;
				}
			}
			Tile tile = Main.tile[x, num7 - 1];
			if (Main.tileDungeon[tile.type] || tile.type == 225 || tile.type == 226)
			{
				return false;
			}
			int num9 = num7;
			while (!Main.tile[x, num7].active())
			{
				num7++;
				if (num7 > Main.maxTilesY - 200 || Main.tile[x, num7].liquid > 0)
				{
					return false;
				}
			}
			if (!Main.tileSolid[Main.tile[x, num7].type] || Main.tileSolidTop[Main.tile[x, num7].type] || Main.tile[x, num7].type == 162)
			{
				return false;
			}
			int num10 = num7 - 1;
			if (num10 - num8 > num3)
			{
				return false;
			}
			if (num10 - num9 < num5)
			{
				return false;
			}
			Main.tile[x, num7].slope(0);
			Main.tile[x, num7].halfBrick(halfBrick: false);
			PlaceTile(x, num10, 135, mute: false, forced: true, -1, 7);
			for (int m = num8; m <= num10; m++)
			{
				Main.tile[x, m].wire(wire: true);
				if (m < num9)
				{
					Main.tile[x, m].slope(0);
					Main.tile[x, m].halfBrick(halfBrick: false);
					Main.tile[x, m].actuator(actuator: true);
				}
			}
			return true;
		}

		public static bool IsTileNearby(int x, int y, int type, int distance)
		{
			for (int i = x - distance; i <= x + distance; i++)
			{
				for (int j = y - distance; j <= y + distance; j++)
				{
					if (InWorld(i, j) && Main.tile[i, j].active() && Main.tile[i, j].type == type)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool placeTNTBarrel(int x, int y)
		{
			int num = y;
			while (!Main.tile[x, num].active())
			{
				num++;
				if (num > Main.maxTilesY - 350)
				{
					return false;
				}
			}
			num--;
			if (Main.tile[x, num].shimmer())
			{
				return false;
			}
			if (PlaceTile(x, num, 654))
			{
				return true;
			}
			return false;
		}

		public static bool placeTrap(int x2, int y2, int type = -1)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			int num = y2;
			if (Vector2D.Distance(new Vector2D((double)x2, (double)y2), GenVars.shimmerPosition) < 100.0)
			{
				return false;
			}
			bool flag = false;
			bool flag2 = false;
			if (noTrapsWorldGen)
			{
				Main.tileSolid[138] = false;
			}
			while (!SolidTile(x2, num))
			{
				num++;
				if (num > Main.maxTilesY - 10)
				{
					return false;
				}
				if (num >= Main.maxTilesY - 300)
				{
					flag2 = true;
				}
			}
			if (noTrapsWorldGen)
			{
				Main.tileSolid[138] = true;
			}
			num--;
			if (!noTrapsWorldGen && IsTileNearby(x2, num, 70, 20))
			{
				return false;
			}
			if (Main.tile[x2, num].wall == 87)
			{
				return false;
			}
			if (Main.tile[x2, num].liquid > 0 && Main.tile[x2, num].lava())
			{
				flag = true;
			}
			if (Main.remixWorld)
			{
				if (type == -1 && genRand.Next(20) == 0)
				{
					type = 2;
				}
				else if (type == -1 && (double)num < Main.rockLayer - 30.0 && genRand.Next(3) != 0)
				{
					type = 3;
				}
				else if (type == -1)
				{
					type = genRand.Next(2);
				}
			}
			else if (type == -1 && genRand.Next(20) == 0)
			{
				type = 2;
			}
			else if (type == -1 && num > GenVars.lavaLine + 30 && genRand.Next(6) != 0)
			{
				type = 3;
			}
			else if (type == -1)
			{
				type = genRand.Next(2);
			}
			if (!InWorld(x2, num, 3))
			{
				return false;
			}
			if (flag && type != 3)
			{
				return false;
			}
			if (flag2 && type != 3)
			{
				return false;
			}
			if (Main.tile[x2, num].nactive() || Main.tile[x2 - 1, num].nactive() || Main.tile[x2 + 1, num].nactive() || Main.tile[x2, num - 1].nactive() || Main.tile[x2 - 1, num - 1].nactive() || Main.tile[x2 + 1, num - 1].nactive() || Main.tile[x2, num - 2].nactive() || Main.tile[x2 - 1, num - 2].nactive() || Main.tile[x2 + 1, num - 2].nactive())
			{
				return false;
			}
			if (Main.tile[x2, num + 1].type == 48)
			{
				return false;
			}
			if (Main.tile[x2, num + 1].type == 232)
			{
				return false;
			}
			if (type == 1)
			{
				for (int i = x2 - 3; i <= x2 + 3; i++)
				{
					for (int j = num - 3; j <= num + 3; j++)
					{
						if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161)
						{
							type = 0;
						}
					}
				}
			}
			if (noTrapsWorldGen)
			{
				Main.tileSolid[138] = false;
			}
			switch (type)
			{
			case 0:
			{
				int num20 = x2;
				int num21 = num;
				num21 -= genRand.Next(3);
				while (!SolidTile(num20, num21) && !Main.tileCracked[Main.tile[num20, num21].type])
				{
					num20--;
					if (num20 < 0)
					{
						return false;
					}
				}
				int num22 = num20;
				num20 = x2;
				while (!SolidTile(num20, num21) && !Main.tileCracked[Main.tile[num20, num21].type])
				{
					num20++;
					if (num20 > Main.maxTilesX)
					{
						return false;
					}
				}
				int num23 = num20;
				int num24 = x2 - num22;
				int num25 = num23 - x2;
				bool flag5 = false;
				bool flag6 = false;
				if (num24 > 5 && num24 < 50)
				{
					flag5 = true;
				}
				if (num25 > 5 && num25 < 50)
				{
					flag6 = true;
				}
				if (flag5 && !SolidTile(num22, num21 + 1))
				{
					flag5 = false;
				}
				if (flag6 && !SolidTile(num23, num21 + 1))
				{
					flag6 = false;
				}
				if (flag5 && (Main.tile[num22, num21].type == 10 || Main.tile[num22, num21].type == 48 || Main.tile[num22, num21 + 1].type == 10 || Main.tile[num22, num21 + 1].type == 48))
				{
					flag5 = false;
				}
				if (flag6 && (Main.tile[num23, num21].type == 10 || Main.tile[num23, num21].type == 48 || Main.tile[num23, num21 + 1].type == 10 || Main.tile[num23, num21 + 1].type == 48))
				{
					flag6 = false;
				}
				int num26 = 0;
				if (flag5 && flag6)
				{
					num26 = 1;
					num20 = num22;
					if (genRand.Next(2) == 0)
					{
						num20 = num23;
						num26 = -1;
					}
				}
				else if (flag6)
				{
					num20 = num23;
					num26 = -1;
				}
				else
				{
					if (!flag5)
					{
						trapDiag[type, 0]++;
						return false;
					}
					num20 = num22;
					num26 = 1;
				}
				if (Main.tile[num20, num21].type == 190)
				{
					trapDiag[type, 0]++;
					return false;
				}
				if (Main.tile[x2, num].wall > 0)
				{
					PlaceTile(x2, num, 135, mute: true, forced: true, -1, 2);
				}
				else
				{
					PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
				}
				KillTile(num20, num21);
				PlaceTile(num20, num21, 137, mute: true, forced: true);
				if (num26 == 1)
				{
					Main.tile[num20, num21].frameX += 18;
				}
				int num27 = x2;
				int num28 = num;
				while (num27 != num20 || num28 != num21)
				{
					Main.tile[num27, num28].wire(wire: true);
					if (num27 > num20)
					{
						num27--;
					}
					if (num27 < num20)
					{
						num27++;
					}
					Main.tile[num27, num28].wire(wire: true);
					if (num28 > num21)
					{
						num28--;
					}
					if (num28 < num21)
					{
						num28++;
					}
					Main.tile[num27, num28].wire(wire: true);
				}
				trapDiag[type, 1]++;
				return true;
			}
			case 1:
			{
				if (noTrapsWorldGen)
				{
					Main.tileSolid[138] = true;
				}
				int num3 = x2;
				int num4 = num - 8;
				num3 += genRand.Next(-1, 2);
				if (noTrapsWorldGen)
				{
					if (IsTileNearby(num3, num4, 138, 6))
					{
						return false;
					}
					if (IsTileNearby(num3, num4, 664, 6))
					{
						return false;
					}
				}
				else
				{
					if (IsTileNearby(num3, num4, 138, 10))
					{
						return false;
					}
					if (IsTileNearby(num3, num4, 664, 10))
					{
						return false;
					}
					if (IsTileNearby(num3, num4, 665, 10))
					{
						return false;
					}
				}
				bool flag3 = true;
				while (flag3)
				{
					bool flag4 = true;
					int num5 = 0;
					for (int m = num3 - 2; m <= num3 + 3; m++)
					{
						for (int n = num4; n <= num4 + 3; n++)
						{
							if (!SolidTile(m, n))
							{
								flag4 = false;
							}
							if (Main.tile[m, n].active())
							{
								if (Main.tile[m, n].type == 226)
								{
									trapDiag[type, 0]++;
									return false;
								}
								if (Main.tile[m, n].type == 0 || Main.tile[m, n].type == 1 || Main.tile[m, n].type == 59)
								{
									num5++;
								}
							}
						}
					}
					num4--;
					if ((double)num4 < Main.worldSurface)
					{
						trapDiag[type, 0]++;
						return false;
					}
					if (flag4 && num5 > 2)
					{
						flag3 = false;
					}
				}
				if (num - num4 <= 5 || num - num4 >= 40)
				{
					trapDiag[type, 0]++;
					return false;
				}
				for (int num6 = num3; num6 <= num3 + 1; num6++)
				{
					for (int num7 = num4; num7 <= num; num7++)
					{
						KillTile(num6, num7);
					}
				}
				for (int num8 = num3 - 2; num8 <= num3 + 3; num8++)
				{
					for (int num9 = num4 - 2; num9 <= num4 + 3; num9++)
					{
						if (SolidTile(num8, num9))
						{
							Main.tile[num8, num9].type = 1;
						}
					}
				}
				if (IsTileNearby(num3, num4, 21, 4) || IsTileNearby(num3, num4, 467, 4))
				{
					trapDiag[type, 0]++;
					return false;
				}
				PlaceTile(x2, num, 135, mute: true, forced: true, -1, 7);
				PlaceTile(num3, num4 + 2, 130, mute: true);
				PlaceTile(num3 + 1, num4 + 2, 130, mute: true);
				if ((tenthAnniversaryWorldGen || noTrapsWorldGen) && genRand.Next(3) == 0)
				{
					PlaceTile(num3 + 1, num4 + 1, 664, mute: true);
				}
				else
				{
					PlaceTile(num3 + 1, num4 + 1, 138, mute: true);
				}
				num4 += 2;
				Main.tile[num3, num4].wire(wire: true);
				Main.tile[num3 + 1, num4].wire(wire: true);
				num4++;
				PlaceTile(num3, num4, 130, mute: true);
				PlaceTile(num3 + 1, num4, 130, mute: true);
				Main.tile[num3, num4].wire(wire: true);
				Main.tile[num3 + 1, num4].wire(wire: true);
				PlaceTile(num3, num4 + 1, 130, mute: true);
				PlaceTile(num3 + 1, num4 + 1, 130, mute: true);
				Main.tile[num3, num4 + 1].wire(wire: true);
				Main.tile[num3 + 1, num4 + 1].wire(wire: true);
				int num10 = x2;
				int num11 = num;
				while (num10 != num3 || num11 != num4)
				{
					Main.tile[num10, num11].wire(wire: true);
					if (num10 > num3)
					{
						num10--;
					}
					if (num10 < num3)
					{
						num10++;
					}
					Main.tile[num10, num11].wire(wire: true);
					if (num11 > num4)
					{
						num11--;
					}
					if (num11 < num4)
					{
						num11++;
					}
					Main.tile[num10, num11].wire(wire: true);
				}
				trapDiag[type, 1]++;
				return true;
			}
			case 2:
			{
				int num12 = genRand.Next(4, 7);
				int num13 = x2;
				num13 += genRand.Next(-1, 2);
				int num14 = num;
				for (int num15 = 0; num15 < num12; num15++)
				{
					num14++;
					if (!SolidTile(num13, num14))
					{
						trapDiag[type, 0]++;
						return false;
					}
				}
				for (int num16 = num13 - 2; num16 <= num13 + 2; num16++)
				{
					for (int num17 = num14 - 2; num17 <= num14 + 2; num17++)
					{
						if (!SolidTile(num16, num17))
						{
							return false;
						}
					}
				}
				KillTile(num13, num14);
				Main.tile[num13, num14].active(active: true);
				Main.tile[num13, num14].type = 141;
				Main.tile[num13, num14].frameX = 0;
				Main.tile[num13, num14].frameY = (short)(18 * genRand.Next(2));
				PlaceTile(x2, num, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
				int num18 = x2;
				int num19 = num;
				while (num18 != num13 || num19 != num14)
				{
					Main.tile[num18, num19].wire(wire: true);
					if (num18 > num13)
					{
						num18--;
					}
					if (num18 < num13)
					{
						num18++;
					}
					Main.tile[num18, num19].wire(wire: true);
					if (num19 > num14)
					{
						num19--;
					}
					if (num19 < num14)
					{
						num19++;
					}
					Main.tile[num18, num19].wire(wire: true);
				}
				trapDiag[type, 1]++;
				break;
			}
			case 3:
			{
				if (Main.tile[x2 + 1, num].active())
				{
					return false;
				}
				if (Main.tile[x2, num].liquid > 0 && !Main.tile[x2, num].lava())
				{
					return false;
				}
				if (noTrapsWorldGen && (tenthAnniversaryWorldGen || notTheBees))
				{
					if (genRand.Next(3) != 0)
					{
						return false;
					}
					if (IsTileNearby(x2, num, 443, 30))
					{
						return false;
					}
				}
				for (int k = x2; k <= x2 + 1; k++)
				{
					int j2 = num + 1;
					if (!SolidTile(k, j2))
					{
						return false;
					}
				}
				int num2 = genRand.Next(2);
				for (int l = 0; l < 2; l++)
				{
					Main.tile[x2 + l, num].active(active: true);
					Main.tile[x2 + l, num].type = 443;
					Main.tile[x2 + l, num].frameX = (short)(18 * l + 36 * num2);
					Main.tile[x2 + l, num].frameY = 0;
				}
				return true;
			}
			}
			if (noTrapsWorldGen)
			{
				Main.tileSolid[138] = true;
			}
			return false;
		}

		public static int countWires(int x, int y, int size)
		{
			int num = 0;
			for (int i = x - size; i <= x + size; i++)
			{
				for (int j = y - size; j <= y + size; j++)
				{
					if (InWorld(i, j))
					{
						if (Main.tile[i, j].wire())
						{
							num++;
						}
						if (Main.tile[i, j].wire2())
						{
							num++;
						}
						if (Main.tile[i, j].wire3())
						{
							num++;
						}
						if (Main.tile[i, j].wire4())
						{
							num++;
						}
					}
				}
			}
			return num;
		}

		public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false)
		{
			numTileCount = 0;
			shroomCount = 0;
			lavaCount = 0;
			iceCount = 0;
			sandCount = 0;
			rockCount = 0;
			CountedTiles.Clear();
			nextCount(x, y, jungle, lavaOk);
			return numTileCount;
		}

		public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false)
		{
			if (numTileCount >= maxTileCount)
			{
				return;
			}
			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
			{
				numTileCount = maxTileCount;
			}
			else
			{
				if (CountedTiles.ContainsKey(new Point(x, y)))
				{
					return;
				}
				if (Main.tile[x, y].wall == 244)
				{
					numTileCount = maxTileCount;
					return;
				}
				if (Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > 0)
				{
					numTileCount = maxTileCount;
					return;
				}
				if (!jungle)
				{
					if (Main.tile[x, y].wall != 0)
					{
						numTileCount = maxTileCount;
						return;
					}
					if (!lavaOk)
					{
						if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
						{
							lavaCount++;
							numTileCount = maxTileCount;
							return;
						}
					}
					else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > 0)
					{
						lavaCount++;
					}
				}
				if (Main.tile[x, y].active())
				{
					if (Main.tile[x, y].type == 70)
					{
						shroomCount++;
					}
					if (Main.tile[x, y].type == 1)
					{
						rockCount++;
					}
					if (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161)
					{
						iceCount++;
					}
					if (Main.tile[x, y].type == 53 || Main.tile[x, y].type == 396 || Main.tile[x, y].type == 397)
					{
						sandCount++;
					}
				}
				if (!SolidTile(x, y))
				{
					CountedTiles.Add(new Point(x, y), value: true);
					numTileCount++;
					nextCount(x - 1, y, jungle, lavaOk);
					nextCount(x + 1, y, jungle, lavaOk);
					nextCount(x, y - 1, jungle, lavaOk);
					nextCount(x, y + 1, jungle, lavaOk);
				}
			}
		}

		public static int countDirtTiles(int x, int y)
		{
			numTileCount = 0;
			CountedTiles.Clear();
			nextDirtCount(x, y);
			return numTileCount;
		}

		public static void nextDirtCount(int x, int y)
		{
			if (numTileCount >= maxTileCount)
			{
				return;
			}
			if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
			{
				numTileCount = maxTileCount;
			}
			else if (!CountedTiles.ContainsKey(new Point(x, y)))
			{
				if (Main.tile[x, y].active() && (Main.tile[x, y].type == 147 || Main.tile[x, y].type == 161))
				{
					numTileCount = maxTileCount;
				}
				else if (Main.tile[x, y].wall == 244 || Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.tile[x, y].wall == 187 || Main.tile[x, y].wall == 216)
				{
					numTileCount = maxTileCount;
				}
				else if (!SolidTile(x, y) && (Main.tile[x, y].wall == 2 || Main.tile[x, y].wall == 59))
				{
					CountedTiles.Add(new Point(x, y), value: true);
					numTileCount++;
					nextDirtCount(x - 1, y);
					nextDirtCount(x + 1, y);
					nextDirtCount(x, y - 1);
					nextDirtCount(x, y + 1);
					nextDirtCount(x - 1, y - 1);
					nextDirtCount(x - 1, y + 1);
					nextDirtCount(x + 1, y - 1);
					nextDirtCount(x + 1, y + 1);
					nextDirtCount(x - 2, y);
					nextDirtCount(x + 2, y);
				}
			}
		}

		public static bool InWorld(int x, int y, int fluff = 0)
		{
			if (x < fluff || x >= Main.maxTilesX - fluff || y < fluff || y >= Main.maxTilesY - fluff)
			{
				return false;
			}
			return true;
		}

		public static void gemCave(int x, int y)
		{
			countTiles(x, y);
			for (int i = 0; i < 6; i++)
			{
				gem[i] = false;
			}
			gem[genRand.Next(6)] = true;
			for (int j = 0; j < 6; j++)
			{
				if (genRand.Next(6) == 0)
				{
					gem[j] = true;
				}
			}
			Spread.Gem(x, y);
		}

		public static int randGem()
		{
			int num = genRand.Next(6);
			while (!gem[num])
			{
				num = genRand.Next(6);
			}
			return num;
		}

		public static ushort randGemTile()
		{
			if (genRand.Next(20) != 0)
			{
				return 1;
			}
			return (ushort)randGem() switch
			{
				0 => 67, 
				1 => 66, 
				2 => 63, 
				3 => 65, 
				4 => 64, 
				_ => 68, 
			};
		}

		public static void randMoss(bool justNeon = false)
		{
			neonMossType = genRand.NextFromList(new ushort[4] { 539, 536, 534, 625 });
			if (!justNeon)
			{
				mossType[0] = genRand.Next(5);
				mossType[1] = genRand.Next(5);
				while (mossType[1] == mossType[0])
				{
					mossType[1] = genRand.Next(5);
				}
				mossType[2] = genRand.Next(5);
				while (mossType[2] == mossType[0] || mossType[2] == mossType[1])
				{
					mossType[2] = genRand.Next(5);
				}
			}
		}

		public static void neonMossBiome(int i, int j, int maxY = 99999)
		{
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_018c: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_024c: Unknown result type (might be due to invalid IL or missing references)
			//IL_025b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0267: Unknown result type (might be due to invalid IL or missing references)
			//IL_026c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0328: Unknown result type (might be due to invalid IL or missing references)
			//IL_0329: Unknown result type (might be due to invalid IL or missing references)
			//IL_032a: Unknown result type (might be due to invalid IL or missing references)
			//IL_032f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0384: Unknown result type (might be due to invalid IL or missing references)
			//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = genRand.NextDouble() * 4.0 - 2.0;
			val2.Y = genRand.NextDouble() * 4.0 - 2.0;
			if (val2.X == 0.0)
			{
				val2.X = 1.0;
			}
			while (((Vector2D)(ref val2)).Length() < 4.0)
			{
				val2 *= 1.5;
			}
			double num = genRand.Next(60, 80);
			double num2 = genRand.Next(30, 40);
			double num3 = (double)Main.maxTilesX / 4200.0;
			if (getGoodWorldGen)
			{
				num3 *= 1.5;
			}
			num *= num3;
			num2 *= num3;
			while (num2 > 0.0)
			{
				num *= 0.98;
				num2 -= 1.0;
				int num4 = (int)(val.X - num);
				int num5 = (int)(val.X + num);
				int num6 = (int)(val.Y - num);
				int num7 = (int)(val.Y + num);
				if (num4 < 1)
				{
					num4 = 1;
				}
				if (num5 > Main.maxTilesX - 1)
				{
					num5 = Main.maxTilesX - 1;
				}
				if (num6 < 1)
				{
					num6 = 1;
				}
				if (num7 > Main.maxTilesY - 1)
				{
					num7 = Main.maxTilesY - 1;
				}
				if (Main.remixWorld)
				{
					if ((double)num6 < Main.worldSurface)
					{
						num6 = (int)Main.worldSurface;
						if (val2.Y < 5.0)
						{
							val2.Y = 5.0;
						}
					}
				}
				else if ((double)num6 < Main.rockLayer)
				{
					num6 = (int)Main.rockLayer;
					if (val2.Y < 5.0)
					{
						val2.Y = 5.0;
					}
				}
				if (num7 > maxY)
				{
					num7 = maxY;
					if (val2.Y > -5.0)
					{
						val2.Y = -5.0;
					}
				}
				double num8 = num * (1.0 + genRand.NextDouble() * 0.4 - 0.2);
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						Vector2D val3 = new Vector2D(Math.Abs((double)k - val.X), Math.Abs((double)l - val.Y));
						if (((Vector2D)(ref val3)).Length() < num8 * 0.8 && TileType(k, l) == 1 && (!Main.tile[k - 1, l].active() || !Main.tile[k + 1, l].active() || !Main.tile[k, l - 1].active() || !Main.tile[k, l + 1].active()))
						{
							SpreadGrass(k - 1, l, 1, neonMossType);
						}
					}
				}
				val += val2;
				val2.X += genRand.NextDouble() * 4.0 - 2.0;
				val2.Y += genRand.NextDouble() * 4.0 - 2.0;
				val2.Y = Utils.Clamp(val2.Y, -10.0, 10.0);
				val2.X = Utils.Clamp(val2.X, -10.0, 10.0);
			}
		}

		public static void setMoss(int x, int y)
		{
			int num = 0;
			num = ((!((double)x < (double)Main.maxTilesX * 0.334)) ? (((double)x < (double)Main.maxTilesX * 0.667) ? 1 : 2) : 0);
			GenVars.mossWall = (ushort)(54 + mossType[num]);
			GenVars.mossTile = (ushort)(179 + mossType[num]);
		}

		public static void FillWallHolesInArea(Rectangle worldCoordsArea)
		{
			int num = Math.Max(worldCoordsArea.Left, 0);
			int num2 = Math.Min(worldCoordsArea.Right, Main.maxTilesX);
			int num3 = 0;
			for (int i = num; i <= num2; i++)
			{
				if (i >= 0 && i < Main.maxTilesX)
				{
					num3 += FillWallHolesInColumn(i, worldCoordsArea.Top, worldCoordsArea.Bottom);
				}
			}
		}

		private static int FillWallHolesInColumn(int x, int startY, int endY)
		{
			int num = 0;
			x = Utils.Clamp(x, 2, Main.maxTilesX - 1 - 2);
			startY = Math.Max(startY, 2);
			endY = Math.Min(endY, Main.maxTilesY - 2);
			bool flag = false;
			for (int i = startY; i < endY; i++)
			{
				if (Main.tile[x, i].wall == 0)
				{
					if (flag)
					{
						flag = false;
						if (FillWallHolesInSpot(x, i, 150))
						{
							num++;
						}
					}
				}
				else
				{
					flag = true;
				}
			}
			return num;
		}

		private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold)
		{
			if (!InWorld(originX, originY, 2))
			{
				return false;
			}
			List<Point> list = new List<Point>();
			List<Point> list2 = new List<Point>();
			HashSet<Point> hashSet = new HashSet<Point>();
			Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
			list2.Add(new Point(originX, originY));
			while (list2.Count > 0)
			{
				list.Clear();
				list.AddRange(list2);
				list2.Clear();
				while (list.Count > 0)
				{
					if (hashSet.Count >= maxWallsThreshold)
					{
						return false;
					}
					Point item = list[0];
					if (hashSet.Contains(item))
					{
						list.Remove(item);
						continue;
					}
					if (!InWorld(item.X, item.Y, 1))
					{
						list.Remove(item);
						continue;
					}
					hashSet.Add(item);
					list.Remove(item);
					Tile tile = Main.tile[item.X, item.Y];
					if (tile.wall != 0)
					{
						if (dictionary.ContainsKey(tile.wall))
						{
							dictionary[tile.wall] = dictionary[tile.wall] + 1;
						}
						else
						{
							dictionary[tile.wall] = 1;
						}
						continue;
					}
					bool flag = false;
					if (!flag)
					{
						int y = item.Y;
						for (int i = item.X - 1; i <= item.X + 1; i++)
						{
							if (!Main.tile[i, y].active())
							{
								flag = true;
								break;
							}
						}
					}
					if (!flag)
					{
						int x = item.X;
						for (int j = item.Y - 1; j <= item.Y + 1; j++)
						{
							if (!Main.tile[x, j].active())
							{
								flag = true;
								break;
							}
						}
					}
					if (flag)
					{
						Point item2 = new Point(item.X - 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!hashSet.Contains(item2))
						{
							list2.Add(item2);
						}
					}
				}
			}
			if (hashSet.Count == 1)
			{
				return false;
			}
			ushort wall = 0;
			int num = -1;
			foreach (KeyValuePair<ushort, int> item3 in dictionary)
			{
				if (item3.Value > num)
				{
					wall = item3.Key;
					num = item3.Value;
				}
			}
			if (num == -1)
			{
				wall = 2;
			}
			foreach (Point item4 in hashSet)
			{
				Tile tile2 = Main.tile[item4.X, item4.Y];
				if (tile2.wall == 0)
				{
					tile2.wall = wall;
				}
			}
			return true;
		}

		public static void tileCountAndDestroy()
		{
			for (int i = 10; i < Main.maxTilesX - 10; i++)
			{
				for (int j = 10; j < Main.maxTilesY - 10; j++)
				{
					if (Main.tile[i, j].active() && tileCounter(i, j) < tileCounterMax)
					{
						tileCounterKill();
					}
				}
			}
		}

		public static int tileCounter(int x, int y)
		{
			tileCounterNum = 0;
			tileCounterNext(x, y);
			return tileCounterNum;
		}

		public static void tileCounterNext(int x, int y)
		{
			if (tileCounterNum >= tileCounterMax || x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || !Main.tileSolid[Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, y].type])
			{
				return;
			}
			for (int i = 0; i < tileCounterNum; i++)
			{
				if (tileCounterX[i] == x && tileCounterY[i] == y)
				{
					return;
				}
			}
			tileCounterX[tileCounterNum] = x;
			tileCounterY[tileCounterNum] = y;
			tileCounterNum++;
			tileCounterNext(x - 1, y);
			tileCounterNext(x + 1, y);
			tileCounterNext(x, y - 1);
			tileCounterNext(x, y + 1);
		}

		public static void tileCounterKill()
		{
			for (int i = 0; i < tileCounterNum; i++)
			{
				int num = tileCounterX[i];
				int num2 = tileCounterY[i];
				Main.tile[num, num2].active(active: false);
			}
		}

		private static void AddGenerationPass(string name, WorldGenLegacyMethod method)
		{
			_generator.Append(new PassLegacy(name, method));
		}

		private static void AddGenerationPass(GenPass pass)
		{
			_generator.Append(pass);
		}

		private static void AddGenerationPass(string name, double weight, WorldGenLegacyMethod method)
		{
			_generator.Append(new PassLegacy(name, method, weight));
		}

		public static bool checkUnderground(int x, int y)
		{
			try
			{
				int num = 120;
				int num2 = 80;
				int num3 = 3;
				if ((double)y > Main.worldSurface + (double)num2)
				{
					return true;
				}
				if ((double)y < Main.worldSurface / 2.0)
				{
					return false;
				}
				int num4 = y - num2;
				int num5 = x - num / 2;
				int num6 = 0;
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num5 >= Main.maxTilesX - num)
				{
					num5 = Main.maxTilesX - num - 1;
				}
				for (int i = num5; i < num5 + num; i++)
				{
					for (int j = num4; j < num4 + num3; j++)
					{
						if (SolidTile(i, j) || Main.tile[x, y].wall > 0)
						{
							num6++;
						}
					}
				}
				if ((double)num6 >= (double)(num * num3) * 0.8)
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static int GetNextJungleChestItem()
		{
			int result = 211;
			switch (GenVars.JungleItemCount % 4)
			{
			case 0:
				result = 211;
				break;
			case 1:
				result = 212;
				break;
			case 2:
				result = 213;
				break;
			case 3:
				result = 964;
				break;
			}
			if (genRand.Next(50) == 0)
			{
				result = 753;
			}
			else if (genRand.Next(15) == 0)
			{
				result = 2292;
			}
			else if (genRand.Next(20) == 0)
			{
				result = 3017;
			}
			GenVars.JungleItemCount++;
			return result;
		}

		private static void ScanTileColumnAndRemoveClumps(int x)
		{
			int num = 0;
			int y = 0;
			for (int i = 10; i < Main.maxTilesY - 10; i++)
			{
				if (Main.tile[x, i].active() && Main.tileSolid[Main.tile[x, i].type] && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[x, i].type])
				{
					if (num == 0)
					{
						y = i;
					}
					num++;
					continue;
				}
				if (num > 0 && num < tileCounterMax)
				{
					SmallConsecutivesFound++;
					if (tileCounter(x, y) < tileCounterMax)
					{
						SmallConsecutivesEliminated++;
						tileCounterKill();
					}
				}
				num = 0;
			}
		}

		public static void OreHelper(int X, int Y)
		{
			for (int i = X - 1; i <= X + 1; i++)
			{
				for (int j = Y - 1; j <= Y + 1; j++)
				{
					if (Main.tile[i, j].type == 1 || Main.tile[i, j].type == 40)
					{
						Main.tile[i, j].type = 0;
					}
				}
			}
		}

		public static bool StonePatch(int X, int Y)
		{
			//IL_0291: Unknown result type (might be due to invalid IL or missing references)
			//IL_0298: Unknown result type (might be due to invalid IL or missing references)
			//IL_029d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_042f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0430: Unknown result type (might be due to invalid IL or missing references)
			//IL_0431: Unknown result type (might be due to invalid IL or missing references)
			//IL_0436: Unknown result type (might be due to invalid IL or missing references)
			//IL_0489: Unknown result type (might be due to invalid IL or missing references)
			//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
			int num = Y;
			while (!SolidTile(X, num))
			{
				num++;
				if ((double)num > Main.worldSurface)
				{
					return false;
				}
			}
			if (!TileID.Sets.Conversion.Grass[Main.tile[X, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X - 1, num].type] || !TileID.Sets.Conversion.Grass[Main.tile[X + 1, num].type])
			{
				return false;
			}
			if (Main.tile[X, num].wall > 0)
			{
				return false;
			}
			for (int i = X - 10; i <= X + 10; i++)
			{
				for (int j = num + 7; j <= num + 30; j++)
				{
					if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0 || Main.tile[i, j].type == 199 || Main.tile[i, j].type == 23)
					{
						return false;
					}
				}
			}
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)X, (double)num);
			Vector2D val2 = default(Vector2D);
			val2.X = genRand.NextDouble() * 0.6 - 0.3;
			val2.Y = genRand.NextDouble() * 0.5 + 0.5;
			double num2 = genRand.Next(13, 18);
			int num3 = genRand.Next(13, 19);
			if (genRand.Next(3) == 0)
			{
				num2 += (double)genRand.Next(3);
			}
			if (genRand.Next(3) == 0)
			{
				num3 += genRand.Next(3);
			}
			while (num3 > 0)
			{
				num3--;
				for (int k = X - (int)num2 * 4; (double)k <= (double)X + num2 * 4.0; k++)
				{
					for (int l = num - (int)num2 * 4; (double)l <= (double)num + num2 * 4.0; l++)
					{
						double num4 = num2 * (0.7 + genRand.NextDouble() * 0.6) * 0.3;
						if (genRand.Next(8) == 0)
						{
							num4 *= 2.0;
						}
						Vector2D val3 = val - new Vector2D((double)k, (double)l);
						if (((Vector2D)(ref val3)).Length() < num4 * 2.0 && !Main.tile[k, l].active() && Main.tile[k, l + 1].active() && Main.tile[k, l + 1].type == 1 && genRand.Next(7) == 0 && SolidTile(k - 1, l + 1) && SolidTile(k + 1, l + 1))
						{
							if (genRand.Next(3) != 0)
							{
								PlaceTile(k, l, 186, mute: true, forced: false, -1, genRand.Next(7, 13));
							}
							if (genRand.Next(3) != 0)
							{
								PlaceSmallPile(k, l, genRand.Next(6), 1, 185);
							}
							PlaceSmallPile(k, l, genRand.Next(6), 0, 185);
						}
						if (((Vector2D)(ref val3)).Length() < num4)
						{
							if (Main.tileSolid[Main.tile[k, l].type])
							{
								Main.tile[k, l].type = 1;
							}
							if (!gen)
							{
								SquareTileFrame(k, l);
							}
						}
					}
				}
				val += val2;
				val2.X += genRand.NextDouble() * 0.2 - 0.1;
				val2.Y += genRand.NextDouble() * 0.2 - 0.1;
				Utils.Clamp(val2.X, -0.3, 0.3);
				Utils.Clamp(val2.Y, 0.5, 1.0);
			}
			return true;
		}

		public static bool ShellPile(int X, int Y)
		{
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_012a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0449: Unknown result type (might be due to invalid IL or missing references)
			//IL_0467: Unknown result type (might be due to invalid IL or missing references)
			int num = Y;
			while (!SolidTile(X, num))
			{
				num++;
				if ((double)num > Main.worldSurface)
				{
					return false;
				}
			}
			if (Main.tile[X, num].type != 53)
			{
				return false;
			}
			if (Main.tile[X, num].wall > 0)
			{
				return false;
			}
			num--;
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)X, (double)num);
			Vector2D val2 = default(Vector2D);
			val2.X = genRand.NextDouble() * 0.6 - 0.3;
			val2.Y = genRand.NextDouble() * 0.5 + 0.5;
			double num2 = genRand.Next(2, 4);
			if (genRand.Next(10) == 0)
			{
				num2 += 1.0;
			}
			int num3 = genRand.Next(3, 6);
			while (num3 > 0)
			{
				num3--;
				for (int i = X - (int)num2 * 4; (double)i <= (double)X + num2 * 4.0; i++)
				{
					int num4 = num + (int)num2 * 4;
					while ((double)num4 > (double)num - num2 * 4.0)
					{
						double num5 = num2 * (double)genRand.Next(70, 91) * 0.01;
						Vector2D val3 = val - new Vector2D((double)i, (double)num4);
						val3.X *= 0.6;
						if (((Vector2D)(ref val3)).Length() < num5)
						{
							if (num4 <= num + 1 || genRand.Next(6) == 0)
							{
								Main.tile[i, num4].type = 495;
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
								Main.tile[i, num4].slope(0);
								if (!Main.tile[i, num4 + 1].active())
								{
									Main.tile[i, num4 + 1].type = 495;
									Main.tile[i, num4 + 1].active(active: true);
									Main.tile[i, num4 + 1].halfBrick(halfBrick: false);
									Main.tile[i, num4 + 1].slope(0);
									if (!Main.tile[i, num4 + 2].active())
									{
										Main.tile[i, num4 + 2].type = 53;
										Main.tile[i, num4 + 2].active(active: true);
										Main.tile[i, num4 + 2].halfBrick(halfBrick: false);
										Main.tile[i, num4 + 2].slope(0);
										if (!Main.tile[i, num4 + 3].active())
										{
											Main.tile[i, num4 + 3].type = 397;
											Main.tile[i, num4 + 3].active(active: true);
											Main.tile[i, num4 + 3].halfBrick(halfBrick: false);
											Main.tile[i, num4 + 3].slope(0);
										}
									}
								}
								if (!gen)
								{
									SquareTileFrame(i, num4);
								}
							}
							else if (Main.tile[i, num4].type != 495)
							{
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
								Main.tile[i, num4].slope(0);
								Main.tile[i, num4].type = 53;
								if (!gen)
								{
									SquareTileFrame(i, num4);
								}
							}
						}
						num4--;
					}
				}
				val += val2;
				val2.X += genRand.NextDouble() * 0.2 - 0.1;
				val2.Y += genRand.NextDouble() * 0.2 - 0.1;
				Utils.Clamp(val2.X, -0.3, 0.3);
				Utils.Clamp(val2.Y, 0.5, 1.0);
			}
			return true;
		}

		public static bool MarblePileWithStatues(int X, int Y)
		{
			//IL_021b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0223: Unknown result type (might be due to invalid IL or missing references)
			//IL_0228: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0384: Unknown result type (might be due to invalid IL or missing references)
			//IL_0386: Unknown result type (might be due to invalid IL or missing references)
			//IL_0388: Unknown result type (might be due to invalid IL or missing references)
			//IL_038d: Unknown result type (might be due to invalid IL or missing references)
			//IL_03eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_040a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0469: Unknown result type (might be due to invalid IL or missing references)
			int num = Y;
			while (!SolidTile(X, num))
			{
				num++;
				if ((double)num > Main.worldSurface)
				{
					return false;
				}
			}
			if (Main.tile[X, num].type != 0 && Main.tile[X, num].type != 2)
			{
				return false;
			}
			if (Main.tile[X, num].wall > 0)
			{
				return false;
			}
			int num2 = 130;
			int num3 = 60;
			int num4 = (int)MathHelper.Clamp(X - num2, 30f, Main.maxTilesX - 30);
			int num5 = (int)MathHelper.Clamp(X + num2, 30f, Main.maxTilesX - 30);
			int num6 = (int)MathHelper.Clamp(num - num3, 30f, Main.maxTilesY - 30);
			int num7 = (int)MathHelper.Clamp(num + num3, 30f, Main.maxTilesY - 30);
			for (int i = num4; i <= num5; i++)
			{
				for (int j = num6; j <= num7; j++)
				{
					if (Main.tile[i, j].active() && (Main.tile[i, j].type == 367 || Main.tile[i, j].type == 191))
					{
						return false;
					}
				}
			}
			num--;
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)X, (double)num);
			Vector2D val2 = default(Vector2D);
			val2.X = genRand.NextDouble() * 0.6 - 0.3;
			val2.Y = genRand.NextDouble() * 0.5 + 0.5;
			double num8 = genRand.Next(2, 4);
			if (genRand.Next(10) == 0)
			{
				num8 += 1.0;
			}
			int num9 = genRand.Next(3, 6);
			while (num9 > 0)
			{
				num9--;
				for (int k = X - (int)num8 * 5; (double)k <= (double)X + num8 * 5.0; k++)
				{
					int num10 = num + (int)num8 * 3;
					while ((double)num10 > (double)num - num8 * 3.0)
					{
						double num11 = num8 * (double)genRand.Next(70, 91) * 0.01 * 1.2;
						Vector2D val3 = val - new Vector2D((double)k, (double)num10);
						if (((Vector2D)(ref val3)).Length() > 30.0)
						{
							((Vector2D)(ref val))._002Ector((double)X, (double)num);
							val2.X = genRand.NextDouble() * 0.6 - 0.3;
							val2.Y = genRand.NextDouble() * 0.5 + 0.5;
						}
						else
						{
							val3.X *= 0.25;
							val3.Y *= 0.8;
							if (((Vector2D)(ref val3)).Length() < num11 && Main.tile[k, num10].active())
							{
								Main.tile[k, num10].active(active: true);
								Main.tile[k, num10].halfBrick(halfBrick: false);
								Main.tile[k, num10].slope(0);
								Main.tile[k, num10].type = 367;
								if (!gen)
								{
									SquareTileFrame(k, num10);
								}
							}
						}
						num10--;
					}
				}
				val += val2;
				val2.X += genRand.NextDouble() * 0.2 - 0.1;
				val2.Y += (0.1 + genRand.NextDouble() * 0.1) * 0.8;
				Utils.Clamp(val2.X, -0.3, 0.3);
				Utils.Clamp(val2.Y, 0.5, 1.0);
			}
			int num12 = 0;
			for (int l = X - (int)num8 * 5; (double)l <= (double)X + num8 * 5.0; l++)
			{
				if (num12 >= 3)
				{
					break;
				}
				if (l % 2 != 1 && (num12 <= 0 || genRand.Next(5) == 0))
				{
					int num13 = (int)val.Y - 20;
					Tile tile = Main.tile[l, num13];
					while (tile != null && !tile.active())
					{
						num13++;
						tile = Main.tile[l, num13];
					}
					if (tile != null && tile.type == 367 && !Main.tile[l, num13 - 1].active() && Statue(l, num13 - 1, 26))
					{
						num12++;
					}
				}
			}
			return true;
		}

		public static bool Statue(int x, int y, byte paint)
		{
			int num = genRand.Next(2, GenVars.statueList.Length);
			int x2 = GenVars.statueList[num].X;
			int y2 = GenVars.statueList[num].Y;
			while (!Main.tile[x, y].active())
			{
				y++;
				if (y >= Main.maxTilesY)
				{
					break;
				}
			}
			if (y >= Main.maxTilesY)
			{
				return false;
			}
			y--;
			if (PlaceTile(x, y, x2, mute: true, forced: true, -1, y2))
			{
				for (int i = 0; i < 2; i++)
				{
					for (int j = 0; j < 3; j++)
					{
						Main.tile[x + i, y + j - 2].color(paint);
					}
				}
				return true;
			}
			return false;
		}

		public static bool OrePatch(int X, int Y)
		{
			//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_050e: Unknown result type (might be due to invalid IL or missing references)
			//IL_052d: Unknown result type (might be due to invalid IL or missing references)
			ushort type = (ushort)SavedOreTiers.Copper;
			if (genRand.Next(3) == 0)
			{
				type = (ushort)SavedOreTiers.Iron;
			}
			int num = X;
			int num2 = Y;
			while (!SolidTile(num, num2))
			{
				num2++;
				if ((double)num2 > Main.worldSurface)
				{
					return false;
				}
			}
			if (!TileID.Sets.Conversion.Grass[Main.tile[num, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num - 1, num2].type] || !TileID.Sets.Conversion.Grass[Main.tile[num + 1, num2].type])
			{
				return false;
			}
			if (Main.tile[num, num2].wall > 0)
			{
				return false;
			}
			for (int i = num - 10; i <= num + 10; i++)
			{
				for (int j = num2 + 7; j <= num2 + 30; j++)
				{
					if (!Main.tile[i, j].active() || Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.Clouds[Main.tile[i, j].type] || TileID.Sets.Conversion.Sand[Main.tile[i, j].type] || Main.tile[i, j].wall == 0)
					{
						return false;
					}
				}
			}
			num2 += genRand.Next(2);
			Main.tile[num, num2].type = type;
			Main.tile[num, num2].active(active: true);
			OreHelper(num, num2);
			if (!gen)
			{
				SquareTileFrame(num, num2);
			}
			int num3 = num2;
			while (num2 < num3 + genRand.Next(8, 13))
			{
				num += genRand.Next(-1, 2);
				num2 += genRand.Next(1, 3);
				if (genRand.Next(3) == 0)
				{
					num2++;
				}
				Main.tile[num, num2].type = type;
				Main.tile[num, num2].active(active: true);
				OreHelper(num, num2);
				if (!gen)
				{
					SquareTileFrame(num, num2);
				}
				if (genRand.Next(4) == 0)
				{
					int num4 = num + genRand.Next(-2, 3);
					int num5 = num2 + genRand.Next(2);
					Main.tile[num4, num5].type = type;
					Main.tile[num4, num5].active(active: true);
					OreHelper(num4, num5);
					if (!gen)
					{
						SquareTileFrame(num4, num5);
					}
				}
			}
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)num, (double)num2);
			Vector2D val2 = default(Vector2D);
			val2.X = genRand.NextDouble() * 0.6 - 0.3;
			val2.Y = genRand.NextDouble() * 0.5 + 0.5;
			double num6 = genRand.Next(5, 9);
			int num7 = genRand.Next(9, 14);
			if (genRand.Next(3) == 0)
			{
				num6 += (double)genRand.Next(2);
			}
			if (genRand.Next(3) == 0)
			{
				num7 += genRand.Next(2);
			}
			while (num7 > 0)
			{
				num7--;
				for (int k = num - (int)num6 * 4; (double)k <= (double)num + num6 * 4.0; k++)
				{
					for (int l = num2 - (int)num6 * 4; (double)l <= (double)num2 + num6 * 4.0; l++)
					{
						double num8 = num6 * (0.5 + genRand.NextDouble() * 0.5) * 0.1;
						double num9 = num6 * (0.7 + genRand.NextDouble() * 0.6) * 0.3;
						if (genRand.Next(8) == 0)
						{
							num9 *= 2.0;
						}
						Vector2D val3 = val - new Vector2D((double)k, (double)l);
						if (((Vector2D)(ref val3)).Length() < num8)
						{
							Main.tile[k, l].active(active: false);
						}
						else if (((Vector2D)(ref val3)).Length() < num9)
						{
							Main.tile[k, l].type = type;
							if (genRand.Next(4) == 0)
							{
								Main.tile[k, l].active(active: true);
							}
							OreHelper(k, l);
							if (!gen)
							{
								SquareTileFrame(k, l);
							}
						}
					}
				}
				val += val2;
				val2.X += genRand.NextDouble() * 0.2 - 0.1;
				val2.Y += genRand.NextDouble() * 0.2 - 0.1;
				Utils.Clamp(val2.X, -0.3, 0.3);
				Utils.Clamp(val2.Y, 0.5, 1.0);
			}
			return true;
		}

		public static bool PlaceOasis(int X, int Y)
		{
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			int i = Y;
			if (!Main.tile[X, i].active() && Main.tile[X, i].wall == 0)
			{
				for (; !Main.tile[X, i].active() && Main.tile[X, i].wall == 0 && (double)i <= Main.worldSurface; i++)
				{
				}
				if ((double)i > Main.worldSurface - 10.0)
				{
					return false;
				}
				if (Main.tile[X, i].type != 53)
				{
					return false;
				}
				int num = 350;
				for (int j = 0; j < GenVars.numOasis; j++)
				{
					if (Vector2D.Distance(GenVars.oasisPosition[j].ToVector2D(), new Vector2D((double)X, (double)i)) < (double)num)
					{
						return false;
					}
				}
				int num2 = genRand.Next(45, 61);
				int oasisHeight = GenVars.oasisHeight;
				int num3 = num2 + 50;
				int num4 = 4;
				for (int k = X - num3; k <= X + num3; k++)
				{
					for (int l = i - oasisHeight; l <= i + oasisHeight + num4; l++)
					{
						Tile tile = Main.tile[k, l];
						if (tile.active())
						{
							if (Main.tileSolid[tile.type])
							{
								if ((tile.type == 151 || tile.type == 397) && Math.Abs(k - X) < num2 && Math.Abs(l - i) < oasisHeight / 2)
								{
									return false;
								}
								if (tile.type != 53)
								{
									return false;
								}
							}
						}
						else if ((tile.liquid > 0 || tile.wall > 0) && Math.Abs(k - X) < num2 && Math.Abs(l - i) < oasisHeight / 2)
						{
							return false;
						}
					}
					if (k > X - num2 / 2 && k < X - num2 / 2)
					{
						if (Main.tile[k, i - 6].active())
						{
							return false;
						}
						if (!Main.tile[k, i + 1].active())
						{
							return false;
						}
					}
				}
				int num5 = 5;
				int num6 = i;
				while (!Main.tile[X - num2, i + num5].active() || Main.tile[X - num2, i + num5].wall != 0 || !Main.tile[X + num2, i + num5].active() || Main.tile[X + num2, i + num5].wall != 0)
				{
					i++;
					if (i - num6 > 20)
					{
						break;
					}
				}
				int num7 = num2 / 2;
				int num8 = X - num2 * 3;
				int num9 = X + num2 * 3;
				int num10 = i - oasisHeight * 4;
				int num11 = i + oasisHeight * 3;
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				for (int m = num8; m < num9; m++)
				{
					for (int n = num10; n < num11; n++)
					{
						double num12 = (double)Math.Abs(m - X) * 0.7;
						double num13 = (double)Math.Abs(n - i) * 1.35;
						double num14 = Math.Sqrt(num12 * num12 + num13 * num13);
						double num15 = (double)num7 * (0.53 + genRand.NextDouble() * 0.04);
						double num16 = (double)Math.Abs(m - X) / (double)(num9 - X);
						num16 = 1.0 - num16;
						num16 *= 2.3;
						num16 *= num16;
						num16 *= num16;
						if (num14 < num15)
						{
							if (n == i + 1)
							{
								Main.tile[m, n].liquid = 127;
							}
							else if (n > i + 1)
							{
								Main.tile[m, n].liquid = byte.MaxValue;
							}
							Main.tile[m, n].lava(lava: false);
							Main.tile[m, n].active(active: false);
						}
						else if (n < i && num12 < num15 + (double)(Math.Abs(n - i) * 3) * num16)
						{
							if (Main.tile[m, n].type == 53)
							{
								Main.tile[m, n].active(active: false);
							}
						}
						else if (n >= i && num12 < num15 + (double)Math.Abs(n - i) * num16 && Main.tile[m, n].wall == 0)
						{
							if (Main.tile[m, n].active() && Main.tileSolid[Main.tile[m, n].type] && !Main.tileSolidTop[Main.tile[m, n].type])
							{
								Main.tile[m, n].slope(0);
								Main.tile[m, n].halfBrick(halfBrick: false);
								continue;
							}
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = 53;
							Main.tile[m, n].slope(0);
							Main.tile[m, n].halfBrick(halfBrick: false);
						}
					}
				}
				int num17 = 50;
				num8 = X - num2 * 2;
				num9 = X + num2 * 2;
				num11 = i + oasisHeight * 2;
				for (int num18 = num8; num18 < num9; num18++)
				{
					for (int num19 = num11; num19 >= i; num19--)
					{
						double num20 = (double)Math.Abs(num18 - X) * 0.7;
						double num21 = (double)Math.Abs(num19 - i) * 1.35;
						double num22 = Math.Sqrt(num20 * num20 + num21 * num21);
						double num23 = (double)num7 * 0.5700000000000001;
						if (num22 > num23)
						{
							bool flag = false;
							if (!Main.tile[num18, num19].active() && Main.tile[num18, num19].wall == 0)
							{
								int num24 = -1;
								int num25 = -1;
								for (int num26 = num18; num26 <= num18 + num17 && Main.tile[num26, num19 + 1].active() && Main.tileSolid[Main.tile[num26, num19 + 1].type] && Main.tile[num26, num19].wall <= 0; num26++)
								{
									if (Main.tile[num26, num19].active() && Main.tileSolid[Main.tile[num26, num19].type])
									{
										if (Main.tile[num26, num19].type == 53)
										{
											flag = true;
										}
										num25 = num26;
										break;
									}
									if (Main.tile[num26, num19].active())
									{
										break;
									}
								}
								int num27 = num18;
								while (num27 >= num18 - num17 && Main.tile[num27, num19 + 1].active() && Main.tileSolid[Main.tile[num27, num19 + 1].type] && Main.tile[num27, num19].wall <= 0)
								{
									if (Main.tile[num27, num19].active() && Main.tileSolid[Main.tile[num27, num19].type])
									{
										if (Main.tile[num27, num19].type == 53)
										{
											flag = true;
										}
										num24 = num27;
										break;
									}
									if (Main.tile[num27, num19].active())
									{
										break;
									}
									num27--;
								}
								flag = true;
								if (num24 > -1 && num25 > -1 && flag)
								{
									int num28 = 0;
									for (int num29 = num24 + 1; num29 < num25; num29++)
									{
										if (num25 - num24 > 5 && genRand.Next(5) == 0)
										{
											num28 = genRand.Next(5, 10);
										}
										Main.tile[num29, num19].active(active: true);
										Main.tile[num29, num19].type = 53;
										if (num28 > 0)
										{
											num28--;
											Main.tile[num29, num19 - 1].active(active: true);
											Main.tile[num29, num19 - 1].type = 53;
										}
									}
								}
							}
						}
					}
				}
				if (GenVars.numOasis < GenVars.maxOasis)
				{
					GenVars.oasisPosition[GenVars.numOasis] = new Point(X, i);
					GenVars.oasisWidth[GenVars.numOasis] = num2;
					GenVars.numOasis++;
				}
				return true;
			}
			return false;
		}

		public static bool BiomeTileCheck(int x, int y)
		{
			int num = 50;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (!InWorld(i, j))
					{
						continue;
					}
					if (Main.tile[i, j].active())
					{
						int type = Main.tile[i, j].type;
						if (type == 368 || type == 367 || type == 147 || type == 161 || type == 162 || type == 70 || type == 72 || type == 396 || type == 397)
						{
							return true;
						}
					}
					int wall = Main.tile[i, j].wall;
					if (wall == 187 || wall == 216)
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool oceanDepths(int x, int y)
		{
			if ((double)y > oceanLevel)
			{
				return false;
			}
			if (x < beachDistance || x > Main.maxTilesX - beachDistance)
			{
				return true;
			}
			return false;
		}

		public static void UpdateDesertHiveBounds(int x, int y)
		{
			if (GenVars.desertHiveHigh > y)
			{
				GenVars.desertHiveHigh = y;
			}
			if (GenVars.desertHiveLow < y)
			{
				GenVars.desertHiveLow = y;
			}
			if (GenVars.desertHiveLeft > x)
			{
				GenVars.desertHiveLeft = x;
			}
			if (GenVars.desertHiveRight < x)
			{
				GenVars.desertHiveRight = x;
			}
		}

		public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null)
		{
			remixWorldGen = tempRemixWorldGen;
			tenthAnniversaryWorldGen = tempTenthAnniversaryWorldGen;
			drunkWorldGen = false;
			drunkWorldGenText = false;
			Main.afterPartyOfDoom = false;
			if (seed == 5162020 || everythingWorldGen)
			{
				drunkWorldGen = true;
				drunkWorldGenText = true;
				Main.drunkWorld = true;
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
				if (!Main.dayTime)
				{
					Main.time = 0.0;
				}
			}
			else if (seed == 5162021 || seed == 5162011)
			{
				tenthAnniversaryWorldGen = true;
			}
			Main.notTheBeesWorld = notTheBees;
			if (notTheBees)
			{
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			Main.noTrapsWorld = noTrapsWorldGen;
			if (noTrapsWorldGen)
			{
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			if (getGoodWorldGen)
			{
				Main.getGoodWorld = true;
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			else
			{
				Main.getGoodWorld = false;
			}
			Main.tenthAnniversaryWorld = tenthAnniversaryWorldGen;
			if (tenthAnniversaryWorldGen)
			{
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			Main.dontStarveWorld = dontStarveWorldGen;
			if (dontStarveWorldGen)
			{
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			Main.remixWorld = remixWorldGen;
			if (remixWorldGen)
			{
				Main.rand = new UnifiedRandom();
				seed = Main.rand.Next(999999999);
			}
			Main.zenithWorld = everythingWorldGen;
			Console.WriteLine("Creating world - Seed: {0} Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", seed, Main.maxTilesX, Main.maxTilesY, WorldGenParam_Evil, Main.expertMode);
			Main.lockMenuBGChange = true;
			GenVars.configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
			Hooks.ProcessWorldGenConfig(ref GenVars.configuration);
			_lastSeed = seed;
			_generator = new WorldGenerator(seed, GenVars.configuration);
			_genRand = new UnifiedRandom(seed);
			Main.rand = new UnifiedRandom(seed);
			GenVars.structures = new StructureMap();
			GenVars.desertHiveHigh = Main.maxTilesY;
			GenVars.desertHiveLow = 0;
			GenVars.desertHiveLeft = Main.maxTilesX;
			GenVars.desertHiveRight = 0;
			GenVars.worldSurfaceLow = 0.0;
			GenVars.worldSurface = 0.0;
			GenVars.worldSurfaceHigh = 0.0;
			GenVars.rockLayerLow = 0.0;
			GenVars.rockLayer = 0.0;
			GenVars.rockLayerHigh = 0.0;
			GenVars.copper = 7;
			GenVars.iron = 6;
			GenVars.silver = 9;
			GenVars.gold = 8;
			GenVars.dungeonSide = 0;
			GenVars.jungleHut = (ushort)genRand.Next(5);
			GenVars.shellStartXLeft = 0;
			GenVars.shellStartYLeft = 0;
			GenVars.shellStartXRight = 0;
			GenVars.shellStartYRight = 0;
			GenVars.PyrX = null;
			GenVars.PyrY = null;
			GenVars.numPyr = 0;
			GenVars.jungleMinX = -1;
			GenVars.jungleMaxX = -1;
			GenVars.snowMinX = new int[Main.maxTilesY];
			GenVars.snowMaxX = new int[Main.maxTilesY];
			GenVars.snowTop = 0;
			GenVars.snowBottom = 0;
			GenVars.skyLakes = 1;
			if (Main.maxTilesX > 8000)
			{
				GenVars.skyLakes++;
			}
			if (Main.maxTilesX > 6000)
			{
				GenVars.skyLakes++;
			}
			GenVars.beachBordersWidth = 275;
			GenVars.beachSandRandomCenter = GenVars.beachBordersWidth + 5 + 40;
			GenVars.beachSandRandomWidthRange = 20;
			GenVars.beachSandDungeonExtraWidth = 40;
			GenVars.beachSandJungleExtraWidth = 20;
			GenVars.oceanWaterStartRandomMin = 220;
			GenVars.oceanWaterStartRandomMax = GenVars.oceanWaterStartRandomMin + 40;
			GenVars.oceanWaterForcedJungleLength = 275;
			GenVars.leftBeachEnd = 0;
			GenVars.rightBeachStart = 0;
			GenVars.evilBiomeBeachAvoidance = GenVars.beachSandRandomCenter + 60;
			GenVars.evilBiomeAvoidanceMidFixer = 50;
			GenVars.lakesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
			GenVars.smallHolesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
			GenVars.surfaceCavesBeachAvoidance = GenVars.beachSandRandomCenter + 20;
			GenVars.surfaceCavesBeachAvoidance2 = GenVars.beachSandRandomCenter + 20;
			GenVars.jungleOriginX = 0;
			GenVars.snowOriginLeft = 0;
			GenVars.snowOriginRight = 0;
			GenVars.logX = -1;
			GenVars.logY = -1;
			GenVars.dungeonLocation = 0;
			if (everythingWorldGen)
			{
				Main.starGame = true;
			}
			AddGenerationPass("Reset", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (genRand.Next(2) == 0)
				{
					GenVars.crimsonLeft = false;
				}
				else
				{
					GenVars.crimsonLeft = true;
				}
				GenVars.numOceanCaveTreasure = 0;
				GenVars.skipDesertTileCheck = false;
				growGrassUnderground = false;
				gen = true;
				Liquid.ReInit();
				noTileActions = true;
				progress.Message = "";
				SetupStatueList();
				RandomizeWeather();
				Main.cloudAlpha = 0f;
				Main.maxRaining = 0f;
				Main.raining = false;
				heartCount = 0;
				GenVars.extraBastStatueCount = 0;
				GenVars.extraBastStatueCountMax = 2;
				Main.checkXMas();
				Main.checkHalloween();
				ResetGenerator();
				GenVars.UndergroundDesertLocation = Rectangle.Empty;
				GenVars.UndergroundDesertHiveLocation = Rectangle.Empty;
				GenVars.numLarva = 0;
				List<int> list3 = new List<int> { 274, 220, 112, 218, 3019 };
				if (remixWorldGen)
				{
					list3 = new List<int> { 274, 220, 683, 218, 3019 };
				}
				List<int> list4 = new List<int>();
				while (list3.Count > 0)
				{
					int index = genRand.Next(list3.Count);
					int item = list3[index];
					list4.Add(item);
					list3.RemoveAt(index);
				}
				GenVars.hellChestItem = list4.ToArray();
				int num1083 = 86400;
				Main.slimeRainTime = -genRand.Next(num1083 * 2, num1083 * 3);
				Main.cloudBGActive = -genRand.Next(8640, 86400);
				skipFramingDuringGen = false;
				SavedOreTiers.Copper = 7;
				SavedOreTiers.Iron = 6;
				SavedOreTiers.Silver = 9;
				SavedOreTiers.Gold = 8;
				GenVars.copperBar = 20;
				GenVars.ironBar = 22;
				GenVars.silverBar = 21;
				GenVars.goldBar = 19;
				if (genRand.Next(2) == 0)
				{
					GenVars.copper = 166;
					GenVars.copperBar = 703;
					SavedOreTiers.Copper = 166;
				}
				if ((!dontStarveWorldGen || drunkWorldGen) && genRand.Next(2) == 0)
				{
					GenVars.iron = 167;
					GenVars.ironBar = 704;
					SavedOreTiers.Iron = 167;
				}
				if (genRand.Next(2) == 0)
				{
					GenVars.silver = 168;
					GenVars.silverBar = 705;
					SavedOreTiers.Silver = 168;
				}
				if ((!dontStarveWorldGen || drunkWorldGen) && genRand.Next(2) == 0)
				{
					GenVars.gold = 169;
					GenVars.goldBar = 706;
					SavedOreTiers.Gold = 169;
				}
				crimson = genRand.Next(2) == 0;
				if (WorldGenParam_Evil == 0)
				{
					crimson = false;
				}
				if (WorldGenParam_Evil == 1)
				{
					crimson = true;
				}
				if (GenVars.jungleHut == 0)
				{
					GenVars.jungleHut = 119;
				}
				else if (GenVars.jungleHut == 1)
				{
					GenVars.jungleHut = 120;
				}
				else if (GenVars.jungleHut == 2)
				{
					GenVars.jungleHut = 158;
				}
				else if (GenVars.jungleHut == 3)
				{
					GenVars.jungleHut = 175;
				}
				else if (GenVars.jungleHut == 4)
				{
					GenVars.jungleHut = 45;
				}
				Main.worldID = genRand.Next(int.MaxValue);
				RandomizeTreeStyle();
				RandomizeCaveBackgrounds();
				RandomizeBackgrounds(genRand);
				RandomizeMoonState(genRand);
				TreeTops.CopyExistingWorldInfoForWorldGeneration();
				GenVars.dungeonSide = ((genRand.Next(2) != 0) ? 1 : (-1));
				if (remixWorldGen)
				{
					if (GenVars.dungeonSide == -1)
					{
						double num1084 = 1.0 - (double)genRand.Next(20, 35) * 0.01;
						GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1084);
					}
					else
					{
						double num1085 = (double)genRand.Next(20, 35) * 0.01;
						GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1085);
					}
				}
				else
				{
					int minValue3 = 15;
					int maxValue12 = 30;
					if (tenthAnniversaryWorldGen && !remixWorldGen)
					{
						minValue3 = 25;
						maxValue12 = 35;
					}
					if (GenVars.dungeonSide == -1)
					{
						double num1086 = 1.0 - (double)genRand.Next(minValue3, maxValue12) * 0.01;
						GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1086);
					}
					else
					{
						double num1087 = (double)genRand.Next(minValue3, maxValue12) * 0.01;
						GenVars.jungleOriginX = (int)((double)Main.maxTilesX * num1087);
					}
				}
				int num1088 = genRand.Next(Main.maxTilesX);
				if (drunkWorldGen)
				{
					GenVars.dungeonSide *= -1;
				}
				if (GenVars.dungeonSide == 1)
				{
					while ((double)num1088 < (double)Main.maxTilesX * 0.6 || (double)num1088 > (double)Main.maxTilesX * 0.75)
					{
						num1088 = genRand.Next(Main.maxTilesX);
					}
				}
				else
				{
					while ((double)num1088 < (double)Main.maxTilesX * 0.25 || (double)num1088 > (double)Main.maxTilesX * 0.4)
					{
						num1088 = genRand.Next(Main.maxTilesX);
					}
				}
				if (drunkWorldGen)
				{
					GenVars.dungeonSide *= -1;
				}
				int num1089 = genRand.Next(50, 90);
				double num1090 = (double)Main.maxTilesX / 4200.0;
				num1089 += (int)((double)genRand.Next(20, 40) * num1090);
				num1089 += (int)((double)genRand.Next(20, 40) * num1090);
				int num1091 = num1088 - num1089;
				num1089 = genRand.Next(50, 90);
				num1089 += (int)((double)genRand.Next(20, 40) * num1090);
				num1089 += (int)((double)genRand.Next(20, 40) * num1090);
				int num1092 = num1088 + num1089;
				if (num1091 < 0)
				{
					num1091 = 0;
				}
				if (num1092 > Main.maxTilesX)
				{
					num1092 = Main.maxTilesX;
				}
				GenVars.snowOriginLeft = num1091;
				GenVars.snowOriginRight = num1092;
				GenVars.leftBeachEnd = genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
				if (tenthAnniversaryWorldGen && !remixWorldGen)
				{
					GenVars.leftBeachEnd = GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange;
				}
				if (GenVars.dungeonSide == 1)
				{
					GenVars.leftBeachEnd += GenVars.beachSandDungeonExtraWidth;
				}
				else
				{
					GenVars.leftBeachEnd += GenVars.beachSandJungleExtraWidth;
				}
				GenVars.rightBeachStart = Main.maxTilesX - genRand.Next(GenVars.beachSandRandomCenter - GenVars.beachSandRandomWidthRange, GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
				if (tenthAnniversaryWorldGen && !remixWorldGen)
				{
					GenVars.rightBeachStart = Main.maxTilesX - (GenVars.beachSandRandomCenter + GenVars.beachSandRandomWidthRange);
				}
				if (GenVars.dungeonSide == -1)
				{
					GenVars.rightBeachStart -= GenVars.beachSandDungeonExtraWidth;
				}
				else
				{
					GenVars.rightBeachStart -= GenVars.beachSandJungleExtraWidth;
				}
				int num1093 = 50;
				if (GenVars.dungeonSide == -1)
				{
					GenVars.dungeonLocation = genRand.Next(GenVars.leftBeachEnd + num1093, (int)((double)Main.maxTilesX * 0.2));
				}
				else
				{
					GenVars.dungeonLocation = genRand.Next((int)((double)Main.maxTilesX * 0.8), GenVars.rightBeachStart - num1093);
				}
				int num1094 = 0;
				if (Main.maxTilesX >= 8400)
				{
					num1094 = 2;
				}
				else if (Main.maxTilesX >= 6400)
				{
					num1094 = 1;
				}
				GenVars.extraBastStatueCountMax = 2 + num1094;
				Main.tileSolid[659] = false;
			});
			AddGenerationPass(new TerrainPass());
			AddGenerationPass("Dunes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[1].Value;
				int random9 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				double num1077 = passConfig.Get<double>("ChanceOfPyramid");
				if (drunkWorldGen)
				{
					num1077 = 1.0;
				}
				double num1078 = (double)Main.maxTilesX / 4200.0;
				GenVars.PyrX = new int[random9 + 3];
				GenVars.PyrY = new int[random9 + 3];
				DunesBiome dunesBiome = GenVars.configuration.CreateBiome<DunesBiome>();
				for (int num1079 = 0; num1079 < random9; num1079++)
				{
					progress.Set((double)num1079 / (double)random9);
					Point origin5 = Point.Zero;
					bool flag61 = false;
					int num1080 = 0;
					while (!flag61)
					{
						origin5 = RandomWorldPoint(0, 500, 0, 500);
						bool flag62 = Math.Abs(origin5.X - GenVars.jungleOriginX) < (int)(600.0 * num1078);
						bool flag63 = Math.Abs(origin5.X - Main.maxTilesX / 2) < 300;
						bool flag64 = origin5.X > GenVars.snowOriginLeft - 300 && origin5.X < GenVars.snowOriginRight + 300;
						num1080++;
						if (num1080 >= Main.maxTilesX)
						{
							flag62 = false;
						}
						if (num1080 >= Main.maxTilesX * 2)
						{
							flag64 = false;
						}
						flag61 = !(flag62 || flag63 || flag64);
					}
					dunesBiome.Place(origin5, GenVars.structures);
					if (genRand.NextDouble() <= num1077)
					{
						int num1081 = genRand.Next(origin5.X - 200, origin5.X + 200);
						for (int num1082 = 0; num1082 < Main.maxTilesY; num1082++)
						{
							if (Main.tile[num1081, num1082].active())
							{
								GenVars.PyrX[GenVars.numPyr] = num1081;
								GenVars.PyrY[GenVars.numPyr] = num1082 + 20;
								GenVars.numPyr++;
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Ocean Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Language.GetTextValue("WorldGeneration.OceanSand");
				for (int num1066 = 0; num1066 < 3; num1066++)
				{
					progress.Set((double)num1066 / 3.0);
					int num1067 = genRand.Next(Main.maxTilesX);
					while ((double)num1067 > (double)Main.maxTilesX * 0.4 && (double)num1067 < (double)Main.maxTilesX * 0.6)
					{
						num1067 = genRand.Next(Main.maxTilesX);
					}
					int num1068 = genRand.Next(35, 90);
					if (num1066 == 1)
					{
						double num1069 = (double)Main.maxTilesX / 4200.0;
						num1068 += (int)((double)genRand.Next(20, 40) * num1069);
					}
					if (genRand.Next(3) == 0)
					{
						num1068 *= 2;
					}
					if (num1066 == 1)
					{
						num1068 *= 2;
					}
					int num1070 = num1067 - num1068;
					num1068 = genRand.Next(35, 90);
					if (genRand.Next(3) == 0)
					{
						num1068 *= 2;
					}
					if (num1066 == 1)
					{
						num1068 *= 2;
					}
					int num1071 = num1067 + num1068;
					if (num1070 < 0)
					{
						num1070 = 0;
					}
					if (num1071 > Main.maxTilesX)
					{
						num1071 = Main.maxTilesX;
					}
					if (num1066 == 0)
					{
						num1070 = 0;
						num1071 = GenVars.leftBeachEnd;
					}
					else if (num1066 == 2)
					{
						num1070 = GenVars.rightBeachStart;
						num1071 = Main.maxTilesX;
					}
					else if (num1066 == 1)
					{
						continue;
					}
					int num1072 = genRand.Next(50, 100);
					for (int num1073 = num1070; num1073 < num1071; num1073++)
					{
						if (genRand.Next(2) == 0)
						{
							num1072 += genRand.Next(-1, 2);
							if (num1072 < 50)
							{
								num1072 = 50;
							}
							if (num1072 > 200)
							{
								num1072 = 200;
							}
						}
						for (int num1074 = 0; (double)num1074 < (Main.worldSurface + Main.rockLayer) / 2.0; num1074++)
						{
							if (Main.tile[num1073, num1074].active())
							{
								if (num1073 == (num1070 + num1071) / 2 && genRand.Next(6) == 0)
								{
									GenVars.PyrX[GenVars.numPyr] = num1073;
									GenVars.PyrY[GenVars.numPyr] = num1074;
									GenVars.numPyr++;
								}
								int num1075 = num1072;
								if (num1073 - num1070 < num1075)
								{
									num1075 = num1073 - num1070;
								}
								if (num1071 - num1073 < num1075)
								{
									num1075 = num1071 - num1073;
								}
								num1075 += genRand.Next(5);
								for (int num1076 = num1074; num1076 < num1074 + num1075; num1076++)
								{
									if (num1073 > num1070 + genRand.Next(5) && num1073 < num1071 - genRand.Next(5))
									{
										Main.tile[num1073, num1076].type = 53;
									}
								}
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Sand Patches", delegate
			{
				int num1061 = (int)((double)Main.maxTilesX * 0.013);
				if (remixWorldGen)
				{
					num1061 /= 4;
				}
				for (int num1062 = 0; num1062 < num1061; num1062++)
				{
					int num1063 = genRand.Next(0, Main.maxTilesX);
					int num1064 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					if (remixWorldGen)
					{
						num1064 = genRand.Next((int)Main.rockLayer - 100, Main.maxTilesY - 350);
					}
					while ((double)num1063 > (double)Main.maxTilesX * 0.46 && (double)num1063 < (double)Main.maxTilesX * 0.54 && (double)num1064 < Main.worldSurface + 150.0)
					{
						num1063 = genRand.Next(0, Main.maxTilesX);
						num1064 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					int num1065 = genRand.Next(15, 70);
					int steps2 = genRand.Next(20, 130);
					TileRunner(num1063, num1064, num1065, steps2, 53);
				}
			});
			AddGenerationPass("Tunnels", delegate
			{
				int num1055 = (int)((double)Main.maxTilesX * 0.0015);
				if (remixWorldGen)
				{
					num1055 = (int)((double)num1055 * 1.5);
				}
				for (int num1056 = 0; num1056 < num1055; num1056++)
				{
					if (GenVars.numTunnels >= GenVars.maxTunnels - 1)
					{
						break;
					}
					int[] array = new int[10];
					int[] array2 = new int[10];
					int num1057 = genRand.Next(450, Main.maxTilesX - 450);
					if (!remixWorldGen)
					{
						if (tenthAnniversaryWorldGen)
						{
							num1057 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						}
						else
						{
							while ((double)num1057 > (double)Main.maxTilesX * 0.4 && (double)num1057 < (double)Main.maxTilesX * 0.6)
							{
								num1057 = genRand.Next(450, Main.maxTilesX - 450);
							}
						}
					}
					int num1058 = 0;
					bool flag60;
					do
					{
						flag60 = false;
						for (int num1059 = 0; num1059 < 10; num1059++)
						{
							for (num1057 %= Main.maxTilesX; !Main.tile[num1057, num1058].active(); num1058++)
							{
							}
							if (Main.tile[num1057, num1058].type == 53)
							{
								flag60 = true;
							}
							array[num1059] = num1057;
							array2[num1059] = num1058 - genRand.Next(11, 16);
							num1057 += genRand.Next(5, 11);
						}
					}
					while (flag60);
					GenVars.tunnelX[GenVars.numTunnels] = array[5];
					GenVars.numTunnels++;
					for (int num1060 = 0; num1060 < 10; num1060++)
					{
						TileRunner(array[num1060], array2[num1060], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, -2.0, -0.3);
						TileRunner(array[num1060], array2[num1060], genRand.Next(5, 8), genRand.Next(6, 9), 0, addTile: true, 2.0, -0.3);
					}
				}
			});
			AddGenerationPass("Mount Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				GenVars.numMCaves = 0;
				progress.Message = Lang.gen[2].Value;
				int num1047 = (int)((double)Main.maxTilesX * 0.001);
				if (remixWorldGen)
				{
					num1047 = (int)((double)num1047 * 1.5);
				}
				for (int num1048 = 0; num1048 < num1047; num1048++)
				{
					progress.Set((double)num1048 / (double)num1047);
					int num1049 = 0;
					bool flag58 = false;
					bool flag59 = false;
					int num1050 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
					while (!flag59)
					{
						flag59 = true;
						if (!remixWorldGen)
						{
							while (num1050 > Main.maxTilesX / 2 - 90 && num1050 < Main.maxTilesX / 2 + 90)
							{
								num1050 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.75));
							}
						}
						for (int num1051 = 0; num1051 < GenVars.numMCaves; num1051++)
						{
							if (Math.Abs(num1050 - GenVars.mCaveX[num1051]) < 100)
							{
								num1049++;
								flag59 = false;
								break;
							}
						}
						if (num1049 >= Main.maxTilesX / 5)
						{
							flag58 = true;
							break;
						}
					}
					if (!flag58)
					{
						for (int num1052 = 0; (double)num1052 < Main.worldSurface; num1052++)
						{
							if (Main.tile[num1050, num1052].active())
							{
								for (int num1053 = num1050 - 50; num1053 < num1050 + 50; num1053++)
								{
									for (int num1054 = num1052 - 25; num1054 < num1052 + 25; num1054++)
									{
										if (Main.tile[num1053, num1054].active() && (Main.tile[num1053, num1054].type == 53 || Main.tile[num1053, num1054].type == 151 || Main.tile[num1053, num1054].type == 274))
										{
											flag58 = true;
										}
									}
								}
								if (!flag58)
								{
									Mountinater(num1050, num1052);
									GenVars.mCaveX[GenVars.numMCaves] = num1050;
									GenVars.mCaveY[GenVars.numMCaves] = num1052;
									GenVars.numMCaves++;
									break;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Dirt Wall Backgrounds", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[3].Value;
				int num1044 = 0;
				for (int num1045 = 1; num1045 < Main.maxTilesX - 1; num1045++)
				{
					ushort wall3 = 2;
					double value20 = (double)num1045 / (double)Main.maxTilesX;
					progress.Set(value20);
					bool flag57 = false;
					num1044 += genRand.Next(-1, 2);
					if (num1044 < 0)
					{
						num1044 = 0;
					}
					if (num1044 > 10)
					{
						num1044 = 10;
					}
					for (int num1046 = 0; (double)num1046 < Main.worldSurface + 10.0 && !((double)num1046 > Main.worldSurface + (double)num1044); num1046++)
					{
						if (Main.tile[num1045, num1046].active())
						{
							wall3 = (ushort)((Main.tile[num1045, num1046].type != 147) ? 2 : 40);
						}
						if (flag57 && Main.tile[num1045, num1046].wall != 64)
						{
							Main.tile[num1045, num1046].wall = wall3;
						}
						if (Main.tile[num1045, num1046].active() && Main.tile[num1045 - 1, num1046].active() && Main.tile[num1045 + 1, num1046].active() && Main.tile[num1045, num1046 + 1].active() && Main.tile[num1045 - 1, num1046 + 1].active() && Main.tile[num1045 + 1, num1046 + 1].active())
						{
							flag57 = true;
						}
					}
				}
			});
			AddGenerationPass("Rocks In Dirt", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[4].Value;
				double num1038 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.00015;
				for (int num1039 = 0; (double)num1039 < num1038; num1039++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow + 1), genRand.Next(4, 15), genRand.Next(5, 40), 1);
				}
				progress.Set(0.34);
				num1038 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0002;
				for (int num1040 = 0; (double)num1040 < num1038; num1040++)
				{
					int num1041 = genRand.Next(0, Main.maxTilesX);
					int num1042 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1);
					if (!Main.tile[num1041, num1042 - 10].active())
					{
						num1042 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1);
					}
					TileRunner(num1041, num1042, genRand.Next(4, 10), genRand.Next(5, 30), 1);
				}
				progress.Set(0.67);
				num1038 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0045;
				for (int num1043 = 0; (double)num1043 < num1038; num1043++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh + 1), genRand.Next(2, 7), genRand.Next(2, 23), 1);
				}
			});
			AddGenerationPass("Dirt In Rocks", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[5].Value;
				double num1034 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.005;
				for (int num1035 = 0; (double)num1035 < num1034; num1035++)
				{
					progress.Set((double)num1035 / num1034);
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 0);
				}
				if (remixWorldGen)
				{
					for (int num1036 = 0; num1036 < Main.maxTilesX; num1036++)
					{
						for (int num1037 = (int)Main.worldSurface + genRand.Next(-1, 3); num1037 < Main.maxTilesY; num1037++)
						{
							if (Main.tile[num1036, num1037].active())
							{
								if (Main.tile[num1036, num1037].type == 0)
								{
									Main.tile[num1036, num1037].type = 1;
								}
								else if (Main.tile[num1036, num1037].type == 1)
								{
									Main.tile[num1036, num1037].type = 0;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Clay", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[6].Value;
				for (int num1027 = 0; num1027 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num1027++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 14), genRand.Next(10, 50), 40);
				}
				progress.Set(0.25);
				if (remixWorldGen)
				{
					for (int num1028 = 0; num1028 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 7E-05); num1028++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayer - 25, Main.maxTilesY - 350), genRand.Next(8, 15), genRand.Next(5, 50), 40);
					}
				}
				else
				{
					for (int num1029 = 0; num1029 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 5E-05); num1029++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh + 1), genRand.Next(8, 14), genRand.Next(15, 45), 40);
					}
					progress.Set(0.5);
					for (int num1030 = 0; num1030 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05); num1030++)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh + 1), genRand.Next(8, 15), genRand.Next(5, 50), 40);
					}
				}
				progress.Set(0.75);
				for (int num1031 = 5; num1031 < Main.maxTilesX - 5; num1031++)
				{
					for (int num1032 = 1; (double)num1032 < Main.worldSurface - 1.0; num1032++)
					{
						if (Main.tile[num1031, num1032].active())
						{
							for (int num1033 = num1032; num1033 < num1032 + 5; num1033++)
							{
								if (Main.tile[num1031, num1033].type == 40)
								{
									Main.tile[num1031, num1033].type = 0;
								}
							}
							break;
						}
					}
				}
			});
			AddGenerationPass("Small Holes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[7].Value;
				double worldSurfaceHigh2 = GenVars.worldSurfaceHigh;
				for (int num1022 = 0; num1022 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015); num1022++)
				{
					double value19 = (double)num1022 / ((double)(Main.maxTilesX * Main.maxTilesY) * 0.0015);
					progress.Set(value19);
					int type14 = -1;
					if (genRand.Next(5) == 0)
					{
						type14 = -2;
					}
					int num1023 = genRand.Next(0, Main.maxTilesX);
					int num1024 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					if (!remixWorldGen && tenthAnniversaryWorldGen)
					{
						while ((double)num1023 < (double)Main.maxTilesX * 0.2 && (double)num1023 > (double)Main.maxTilesX * 0.8 && (double)num1024 < GenVars.worldSurface)
						{
							num1023 = genRand.Next(0, Main.maxTilesX);
							num1024 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
						}
					}
					else
					{
						while (((num1023 < GenVars.smallHolesBeachAvoidance || num1023 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num1024 < worldSurfaceHigh2) || ((double)num1023 > (double)Main.maxTilesX * 0.45 && (double)num1023 < (double)Main.maxTilesX * 0.55 && (double)num1024 < GenVars.worldSurface))
						{
							num1023 = genRand.Next(0, Main.maxTilesX);
							num1024 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
						}
					}
					int num1025 = genRand.Next(2, 5);
					int num1026 = genRand.Next(2, 20);
					if (remixWorldGen && (double)num1024 > Main.rockLayer)
					{
						num1025 = (int)((double)num1025 * 0.8);
						num1026 = (int)((double)num1026 * 0.9);
					}
					TileRunner(num1023, num1024, num1025, num1026, type14);
					num1023 = genRand.Next(0, Main.maxTilesX);
					num1024 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					while (((num1023 < GenVars.smallHolesBeachAvoidance || num1023 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num1024 < worldSurfaceHigh2) || ((double)num1023 > (double)Main.maxTilesX * 0.45 && (double)num1023 < (double)Main.maxTilesX * 0.55 && (double)num1024 < GenVars.worldSurface))
					{
						num1023 = genRand.Next(0, Main.maxTilesX);
						num1024 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY);
					}
					num1025 = genRand.Next(8, 15);
					num1026 = genRand.Next(7, 30);
					if (remixWorldGen && (double)num1024 > Main.rockLayer)
					{
						num1025 = (int)((double)num1025 * 0.7);
						num1026 = (int)((double)num1026 * 0.9);
					}
					TileRunner(num1023, num1024, num1025, num1026, type14);
				}
			});
			AddGenerationPass("Dirt Layer Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[8].Value;
				double worldSurfaceHigh = GenVars.worldSurfaceHigh;
				int num1016 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05);
				if (remixWorldGen)
				{
					num1016 *= 2;
				}
				for (int num1017 = 0; num1017 < num1016; num1017++)
				{
					double value18 = (double)num1017 / (double)num1016;
					progress.Set(value18);
					if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type13 = -1;
						if (genRand.Next(6) == 0)
						{
							type13 = -2;
						}
						int num1018 = genRand.Next(0, Main.maxTilesX);
						int num1019 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.rockLayerHigh + 1);
						while (((num1018 < GenVars.smallHolesBeachAvoidance || num1018 > Main.maxTilesX - GenVars.smallHolesBeachAvoidance) && (double)num1019 < worldSurfaceHigh) || ((double)num1018 >= (double)Main.maxTilesX * 0.45 && (double)num1018 <= (double)Main.maxTilesX * 0.55 && (double)num1019 < Main.worldSurface))
						{
							num1018 = genRand.Next(0, Main.maxTilesX);
							num1019 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.rockLayerHigh + 1);
						}
						int num1020 = genRand.Next(5, 15);
						int num1021 = genRand.Next(30, 200);
						if (remixWorldGen)
						{
							num1020 = (int)((double)num1020 * 1.1);
							num1021 = (int)((double)num1021 * 1.9);
						}
						TileRunner(num1018, num1019, num1020, num1021, type13);
					}
				}
			});
			AddGenerationPass("Rock Layer Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[9].Value;
				int num1008 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013);
				if (remixWorldGen)
				{
					num1008 = (int)((double)num1008 * 1.1);
				}
				for (int num1009 = 0; num1009 < num1008; num1009++)
				{
					double value17 = (double)num1009 / (double)num1008;
					progress.Set(value17);
					if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
					{
						int type11 = -1;
						if (genRand.Next(10) == 0)
						{
							type11 = -2;
						}
						int num1010 = genRand.Next(6, 20);
						int num1011 = genRand.Next(50, 300);
						if (remixWorldGen)
						{
							num1010 = (int)((double)num1010 * 0.7);
							num1011 = (int)((double)num1011 * 0.7);
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY), num1010, num1011, type11);
					}
				}
				if (remixWorldGen)
				{
					num1008 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00013 * 0.4);
					for (int num1012 = 0; num1012 < num1008; num1012++)
					{
						if (GenVars.rockLayerHigh <= (double)Main.maxTilesY)
						{
							int type12 = -1;
							if (genRand.Next(10) == 0)
							{
								type12 = -2;
							}
							int num1013 = genRand.Next(7, 26);
							int steps = genRand.Next(50, 200);
							double num1014 = (double)genRand.Next(100, 221) * 0.1;
							double num1015 = (double)genRand.Next(-10, 11) * 0.02;
							int i5 = genRand.Next(0, Main.maxTilesX);
							int j7 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
							TileRunner(i5, j7, num1013, steps, type12, addTile: false, num1014, num1015, noYChange: true);
							TileRunner(i5, j7, num1013, steps, type12, addTile: false, 0.0 - num1014, 0.0 - num1015, noYChange: true);
						}
					}
				}
			});
			AddGenerationPass("Surface Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[10].Value;
				int num989 = (int)((double)Main.maxTilesX * 0.002);
				int num990 = (int)((double)Main.maxTilesX * 0.0007);
				int num991 = (int)((double)Main.maxTilesX * 0.0003);
				if (remixWorldGen)
				{
					num989 *= 3;
					num990 *= 3;
					num991 *= 3;
				}
				for (int num992 = 0; num992 < num989; num992++)
				{
					int num993 = genRand.Next(0, Main.maxTilesX);
					while (((double)num993 > (double)Main.maxTilesX * 0.45 && (double)num993 < (double)Main.maxTilesX * 0.55) || num993 < GenVars.leftBeachEnd + 20 || num993 > GenVars.rightBeachStart - 20)
					{
						num993 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num994 = 0; (double)num994 < GenVars.worldSurfaceHigh; num994++)
					{
						if (Main.tile[num993, num994].active())
						{
							TileRunner(num993, num994, genRand.Next(3, 6), genRand.Next(5, 50), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 1.0);
							break;
						}
					}
				}
				progress.Set(0.2);
				for (int num995 = 0; num995 < num990; num995++)
				{
					int num996 = genRand.Next(0, Main.maxTilesX);
					while (((double)num996 > (double)Main.maxTilesX * 0.43 && (double)num996 < (double)Main.maxTilesX * 0.5700000000000001) || num996 < GenVars.leftBeachEnd + 20 || num996 > GenVars.rightBeachStart - 20)
					{
						num996 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num997 = 0; (double)num997 < GenVars.worldSurfaceHigh; num997++)
					{
						if (Main.tile[num996, num997].active())
						{
							TileRunner(num996, num997, genRand.Next(10, 15), genRand.Next(50, 130), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
							break;
						}
					}
				}
				progress.Set(0.4);
				for (int num998 = 0; num998 < num991; num998++)
				{
					int num999 = genRand.Next(0, Main.maxTilesX);
					while (((double)num999 > (double)Main.maxTilesX * 0.4 && (double)num999 < (double)Main.maxTilesX * 0.6) || num999 < GenVars.leftBeachEnd + 20 || num999 > GenVars.rightBeachStart - 20)
					{
						num999 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num1000 = 0; (double)num1000 < GenVars.worldSurfaceHigh; num1000++)
					{
						if (Main.tile[num999, num1000].active())
						{
							TileRunner(num999, num1000, genRand.Next(12, 25), genRand.Next(150, 500), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 4.0);
							TileRunner(num999, num1000, genRand.Next(8, 17), genRand.Next(60, 200), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
							TileRunner(num999, num1000, genRand.Next(5, 13), genRand.Next(40, 170), -1, addTile: false, (double)genRand.Next(-10, 11) * 0.1, 2.0);
							break;
						}
					}
				}
				progress.Set(0.6);
				for (int num1001 = 0; num1001 < (int)((double)Main.maxTilesX * 0.0004); num1001++)
				{
					int num1002 = genRand.Next(0, Main.maxTilesX);
					while (((double)num1002 > (double)Main.maxTilesX * 0.4 && (double)num1002 < (double)Main.maxTilesX * 0.6) || num1002 < GenVars.leftBeachEnd + 20 || num1002 > GenVars.rightBeachStart - 20)
					{
						num1002 = genRand.Next(0, Main.maxTilesX);
					}
					for (int num1003 = 0; (double)num1003 < GenVars.worldSurfaceHigh; num1003++)
					{
						if (Main.tile[num1002, num1003].active())
						{
							TileRunner(num1002, num1003, genRand.Next(7, 12), genRand.Next(150, 250), -1, addTile: false, 0.0, 1.0, noYChange: true);
							break;
						}
					}
				}
				progress.Set(0.8);
				double num1004 = (double)Main.maxTilesX / 4200.0;
				for (int num1005 = 0; (double)num1005 < 5.0 * num1004; num1005++)
				{
					try
					{
						int num1006 = (int)Main.rockLayer;
						int num1007 = Main.maxTilesY - 400;
						if (num1006 >= num1007)
						{
							num1006 = num1007 - 1;
						}
						Caverer(genRand.Next(GenVars.surfaceCavesBeachAvoidance2, Main.maxTilesX - GenVars.surfaceCavesBeachAvoidance2), genRand.Next(num1006, num1007));
					}
					catch
					{
					}
				}
			});
			AddGenerationPass("Wavy Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (dontStarveWorldGen)
				{
					progress.Message = Language.GetTextValue("WorldGeneration.WavyCaves");
					double num980 = (double)Main.maxTilesX / 4200.0;
					num980 *= num980;
					int num981 = (int)(35.0 * num980);
					if (Main.remixWorld)
					{
						num981 /= 3;
					}
					int num982 = 0;
					int num983 = 80;
					for (int num984 = 0; num984 < num981; num984++)
					{
						double num985 = (double)num984 / (double)(num981 - 1);
						progress.Set(num985);
						int num986 = genRand.Next((int)Main.worldSurface + 100, Main.UnderworldLayer - 100);
						int num987 = 0;
						while (Math.Abs(num986 - num982) < num983)
						{
							num987++;
							if (num987 > 100)
							{
								break;
							}
							num986 = genRand.Next((int)Main.worldSurface + 100, Main.UnderworldLayer - 100);
						}
						num982 = num986;
						int num988 = 80;
						int startX = num988 + (int)((double)(Main.maxTilesX - num988 * 2) * num985);
						try
						{
							WavyCaverer(startX, num986, 12 + genRand.Next(3, 6), 0.25 + genRand.NextDouble(), genRand.Next(300, 500), -1);
						}
						catch
						{
						}
					}
				}
			});
			AddGenerationPass("Generate Ice Biome", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[56].Value;
				GenVars.snowTop = (int)Main.worldSurface;
				int num972 = GenVars.lavaLine - genRand.Next(160, 200);
				int num973 = GenVars.lavaLine;
				if (remixWorldGen)
				{
					num973 = Main.maxTilesY - 250;
					num972 = num973 - genRand.Next(160, 200);
				}
				int num974 = GenVars.snowOriginLeft;
				int num975 = GenVars.snowOriginRight;
				int num976 = 10;
				for (int num977 = 0; num977 <= num973 - 140; num977++)
				{
					progress.Set((double)num977 / (double)(num973 - 140));
					num974 += genRand.Next(-4, 4);
					num975 += genRand.Next(-3, 5);
					if (num977 > 0)
					{
						num974 = (num974 + GenVars.snowMinX[num977 - 1]) / 2;
						num975 = (num975 + GenVars.snowMaxX[num977 - 1]) / 2;
					}
					if (GenVars.dungeonSide > 0)
					{
						if (genRand.Next(4) == 0)
						{
							num974++;
							num975++;
						}
					}
					else if (genRand.Next(4) == 0)
					{
						num974--;
						num975--;
					}
					GenVars.snowMinX[num977] = num974;
					GenVars.snowMaxX[num977] = num975;
					for (int num978 = num974; num978 < num975; num978++)
					{
						if (num977 < num972)
						{
							if (Main.tile[num978, num977].wall == 2)
							{
								Main.tile[num978, num977].wall = 40;
							}
							switch (Main.tile[num978, num977].type)
							{
							case 0:
							case 2:
							case 23:
							case 40:
							case 53:
								Main.tile[num978, num977].type = 147;
								break;
							case 1:
								Main.tile[num978, num977].type = 161;
								break;
							}
						}
						else
						{
							num976 += genRand.Next(-3, 4);
							if (genRand.Next(3) == 0)
							{
								num976 += genRand.Next(-4, 5);
								if (genRand.Next(3) == 0)
								{
									num976 += genRand.Next(-6, 7);
								}
							}
							if (num976 < 0)
							{
								num976 = genRand.Next(3);
							}
							else if (num976 > 50)
							{
								num976 = 50 - genRand.Next(3);
							}
							for (int num979 = num977; num979 < num977 + num976; num979++)
							{
								if (Main.tile[num978, num979].wall == 2)
								{
									Main.tile[num978, num979].wall = 40;
								}
								switch (Main.tile[num978, num979].type)
								{
								case 0:
								case 2:
								case 23:
								case 40:
								case 53:
									Main.tile[num978, num979].type = 147;
									break;
								case 1:
									Main.tile[num978, num979].type = 161;
									break;
								}
							}
						}
					}
					if (GenVars.snowBottom < num977)
					{
						GenVars.snowBottom = num977;
					}
				}
			});
			AddGenerationPass("Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				double num968 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.002;
				for (int num969 = 0; (double)num969 < num968; num969++)
				{
					progress.Set((double)num969 / num968);
					int num970 = genRand.Next(1, Main.maxTilesX - 1);
					int num971 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh);
					if (num971 >= Main.maxTilesY)
					{
						num971 = Main.maxTilesY - 2;
					}
					if (Main.tile[num970 - 1, num971].active() && Main.tile[num970 - 1, num971].type == 0 && Main.tile[num970 + 1, num971].active() && Main.tile[num970 + 1, num971].type == 0 && Main.tile[num970, num971 - 1].active() && Main.tile[num970, num971 - 1].type == 0 && Main.tile[num970, num971 + 1].active() && Main.tile[num970, num971 + 1].type == 0)
					{
						Main.tile[num970, num971].active(active: true);
						Main.tile[num970, num971].type = 2;
					}
					num970 = genRand.Next(1, Main.maxTilesX - 1);
					num971 = genRand.Next(0, (int)GenVars.worldSurfaceLow);
					if (num971 >= Main.maxTilesY)
					{
						num971 = Main.maxTilesY - 2;
					}
					if (Main.tile[num970 - 1, num971].active() && Main.tile[num970 - 1, num971].type == 0 && Main.tile[num970 + 1, num971].active() && Main.tile[num970 + 1, num971].type == 0 && Main.tile[num970, num971 - 1].active() && Main.tile[num970, num971 - 1].type == 0 && Main.tile[num970, num971 + 1].active() && Main.tile[num970, num971 + 1].type == 0)
					{
						Main.tile[num970, num971].active(active: true);
						Main.tile[num970, num971].type = 2;
					}
				}
			});
			AddGenerationPass(new JunglePass());
			AddGenerationPass("Mud Caves To Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[77].Value;
				NotTheBees();
				for (int num963 = 0; num963 < Main.maxTilesX; num963++)
				{
					for (int num964 = 0; num964 < Main.maxTilesY; num964++)
					{
						if (Main.tile[num963, num964].active())
						{
							grassSpread = 0;
							SpreadGrass(num963, num964, 59, 60);
						}
						progress.Set(0.2 * ((double)(num963 * Main.maxTilesY + num964) / (double)(Main.maxTilesX * Main.maxTilesY)));
					}
				}
				SmallConsecutivesFound = 0;
				SmallConsecutivesEliminated = 0;
				double num965 = Main.maxTilesX - 20;
				for (int num966 = 10; num966 < Main.maxTilesX - 10; num966++)
				{
					ScanTileColumnAndRemoveClumps(num966);
					double num967 = (double)(num966 - 10) / num965;
					progress.Set(0.2 + num967 * 0.8);
				}
			});
			AddGenerationPass("Full Desert", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[78].Value;
				Main.tileSolid[484] = false;
				int num955 = 0;
				int num956 = GenVars.dungeonSide;
				int num957 = Main.maxTilesX / 2;
				int num958 = genRand.Next(num957) / 8;
				num958 += num957 / 8;
				int x15 = num957 + num958 * -num956;
				int num959 = 0;
				DesertBiome desertBiome = GenVars.configuration.CreateBiome<DesertBiome>();
				while (!desertBiome.Place(new Point(x15, (int)GenVars.worldSurfaceHigh + 25), GenVars.structures))
				{
					num958 = genRand.Next(num957) / 2;
					num958 += num957 / 8;
					num958 += genRand.Next(num959 / 12);
					x15 = num957 + num958 * -num956;
					if (++num959 > Main.maxTilesX / 4)
					{
						num956 *= -1;
						num959 = 0;
						num955++;
						if (num955 >= 2)
						{
							GenVars.skipDesertTileCheck = true;
						}
					}
				}
				if (remixWorldGen)
				{
					for (int num960 = 50; num960 < Main.maxTilesX - 50; num960++)
					{
						for (int num961 = (int)Main.rockLayer + genRand.Next(-1, 2); num961 < Main.maxTilesY - 50; num961++)
						{
							if ((Main.tile[num960, num961].type == 396 || Main.tile[num960, num961].type == 397 || Main.tile[num960, num961].type == 53) && !SolidTile(num960, num961 - 1))
							{
								for (int num962 = num961; num962 < num961 + genRand.Next(4, 7) && Main.tile[num960, num962 + 1].active() && (Main.tile[num960, num962].type == 396 || Main.tile[num960, num962].type == 397); num962++)
								{
									Main.tile[num960, num962].type = 53;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Floating Islands", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				GenVars.numIslandHouses = 0;
				GenVars.skyIslandHouseCount = 0;
				progress.Message = Lang.gen[12].Value;
				int num945 = (int)((double)Main.maxTilesX * 0.0008);
				int num946 = 0;
				double num947 = num945 + GenVars.skyLakes;
				for (int num948 = 0; (double)num948 < num947; num948++)
				{
					progress.Set((double)num948 / num947);
					int num949 = Main.maxTilesX;
					while (--num949 > 0)
					{
						bool flag56 = true;
						int num950 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						while (num950 > Main.maxTilesX / 2 - 150 && num950 < Main.maxTilesX / 2 + 150)
						{
							num950 = genRand.Next((int)((double)Main.maxTilesX * 0.1), (int)((double)Main.maxTilesX * 0.9));
						}
						for (int num951 = 0; num951 < GenVars.numIslandHouses; num951++)
						{
							if (num950 > GenVars.floatingIslandHouseX[num951] - 180 && num950 < GenVars.floatingIslandHouseX[num951] + 180)
							{
								flag56 = false;
								break;
							}
						}
						if (flag56)
						{
							flag56 = false;
							int num952 = 0;
							for (int num953 = 200; (double)num953 < Main.worldSurface; num953++)
							{
								if (Main.tile[num950, num953].active())
								{
									num952 = num953;
									flag56 = true;
									break;
								}
							}
							if (flag56)
							{
								int num954 = 0;
								num949 = -1;
								int val = genRand.Next(90, num952 - 100);
								val = Math.Min(val, (int)GenVars.worldSurfaceLow - 50);
								if (num946 >= num945)
								{
									GenVars.skyLake[GenVars.numIslandHouses] = true;
									CloudLake(num950, val);
								}
								else
								{
									GenVars.skyLake[GenVars.numIslandHouses] = false;
									if (drunkWorldGen && !remixWorldGen)
									{
										if (genRand.Next(2) == 0)
										{
											num954 = 3;
											SnowCloudIsland(num950, val);
										}
										else
										{
											num954 = 1;
											DesertCloudIsland(num950, val);
										}
									}
									else
									{
										if (remixWorldGen && drunkWorldGen)
										{
											num954 = ((GenVars.crimsonLeft && num950 < Main.maxTilesX / 2) ? 5 : ((GenVars.crimsonLeft || num950 <= Main.maxTilesX / 2) ? 4 : 5));
										}
										else if (getGoodWorldGen || remixWorldGen)
										{
											num954 = ((!crimson) ? 4 : 5);
										}
										else if (Main.tenthAnniversaryWorld)
										{
											num954 = 6;
										}
										CloudIsland(num950, val);
									}
								}
								GenVars.floatingIslandHouseX[GenVars.numIslandHouses] = num950;
								GenVars.floatingIslandHouseY[GenVars.numIslandHouses] = val;
								GenVars.floatingIslandStyle[GenVars.numIslandHouses] = num954;
								GenVars.numIslandHouses++;
								num946++;
							}
						}
					}
				}
			});
			AddGenerationPass("Mushroom Patches", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				//IL_0287: Unknown result type (might be due to invalid IL or missing references)
				//IL_0292: Unknown result type (might be due to invalid IL or missing references)
				progress.Message = Lang.gen[13].Value;
				if (remixWorldGen)
				{
					for (int num924 = 10; num924 < Main.maxTilesX - 10; num924++)
					{
						for (int num925 = Main.maxTilesY + genRand.Next(3) - 350; num925 < Main.maxTilesY - 10; num925++)
						{
							if (Main.tile[num924, num925].type == 0)
							{
								Main.tile[num924, num925].type = 59;
							}
						}
					}
				}
				double num926 = (double)Main.maxTilesX / 700.0;
				if (num926 > (double)GenVars.maxMushroomBiomes)
				{
					num926 = GenVars.maxMushroomBiomes;
				}
				for (int num927 = 0; (double)num927 < num926; num927++)
				{
					int num928 = 0;
					bool flag55 = true;
					while (flag55)
					{
						int num929 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
						if (num928 > Main.maxTilesX / 4)
						{
							num929 = genRand.Next((int)((double)Main.maxTilesX * 0.25), (int)((double)Main.maxTilesX * 0.975));
						}
						int num930 = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer + 50, Main.maxTilesY - 300) : genRand.Next((int)Main.worldSurface + 50, (int)Main.rockLayer - 50));
						flag55 = false;
						int num931 = 100;
						int num932 = 500;
						for (int num933 = num929 - num931; num933 < num929 + num931; num933 += 3)
						{
							for (int num934 = num930 - num931; num934 < num930 + num931; num934 += 3)
							{
								if (InWorld(num933, num934))
								{
									if (Main.tile[num933, num934].type == 147 || Main.tile[num933, num934].type == 161 || Main.tile[num933, num934].type == 162 || Main.tile[num933, num934].type == 60 || Main.tile[num933, num934].type == 368 || Main.tile[num933, num934].type == 367)
									{
										flag55 = true;
										break;
									}
									if (GenVars.UndergroundDesertLocation.Contains(new Point(num933, num934)))
									{
										flag55 = true;
										break;
									}
								}
								else
								{
									flag55 = true;
								}
							}
						}
						if (!flag55)
						{
							for (int num935 = 0; num935 < GenVars.numMushroomBiomes; num935++)
							{
								if (Vector2D.Distance(GenVars.mushroomBiomesPosition[num935].ToVector2D(), new Vector2D((double)num929, (double)num930)) < (double)num932)
								{
									flag55 = true;
								}
							}
						}
						if (!flag55 && GenVars.numMushroomBiomes < GenVars.maxMushroomBiomes)
						{
							ShroomPatch(num929, num930);
							for (int num936 = 0; num936 < 5; num936++)
							{
								int i4 = num929 + genRand.Next(-40, 41);
								int j6 = num930 + genRand.Next(-40, 41);
								ShroomPatch(i4, j6);
							}
							GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].X = num929;
							GenVars.mushroomBiomesPosition[GenVars.numMushroomBiomes].Y = num930;
							GenVars.numMushroomBiomes++;
						}
						num928++;
						if (num928 > Main.maxTilesX / 2)
						{
							break;
						}
					}
				}
				for (int num937 = 0; num937 < Main.maxTilesX; num937++)
				{
					progress.Set((double)num937 / (double)Main.maxTilesX);
					for (int num938 = (int)Main.worldSurface; num938 < Main.maxTilesY; num938++)
					{
						if (InWorld(num937, num938, 50) && Main.tile[num937, num938].active())
						{
							grassSpread = 0;
							SpreadGrass(num937, num938, 59, 70, repeat: false);
						}
					}
				}
				for (int num939 = 0; num939 < Main.maxTilesX; num939++)
				{
					for (int num940 = (int)Main.worldSurface; num940 < Main.maxTilesY; num940++)
					{
						if (Main.tile[num939, num940].active() && Main.tile[num939, num940].type == 70)
						{
							int type10 = 59;
							for (int num941 = num939 - 1; num941 <= num939 + 1; num941++)
							{
								for (int num942 = num940 - 1; num942 <= num940 + 1; num942++)
								{
									if (Main.tile[num941, num942].active())
									{
										if (!Main.tile[num941 - 1, num942].active() && !Main.tile[num941 + 1, num942].active())
										{
											KillTile(num941, num942);
										}
										else if (!Main.tile[num941, num942 - 1].active() && !Main.tile[num941, num942 + 1].active())
										{
											KillTile(num941, num942);
										}
									}
									else if (Main.tile[num941 - 1, num942].active() && Main.tile[num941 + 1, num942].active())
									{
										PlaceTile(num941, num942, type10);
										if (Main.tile[num941 - 1, num940].type == 70)
										{
											Main.tile[num941 - 1, num940].type = 59;
										}
										if (Main.tile[num941 + 1, num940].type == 70)
										{
											Main.tile[num941 + 1, num940].type = 59;
										}
									}
									else if (Main.tile[num941, num942 - 1].active() && Main.tile[num941, num942 + 1].active())
									{
										PlaceTile(num941, num942, type10);
										if (Main.tile[num941, num940 - 1].type == 70)
										{
											Main.tile[num941, num940 - 1].type = 59;
										}
										if (Main.tile[num941, num940 + 1].type == 70)
										{
											Main.tile[num941, num940 + 1].type = 59;
										}
									}
								}
							}
							if (genRand.Next(4) == 0)
							{
								int num943 = num939 + genRand.Next(-20, 21);
								int num944 = num940 + genRand.Next(-20, 21);
								if (InWorld(num943, num944) && Main.tile[num943, num944].type == 59)
								{
									Main.tile[num943, num944].type = 70;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Marble", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[80].Value;
				int num919 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				double num920 = (double)(Main.maxTilesX - 160) / (double)num919;
				MarbleBiome marbleBiome = GenVars.configuration.CreateBiome<MarbleBiome>();
				int num921 = 0;
				int num922 = 0;
				while (num922 < num919)
				{
					double num923 = (double)num922 / (double)num919;
					progress.Set(num923);
					Point origin4 = RandomRectanglePoint((int)(num923 * (double)(Main.maxTilesX - 160)) + 80, (int)GenVars.rockLayer + 20, (int)num920, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200);
					if (remixWorldGen)
					{
						origin4 = RandomRectanglePoint((int)(num923 * (double)(Main.maxTilesX - 160)) + 80, (int)GenVars.worldSurface + 100, (int)num920, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100);
					}
					while ((double)origin4.X > (double)Main.maxTilesX * 0.45 && (double)origin4.X < (double)Main.maxTilesX * 0.55)
					{
						origin4.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					}
					num921++;
					if (marbleBiome.Place(origin4, GenVars.structures))
					{
						num922++;
						num921 = 0;
					}
					else if (num921 > Main.maxTilesX * 10)
					{
						num919 = num922;
						num922++;
						num921 = 0;
					}
				}
			});
			AddGenerationPass("Granite", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[81].Value;
				int num913 = passConfig.Get<WorldGenRange>("Count").GetRandom(genRand);
				double num914 = (double)(Main.maxTilesX - 200) / (double)num913;
				List<Point> list2 = new List<Point>(num913);
				int num915 = 0;
				int num916 = 0;
				while (num916 < num913)
				{
					double num917 = (double)num916 / (double)num913;
					progress.Set(num917);
					Point point3 = RandomRectanglePoint((int)(num917 * (double)(Main.maxTilesX - 200)) + 100, (int)GenVars.rockLayer + 20, (int)num914, Main.maxTilesY - ((int)GenVars.rockLayer + 40) - 200);
					if (remixWorldGen)
					{
						point3 = RandomRectanglePoint((int)(num917 * (double)(Main.maxTilesX - 200)) + 100, (int)GenVars.worldSurface + 100, (int)num914, (int)GenVars.rockLayer - (int)GenVars.worldSurface - 100);
					}
					while ((double)point3.X > (double)Main.maxTilesX * 0.45 && (double)point3.X < (double)Main.maxTilesX * 0.55)
					{
						point3.X = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
					}
					num915++;
					if (GraniteBiome.CanPlace(point3, GenVars.structures))
					{
						list2.Add(point3);
						num916++;
					}
					else if (num915 > Main.maxTilesX * 10)
					{
						num913 = num916;
						num916++;
						num915 = 0;
					}
				}
				GraniteBiome graniteBiome = GenVars.configuration.CreateBiome<GraniteBiome>();
				for (int num918 = 0; num918 < num913; num918++)
				{
					graniteBiome.Place(list2[num918], GenVars.structures);
				}
			});
			AddGenerationPass("Dirt To Mud", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[14].Value;
				double num911 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.001;
				for (int num912 = 0; (double)num912 < num911; num912++)
				{
					progress.Set((double)num912 / num911);
					if (remixWorldGen)
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)GenVars.rockLayerLow), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0.0, 0.0, noYChange: false, overRide: true, 53);
					}
					else
					{
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(2, 6), genRand.Next(2, 40), 59, addTile: false, 0.0, 0.0, noYChange: false, overRide: true, 53);
					}
				}
			});
			AddGenerationPass("Silt", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[15].Value;
				for (int num905 = 0; num905 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0001); num905++)
				{
					int num906 = genRand.Next(0, Main.maxTilesX);
					int num907 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
					if (remixWorldGen)
					{
						num907 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					if (Main.tile[num906, num907].wall != 187 && Main.tile[num906, num907].wall != 216)
					{
						TileRunner(num906, num907, genRand.Next(5, 12), genRand.Next(15, 50), 123);
					}
				}
				for (int num908 = 0; num908 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0005); num908++)
				{
					int num909 = genRand.Next(0, Main.maxTilesX);
					int num910 = genRand.Next((int)GenVars.rockLayerHigh, Main.maxTilesY);
					if (remixWorldGen)
					{
						num910 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					if (Main.tile[num909, num910].wall != 187 && Main.tile[num909, num910].wall != 216)
					{
						TileRunner(num909, num910, genRand.Next(2, 5), genRand.Next(2, 5), 123);
					}
				}
			});
			AddGenerationPass("Shinies", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[16].Value;
				if (remixWorldGen)
				{
					for (int num875 = 0; num875 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05); num875++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), GenVars.copper);
					}
					for (int num876 = 0; num876 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num876++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), GenVars.copper);
					}
					for (int num877 = 0; num877 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num877++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.copper);
					}
					for (int num878 = 0; num878 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num878++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), GenVars.iron);
					}
					for (int num879 = 0; num879 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num879++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.iron);
					}
					for (int num880 = 0; num880 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num880++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.iron);
					}
					for (int num881 = 0; num881 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num881++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer - 100, Main.maxTilesY - 250), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.silver);
					}
					for (int num882 = 0; num882 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num882++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
					}
					for (int num883 = 0; num883 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num883++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
					}
					for (int num884 = 0; num884 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num884++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.gold = 8;
							}
							else
							{
								GenVars.gold = 169;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
					}
					for (int num885 = 0; num885 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num885++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.gold = 8;
							}
							else
							{
								GenVars.gold = 169;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
					}
					if (drunkWorldGen)
					{
						for (int num886 = 0; num886 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num886++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
						for (int num887 = 0; num887 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num887++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
					if (crimson)
					{
						for (int num888 = 0; num888 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 4.25E-05); num888++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
					}
					else
					{
						for (int num889 = 0; num889 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 4.25E-05); num889++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.worldSurface, (int)Main.rockLayer), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
				}
				else
				{
					for (int num890 = 0; num890 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 6E-05); num890++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 6), genRand.Next(2, 6), GenVars.copper);
					}
					for (int num891 = 0; num891 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num891++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 7), genRand.Next(3, 7), GenVars.copper);
					}
					for (int num892 = 0; num892 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num892++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.copper = 7;
							}
							else
							{
								GenVars.copper = 166;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.copper);
					}
					for (int num893 = 0; num893 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3E-05); num893++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurfaceHigh), genRand.Next(3, 7), genRand.Next(2, 5), GenVars.iron);
					}
					for (int num894 = 0; num894 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 8E-05); num894++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.iron);
					}
					for (int num895 = 0; num895 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0002); num895++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.iron = 6;
							}
							else
							{
								GenVars.iron = 167;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.iron);
					}
					for (int num896 = 0; num896 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.6E-05); num896++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.worldSurfaceHigh, (int)GenVars.rockLayerHigh), genRand.Next(3, 6), genRand.Next(3, 6), GenVars.silver);
					}
					for (int num897 = 0; num897 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00015); num897++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
					}
					for (int num898 = 0; num898 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00017); num898++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.silver = 9;
							}
							else
							{
								GenVars.silver = 168;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow), genRand.Next(4, 9), genRand.Next(4, 8), GenVars.silver);
					}
					for (int num899 = 0; num899 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num899++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.gold = 8;
							}
							else
							{
								GenVars.gold = 169;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
					}
					for (int num900 = 0; num900 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.00012); num900++)
					{
						if (drunkWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								GenVars.gold = 8;
							}
							else
							{
								GenVars.gold = 169;
							}
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(0, (int)GenVars.worldSurfaceLow - 20), genRand.Next(4, 8), genRand.Next(4, 8), GenVars.gold);
					}
					if (drunkWorldGen)
					{
						for (int num901 = 0; num901 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num901++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
						for (int num902 = 0; num902 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); num902++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
					if (crimson)
					{
						for (int num903 = 0; num903 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num903++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 204);
						}
					}
					else
					{
						for (int num904 = 0; num904 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 2.25E-05); num904++)
						{
							TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next((int)Main.rockLayer, Main.maxTilesY), genRand.Next(3, 6), genRand.Next(4, 8), 22);
						}
					}
				}
			});
			AddGenerationPass("Webs", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[17].Value;
				for (int num871 = 0; num871 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0006); num871++)
				{
					int num872 = genRand.Next(20, Main.maxTilesX - 20);
					int num873 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY - 20);
					if (num871 < GenVars.numMCaves)
					{
						num872 = GenVars.mCaveX[num871];
						num873 = GenVars.mCaveY[num871];
					}
					if (!Main.tile[num872, num873].active() && ((double)num873 > Main.worldSurface || Main.tile[num872, num873].wall > 0))
					{
						while (!Main.tile[num872, num873].active() && num873 > (int)GenVars.worldSurfaceLow)
						{
							num873--;
						}
						num873++;
						int num874 = 1;
						if (genRand.Next(2) == 0)
						{
							num874 = -1;
						}
						for (; !Main.tile[num872, num873].active() && num872 > 10 && num872 < Main.maxTilesX - 10; num872 += num874)
						{
						}
						num872 -= num874;
						if ((double)num873 > Main.worldSurface || Main.tile[num872, num873].wall > 0)
						{
							TileRunner(num872, num873, genRand.Next(4, 11), genRand.Next(2, 4), 51, addTile: true, num874, -1.0, noYChange: false, overRide: false);
						}
					}
				}
			});
			AddGenerationPass("Underworld", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[18].Value;
				progress.Set(0.0);
				int num835 = Main.maxTilesY - genRand.Next(150, 190);
				for (int num836 = 0; num836 < Main.maxTilesX; num836++)
				{
					num835 += genRand.Next(-3, 4);
					if (num835 < Main.maxTilesY - 190)
					{
						num835 = Main.maxTilesY - 190;
					}
					if (num835 > Main.maxTilesY - 160)
					{
						num835 = Main.maxTilesY - 160;
					}
					for (int num837 = num835 - 20 - genRand.Next(3); num837 < Main.maxTilesY; num837++)
					{
						if (num837 >= num835)
						{
							Main.tile[num836, num837].active(active: false);
							Main.tile[num836, num837].lava(lava: false);
							Main.tile[num836, num837].liquid = 0;
						}
						else
						{
							Main.tile[num836, num837].type = 57;
						}
					}
				}
				int num838 = Main.maxTilesY - genRand.Next(40, 70);
				for (int num839 = 10; num839 < Main.maxTilesX - 10; num839++)
				{
					num838 += genRand.Next(-10, 11);
					if (num838 > Main.maxTilesY - 60)
					{
						num838 = Main.maxTilesY - 60;
					}
					if (num838 < Main.maxTilesY - 100)
					{
						num838 = Main.maxTilesY - 120;
					}
					for (int num840 = num838; num840 < Main.maxTilesY - 10; num840++)
					{
						if (!Main.tile[num839, num840].active())
						{
							Main.tile[num839, num840].lava(lava: true);
							Main.tile[num839, num840].liquid = byte.MaxValue;
						}
					}
				}
				for (int num841 = 0; num841 < Main.maxTilesX; num841++)
				{
					if (genRand.Next(50) == 0)
					{
						int num842 = Main.maxTilesY - 65;
						while (!Main.tile[num841, num842].active() && num842 > Main.maxTilesY - 135)
						{
							num842--;
						}
						TileRunner(genRand.Next(0, Main.maxTilesX), num842 + genRand.Next(20, 50), genRand.Next(15, 20), 1000, 57, addTile: true, 0.0, genRand.Next(1, 3), noYChange: true);
					}
				}
				Liquid.QuickWater(-2);
				for (int num843 = 0; num843 < Main.maxTilesX; num843++)
				{
					double num844 = (double)num843 / (double)(Main.maxTilesX - 1);
					progress.Set(num844 / 2.0 + 0.5);
					if (genRand.Next(13) == 0)
					{
						int num845 = Main.maxTilesY - 65;
						while ((Main.tile[num843, num845].liquid > 0 || Main.tile[num843, num845].active()) && num845 > Main.maxTilesY - 140)
						{
							num845--;
						}
						if ((!drunkWorldGen && !remixWorldGen) || genRand.Next(3) == 0 || !((double)num843 > (double)Main.maxTilesX * 0.4) || !((double)num843 < (double)Main.maxTilesX * 0.6))
						{
							TileRunner(num843, num845 - genRand.Next(2, 5), genRand.Next(5, 30), 1000, 57, addTile: true, 0.0, genRand.Next(1, 3), noYChange: true);
						}
						double num846 = genRand.Next(1, 3);
						if (genRand.Next(3) == 0)
						{
							num846 *= 0.5;
						}
						if ((!drunkWorldGen && !remixWorldGen) || genRand.Next(3) == 0 || !((double)num843 > (double)Main.maxTilesX * 0.4) || !((double)num843 < (double)Main.maxTilesX * 0.6))
						{
							if (genRand.Next(2) == 0)
							{
								TileRunner(num843, num845 - genRand.Next(2, 5), (int)((double)genRand.Next(5, 15) * num846), (int)((double)genRand.Next(10, 15) * num846), 57, addTile: true, 1.0, 0.3);
							}
							if (genRand.Next(2) == 0)
							{
								num846 = genRand.Next(1, 3);
								TileRunner(num843, num845 - genRand.Next(2, 5), (int)((double)genRand.Next(5, 15) * num846), (int)((double)genRand.Next(10, 15) * num846), 57, addTile: true, -1.0, 0.3);
							}
						}
						TileRunner(num843 + genRand.Next(-10, 10), num845 + genRand.Next(-10, 10), genRand.Next(5, 15), genRand.Next(5, 10), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						if (genRand.Next(3) == 0)
						{
							TileRunner(num843 + genRand.Next(-10, 10), num845 + genRand.Next(-10, 10), genRand.Next(10, 30), genRand.Next(10, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						}
						if (genRand.Next(5) == 0)
						{
							TileRunner(num843 + genRand.Next(-15, 15), num845 + genRand.Next(-15, 10), genRand.Next(15, 30), genRand.Next(5, 20), -2, addTile: false, genRand.Next(-1, 3), genRand.Next(-1, 3));
						}
					}
				}
				for (int num847 = 0; num847 < Main.maxTilesX; num847++)
				{
					TileRunner(genRand.Next(20, Main.maxTilesX - 20), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(2, 7), genRand.Next(2, 7), -2);
				}
				if (drunkWorldGen || remixWorldGen)
				{
					for (int num848 = 0; num848 < Main.maxTilesX * 2; num848++)
					{
						TileRunner(genRand.Next((int)((double)Main.maxTilesX * 0.35), (int)((double)Main.maxTilesX * 0.65)), genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), genRand.Next(5, 20), genRand.Next(5, 10), -2);
					}
				}
				for (int num849 = 0; num849 < Main.maxTilesX; num849++)
				{
					if (!Main.tile[num849, Main.maxTilesY - 145].active())
					{
						Main.tile[num849, Main.maxTilesY - 145].liquid = byte.MaxValue;
						Main.tile[num849, Main.maxTilesY - 145].lava(lava: true);
					}
					if (!Main.tile[num849, Main.maxTilesY - 144].active())
					{
						Main.tile[num849, Main.maxTilesY - 144].liquid = byte.MaxValue;
						Main.tile[num849, Main.maxTilesY - 144].lava(lava: true);
					}
				}
				for (int num850 = 0; num850 < (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0008); num850++)
				{
					TileRunner(genRand.Next(0, Main.maxTilesX), genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), genRand.Next(2, 7), genRand.Next(3, 7), 58);
				}
				if (remixWorldGen)
				{
					int num851 = (int)((double)Main.maxTilesX * 0.38);
					int num852 = (int)((double)Main.maxTilesX * 0.62);
					int num853 = num851;
					int num854 = Main.maxTilesY - 1;
					int num855 = Main.maxTilesY - 135;
					int num856 = Main.maxTilesY - 160;
					bool flag54 = false;
					Liquid.QuickWater(-2);
					for (; num854 < Main.maxTilesY - 1 || num853 < num852; num853++)
					{
						if (!flag54)
						{
							num854 -= genRand.Next(1, 4);
							if (num854 < num855)
							{
								flag54 = true;
							}
						}
						else if (num853 >= num852)
						{
							num854 += genRand.Next(1, 4);
							if (num854 > Main.maxTilesY - 1)
							{
								num854 = Main.maxTilesY - 1;
							}
						}
						else
						{
							if ((num853 <= Main.maxTilesX / 2 - 5 || num853 >= Main.maxTilesX / 2 + 5) && genRand.Next(4) == 0)
							{
								if (genRand.Next(3) == 0)
								{
									num854 += genRand.Next(-1, 2);
								}
								else if (genRand.Next(6) == 0)
								{
									num854 += genRand.Next(-2, 3);
								}
								else if (genRand.Next(8) == 0)
								{
									num854 += genRand.Next(-4, 5);
								}
							}
							if (num854 < num856)
							{
								num854 = num856;
							}
							if (num854 > num855)
							{
								num854 = num855;
							}
						}
						for (int num857 = num854; num857 > num854 - 20; num857--)
						{
							Main.tile[num853, num857].liquid = 0;
						}
						for (int num858 = num854; num858 < Main.maxTilesY; num858++)
						{
							Main.tile[num853, num858] = new Tile();
							Main.tile[num853, num858].active(active: true);
							Main.tile[num853, num858].type = 57;
						}
					}
					Liquid.QuickWater(-2);
					for (int num859 = num851; num859 < num852 + 15; num859++)
					{
						for (int num860 = Main.maxTilesY - 300; num860 < num855 + 20; num860++)
						{
							Main.tile[num859, num860].liquid = 0;
							if (Main.tile[num859, num860].type == 57 && Main.tile[num859, num860].active() && (!Main.tile[num859 - 1, num860 - 1].active() || !Main.tile[num859, num860 - 1].active() || !Main.tile[num859 + 1, num860 - 1].active() || !Main.tile[num859 - 1, num860].active() || !Main.tile[num859 + 1, num860].active() || !Main.tile[num859 - 1, num860 + 1].active() || !Main.tile[num859, num860 + 1].active() || !Main.tile[num859 + 1, num860 + 1].active()))
							{
								Main.tile[num859, num860].type = 633;
							}
						}
					}
					for (int num861 = num851; num861 < num852 + 15; num861++)
					{
						for (int num862 = Main.maxTilesY - 200; num862 < num855 + 20; num862++)
						{
							if (Main.tile[num861, num862].type == 633 && Main.tile[num861, num862].active() && !Main.tile[num861, num862 - 1].active() && genRand.Next(3) == 0)
							{
								TryGrowingTreeByType(634, num861, num862);
							}
						}
					}
				}
				else if (!drunkWorldGen)
				{
					for (int num863 = 25; num863 < Main.maxTilesX - 25; num863++)
					{
						if ((double)num863 < (double)Main.maxTilesX * 0.17 || (double)num863 > (double)Main.maxTilesX * 0.83)
						{
							for (int num864 = Main.maxTilesY - 300; num864 < Main.maxTilesY - 100 + genRand.Next(-1, 2); num864++)
							{
								if (Main.tile[num863, num864].type == 57 && Main.tile[num863, num864].active() && (!Main.tile[num863 - 1, num864 - 1].active() || !Main.tile[num863, num864 - 1].active() || !Main.tile[num863 + 1, num864 - 1].active() || !Main.tile[num863 - 1, num864].active() || !Main.tile[num863 + 1, num864].active() || !Main.tile[num863 - 1, num864 + 1].active() || !Main.tile[num863, num864 + 1].active() || !Main.tile[num863 + 1, num864 + 1].active()))
								{
									Main.tile[num863, num864].type = 633;
								}
							}
						}
					}
					for (int num865 = 25; num865 < Main.maxTilesX - 25; num865++)
					{
						if ((double)num865 < (double)Main.maxTilesX * 0.17 || (double)num865 > (double)Main.maxTilesX * 0.83)
						{
							for (int num866 = Main.maxTilesY - 200; num866 < Main.maxTilesY - 50; num866++)
							{
								if (Main.tile[num865, num866].type == 633 && Main.tile[num865, num866].active() && !Main.tile[num865, num866 - 1].active() && genRand.Next(3) == 0)
								{
									TryGrowingTreeByType(634, num865, num866);
								}
							}
						}
					}
				}
				AddHellHouses();
				if (drunkWorldGen)
				{
					for (int num867 = 25; num867 < Main.maxTilesX - 25; num867++)
					{
						for (int num868 = Main.maxTilesY - 300; num868 < Main.maxTilesY - 100 + genRand.Next(-1, 2); num868++)
						{
							if (Main.tile[num867, num868].type == 57 && Main.tile[num867, num868].active() && (!Main.tile[num867 - 1, num868 - 1].active() || !Main.tile[num867, num868 - 1].active() || !Main.tile[num867 + 1, num868 - 1].active() || !Main.tile[num867 - 1, num868].active() || !Main.tile[num867 + 1, num868].active() || !Main.tile[num867 - 1, num868 + 1].active() || !Main.tile[num867, num868 + 1].active() || !Main.tile[num867 + 1, num868 + 1].active()))
							{
								Main.tile[num867, num868].type = 633;
							}
						}
					}
					for (int num869 = 25; num869 < Main.maxTilesX - 25; num869++)
					{
						for (int num870 = Main.maxTilesY - 200; num870 < Main.maxTilesY - 50; num870++)
						{
							if (Main.tile[num869, num870].type == 633 && Main.tile[num869, num870].active() && !Main.tile[num869, num870 - 1].active() && genRand.Next(3) == 0)
							{
								TryGrowingTreeByType(634, num869, num870);
							}
						}
					}
				}
			});
			AddGenerationPass("Corruption", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				int num775 = Main.maxTilesX;
				int num776 = 0;
				int num777 = Main.maxTilesX;
				int num778 = 0;
				for (int num779 = 0; num779 < Main.maxTilesX; num779++)
				{
					for (int num780 = 0; (double)num780 < Main.worldSurface; num780++)
					{
						if (Main.tile[num779, num780].active())
						{
							if (Main.tile[num779, num780].type == 60)
							{
								if (num779 < num775)
								{
									num775 = num779;
								}
								if (num779 > num776)
								{
									num776 = num779;
								}
							}
							else if (Main.tile[num779, num780].type == 147 || Main.tile[num779, num780].type == 161)
							{
								if (num779 < num777)
								{
									num777 = num779;
								}
								if (num779 > num778)
								{
									num778 = num779;
								}
							}
						}
					}
				}
				int num781 = 10;
				num775 -= num781;
				num776 += num781;
				num777 -= num781;
				num778 += num781;
				int num782 = 500;
				int num783 = 100;
				bool flag48 = crimson;
				double num784 = (double)Main.maxTilesX * 0.00045;
				if (remixWorldGen)
				{
					num784 *= 2.0;
				}
				else if (tenthAnniversaryWorldGen)
				{
					num782 *= 2;
					num783 *= 2;
				}
				if (drunkWorldGen)
				{
					flag48 = true;
					num784 /= 2.0;
				}
				if (flag48)
				{
					progress.Message = Lang.gen[72].Value;
					for (int num785 = 0; (double)num785 < num784; num785++)
					{
						int num786 = num777;
						int num787 = num778;
						int num788 = num775;
						int num789 = num776;
						double value15 = (double)num785 / num784;
						progress.Set(value15);
						bool flag49 = false;
						int num790 = 0;
						int num791 = 0;
						int num792 = 0;
						while (!flag49)
						{
							flag49 = true;
							int num793 = Main.maxTilesX / 2;
							int num794 = 200;
							if (drunkWorldGen)
							{
								num794 = 100;
								num790 = ((!GenVars.crimsonLeft) ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num782) : genRand.Next(num782, (int)((double)Main.maxTilesX * 0.5)));
							}
							else
							{
								num790 = genRand.Next(num782, Main.maxTilesX - num782);
							}
							num791 = num790 - genRand.Next(200) - 100;
							num792 = num790 + genRand.Next(200) + 100;
							if (num791 < GenVars.evilBiomeBeachAvoidance)
							{
								num791 = GenVars.evilBiomeBeachAvoidance;
							}
							if (num792 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
							{
								num792 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
							}
							if (num790 < num791 + GenVars.evilBiomeAvoidanceMidFixer)
							{
								num790 = num791 + GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (num790 > num792 - GenVars.evilBiomeAvoidanceMidFixer)
							{
								num790 = num792 - GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (GenVars.dungeonSide < 0 && num791 < 400)
							{
								num791 = 400;
							}
							else if (GenVars.dungeonSide > 0 && num791 > Main.maxTilesX - 400)
							{
								num791 = Main.maxTilesX - 400;
							}
							if (num791 < GenVars.dungeonLocation + num783 && num792 > GenVars.dungeonLocation - num783)
							{
								flag49 = false;
							}
							if (!remixWorldGen)
							{
								if (!tenthAnniversaryWorldGen)
								{
									if (num790 > num793 - num794 && num790 < num793 + num794)
									{
										flag49 = false;
									}
									if (num791 > num793 - num794 && num791 < num793 + num794)
									{
										flag49 = false;
									}
									if (num792 > num793 - num794 && num792 < num793 + num794)
									{
										flag49 = false;
									}
								}
								if (num790 > GenVars.UndergroundDesertLocation.X && num790 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag49 = false;
								}
								if (num791 > GenVars.UndergroundDesertLocation.X && num791 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag49 = false;
								}
								if (num792 > GenVars.UndergroundDesertLocation.X && num792 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag49 = false;
								}
								if (num791 < num787 && num792 > num786)
								{
									num786++;
									num787--;
									flag49 = false;
								}
								if (num791 < num789 && num792 > num788)
								{
									num788++;
									num789--;
									flag49 = false;
								}
							}
						}
						CrimStart(num790, (int)GenVars.worldSurfaceLow - 10);
						for (int num795 = num791; num795 < num792; num795++)
						{
							for (int num796 = (int)GenVars.worldSurfaceLow; (double)num796 < Main.worldSurface - 1.0; num796++)
							{
								if (Main.tile[num795, num796].active())
								{
									int num797 = num796 + genRand.Next(10, 14);
									for (int num798 = num796; num798 < num797; num798++)
									{
										if (Main.tile[num795, num798].type == 60 && num795 >= num791 + genRand.Next(5) && num795 < num792 - genRand.Next(5))
										{
											Main.tile[num795, num798].type = 662;
										}
									}
									break;
								}
							}
						}
						double num799 = Main.worldSurface + 40.0;
						for (int num800 = num791; num800 < num792; num800++)
						{
							num799 += (double)genRand.Next(-2, 3);
							if (num799 < Main.worldSurface + 30.0)
							{
								num799 = Main.worldSurface + 30.0;
							}
							if (num799 > Main.worldSurface + 50.0)
							{
								num799 = Main.worldSurface + 50.0;
							}
							bool flag50 = false;
							for (int num801 = (int)GenVars.worldSurfaceLow; (double)num801 < num799; num801++)
							{
								if (Main.tile[num800, num801].active())
								{
									if (Main.tile[num800, num801].type == 53 && num800 >= num791 + genRand.Next(5) && num800 <= num792 - genRand.Next(5))
									{
										Main.tile[num800, num801].type = 234;
									}
									if ((double)num801 < Main.worldSurface - 1.0 && !flag50)
									{
										if (Main.tile[num800, num801].type == 0)
										{
											grassSpread = 0;
											SpreadGrass(num800, num801, 0, 199);
										}
										else if (Main.tile[num800, num801].type == 59)
										{
											grassSpread = 0;
											SpreadGrass(num800, num801, 59, 662);
										}
									}
									flag50 = true;
									if (Main.tile[num800, num801].wall == 216)
									{
										Main.tile[num800, num801].wall = 218;
									}
									else if (Main.tile[num800, num801].wall == 187)
									{
										Main.tile[num800, num801].wall = 221;
									}
									if (Main.tile[num800, num801].type == 1)
									{
										if (num800 >= num791 + genRand.Next(5) && num800 <= num792 - genRand.Next(5))
										{
											Main.tile[num800, num801].type = 203;
										}
									}
									else if (Main.tile[num800, num801].type == 2)
									{
										Main.tile[num800, num801].type = 199;
									}
									else if (Main.tile[num800, num801].type == 60)
									{
										Main.tile[num800, num801].type = 662;
									}
									else if (Main.tile[num800, num801].type == 161)
									{
										Main.tile[num800, num801].type = 200;
									}
									else if (Main.tile[num800, num801].type == 396)
									{
										Main.tile[num800, num801].type = 401;
									}
									else if (Main.tile[num800, num801].type == 397)
									{
										Main.tile[num800, num801].type = 399;
									}
								}
							}
						}
						int num802 = genRand.Next(10, 15);
						for (int num803 = 0; num803 < num802; num803++)
						{
							int num804 = 0;
							bool flag51 = false;
							int num805 = 0;
							while (!flag51)
							{
								num804++;
								int num806 = genRand.Next(num791 - num805, num792 + num805);
								int num807 = genRand.Next((int)(Main.worldSurface - (double)(num805 / 2)), (int)(Main.worldSurface + 100.0 + (double)num805));
								while (oceanDepths(num806, num807))
								{
									num806 = genRand.Next(num791 - num805, num792 + num805);
									num807 = genRand.Next((int)(Main.worldSurface - (double)(num805 / 2)), (int)(Main.worldSurface + 100.0 + (double)num805));
								}
								if (num804 > 100)
								{
									num805++;
									num804 = 0;
								}
								if (!Main.tile[num806, num807].active())
								{
									for (; !Main.tile[num806, num807].active(); num807++)
									{
									}
									num807--;
								}
								else
								{
									while (Main.tile[num806, num807].active() && (double)num807 > Main.worldSurface)
									{
										num807--;
									}
								}
								if ((num805 > 10 || (Main.tile[num806, num807 + 1].active() && Main.tile[num806, num807 + 1].type == 203)) && !IsTileNearby(num806, num807, 26, 3))
								{
									Place3x2(num806, num807, 26, 1);
									if (Main.tile[num806, num807].type == 26)
									{
										flag51 = true;
									}
								}
								if (num805 > 100)
								{
									flag51 = true;
								}
							}
						}
					}
					CrimPlaceHearts();
				}
				if (drunkWorldGen)
				{
					flag48 = false;
				}
				if (!flag48)
				{
					progress.Message = Lang.gen[20].Value;
					for (int num808 = 0; (double)num808 < num784; num808++)
					{
						int num809 = num777;
						int num810 = num778;
						int num811 = num775;
						int num812 = num776;
						double value16 = (double)num808 / num784;
						progress.Set(value16);
						bool flag52 = false;
						int num813 = 0;
						int num814 = 0;
						int num815 = 0;
						while (!flag52)
						{
							flag52 = true;
							int num816 = Main.maxTilesX / 2;
							int num817 = 200;
							num813 = ((!drunkWorldGen) ? genRand.Next(num782, Main.maxTilesX - num782) : (GenVars.crimsonLeft ? genRand.Next((int)((double)Main.maxTilesX * 0.5), Main.maxTilesX - num782) : genRand.Next(num782, (int)((double)Main.maxTilesX * 0.5))));
							num814 = num813 - genRand.Next(200) - 100;
							num815 = num813 + genRand.Next(200) + 100;
							if (num814 < GenVars.evilBiomeBeachAvoidance)
							{
								num814 = GenVars.evilBiomeBeachAvoidance;
							}
							if (num815 > Main.maxTilesX - GenVars.evilBiomeBeachAvoidance)
							{
								num815 = Main.maxTilesX - GenVars.evilBiomeBeachAvoidance;
							}
							if (num813 < num814 + GenVars.evilBiomeAvoidanceMidFixer)
							{
								num813 = num814 + GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (num813 > num815 - GenVars.evilBiomeAvoidanceMidFixer)
							{
								num813 = num815 - GenVars.evilBiomeAvoidanceMidFixer;
							}
							if (num814 < GenVars.dungeonLocation + num783 && num815 > GenVars.dungeonLocation - num783)
							{
								flag52 = false;
							}
							if (!remixWorldGen)
							{
								if (!tenthAnniversaryWorldGen)
								{
									if (num813 > num816 - num817 && num813 < num816 + num817)
									{
										flag52 = false;
									}
									if (num814 > num816 - num817 && num814 < num816 + num817)
									{
										flag52 = false;
									}
									if (num815 > num816 - num817 && num815 < num816 + num817)
									{
										flag52 = false;
									}
								}
								if (num813 > GenVars.UndergroundDesertLocation.X && num813 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag52 = false;
								}
								if (num814 > GenVars.UndergroundDesertLocation.X && num814 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag52 = false;
								}
								if (num815 > GenVars.UndergroundDesertLocation.X && num815 < GenVars.UndergroundDesertLocation.X + GenVars.UndergroundDesertLocation.Width)
								{
									flag52 = false;
								}
								if (num814 < num810 && num815 > num809)
								{
									num809++;
									num810--;
									flag52 = false;
								}
								if (num814 < num812 && num815 > num811)
								{
									num811++;
									num812--;
									flag52 = false;
								}
							}
						}
						int num818 = 0;
						for (int num819 = num814; num819 < num815; num819++)
						{
							if (num818 > 0)
							{
								num818--;
							}
							if (num819 == num813 || num818 == 0)
							{
								for (int num820 = (int)GenVars.worldSurfaceLow; (double)num820 < Main.worldSurface - 1.0; num820++)
								{
									if (Main.tile[num819, num820].active() || Main.tile[num819, num820].wall > 0)
									{
										if (num819 == num813)
										{
											num818 = 20;
											ChasmRunner(num819, num820, genRand.Next(150) + 150, makeOrb: true);
										}
										else if (genRand.Next(35) == 0 && num818 == 0)
										{
											num818 = 30;
											bool makeOrb = true;
											ChasmRunner(num819, num820, genRand.Next(50) + 50, makeOrb);
										}
										break;
									}
								}
							}
							for (int num821 = (int)GenVars.worldSurfaceLow; (double)num821 < Main.worldSurface - 1.0; num821++)
							{
								if (Main.tile[num819, num821].active())
								{
									int num822 = num821 + genRand.Next(10, 14);
									for (int num823 = num821; num823 < num822; num823++)
									{
										if (Main.tile[num819, num823].type == 60 && num819 >= num814 + genRand.Next(5) && num819 < num815 - genRand.Next(5))
										{
											Main.tile[num819, num823].type = 661;
										}
									}
									break;
								}
							}
						}
						double num824 = Main.worldSurface + 40.0;
						for (int num825 = num814; num825 < num815; num825++)
						{
							num824 += (double)genRand.Next(-2, 3);
							if (num824 < Main.worldSurface + 30.0)
							{
								num824 = Main.worldSurface + 30.0;
							}
							if (num824 > Main.worldSurface + 50.0)
							{
								num824 = Main.worldSurface + 50.0;
							}
							bool flag53 = false;
							for (int num826 = (int)GenVars.worldSurfaceLow; (double)num826 < num824; num826++)
							{
								if (Main.tile[num825, num826].active())
								{
									if (Main.tile[num825, num826].type == 53 && num825 >= num814 + genRand.Next(5) && num825 <= num815 - genRand.Next(5))
									{
										Main.tile[num825, num826].type = 112;
									}
									if ((double)num826 < Main.worldSurface - 1.0 && !flag53)
									{
										if (Main.tile[num825, num826].type == 0)
										{
											grassSpread = 0;
											SpreadGrass(num825, num826, 0, 23);
										}
										else if (Main.tile[num825, num826].type == 59)
										{
											grassSpread = 0;
											SpreadGrass(num825, num826, 59, 661);
										}
									}
									flag53 = true;
									if (Main.tile[num825, num826].wall == 216)
									{
										Main.tile[num825, num826].wall = 217;
									}
									else if (Main.tile[num825, num826].wall == 187)
									{
										Main.tile[num825, num826].wall = 220;
									}
									if (Main.tile[num825, num826].type == 1)
									{
										if (num825 >= num814 + genRand.Next(5) && num825 <= num815 - genRand.Next(5))
										{
											Main.tile[num825, num826].type = 25;
										}
									}
									else if (Main.tile[num825, num826].type == 2)
									{
										Main.tile[num825, num826].type = 23;
									}
									else if (Main.tile[num825, num826].type == 60)
									{
										Main.tile[num825, num826].type = 661;
									}
									else if (Main.tile[num825, num826].type == 161)
									{
										Main.tile[num825, num826].type = 163;
									}
									else if (Main.tile[num825, num826].type == 396)
									{
										Main.tile[num825, num826].type = 400;
									}
									else if (Main.tile[num825, num826].type == 397)
									{
										Main.tile[num825, num826].type = 398;
									}
								}
							}
						}
						for (int num827 = num814; num827 < num815; num827++)
						{
							for (int num828 = 0; num828 < Main.maxTilesY - 50; num828++)
							{
								if (Main.tile[num827, num828].active() && Main.tile[num827, num828].type == 31)
								{
									int num829 = num827 - 13;
									int num830 = num827 + 13;
									int num831 = num828 - 13;
									int num832 = num828 + 13;
									for (int num833 = num829; num833 < num830; num833++)
									{
										if (num833 > 10 && num833 < Main.maxTilesX - 10)
										{
											for (int num834 = num831; num834 < num832; num834++)
											{
												if (Math.Abs(num833 - num827) + Math.Abs(num834 - num828) < 9 + genRand.Next(11) && genRand.Next(3) != 0 && Main.tile[num833, num834].type != 31)
												{
													Main.tile[num833, num834].active(active: true);
													Main.tile[num833, num834].type = 25;
													if (Math.Abs(num833 - num827) <= 1 && Math.Abs(num834 - num828) <= 1)
													{
														Main.tile[num833, num834].active(active: false);
													}
												}
												if (Main.tile[num833, num834].type != 31 && Math.Abs(num833 - num827) <= 2 + genRand.Next(3) && Math.Abs(num834 - num828) <= 2 + genRand.Next(3))
												{
													Main.tile[num833, num834].active(active: false);
												}
											}
										}
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Lakes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[19].Value;
				double num756 = (double)Main.maxTilesX / 4200.0;
				int num757 = genRand.Next((int)(num756 * 3.0), (int)(num756 * 6.0));
				for (int num758 = 0; num758 < num757; num758++)
				{
					int num759 = Main.maxTilesX / 4;
					if (GenVars.numLakes >= GenVars.maxLakes - 1)
					{
						break;
					}
					double value14 = (double)num758 / (double)num757;
					progress.Set(value14);
					while (num759 > 0)
					{
						bool flag47 = false;
						num759--;
						int num760 = genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
						if (tenthAnniversaryWorldGen && !remixWorldGen)
						{
							num760 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
						}
						else
						{
							while ((double)num760 > (double)Main.maxTilesX * 0.45 && (double)num760 < (double)Main.maxTilesX * 0.55)
							{
								num760 = genRand.Next(GenVars.lakesBeachAvoidance, Main.maxTilesX - GenVars.lakesBeachAvoidance);
							}
						}
						for (int num761 = 0; num761 < GenVars.numLakes; num761++)
						{
							if (Math.Abs(num760 - GenVars.LakeX[num761]) < 150)
							{
								flag47 = true;
								break;
							}
						}
						for (int num762 = 0; num762 < GenVars.numMCaves; num762++)
						{
							if (Math.Abs(num760 - GenVars.mCaveX[num762]) < 100)
							{
								flag47 = true;
								break;
							}
						}
						for (int num763 = 0; num763 < GenVars.numTunnels; num763++)
						{
							if (Math.Abs(num760 - GenVars.tunnelX[num763]) < 100)
							{
								flag47 = true;
								break;
							}
						}
						if (!flag47)
						{
							int num764 = (int)GenVars.worldSurfaceLow - 20;
							while (!Main.tile[num760, num764].active())
							{
								num764++;
								if ((double)num764 >= Main.worldSurface || Main.tile[num760, num764].wall > 0)
								{
									flag47 = true;
									break;
								}
							}
							if (Main.tile[num760, num764].type == 53)
							{
								flag47 = true;
							}
							if (!flag47)
							{
								int num765 = 50;
								for (int num766 = num760 - num765; num766 <= num760 + num765; num766++)
								{
									for (int num767 = num764 - num765; num767 <= num764 + num765; num767++)
									{
										if (Main.tile[num766, num767].type == 203 || Main.tile[num766, num767].type == 25)
										{
											flag47 = true;
											break;
										}
									}
								}
								if (!flag47)
								{
									int num768 = num764;
									num765 = 20;
									while (!SolidTile(num760 - num765, num764) || !SolidTile(num760 + num765, num764))
									{
										num764++;
										if ((double)num764 > Main.worldSurface - 50.0)
										{
											flag47 = true;
										}
									}
									if (num764 - num768 <= 10)
									{
										num765 = 60;
										for (int num769 = num760 - num765; num769 <= num760 + num765; num769++)
										{
											int num770 = num764 - 20;
											if (Main.tile[num769, num770].active() || Main.tile[num769, num770].wall > 0)
											{
												flag47 = true;
											}
										}
										if (!flag47)
										{
											int num771 = 0;
											for (int num772 = num760 - num765; num772 <= num760 + num765; num772++)
											{
												for (int num773 = num764; num773 <= num764 + num765 * 2; num773++)
												{
													if (SolidTile(num772, num773))
													{
														num771++;
													}
												}
											}
											int num774 = (num765 * 2 + 1) * (num765 * 2 + 1);
											if (!((double)num771 < (double)num774 * 0.8) && !GenVars.UndergroundDesertLocation.Intersects(new Rectangle(num760 - 8, num764 - 8, 16, 16)))
											{
												SonOfLakinater(num760, num764);
												GenVars.LakeX[GenVars.numLakes] = num760;
												GenVars.numLakes++;
												break;
											}
										}
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Dungeon", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				int dungeonLocation = GenVars.dungeonLocation;
				int num752 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + genRand.Next(-200, 200);
				int num753 = (int)((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
				int num754 = num752;
				bool flag46 = false;
				for (int num755 = 0; num755 < 10; num755++)
				{
					if (SolidTile(dungeonLocation, num754 + num755))
					{
						flag46 = true;
						break;
					}
				}
				if (!flag46)
				{
					for (; num754 < num753 && !SolidTile(dungeonLocation, num754 + 10); num754++)
					{
					}
				}
				if (drunkWorldGen)
				{
					num754 = (int)Main.worldSurface + 70;
				}
				MakeDungeon(dungeonLocation, num754);
			});
			AddGenerationPass("Slush", delegate
			{
				for (int num747 = GenVars.snowTop; num747 < GenVars.snowBottom; num747++)
				{
					for (int num748 = GenVars.snowMinX[num747]; num748 < GenVars.snowMaxX[num747]; num748++)
					{
						switch (Main.tile[num748, num747].type)
						{
						case 123:
							Main.tile[num748, num747].type = 224;
							break;
						case 59:
						{
							bool flag45 = true;
							int num749 = 3;
							for (int num750 = num748 - num749; num750 <= num748 + num749; num750++)
							{
								for (int num751 = num747 - num749; num751 <= num747 + num749; num751++)
								{
									if (Main.tile[num750, num751].type == 60 || Main.tile[num750, num751].type == 70 || Main.tile[num750, num751].type == 71 || Main.tile[num750, num751].type == 72)
									{
										flag45 = false;
										break;
									}
								}
							}
							if (flag45)
							{
								Main.tile[num748, num747].type = 224;
							}
							break;
						}
						case 1:
							Main.tile[num748, num747].type = 161;
							break;
						}
					}
				}
			});
			AddGenerationPass("Mountain Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[21].Value;
				for (int num746 = 0; num746 < GenVars.numMCaves; num746++)
				{
					int i3 = GenVars.mCaveX[num746];
					int j5 = GenVars.mCaveY[num746];
					CaveOpenater(i3, j5);
					Cavinator(i3, j5, genRand.Next(40, 50));
				}
			});
			AddGenerationPass("Beaches", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				int num728 = 50;
				progress.Message = Lang.gen[22].Value;
				bool floridaStyle = false;
				bool floridaStyle2 = false;
				if (genRand.Next(4) == 0)
				{
					if (genRand.Next(2) == 0)
					{
						floridaStyle = true;
					}
					else
					{
						floridaStyle2 = true;
					}
				}
				for (int num729 = 0; num729 < 2; num729++)
				{
					int num730 = 0;
					int num731 = 0;
					if (num729 == 0)
					{
						num730 = 0;
						num731 = genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
						if (GenVars.dungeonSide == 1)
						{
							num731 = GenVars.oceanWaterForcedJungleLength;
						}
						int num732 = GenVars.leftBeachEnd - num728;
						if (num731 > num732)
						{
							num731 = num732;
						}
						int num733 = 0;
						double num734 = 1.0;
						int num735;
						for (num735 = 0; !Main.tile[num731 - 1, num735].active(); num735++)
						{
						}
						GenVars.shellStartYLeft = num735;
						num735 += genRand.Next(1, 5);
						for (int num736 = num731 - 1; num736 >= num730; num736--)
						{
							if (num736 > 30)
							{
								num733++;
								num734 = TuneOceanDepth(num733, num734, floridaStyle);
							}
							else
							{
								num734 += 1.0;
							}
							int num737 = genRand.Next(15, 20);
							for (int num738 = 0; (double)num738 < (double)num735 + num734 + (double)num737; num738++)
							{
								if ((double)num738 < (double)num735 + num734 * 0.75 - 3.0)
								{
									Main.tile[num736, num738].active(active: false);
									if (num738 > num735)
									{
										Main.tile[num736, num738].liquid = byte.MaxValue;
										Main.tile[num736, num738].lava(lava: false);
									}
									else if (num738 == num735)
									{
										Main.tile[num736, num738].liquid = 127;
										if (GenVars.shellStartXLeft == 0)
										{
											GenVars.shellStartXLeft = num736;
										}
									}
								}
								else if (num738 > num735)
								{
									Main.tile[num736, num738].type = 53;
									Main.tile[num736, num738].active(active: true);
								}
								Main.tile[num736, num738].wall = 0;
							}
						}
					}
					else
					{
						num730 = Main.maxTilesX - genRand.Next(GenVars.oceanWaterStartRandomMin, GenVars.oceanWaterStartRandomMax);
						num731 = Main.maxTilesX;
						if (GenVars.dungeonSide == -1)
						{
							num730 = Main.maxTilesX - GenVars.oceanWaterForcedJungleLength;
						}
						int num739 = GenVars.rightBeachStart + num728;
						if (num730 < num739)
						{
							num730 = num739;
						}
						double num740 = 1.0;
						int num741 = 0;
						int num742;
						for (num742 = 0; !Main.tile[num730, num742].active(); num742++)
						{
						}
						GenVars.shellStartXRight = 0;
						GenVars.shellStartYRight = num742;
						num742 += genRand.Next(1, 5);
						for (int num743 = num730; num743 < num731; num743++)
						{
							if (num743 < num731 - 30)
							{
								num741++;
								num740 = TuneOceanDepth(num741, num740, floridaStyle2);
							}
							else
							{
								num740 += 1.0;
							}
							int num744 = genRand.Next(15, 20);
							for (int num745 = 0; (double)num745 < (double)num742 + num740 + (double)num744; num745++)
							{
								if ((double)num745 < (double)num742 + num740 * 0.75 - 3.0)
								{
									Main.tile[num743, num745].active(active: false);
									if (num745 > num742)
									{
										Main.tile[num743, num745].liquid = byte.MaxValue;
										Main.tile[num743, num745].lava(lava: false);
									}
									else if (num745 == num742)
									{
										Main.tile[num743, num745].liquid = 127;
										if (GenVars.shellStartXRight == 0)
										{
											GenVars.shellStartXRight = num743;
										}
									}
								}
								else if (num745 > num742)
								{
									Main.tile[num743, num745].type = 53;
									Main.tile[num743, num745].active(active: true);
								}
								Main.tile[num743, num745].wall = 0;
							}
						}
					}
				}
			});
			AddGenerationPass("Gems", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[23].Value;
				Main.tileSolid[484] = false;
				for (int num715 = 63; num715 <= 68; num715++)
				{
					double value13 = (double)(num715 - 63) / 6.0;
					progress.Set(value13);
					double num716 = 0.0;
					switch (num715)
					{
					case 67:
						num716 = (double)Main.maxTilesX * 0.5;
						break;
					case 66:
						num716 = (double)Main.maxTilesX * 0.45;
						break;
					case 63:
						num716 = (double)Main.maxTilesX * 0.3;
						break;
					case 65:
						num716 = (double)Main.maxTilesX * 0.25;
						break;
					case 64:
						num716 = (double)Main.maxTilesX * 0.1;
						break;
					case 68:
						num716 = (double)Main.maxTilesX * 0.05;
						break;
					}
					num716 *= 0.2;
					for (int num717 = 0; (double)num717 < num716; num717++)
					{
						int num718 = genRand.Next(0, Main.maxTilesX);
						int num719 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						while (Main.tile[num718, num719].type != 1)
						{
							num718 = genRand.Next(0, Main.maxTilesX);
							num719 = genRand.Next((int)Main.worldSurface, Main.maxTilesY);
						}
						TileRunner(num718, num719, genRand.Next(2, 6), genRand.Next(3, 7), num715);
					}
				}
				for (int num720 = 0; num720 < 2; num720++)
				{
					int num721 = 1;
					int num722 = 5;
					int num723 = Main.maxTilesX - 5;
					if (num720 == 1)
					{
						num721 = -1;
						num722 = Main.maxTilesX - 5;
						num723 = 5;
					}
					for (int num724 = num722; num724 != num723; num724 += num721)
					{
						if (num724 <= GenVars.UndergroundDesertLocation.Left || num724 >= GenVars.UndergroundDesertLocation.Right)
						{
							for (int num725 = 10; num725 < Main.maxTilesY - 10; num725++)
							{
								if (Main.tile[num724, num725].active() && Main.tile[num724, num725 + 1].active() && Main.tileSand[Main.tile[num724, num725].type] && Main.tileSand[Main.tile[num724, num725 + 1].type])
								{
									ushort type9 = Main.tile[num724, num725].type;
									int num726 = num724 + num721;
									int num727 = num725 + 1;
									if (!Main.tile[num726, num725].active() && !Main.tile[num726, num727].active())
									{
										for (; !Main.tile[num726, num727].active(); num727++)
										{
										}
										num727--;
										Main.tile[num724, num725].active(active: false);
										Main.tile[num726, num727].active(active: true);
										Main.tile[num726, num727].type = type9;
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Gravitating Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[24].Value;
				for (int num711 = 0; num711 < Main.maxTilesX; num711++)
				{
					double value12 = (double)num711 / (double)(Main.maxTilesX - 1);
					progress.Set(value12);
					bool flag44 = false;
					int num712 = 0;
					for (int num713 = Main.maxTilesY - 1; num713 > 0; num713--)
					{
						if (SolidOrSlopedTile(num711, num713))
						{
							ushort type8 = Main.tile[num711, num713].type;
							if (flag44 && num713 < (int)Main.worldSurface && num713 != num712 - 1 && TileID.Sets.Falling[type8])
							{
								for (int num714 = num713; num714 < num712; num714++)
								{
									Main.tile[num711, num714].ResetToType(type8);
								}
							}
							flag44 = true;
							num712 = num713;
						}
					}
				}
			});
			AddGenerationPass("Create Ocean Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				int maxValue11 = 3;
				if (remixWorldGen)
				{
					maxValue11 = 2;
				}
				for (int num708 = 0; num708 < 2; num708++)
				{
					if ((num708 != 0 || GenVars.dungeonSide <= 0) && (num708 != 1 || GenVars.dungeonSide >= 0) && (genRand.Next(maxValue11) == 0 || drunkWorldGen || tenthAnniversaryWorldGen))
					{
						progress.Message = Lang.gen[90].Value;
						int num709 = genRand.Next(55, 95);
						if (num708 == 1)
						{
							num709 = genRand.Next(Main.maxTilesX - 95, Main.maxTilesX - 55);
						}
						int num710;
						for (num710 = 0; !Main.tile[num709, num710].active(); num710++)
						{
						}
						oceanCave(num709, num710);
					}
				}
			});
			AddGenerationPass("Shimmer", delegate
			{
				//IL_0271: Unknown result type (might be due to invalid IL or missing references)
				//IL_0276: Unknown result type (might be due to invalid IL or missing references)
				int num701 = (int)((double)((Main.maxTilesY - 250) * 2) + Main.rockLayer) / 3;
				if (num701 > Main.maxTilesY - 330 - 100 - 30)
				{
					num701 = Main.maxTilesY - 330 - 100 - 30;
				}
				int num702 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2 + 20, num701);
				int num703 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
				int num704 = (int)Main.worldSurface + 150;
				int num705 = (int)(Main.rockLayer + Main.worldSurface + 200.0) / 2;
				if (num705 <= num704)
				{
					num705 = num704 + 50;
				}
				if (tenthAnniversaryWorldGen)
				{
					num702 = genRand.Next(num704, num705);
				}
				int num706 = 0;
				while (!ShimmerMakeBiome(num703, num702))
				{
					num706++;
					if (tenthAnniversaryWorldGen && num706 < 10000)
					{
						num702 = genRand.Next(num704, num705);
						num703 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
					}
					else if (num706 > 20000)
					{
						num702 = genRand.Next((int)Main.worldSurface + 100 + 20, num701);
						num703 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.8), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.2)));
					}
					else
					{
						num702 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2 + 20, num701);
						num703 = ((GenVars.dungeonSide < 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.89), Main.maxTilesX - 200) : genRand.Next(200, (int)((double)Main.maxTilesX * 0.11)));
					}
				}
				GenVars.shimmerPosition = new Vector2D((double)num703, (double)num702);
				int num707 = 200;
				GenVars.structures.AddProtectedStructure(new Rectangle(num703 - num707 / 2, num702 - num707 / 2, num707, num707));
			});
			AddGenerationPass("Clean Up Dirt", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[25].Value;
				for (int num695 = 3; num695 < Main.maxTilesX - 3; num695++)
				{
					double num696 = (double)num695 / (double)Main.maxTilesX;
					progress.Set(0.5 * num696);
					bool flag42 = true;
					for (int num697 = 0; (double)num697 < Main.worldSurface; num697++)
					{
						if (flag42)
						{
							if (Main.tile[num695, num697].wall == 2 || Main.tile[num695, num697].wall == 40 || Main.tile[num695, num697].wall == 64 || Main.tile[num695, num697].wall == 86)
							{
								Main.tile[num695, num697].wall = 0;
							}
							if (Main.tile[num695, num697].type != 53 && Main.tile[num695, num697].type != 112 && Main.tile[num695, num697].type != 234)
							{
								if (Main.tile[num695 - 1, num697].wall == 2 || Main.tile[num695 - 1, num697].wall == 40 || Main.tile[num695 - 1, num697].wall == 40)
								{
									Main.tile[num695 - 1, num697].wall = 0;
								}
								if ((Main.tile[num695 - 2, num697].wall == 2 || Main.tile[num695 - 2, num697].wall == 40 || Main.tile[num695 - 2, num697].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num695 - 2, num697].wall = 0;
								}
								if ((Main.tile[num695 - 3, num697].wall == 2 || Main.tile[num695 - 3, num697].wall == 40 || Main.tile[num695 - 3, num697].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num695 - 3, num697].wall = 0;
								}
								if (Main.tile[num695 + 1, num697].wall == 2 || Main.tile[num695 + 1, num697].wall == 40 || Main.tile[num695 + 1, num697].wall == 40)
								{
									Main.tile[num695 + 1, num697].wall = 0;
								}
								if ((Main.tile[num695 + 2, num697].wall == 2 || Main.tile[num695 + 2, num697].wall == 40 || Main.tile[num695 + 2, num697].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num695 + 2, num697].wall = 0;
								}
								if ((Main.tile[num695 + 3, num697].wall == 2 || Main.tile[num695 + 3, num697].wall == 40 || Main.tile[num695 + 3, num697].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num695 + 3, num697].wall = 0;
								}
								if (Main.tile[num695, num697].active())
								{
									flag42 = false;
								}
							}
						}
						else if (Main.tile[num695, num697].wall == 0 && Main.tile[num695, num697 + 1].wall == 0 && Main.tile[num695, num697 + 2].wall == 0 && Main.tile[num695, num697 + 3].wall == 0 && Main.tile[num695, num697 + 4].wall == 0 && Main.tile[num695 - 1, num697].wall == 0 && Main.tile[num695 + 1, num697].wall == 0 && Main.tile[num695 - 2, num697].wall == 0 && Main.tile[num695 + 2, num697].wall == 0 && !Main.tile[num695, num697].active() && !Main.tile[num695, num697 + 1].active() && !Main.tile[num695, num697 + 2].active() && !Main.tile[num695, num697 + 3].active())
						{
							flag42 = true;
						}
					}
				}
				for (int num698 = Main.maxTilesX - 5; num698 >= 5; num698--)
				{
					double num699 = (double)num698 / (double)Main.maxTilesX;
					progress.Set(1.0 - 0.5 * num699);
					bool flag43 = true;
					for (int num700 = 0; (double)num700 < Main.worldSurface; num700++)
					{
						if (flag43)
						{
							if (Main.tile[num698, num700].wall == 2 || Main.tile[num698, num700].wall == 40 || Main.tile[num698, num700].wall == 64)
							{
								Main.tile[num698, num700].wall = 0;
							}
							if (Main.tile[num698, num700].type != 53)
							{
								if (Main.tile[num698 - 1, num700].wall == 2 || Main.tile[num698 - 1, num700].wall == 40 || Main.tile[num698 - 1, num700].wall == 40)
								{
									Main.tile[num698 - 1, num700].wall = 0;
								}
								if ((Main.tile[num698 - 2, num700].wall == 2 || Main.tile[num698 - 2, num700].wall == 40 || Main.tile[num698 - 2, num700].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num698 - 2, num700].wall = 0;
								}
								if ((Main.tile[num698 - 3, num700].wall == 2 || Main.tile[num698 - 3, num700].wall == 40 || Main.tile[num698 - 3, num700].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num698 - 3, num700].wall = 0;
								}
								if (Main.tile[num698 + 1, num700].wall == 2 || Main.tile[num698 + 1, num700].wall == 40 || Main.tile[num698 + 1, num700].wall == 40)
								{
									Main.tile[num698 + 1, num700].wall = 0;
								}
								if ((Main.tile[num698 + 2, num700].wall == 2 || Main.tile[num698 + 2, num700].wall == 40 || Main.tile[num698 + 2, num700].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num698 + 2, num700].wall = 0;
								}
								if ((Main.tile[num698 + 3, num700].wall == 2 || Main.tile[num698 + 3, num700].wall == 40 || Main.tile[num698 + 3, num700].wall == 40) && genRand.Next(2) == 0)
								{
									Main.tile[num698 + 3, num700].wall = 0;
								}
								if (Main.tile[num698, num700].active())
								{
									flag43 = false;
								}
							}
						}
						else if (Main.tile[num698, num700].wall == 0 && Main.tile[num698, num700 + 1].wall == 0 && Main.tile[num698, num700 + 2].wall == 0 && Main.tile[num698, num700 + 3].wall == 0 && Main.tile[num698, num700 + 4].wall == 0 && Main.tile[num698 - 1, num700].wall == 0 && Main.tile[num698 + 1, num700].wall == 0 && Main.tile[num698 - 2, num700].wall == 0 && Main.tile[num698 + 2, num700].wall == 0 && !Main.tile[num698, num700].active() && !Main.tile[num698, num700 + 1].active() && !Main.tile[num698, num700 + 2].active() && !Main.tile[num698, num700 + 3].active())
						{
							flag43 = true;
						}
					}
				}
			});
			AddGenerationPass("Pyramids", delegate
			{
				Rectangle undergroundDesertLocation = GenVars.UndergroundDesertLocation;
				if (Main.tenthAnniversaryWorld)
				{
					int x14 = undergroundDesertLocation.Center.X;
					int j4 = undergroundDesertLocation.Top - 10;
					Pyramid(x14, j4);
				}
				for (int num688 = 0; num688 < GenVars.numPyr; num688++)
				{
					int num689 = GenVars.PyrX[num688];
					int num690 = GenVars.PyrY[num688];
					if (num689 > 300 && num689 < Main.maxTilesX - 300 && (GenVars.dungeonSide >= 0 || !((double)num689 < (double)GenVars.dungeonX + (double)Main.maxTilesX * 0.15)) && (GenVars.dungeonSide <= 0 || !((double)num689 > (double)GenVars.dungeonX - (double)Main.maxTilesX * 0.15)) && (!Main.tenthAnniversaryWorld || !undergroundDesertLocation.Contains(num689, num690)))
					{
						for (; !Main.tile[num689, num690].active() && (double)num690 < Main.worldSurface; num690++)
						{
						}
						if (!((double)num690 >= Main.worldSurface) && Main.tile[num689, num690].type == 53)
						{
							int num691 = Main.maxTilesX;
							for (int num692 = 0; num692 < num688; num692++)
							{
								int num693 = Math.Abs(num689 - GenVars.PyrX[num692]);
								if (num693 < num691)
								{
									num691 = num693;
								}
							}
							int num694 = 220;
							if (drunkWorldGen)
							{
								num694 /= 2;
							}
							if (num691 >= num694)
							{
								num690--;
								Pyramid(num689, num690);
							}
						}
					}
				}
			});
			AddGenerationPass("Dirt Rock Wall Runner", delegate
			{
				for (int num685 = 0; num685 < Main.maxTilesX; num685++)
				{
					int num686 = genRand.Next(10, Main.maxTilesX - 10);
					int num687 = genRand.Next(10, (int)Main.worldSurface);
					if (Main.tile[num686, num687].wall == 2)
					{
						DirtyRockRunner(num686, num687);
					}
				}
			});
			AddGenerationPass("Living Trees", delegate
			{
				int num668 = 200;
				double num669 = (double)Main.maxTilesX / 4200.0;
				int num670 = genRand.Next(0, (int)(2.0 * num669) + 1);
				if (num670 == 0 && genRand.Next(2) == 0)
				{
					num670++;
				}
				if (drunkWorldGen)
				{
					num670 += (int)(2.0 * num669);
				}
				else if (Main.tenthAnniversaryWorld)
				{
					num670 += (int)(3.0 * num669);
				}
				else if (remixWorldGen)
				{
					num670 += (int)(2.0 * num669);
				}
				for (int num671 = 0; num671 < num670; num671++)
				{
					bool flag40 = false;
					int num672 = 0;
					while (!flag40)
					{
						num672++;
						if (num672 > Main.maxTilesX / 2)
						{
							flag40 = true;
						}
						int num673 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						if (tenthAnniversaryWorldGen && !remixWorldGen)
						{
							num673 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((float)Main.maxTilesX * 0.85f));
						}
						if (num673 <= Main.maxTilesX / 2 - num668 || num673 >= Main.maxTilesX / 2 + num668)
						{
							int num674;
							for (num674 = 0; !Main.tile[num673, num674].active() && (double)num674 < Main.worldSurface; num674++)
							{
							}
							if (Main.tile[num673, num674].type == 0)
							{
								num674--;
								if (num674 > 150)
								{
									bool flag41 = true;
									for (int num675 = num673 - 50; num675 < num673 + 50; num675++)
									{
										for (int num676 = num674 - 50; num676 < num674 + 50; num676++)
										{
											if (Main.tile[num675, num676].active())
											{
												switch (Main.tile[num675, num676].type)
												{
												case 41:
												case 43:
												case 44:
												case 189:
												case 196:
												case 460:
												case 481:
												case 482:
												case 483:
													flag41 = false;
													break;
												}
											}
										}
									}
									for (int num677 = 0; num677 < GenVars.numMCaves; num677++)
									{
										if (num673 > GenVars.mCaveX[num677] - 50 && num673 < GenVars.mCaveX[num677] + 50)
										{
											flag41 = false;
											break;
										}
									}
									if (flag41)
									{
										flag40 = GrowLivingTree(num673, num674);
										if (flag40)
										{
											for (int num678 = -1; num678 <= 1; num678++)
											{
												if (num678 != 0)
												{
													int num679 = num673;
													int num680 = genRand.Next(4);
													if (drunkWorldGen || Main.tenthAnniversaryWorld)
													{
														num680 += genRand.Next(2, 5);
													}
													else if (remixWorldGen)
													{
														num680 += genRand.Next(1, 6);
													}
													for (int num681 = 0; num681 < num680; num681++)
													{
														num679 += genRand.Next(13, 31) * num678;
														if (num679 <= Main.maxTilesX / 2 - num668 || num679 >= Main.maxTilesX / 2 + num668)
														{
															int num682 = num674;
															if (Main.tile[num679, num682].active())
															{
																while (Main.tile[num679, num682].active())
																{
																	num682--;
																}
															}
															else
															{
																for (; !Main.tile[num679, num682].active(); num682++)
																{
																}
																num682--;
															}
															flag41 = true;
															for (int num683 = num673 - 50; num683 < num673 + 50; num683++)
															{
																for (int num684 = num674 - 50; num684 < num674 + 50; num684++)
																{
																	if (Main.tile[num683, num684].active())
																	{
																		switch (Main.tile[num683, num684].type)
																		{
																		case 41:
																		case 43:
																		case 44:
																		case 189:
																		case 196:
																		case 460:
																		case 481:
																		case 482:
																		case 483:
																			flag41 = false;
																			break;
																		}
																	}
																}
															}
															if (flag41)
															{
																GrowLivingTree(num679, num682, patch: true);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				Main.tileSolid[192] = false;
			});
			AddGenerationPass("Wood Tree Walls", delegate
			{
				for (int num664 = 25; num664 < Main.maxTilesX - 25; num664++)
				{
					for (int num665 = 25; (double)num665 < Main.worldSurface; num665++)
					{
						if (Main.tile[num664, num665].type == 191 || Main.tile[num664, num665 - 1].type == 191 || Main.tile[num664 - 1, num665].type == 191 || Main.tile[num664 + 1, num665].type == 191 || Main.tile[num664, num665 + 1].type == 191)
						{
							bool flag39 = true;
							for (int num666 = num664 - 1; num666 <= num664 + 1; num666++)
							{
								for (int num667 = num665 - 1; num667 <= num665 + 1; num667++)
								{
									if (num666 != num664 && num667 != num665 && Main.tile[num666, num667].type != 191 && Main.tile[num666, num667].wall != 244)
									{
										flag39 = false;
									}
								}
							}
							if (flag39)
							{
								Main.tile[num664, num665].wall = 244;
							}
						}
					}
				}
			});
			AddGenerationPass("Altars", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
				//IL_0204: Unknown result type (might be due to invalid IL or missing references)
				Main.tileSolid[484] = false;
				progress.Message = Lang.gen[26].Value;
				int num659 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 3.3E-06);
				if (remixWorldGen)
				{
					num659 *= 3;
				}
				for (int num660 = 0; num660 < num659; num660++)
				{
					progress.Set((double)num660 / (double)num659);
					for (int num661 = 0; num661 < 10000; num661++)
					{
						int num662 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						while ((double)num662 > (double)Main.maxTilesX * 0.45 && (double)num662 < (double)Main.maxTilesX * 0.55)
						{
							num662 = genRand.Next(281, Main.maxTilesX - 3 - 280);
						}
						int num663 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int)(Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3);
						if (remixWorldGen)
						{
							num663 = genRand.Next(100, (int)((double)Main.maxTilesY * 0.9));
						}
						while (oceanDepths(num662, num663) || Vector2D.Distance(new Vector2D((double)num662, (double)num663), GenVars.shimmerPosition) < (double)shimmerSafetyDistance)
						{
							num662 = genRand.Next(281, Main.maxTilesX - 3 - 280);
							while ((double)num662 > (double)Main.maxTilesX * 0.45 && (double)num662 < (double)Main.maxTilesX * 0.55)
							{
								num662 = genRand.Next(281, Main.maxTilesX - 3 - 280);
							}
							num663 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, (int)(Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3);
							if (remixWorldGen)
							{
								num663 = genRand.Next(100, (int)((double)Main.maxTilesY * 0.9));
							}
						}
						int style2 = (crimson ? 1 : 0);
						if (drunkWorldGen)
						{
							style2 = (GenVars.crimsonLeft ? ((num662 < Main.maxTilesX / 2) ? 1 : 0) : ((num662 >= Main.maxTilesX / 2) ? 1 : 0));
						}
						if (!IsTileNearby(num662, num663, 26, 3))
						{
							Place3x2(num662, num663, 26, style2);
						}
						if (Main.tile[num662, num663].type == 26)
						{
							break;
						}
					}
				}
			});
			AddGenerationPass("Wet Jungle", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num657 = 0; num657 < Main.maxTilesX; num657++)
				{
					for (int num658 = (int)GenVars.worldSurfaceLow; (double)num658 < Main.worldSurface - 1.0; num658++)
					{
						if (Main.tile[num657, num658].active())
						{
							if (Main.tile[num657, num658].type == 60)
							{
								Main.tile[num657, num658 - 1].liquid = byte.MaxValue;
								Main.tile[num657, num658 - 2].liquid = byte.MaxValue;
							}
							break;
						}
					}
				}
			});
			AddGenerationPass("Jungle Temple", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				int num647 = 0;
				progress.Message = Lang.gen[70].Value;
				long num648 = 0L;
				double num649 = 0.25;
				while (true)
				{
					int num650 = (int)Main.rockLayer;
					int num651 = Main.maxTilesY - 500;
					if (num650 > num651 - 1)
					{
						num650 = num651 - 1;
					}
					int num652 = genRand.Next(num650, num651);
					int num653 = (int)(((genRand.NextDouble() * num649 + 0.1) * (double)(-GenVars.dungeonSide) + 0.5) * (double)Main.maxTilesX);
					if (remixWorldGen)
					{
						if (notTheBees)
						{
							num653 = ((GenVars.dungeonSide <= 0) ? genRand.Next((int)((double)Main.maxTilesX * 0.6), (int)((double)Main.maxTilesX * 0.8)) : genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.4)));
						}
						else
						{
							num653 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
							while ((double)num653 > (double)Main.maxTilesX * 0.4 && (double)num653 < (double)Main.maxTilesX * 0.6)
							{
								num653 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
							}
						}
						while (Main.tile[num653, num652].active() || Main.tile[num653, num652].wall > 0 || (double)num652 > Main.worldSurface - 5.0)
						{
							num652--;
						}
						num652++;
						if (Main.tile[num653, num652].active() && (Main.tile[num653, num652].type == 60 || Main.tile[num653, num652].type == 59))
						{
							int num654 = 10;
							bool flag38 = false;
							for (int num655 = num653 - num654; num655 <= num655 + num654; num655++)
							{
								for (int num656 = num652 - num654; num656 < num654; num656++)
								{
									if (Main.tile[num655, num656].type == 191 || Main.tileDungeon[Main.tile[num655, num656].type])
									{
										flag38 = true;
									}
								}
							}
							if (!flag38)
							{
								num652 -= 10 + genRand.Next(10);
								makeTemple(num653, num652);
								break;
							}
						}
					}
					else if (Main.tile[num653, num652].active() && Main.tile[num653, num652].type == 60)
					{
						makeTemple(num653, num652);
						break;
					}
					if (num648++ > 2000000)
					{
						if (num649 == 0.35)
						{
							num647++;
							if (num647 > 10)
							{
								break;
							}
						}
						num649 = Math.Min(0.35, num649 + 0.05);
						num648 = 0L;
					}
				}
			});
			AddGenerationPass("Hives", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[71].Value;
				double num638 = (double)Main.maxTilesX / 4200.0;
				double num639 = 1 + genRand.Next((int)(5.0 * num638), (int)(8.0 * num638));
				if (drunkWorldGen)
				{
					num639 *= 0.667;
				}
				int num640 = 10000;
				HiveBiome hiveBiome = GenVars.configuration.CreateBiome<HiveBiome>();
				HoneyPatchBiome honeyPatchBiome = GenVars.configuration.CreateBiome<HoneyPatchBiome>();
				while (num639 > 0.0 && num640 > 0)
				{
					num640--;
					Point origin3 = RandomWorldPoint((int)(Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
					if (drunkWorldGen)
					{
						RandomWorldPoint((int)Main.worldSurface, 20, 300, 20);
					}
					if (hiveBiome.Place(origin3, GenVars.structures))
					{
						num639 -= 1.0;
						int num641 = genRand.Next(5);
						int num642 = 0;
						int num643 = 10000;
						while (num642 < num641 && num643 > 0)
						{
							double num644 = genRand.NextDouble() * 60.0 + 30.0;
							double num645 = genRand.NextDouble() * 6.2831854820251465;
							int num646 = (int)(Math.Cos(num645) * num644) + origin3.X;
							int y13 = (int)(Math.Sin(num645) * num644) + origin3.Y;
							num643--;
							if (num646 > 50 && num646 < Main.maxTilesX - 50 && honeyPatchBiome.Place(new Point(num646, y13), GenVars.structures))
							{
								num642++;
							}
						}
					}
				}
			});
			AddGenerationPass("Jungle Chests", delegate
			{
				int num612 = genRand.Next(40, Main.maxTilesX - 40);
				int num613 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
				double num614 = genRand.Next(7, 12);
				num614 *= (double)Main.maxTilesX / 4200.0;
				int num615 = 0;
				for (int num616 = 0; (double)num616 < num614; num616++)
				{
					bool flag36 = true;
					while (flag36)
					{
						num615++;
						num612 = genRand.Next(40, Main.maxTilesX / 2 - 40);
						if (GenVars.dungeonSide < 0)
						{
							num612 += Main.maxTilesX / 2;
						}
						num613 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
						int num617 = genRand.Next(2, 4);
						int num618 = genRand.Next(2, 4);
						Rectangle area = new Rectangle(num612 - num617 - 1, num613 - num618 - 1, num617 + 1, num618 + 1);
						if (Main.tile[num612, num613].type == 60)
						{
							int num619 = 30;
							flag36 = false;
							for (int num620 = num612 - num619; num620 < num612 + num619; num620 += 3)
							{
								for (int num621 = num613 - num619; num621 < num613 + num619; num621 += 3)
								{
									if (Main.tile[num620, num621].active() && (Main.tile[num620, num621].type == 225 || Main.tile[num620, num621].type == 229 || Main.tile[num620, num621].type == 226 || Main.tile[num620, num621].type == 119 || Main.tile[num620, num621].type == 120))
									{
										flag36 = true;
									}
									if (Main.tile[num620, num621].wall == 86 || Main.tile[num620, num621].wall == 87)
									{
										flag36 = true;
									}
								}
							}
							if (!GenVars.structures.CanPlace(area, 1))
							{
								flag36 = true;
							}
						}
						if (!flag36)
						{
							ushort wall2 = 0;
							if (GenVars.jungleHut == 119)
							{
								wall2 = 23;
							}
							else if (GenVars.jungleHut == 120)
							{
								wall2 = 24;
							}
							else if (GenVars.jungleHut == 158)
							{
								wall2 = 42;
							}
							else if (GenVars.jungleHut == 175)
							{
								wall2 = 45;
							}
							else if (GenVars.jungleHut == 45)
							{
								wall2 = 10;
							}
							for (int num622 = num612 - num617 - 1; num622 <= num612 + num617 + 1; num622++)
							{
								for (int num623 = num613 - num618 - 1; num623 <= num613 + num618 + 1; num623++)
								{
									Main.tile[num622, num623].active(active: true);
									Main.tile[num622, num623].type = GenVars.jungleHut;
									Main.tile[num622, num623].liquid = 0;
									Main.tile[num622, num623].lava(lava: false);
								}
							}
							for (int num624 = num612 - num617; num624 <= num612 + num617; num624++)
							{
								for (int num625 = num613 - num618; num625 <= num613 + num618; num625++)
								{
									Main.tile[num624, num625].active(active: false);
									Main.tile[num624, num625].wall = wall2;
								}
							}
							bool flag37 = false;
							int num626 = 0;
							while (!flag37 && num626 < 100)
							{
								num626++;
								int num627 = genRand.Next(num612 - num617, num612 + num617 + 1);
								int num628 = genRand.Next(num613 - num618, num613 + num618 - 2);
								PlaceTile(num627, num628, 4, mute: true, forced: false, -1, 3);
								if (Main.tile[num627, num628].type == 4)
								{
									flag37 = true;
								}
							}
							for (int num629 = num612 - num617 - 1; num629 <= num612 + num617 + 1; num629++)
							{
								for (int num630 = num613 + num618 - 2; num630 <= num613 + num618; num630++)
								{
									Main.tile[num629, num630].active(active: false);
								}
							}
							for (int num631 = num612 - num617 - 1; num631 <= num612 + num617 + 1; num631++)
							{
								for (int num632 = num613 + num618 - 2; num632 <= num613 + num618 - 1; num632++)
								{
									Main.tile[num631, num632].active(active: false);
								}
							}
							for (int num633 = num612 - num617 - 1; num633 <= num612 + num617 + 1; num633++)
							{
								int num634 = 4;
								int num635 = num613 + num618 + 2;
								while (!Main.tile[num633, num635].active() && num635 < Main.maxTilesY && num634 > 0)
								{
									Main.tile[num633, num635].active(active: true);
									Main.tile[num633, num635].type = 59;
									num635++;
									num634--;
								}
							}
							num617 -= genRand.Next(1, 3);
							int num636 = num613 - num618 - 2;
							while (num617 > -1)
							{
								for (int num637 = num612 - num617 - 1; num637 <= num612 + num617 + 1; num637++)
								{
									Main.tile[num637, num636].active(active: true);
									Main.tile[num637, num636].type = GenVars.jungleHut;
								}
								num617 -= genRand.Next(1, 3);
								num636--;
							}
							GenVars.JChestX[GenVars.numJChests] = num612;
							GenVars.JChestY[GenVars.numJChests] = num613;
							GenVars.structures.AddProtectedStructure(area);
							GenVars.numJChests++;
							num615 = 0;
						}
						else if (num615 > Main.maxTilesX * 10)
						{
							num616++;
							num615 = 0;
							break;
						}
					}
				}
				Main.tileSolid[137] = false;
			});
			AddGenerationPass("Settle Liquids", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[27].Value;
				if (notTheBees)
				{
					NotTheBees();
				}
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
				Liquid.QuickWater(3);
				WaterCheck();
				int num605 = 0;
				Liquid.quickSettle = true;
				int num606 = 10;
				while (num605 < num606)
				{
					int num607 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num605++;
					double num608 = 0.0;
					int num609 = num607 * 5;
					while (Liquid.numLiquid > 0)
					{
						num609--;
						if (num609 < 0)
						{
							break;
						}
						double num610 = (double)(num607 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double)num607;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num607)
						{
							num607 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
						}
						if (num610 > num608)
						{
							num608 = num610;
						}
						else
						{
							num610 = num608;
						}
						if (num605 == 1)
						{
							progress.Set(num610 / 3.0 + 0.33);
						}
						int num611 = 10;
						if (num605 > num611)
						{
							num611 = num605;
						}
						Liquid.UpdateLiquid();
					}
					WaterCheck();
					progress.Set((double)num605 * 0.1 / 3.0 + 0.66);
				}
				Liquid.quickSettle = false;
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
				Main.tileSolid[484] = false;
			});
			AddGenerationPass("Remove Water From Sand", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num602 = 400; num602 < Main.maxTilesX - 400; num602++)
				{
					for (int num603 = 100; (double)num603 < Main.worldSurface - 1.0; num603++)
					{
						if (Main.tile[num602, num603].active())
						{
							ushort type7 = Main.tile[num602, num603].type;
							if (type7 == 53 || type7 == 396 || type7 == 397 || type7 == 404 || type7 == 407 || type7 == 151)
							{
								int num604 = num603;
								while (num604 > 100)
								{
									num604--;
									if (Main.tile[num602, num604].active())
									{
										break;
									}
									Main.tile[num602, num604].liquid = 0;
								}
							}
							break;
						}
					}
				}
				Main.tileSolid[192] = true;
			});
			AddGenerationPass("Oasis", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Set(1.0);
					int num598 = Main.maxTilesX / 2100;
					num598 += genRand.Next(2);
					for (int num599 = 0; num599 < num598; num599++)
					{
						int num600 = beachDistance + 300;
						int num601 = Main.maxTilesX * 2;
						while (num601 > 0)
						{
							num601--;
							int x13 = genRand.Next(num600, Main.maxTilesX - num600);
							int y12 = genRand.Next(100, (int)Main.worldSurface);
							if (PlaceOasis(x13, y12))
							{
								num601 = -1;
							}
						}
					}
				}
			});
			AddGenerationPass("Shell Piles", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (dontStarveWorldGen)
				{
					int num586 = (int)(5.0 * ((double)Main.maxTilesX / 4200.0));
					int num587 = 0;
					int num588 = 100;
					int num589 = Main.maxTilesX / 2;
					int num590 = num589 - num588;
					int num591 = num589 + num588;
					for (int num592 = 0; num592 < 80; num592++)
					{
						int num593 = genRand.Next(100, Main.maxTilesX - 100);
						if (num593 >= num590 && num593 <= num591)
						{
							num593 = genRand.Next(100, Main.maxTilesX - 100);
							if (num593 >= num590 && num593 <= num591)
							{
								continue;
							}
						}
						int y11 = (int)Main.worldSurface / 2;
						if (MarblePileWithStatues(num593, y11))
						{
							num587++;
							if (num587 >= num586)
							{
								break;
							}
						}
					}
				}
				if (!notTheBees)
				{
					progress.Set(1.0);
					if (genRand.Next(2) == 0)
					{
						int shellStartXLeft = GenVars.shellStartXLeft;
						int shellStartYLeft = GenVars.shellStartYLeft;
						for (int num594 = shellStartXLeft - 20; num594 <= shellStartXLeft + 20; num594++)
						{
							for (int num595 = shellStartYLeft - 10; num595 <= shellStartYLeft + 10; num595++)
							{
								if (Main.tile[num594, num595].active() && Main.tile[num594, num595].type == 53 && !Main.tile[num594, num595 - 1].active() && Main.tile[num594, num595 - 1].liquid == 0 && !Main.tile[num594 - 1, num595].active() && Main.tile[num594 - 1, num595].liquid > 0)
								{
									GenVars.shellStartXLeft = num594;
									GenVars.shellStartYLeft = num595;
								}
							}
						}
						GenVars.shellStartYLeft -= 50;
						GenVars.shellStartXLeft -= genRand.Next(5);
						if (genRand.Next(2) == 0)
						{
							GenVars.shellStartXLeft -= genRand.Next(10);
						}
						if (genRand.Next(3) == 0)
						{
							GenVars.shellStartXLeft -= genRand.Next(15);
						}
						if (genRand.Next(4) != 0)
						{
							ShellPile(GenVars.shellStartXLeft, GenVars.shellStartYLeft);
						}
						int maxValue9 = genRand.Next(2, 4);
						if (genRand.Next(maxValue9) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(10, 35), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue9) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(40, 65), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue9) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(70, 95), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue9) == 0)
						{
							ShellPile(GenVars.shellStartXLeft - genRand.Next(100, 125), GenVars.shellStartYLeft);
						}
						if (genRand.Next(maxValue9) == 0)
						{
							ShellPile(GenVars.shellStartXLeft + genRand.Next(10, 25), GenVars.shellStartYLeft);
						}
					}
					if (genRand.Next(2) == 0)
					{
						int shellStartXRight = GenVars.shellStartXRight;
						int shellStartYRight = GenVars.shellStartYRight;
						for (int num596 = shellStartXRight - 20; num596 <= shellStartXRight + 20; num596++)
						{
							for (int num597 = shellStartYRight - 10; num597 <= shellStartYRight + 10; num597++)
							{
								if (Main.tile[num596, num597].active() && Main.tile[num596, num597].type == 53 && !Main.tile[num596, num597 - 1].active() && Main.tile[num596, num597 - 1].liquid == 0 && !Main.tile[num596 + 1, num597].active() && Main.tile[num596 + 1, num597].liquid > 0)
								{
									GenVars.shellStartXRight = num596;
									GenVars.shellStartYRight = num597;
								}
							}
						}
						GenVars.shellStartYRight -= 50;
						GenVars.shellStartXRight += genRand.Next(5);
						if (genRand.Next(2) == 0)
						{
							GenVars.shellStartXLeft += genRand.Next(10);
						}
						if (genRand.Next(3) == 0)
						{
							GenVars.shellStartXLeft += genRand.Next(15);
						}
						if (genRand.Next(4) != 0)
						{
							ShellPile(GenVars.shellStartXRight, GenVars.shellStartYRight);
						}
						int maxValue10 = genRand.Next(2, 4);
						if (genRand.Next(maxValue10) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(10, 35), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue10) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(40, 65), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue10) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(70, 95), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue10) == 0)
						{
							ShellPile(GenVars.shellStartXRight + genRand.Next(100, 125), GenVars.shellStartYRight);
						}
						if (genRand.Next(maxValue10) == 0)
						{
							ShellPile(GenVars.shellStartXRight - genRand.Next(10, 25), GenVars.shellStartYRight);
						}
					}
				}
			});
			AddGenerationPass("Smooth World", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[60].Value;
				Main.tileSolid[GenVars.crackedType] = true;
				for (int num582 = 20; num582 < Main.maxTilesX - 20; num582++)
				{
					double value11 = (double)num582 / (double)Main.maxTilesX;
					progress.Set(value11);
					for (int num583 = 20; num583 < Main.maxTilesY - 20; num583++)
					{
						if (Main.tile[num582, num583].type != 48 && Main.tile[num582, num583].type != 137 && Main.tile[num582, num583].type != 232 && Main.tile[num582, num583].type != 191 && Main.tile[num582, num583].type != 151 && Main.tile[num582, num583].type != 274)
						{
							if (!Main.tile[num582, num583 - 1].active() && Main.tile[num582 - 1, num583].type != 136 && Main.tile[num582 + 1, num583].type != 136)
							{
								if (SolidTile(num582, num583) && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num582, num583].type])
								{
									if (!Main.tile[num582 - 1, num583].halfBrick() && !Main.tile[num582 + 1, num583].halfBrick() && Main.tile[num582 - 1, num583].slope() == 0 && Main.tile[num582 + 1, num583].slope() == 0)
									{
										if (SolidTile(num582, num583 + 1))
										{
											if (!SolidTile(num582 - 1, num583) && !Main.tile[num582 - 1, num583 + 1].halfBrick() && SolidTile(num582 - 1, num583 + 1) && SolidTile(num582 + 1, num583) && !Main.tile[num582 + 1, num583 - 1].active())
											{
												if (genRand.Next(2) == 0)
												{
													SlopeTile(num582, num583, 2);
												}
												else
												{
													PoundTile(num582, num583);
												}
											}
											else if (!SolidTile(num582 + 1, num583) && !Main.tile[num582 + 1, num583 + 1].halfBrick() && SolidTile(num582 + 1, num583 + 1) && SolidTile(num582 - 1, num583) && !Main.tile[num582 - 1, num583 - 1].active())
											{
												if (genRand.Next(2) == 0)
												{
													SlopeTile(num582, num583, 1);
												}
												else
												{
													PoundTile(num582, num583);
												}
											}
											else if (SolidTile(num582 + 1, num583 + 1) && SolidTile(num582 - 1, num583 + 1) && !Main.tile[num582 + 1, num583].active() && !Main.tile[num582 - 1, num583].active())
											{
												PoundTile(num582, num583);
											}
											if (SolidTile(num582, num583))
											{
												if (SolidTile(num582 - 1, num583) && SolidTile(num582 + 1, num583 + 2) && !Main.tile[num582 + 1, num583].active() && !Main.tile[num582 + 1, num583 + 1].active() && !Main.tile[num582 - 1, num583 - 1].active())
												{
													KillTile(num582, num583);
												}
												else if (SolidTile(num582 + 1, num583) && SolidTile(num582 - 1, num583 + 2) && !Main.tile[num582 - 1, num583].active() && !Main.tile[num582 - 1, num583 + 1].active() && !Main.tile[num582 + 1, num583 - 1].active())
												{
													KillTile(num582, num583);
												}
												else if (!Main.tile[num582 - 1, num583 + 1].active() && !Main.tile[num582 - 1, num583].active() && SolidTile(num582 + 1, num583) && SolidTile(num582, num583 + 2))
												{
													if (genRand.Next(5) == 0)
													{
														KillTile(num582, num583);
													}
													else if (genRand.Next(5) == 0)
													{
														PoundTile(num582, num583);
													}
													else
													{
														SlopeTile(num582, num583, 2);
													}
												}
												else if (!Main.tile[num582 + 1, num583 + 1].active() && !Main.tile[num582 + 1, num583].active() && SolidTile(num582 - 1, num583) && SolidTile(num582, num583 + 2))
												{
													if (genRand.Next(5) == 0)
													{
														KillTile(num582, num583);
													}
													else if (genRand.Next(5) == 0)
													{
														PoundTile(num582, num583);
													}
													else
													{
														SlopeTile(num582, num583, 1);
													}
												}
											}
										}
										if (SolidTile(num582, num583) && !Main.tile[num582 - 1, num583].active() && !Main.tile[num582 + 1, num583].active())
										{
											KillTile(num582, num583);
										}
									}
								}
								else if (!Main.tile[num582, num583].active() && Main.tile[num582, num583 + 1].type != 151 && Main.tile[num582, num583 + 1].type != 274)
								{
									if (Main.tile[num582 + 1, num583].type != 190 && Main.tile[num582 + 1, num583].type != 48 && Main.tile[num582 + 1, num583].type != 232 && SolidTile(num582 - 1, num583 + 1) && SolidTile(num582 + 1, num583) && !Main.tile[num582 - 1, num583].active() && !Main.tile[num582 + 1, num583 - 1].active())
									{
										if (Main.tile[num582 + 1, num583].type == 495)
										{
											PlaceTile(num582, num583, Main.tile[num582 + 1, num583].type);
										}
										else
										{
											PlaceTile(num582, num583, Main.tile[num582, num583 + 1].type);
										}
										if (genRand.Next(2) == 0)
										{
											SlopeTile(num582, num583, 2);
										}
										else
										{
											PoundTile(num582, num583);
										}
									}
									if (Main.tile[num582 - 1, num583].type != 190 && Main.tile[num582 - 1, num583].type != 48 && Main.tile[num582 - 1, num583].type != 232 && SolidTile(num582 + 1, num583 + 1) && SolidTile(num582 - 1, num583) && !Main.tile[num582 + 1, num583].active() && !Main.tile[num582 - 1, num583 - 1].active())
									{
										if (Main.tile[num582 - 1, num583].type == 495)
										{
											PlaceTile(num582, num583, Main.tile[num582 - 1, num583].type);
										}
										else
										{
											PlaceTile(num582, num583, Main.tile[num582, num583 + 1].type);
										}
										if (genRand.Next(2) == 0)
										{
											SlopeTile(num582, num583, 1);
										}
										else
										{
											PoundTile(num582, num583);
										}
									}
								}
							}
							else if (!Main.tile[num582, num583 + 1].active() && genRand.Next(2) == 0 && SolidTile(num582, num583) && !Main.tile[num582 - 1, num583].halfBrick() && !Main.tile[num582 + 1, num583].halfBrick() && Main.tile[num582 - 1, num583].slope() == 0 && Main.tile[num582 + 1, num583].slope() == 0 && SolidTile(num582, num583 - 1))
							{
								if (SolidTile(num582 - 1, num583) && !SolidTile(num582 + 1, num583) && SolidTile(num582 - 1, num583 - 1))
								{
									SlopeTile(num582, num583, 3);
								}
								else if (SolidTile(num582 + 1, num583) && !SolidTile(num582 - 1, num583) && SolidTile(num582 + 1, num583 - 1))
								{
									SlopeTile(num582, num583, 4);
								}
							}
							if (TileID.Sets.Conversion.Sand[Main.tile[num582, num583].type])
							{
								Tile.SmoothSlope(num582, num583, applyToNeighbors: false);
							}
						}
					}
				}
				for (int num584 = 20; num584 < Main.maxTilesX - 20; num584++)
				{
					for (int num585 = 20; num585 < Main.maxTilesY - 20; num585++)
					{
						if (genRand.Next(2) == 0 && !Main.tile[num584, num585 - 1].active() && Main.tile[num584, num585].type != 137 && Main.tile[num584, num585].type != 48 && Main.tile[num584, num585].type != 232 && Main.tile[num584, num585].type != 191 && Main.tile[num584, num585].type != 151 && Main.tile[num584, num585].type != 274 && Main.tile[num584, num585].type != 75 && Main.tile[num584, num585].type != 76 && SolidTile(num584, num585) && Main.tile[num584 - 1, num585].type != 137 && Main.tile[num584 + 1, num585].type != 137)
						{
							if (SolidTile(num584, num585 + 1) && SolidTile(num584 + 1, num585) && !Main.tile[num584 - 1, num585].active())
							{
								SlopeTile(num584, num585, 2);
							}
							if (SolidTile(num584, num585 + 1) && SolidTile(num584 - 1, num585) && !Main.tile[num584 + 1, num585].active())
							{
								SlopeTile(num584, num585, 1);
							}
						}
						if (Main.tile[num584, num585].slope() == 1 && !SolidTile(num584 - 1, num585))
						{
							SlopeTile(num584, num585);
							PoundTile(num584, num585);
						}
						if (Main.tile[num584, num585].slope() == 2 && !SolidTile(num584 + 1, num585))
						{
							SlopeTile(num584, num585);
							PoundTile(num584, num585);
						}
					}
				}
				Main.tileSolid[137] = true;
				Main.tileSolid[190] = false;
				Main.tileSolid[192] = false;
				Main.tileSolid[GenVars.crackedType] = false;
			});
			AddGenerationPass("Waterfalls", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[69].Value;
				Main.tileSolid[191] = false;
				for (int num573 = 20; num573 < Main.maxTilesX - 20; num573++)
				{
					double num574 = (double)num573 / (double)Main.maxTilesX;
					progress.Set(num574 * 0.5);
					for (int num575 = 20; num575 < Main.maxTilesY - 20; num575++)
					{
						if (SolidTile(num573, num575) && !Main.tile[num573 - 1, num575].active() && SolidTile(num573, num575 + 1) && !Main.tile[num573 + 1, num575].active() && (Main.tile[num573 - 1, num575].liquid > 0 || Main.tile[num573 + 1, num575].liquid > 0))
						{
							bool flag35 = true;
							int num576 = genRand.Next(8, 20);
							int num577 = genRand.Next(8, 20);
							num576 = num575 - num576;
							num577 += num575;
							for (int num578 = num576; num578 <= num577; num578++)
							{
								if (Main.tile[num573, num578].halfBrick())
								{
									flag35 = false;
								}
							}
							if ((Main.tile[num573, num575].type == 75 || Main.tile[num573, num575].type == 76) && genRand.Next(10) != 0)
							{
								flag35 = false;
							}
							if (flag35)
							{
								PoundTile(num573, num575);
							}
						}
					}
				}
				for (int num579 = 20; num579 < Main.maxTilesX - 20; num579++)
				{
					double num580 = (double)num579 / (double)Main.maxTilesX;
					progress.Set(num580 * 0.5 + 0.5);
					for (int num581 = 20; num581 < Main.maxTilesY - 20; num581++)
					{
						if (Main.tile[num579, num581].type != 48 && Main.tile[num579, num581].type != 232 && SolidTile(num579, num581) && SolidTile(num579, num581 + 1))
						{
							if (!SolidTile(num579 + 1, num581) && Main.tile[num579 - 1, num581].halfBrick() && Main.tile[num579 - 2, num581].liquid > 0)
							{
								PoundTile(num579, num581);
							}
							if (!SolidTile(num579 - 1, num581) && Main.tile[num579 + 1, num581].halfBrick() && Main.tile[num579 + 2, num581].liquid > 0)
							{
								PoundTile(num579, num581);
							}
						}
					}
				}
				Main.tileSolid[191] = true;
			});
			AddGenerationPass("Ice", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (notTheBees)
				{
					NotTheBees();
				}
				progress.Set(1.0);
				for (int num571 = 10; num571 < Main.maxTilesX - 10; num571++)
				{
					for (int num572 = (int)Main.worldSurface; num572 < Main.maxTilesY - 100; num572++)
					{
						if (Main.tile[num571, num572].liquid > 0 && (!Main.tile[num571, num572].lava() || remixWorldGen))
						{
							MakeWateryIceThing(num571, num572);
						}
					}
				}
				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
			});
			AddGenerationPass("Wall Variety", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_0098: Unknown result type (might be due to invalid IL or missing references)
				progress.Message = Lang.gen[79].Value;
				double num567 = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
				int num568 = (int)(300.0 * num567);
				int num569 = num568;
				ShapeData shapeData = new ShapeData();
				while (num568 > 0)
				{
					progress.Set(1.0 - (double)num568 / (double)num569);
					Point point2 = RandomWorldPoint((int)GenVars.worldSurface, 2, 190, 2);
					while (Vector2D.Distance(new Vector2D((double)point2.X, (double)point2.Y), GenVars.shimmerPosition) < (double)shimmerSafetyDistance)
					{
						point2 = RandomWorldPoint((int)GenVars.worldSurface, 2, 190, 2);
					}
					Tile tile6 = Main.tile[point2.X, point2.Y];
					Tile tile7 = Main.tile[point2.X, point2.Y - 1];
					ushort num570 = 0;
					if (tile6.type == 60)
					{
						num570 = (ushort)(204 + genRand.Next(4));
					}
					else if (tile6.type == 1 && tile7.wall == 0)
					{
						num570 = (remixWorldGen ? (((double)point2.Y > GenVars.rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((point2.Y <= GenVars.lavaLine || genRand.Next(2) != 0) ? ((ushort)(212 + genRand.Next(4))) : ((ushort)(208 + genRand.Next(4))))) : (((double)point2.Y < GenVars.rockLayer) ? ((ushort)(196 + genRand.Next(4))) : ((point2.Y >= GenVars.lavaLine) ? ((ushort)(208 + genRand.Next(4))) : ((ushort)(212 + genRand.Next(4))))));
					}
					if (tile6.active() && num570 != 0 && !tile7.active())
					{
						bool foundInvalidTile = false;
						bool flag34 = ((tile6.type != 60) ? WorldUtils.Gen(new Point(point2.X, point2.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 60, 147, 161, 396, 397, 70, 191), new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
						{
							foundInvalidTile = true;
							return true;
						}))))) : WorldUtils.Gen(new Point(point2.X, point2.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Actions.Blank().Output(shapeData), new Actions.ContinueWrapper(Actions.Chain(new Modifiers.IsTouching(true, 147, 161, 396, 397, 70, 191), new Actions.Custom(delegate
						{
							foundInvalidTile = true;
							return true;
						}))))));
						if (shapeData.Count > 50 && flag34 && !foundInvalidTile)
						{
							WorldUtils.Gen(new Point(point2.X, point2.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), Actions.Chain(new Modifiers.SkipWalls(87), new Actions.PlaceWall(num570)));
							num568--;
						}
						shapeData.Clear();
					}
				}
			});
			AddGenerationPass("Life Crystals", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (getGoodWorldGen)
				{
					Main.tileSolid[56] = false;
				}
				if (notTheBees)
				{
					NotTheBees();
				}
				progress.Message = Lang.gen[28].Value;
				double num564 = (double)(Main.maxTilesX * Main.maxTilesY) * 2E-05;
				if (tenthAnniversaryWorldGen)
				{
					num564 *= 1.2;
				}
				if (Main.starGame)
				{
					num564 *= Main.starGameMath(0.2);
				}
				for (int num565 = 0; num565 < (int)num564; num565++)
				{
					double value10 = (double)num565 / ((double)(Main.maxTilesX * Main.maxTilesY) * 2E-05);
					progress.Set(value10);
					bool flag33 = false;
					int num566 = 0;
					while (!flag33)
					{
						int j3 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						if (remixWorldGen)
						{
							j3 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
						}
						if (AddLifeCrystal(genRand.Next(40, Main.maxTilesX - 40), j3))
						{
							flag33 = true;
						}
						else
						{
							num566++;
							if (num566 >= 10000)
							{
								flag33 = true;
							}
						}
					}
				}
				Main.tileSolid[225] = false;
			});
			AddGenerationPass("Statues", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[29].Value;
				int num557 = 0;
				double num558 = (double)Main.maxTilesX / 4200.0;
				int num559 = (int)((double)(GenVars.statueList.Length * 2) * num558);
				if (noTrapsWorldGen)
				{
					num559 *= 15;
					if (tenthAnniversaryWorldGen || notTheBees)
					{
						num559 /= 5;
					}
				}
				if (Main.starGame)
				{
					num559 = (int)((double)num559 * Main.starGameMath(0.2));
				}
				for (int num560 = 0; num560 < num559; num560++)
				{
					if (num557 >= GenVars.statueList.Length)
					{
						num557 = 0;
					}
					int x12 = GenVars.statueList[num557].X;
					int y10 = GenVars.statueList[num557].Y;
					double value9 = num560 / num559;
					progress.Set(value9);
					bool flag32 = false;
					int num561 = 0;
					while (!flag32)
					{
						int num562 = genRand.Next(20, Main.maxTilesX - 20);
						int num563 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
						if (remixWorldGen)
						{
							genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
						}
						while (oceanDepths(num562, num563))
						{
							num562 = genRand.Next(20, Main.maxTilesX - 20);
							num563 = genRand.Next((int)(Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300);
							if (remixWorldGen)
							{
								genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
							}
						}
						while (!Main.tile[num562, num563].active())
						{
							num563++;
							if (num563 >= Main.maxTilesY)
							{
								break;
							}
						}
						if (num563 < Main.maxTilesY)
						{
							num563--;
							if (!Main.tile[num562, num563].shimmer())
							{
								PlaceTile(num562, num563, x12, mute: true, forced: true, -1, y10);
							}
							if (Main.tile[num562, num563].active() && Main.tile[num562, num563].type == x12)
							{
								flag32 = true;
								if (GenVars.StatuesWithTraps.Contains(num557))
								{
									PlaceStatueTrap(num562, num563);
								}
								num557++;
							}
							else
							{
								num561++;
								if (num561 >= 10000)
								{
									flag32 = true;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Buried Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[30].Value;
				Main.tileSolid[226] = true;
				Main.tileSolid[162] = true;
				Main.tileSolid[225] = true;
				CaveHouseBiome caveHouseBiome = GenVars.configuration.CreateBiome<CaveHouseBiome>();
				int random6 = passConfig.Get<WorldGenRange>("CaveHouseCount").GetRandom(genRand);
				int random7 = passConfig.Get<WorldGenRange>("UnderworldChestCount").GetRandom(genRand);
				int num545 = passConfig.Get<WorldGenRange>("CaveChestCount").GetRandom(genRand);
				int random8 = passConfig.Get<WorldGenRange>("AdditionalDesertHouseCount").GetRandom(genRand);
				if (Main.starGame)
				{
					num545 = (int)((double)num545 * Main.starGameMath(0.2));
				}
				int num546 = random6 + random7 + num545 + random8;
				int num547 = 10000;
				for (int num548 = 0; num548 < num545; num548++)
				{
					if (num547 <= 0)
					{
						break;
					}
					progress.Set((double)num548 / (double)num546);
					int num549 = genRand.Next(20, Main.maxTilesX - 20);
					int num550 = genRand.Next((int)((GenVars.worldSurfaceHigh + 20.0 + Main.rockLayer) / 2.0), Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						num550 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
					}
					ushort wall = Main.tile[num549, num550].wall;
					if (Main.wallDungeon[wall] || wall == 87 || oceanDepths(num549, num550) || !AddBuriedChest(num549, num550, 0, notNearOtherChests: false, -1, trySlope: false, 0))
					{
						num547--;
						num548--;
					}
				}
				num547 = 10000;
				for (int num551 = 0; num551 < random7; num551++)
				{
					if (num547 <= 0)
					{
						break;
					}
					progress.Set((double)(num551 + num545) / (double)num546);
					int num552 = genRand.Next(20, Main.maxTilesX - 20);
					int num553 = genRand.Next(Main.UnderworldLayer, Main.maxTilesY - 50);
					if (Main.wallDungeon[Main.tile[num552, num553].wall] || !AddBuriedChest(num552, num553, 0, notNearOtherChests: false, -1, trySlope: false, 0))
					{
						num547--;
						num551--;
					}
				}
				num547 = 10000;
				for (int num554 = 0; num554 < random6; num554++)
				{
					if (num547 <= 0)
					{
						break;
					}
					progress.Set((double)(num554 + num545 + random7) / (double)num546);
					int x11 = genRand.Next(80, Main.maxTilesX - 80);
					int y9 = genRand.Next((int)(GenVars.worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						y9 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 400);
					}
					if (oceanDepths(x11, y9) || !caveHouseBiome.Place(new Point(x11, y9), GenVars.structures))
					{
						num547--;
						num554--;
					}
				}
				num547 = 10000;
				Rectangle undergroundDesertHiveLocation = GenVars.UndergroundDesertHiveLocation;
				if ((double)undergroundDesertHiveLocation.Y < Main.worldSurface + 26.0)
				{
					int num555 = (int)Main.worldSurface + 26 - undergroundDesertHiveLocation.Y;
					undergroundDesertHiveLocation.Y += num555;
					undergroundDesertHiveLocation.Height -= num555;
				}
				for (int num556 = 0; num556 < random8; num556++)
				{
					if (num547 <= 0)
					{
						break;
					}
					progress.Set((double)(num556 + num545 + random7 + random6) / (double)num546);
					if (!caveHouseBiome.Place(RandomRectanglePoint(undergroundDesertHiveLocation), GenVars.structures))
					{
						num547--;
						num556--;
					}
				}
				Main.tileSolid[226] = false;
				Main.tileSolid[162] = false;
				Main.tileSolid[225] = false;
			});
			AddGenerationPass("Surface Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[31].Value;
				for (int num535 = 0; num535 < (int)((double)Main.maxTilesX * 0.005); num535++)
				{
					double value8 = (double)num535 / ((double)Main.maxTilesX * 0.005);
					progress.Set(value8);
					bool flag30 = false;
					int num536 = 0;
					while (!flag30)
					{
						int num537 = genRand.Next(200, Main.maxTilesX - 200);
						int num538 = genRand.Next((int)GenVars.worldSurfaceLow, (int)Main.worldSurface);
						if (remixWorldGen)
						{
							num538 = genRand.Next(Main.maxTilesY - 400, Main.maxTilesY - 150);
						}
						else
						{
							while (oceanDepths(num537, num538))
							{
								num537 = genRand.Next(300, Main.maxTilesX - 300);
								num538 = genRand.Next((int)GenVars.worldSurfaceLow, (int)Main.worldSurface);
							}
						}
						bool flag31 = false;
						if (!Main.tile[num537, num538].active())
						{
							if (Main.tile[num537, num538].wall == 2 || Main.tile[num537, num538].wall == 59 || Main.tile[num537, num538].wall == 244 || remixWorldGen)
							{
								flag31 = true;
							}
						}
						else
						{
							int num539 = 50;
							int num540 = num537;
							int num541 = num538;
							int num542 = 1;
							for (int num543 = num540 - num539; num543 <= num540 + num539; num543 += 2)
							{
								for (int num544 = num541 - num539; num544 <= num541 + num539; num544 += 2)
								{
									if ((double)num544 < Main.worldSurface && !Main.tile[num543, num544].active() && Main.tile[num543, num544].wall == 244 && genRand.Next(num542) == 0)
									{
										num542++;
										flag31 = true;
										num537 = num543;
										num538 = num544;
									}
								}
							}
						}
						if (flag31 && AddBuriedChest(num537, num538, 0, notNearOtherChests: true, -1, trySlope: false, 0))
						{
							flag30 = true;
						}
						else
						{
							num536++;
							if (num536 >= 2000)
							{
								flag30 = true;
							}
						}
					}
				}
			});
			AddGenerationPass("Jungle Chests Placement", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[32].Value;
				for (int num530 = 0; num530 < GenVars.numJChests; num530++)
				{
					double value7 = (double)num530 / (double)GenVars.numJChests;
					progress.Set(value7);
					int nextJungleChestItem = GetNextJungleChestItem();
					if (!AddBuriedChest(GenVars.JChestX[num530] + genRand.Next(2), GenVars.JChestY[num530], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0))
					{
						for (int num531 = GenVars.JChestX[num530] - 1; num531 <= GenVars.JChestX[num530] + 1; num531++)
						{
							for (int num532 = GenVars.JChestY[num530]; num532 <= GenVars.JChestY[num530] + 2; num532++)
							{
								KillTile(num531, num532);
							}
						}
						for (int num533 = GenVars.JChestX[num530] - 1; num533 <= GenVars.JChestX[num530] + 1; num533++)
						{
							for (int num534 = GenVars.JChestY[num530]; num534 <= GenVars.JChestY[num530] + 3; num534++)
							{
								if (num534 < Main.maxTilesY)
								{
									Main.tile[num533, num534].slope(0);
									Main.tile[num533, num534].halfBrick(halfBrick: false);
								}
							}
						}
						AddBuriedChest(GenVars.JChestX[num530], GenVars.JChestY[num530], nextJungleChestItem, notNearOtherChests: false, 10, trySlope: false, 0);
					}
				}
			});
			AddGenerationPass("Water Chests", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[33].Value;
				for (int num517 = 0; num517 < GenVars.numOceanCaveTreasure; num517++)
				{
					int contain = genRand.NextFromList(new short[5] { 863, 186, 277, 187, 4404 });
					bool flag28 = false;
					double num518 = 2.0;
					while (!flag28 && num518 < 50.0)
					{
						num518 += 0.1;
						int num519 = genRand.Next(GenVars.oceanCaveTreasure[num517].X - (int)num518, GenVars.oceanCaveTreasure[num517].X + (int)num518 + 1);
						int num520 = genRand.Next(GenVars.oceanCaveTreasure[num517].Y - (int)num518 / 2, GenVars.oceanCaveTreasure[num517].Y + (int)num518 / 2 + 1);
						num519 = ((num519 >= Main.maxTilesX) ? ((int)((double)num519 + num518 / 2.0)) : ((int)((double)num519 - num518 / 2.0)));
						if (Main.tile[num519, num520].liquid > 250 && (Main.tile[num519, num520].liquidType() == 0 || notTheBees || remixWorldGen))
						{
							flag28 = AddBuriedChest(num519, num520, contain, notNearOtherChests: false, 17, trySlope: true, 0);
						}
					}
				}
				int num521 = 0;
				double num522 = (double)Main.maxTilesX / 4200.0;
				for (int num523 = 0; (double)num523 < 9.0 * num522; num523++)
				{
					double value6 = (double)num523 / (9.0 * num522);
					progress.Set(value6);
					int num524 = 0;
					num521++;
					int maxValue8 = 10;
					if (tenthAnniversaryWorldGen)
					{
						maxValue8 = 7;
					}
					if (genRand.Next(maxValue8) == 0)
					{
						num524 = 863;
					}
					else
					{
						switch (num521)
						{
						case 1:
							num524 = 186;
							break;
						case 2:
							num524 = 4404;
							break;
						case 3:
							num524 = 277;
							break;
						default:
							num524 = 187;
							num521 = 0;
							break;
						}
					}
					bool flag29 = false;
					int num525 = 0;
					while (!flag29)
					{
						int num526 = genRand.Next(50, Main.maxTilesX - 50);
						int num527 = genRand.Next(1, Main.UnderworldLayer);
						while (Main.tile[num526, num527].liquid < 250 || (Main.tile[num526, num527].liquidType() != 0 && !notTheBees && !remixWorldGen))
						{
							num526 = genRand.Next(50, Main.maxTilesX - 50);
							num527 = genRand.Next(50, Main.UnderworldLayer);
						}
						flag29 = AddBuriedChest(num526, num527, num524, notNearOtherChests: false, 17, num526 < beachDistance || num526 > Main.maxTilesX - beachDistance, 0);
						num525++;
						if (num525 > 10000)
						{
							break;
						}
					}
					flag29 = false;
					num525 = 0;
					while (!flag29)
					{
						int num528 = genRand.Next(50, Main.maxTilesX - 50);
						int num529 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
						while (Main.tile[num528, num529].liquid < 250 || (Main.tile[num528, num529].liquidType() != 0 && !notTheBees))
						{
							num528 = genRand.Next(50, Main.maxTilesX - 50);
							num529 = genRand.Next((int)Main.worldSurface, Main.UnderworldLayer);
						}
						flag29 = AddBuriedChest(num528, num529, num524, notNearOtherChests: false, 17, num528 < beachDistance || num528 > Main.maxTilesX - beachDistance, 0);
						num525++;
						if (num525 > 10000)
						{
							break;
						}
					}
				}
			});
			AddGenerationPass("Spider Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[64].Value;
				maxTileCount = 3500;
				int num512 = Main.maxTilesX / 2;
				int num513 = (int)((double)Main.maxTilesX * 0.005);
				if (getGoodWorldGen)
				{
					num513 *= 3;
				}
				if (notTheBees)
				{
					Main.tileSolid[225] = true;
				}
				for (int num514 = 0; num514 < num513; num514++)
				{
					double value5 = (double)num514 / ((double)Main.maxTilesX * 0.005);
					progress.Set(value5);
					int num515 = 0;
					int x10 = genRand.Next(200, Main.maxTilesX - 200);
					int y8 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
					if (remixWorldGen)
					{
						y8 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
					}
					int num516 = countTiles(x10, y8, jungle: false, lavaOk: true);
					while ((num516 >= 3500 || num516 < 500) && num515 < num512)
					{
						num515++;
						x10 = genRand.Next(200, Main.maxTilesX - 200);
						y8 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						if (remixWorldGen)
						{
							y8 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
						}
						num516 = countTiles(x10, y8, jungle: false, lavaOk: true);
						if (shroomCount > 1)
						{
							num516 = 0;
						}
					}
					if (num515 < num512)
					{
						Spread.Spider(x10, y8);
					}
				}
				if (notTheBees)
				{
					Main.tileSolid[225] = false;
				}
				Main.tileSolid[162] = true;
			});
			AddGenerationPass("Gem Caves", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees)
				{
					progress.Message = Lang.gen[64].Value;
					maxTileCount = 300;
					double num508 = (double)Main.maxTilesX * 0.003;
					if (tenthAnniversaryWorldGen)
					{
						num508 *= 1.5;
					}
					if (Main.starGame)
					{
						num508 *= Main.starGameMath(0.2);
					}
					for (int num509 = 0; (double)num509 < num508; num509++)
					{
						double value4 = (double)num509 / num508;
						progress.Set(value4);
						int num510 = 0;
						int x9 = genRand.Next(200, Main.maxTilesX - 200);
						int y7 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
						if (remixWorldGen)
						{
							y7 = genRand.Next((int)Main.worldSurface + 30, (int)Main.rockLayer - 30);
						}
						int num511 = countTiles(x9, y7);
						while ((num511 >= 300 || num511 < 50 || lavaCount > 0 || iceCount > 0 || rockCount == 0) && num510 < 1000)
						{
							num510++;
							x9 = genRand.Next(200, Main.maxTilesX - 200);
							y7 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
							if (remixWorldGen)
							{
								y7 = genRand.Next((int)Main.worldSurface + 30, (int)Main.rockLayer - 30);
							}
							num511 = countTiles(x9, y7);
						}
						if (num510 < 1000)
						{
							gemCave(x9, y7);
						}
					}
				}
			});
			AddGenerationPass("Moss", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				//IL_0393: Unknown result type (might be due to invalid IL or missing references)
				//IL_0398: Unknown result type (might be due to invalid IL or missing references)
				//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
				//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
				//IL_05be: Unknown result type (might be due to invalid IL or missing references)
				//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
				if (!notTheBees || remixWorldGen)
				{
					progress.Message = Lang.gen[61].Value;
					randMoss();
					int num478 = Main.maxTilesX / 2100;
					if (remixWorldGen)
					{
						num478 = (int)((double)num478 * 1.5);
					}
					else if (tenthAnniversaryWorldGen)
					{
						num478 *= 2;
					}
					int num479 = 0;
					int num480 = 0;
					while (num480 < num478)
					{
						int num481 = genRand.Next(100, Main.maxTilesX - 100);
						if (remixWorldGen)
						{
							num481 = genRand.Next((int)((double)Main.maxTilesX * 0.3), (int)((double)Main.maxTilesX * 0.7));
						}
						else if (tenthAnniversaryWorldGen)
						{
							if (genRand.Next(2) == 0)
							{
								randMoss(justNeon: true);
							}
						}
						else if (getGoodWorldGen)
						{
							while ((double)num481 > (double)Main.maxTilesX * 0.42 && (double)num481 < (double)Main.maxTilesX * 0.48)
							{
								num481 = genRand.Next(100, Main.maxTilesX - 100);
							}
						}
						else if (!drunkWorldGen)
						{
							while ((double)num481 > (double)Main.maxTilesX * 0.38 && (double)num481 < (double)Main.maxTilesX * 0.62)
							{
								num481 = genRand.Next(100, Main.maxTilesX - 100);
							}
						}
						int num482 = ((!remixWorldGen) ? genRand.Next((int)Main.rockLayer + 40, GenVars.lavaLine - 40) : genRand.Next((int)Main.worldSurface + 50, (int)Main.rockLayer - 50));
						bool flag27 = false;
						int num483 = 50;
						for (int num484 = num481 - num483; num484 <= num481 + num483; num484++)
						{
							for (int num485 = num482 - num483; num485 <= num482 + num483; num485++)
							{
								if (Main.tile[num484, num485].active())
								{
									int type6 = Main.tile[num484, num485].type;
									if (remixWorldGen)
									{
										if (type6 == 60 || type6 == 161 || type6 == 147 || Main.tileDungeon[type6] || type6 == 25 || type6 == 203)
										{
											flag27 = true;
											num484 = num481 + num483 + 1;
											break;
										}
									}
									else if (type6 == 70 || type6 == 60 || type6 == 367 || type6 == 368 || type6 == 161 || type6 == 147 || type6 == 396 || type6 == 397 || Main.tileDungeon[type6])
									{
										flag27 = true;
										num484 = num481 + num483 + 1;
										break;
									}
								}
							}
						}
						if (flag27)
						{
							num479++;
							if (num479 > Main.maxTilesX)
							{
								num480++;
							}
						}
						else
						{
							num479 = 0;
							num480++;
							int maxY = GenVars.lavaLine;
							if (remixWorldGen)
							{
								maxY = (int)Main.rockLayer + 50;
							}
							neonMossBiome(num481, num482, maxY);
						}
					}
					maxTileCount = 2500;
					for (int num486 = 0; num486 < (int)((double)Main.maxTilesX * 0.01); num486++)
					{
						double value3 = (double)num486 / ((double)Main.maxTilesX * 0.01);
						progress.Set(value3);
						int num487 = 0;
						int num488 = genRand.Next(200, Main.maxTilesX - 200);
						int num489 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.waterLine);
						if (remixWorldGen)
						{
							num489 = genRand.Next((int)Main.worldSurface, (int)Main.rockLayer);
						}
						if (!(Vector2D.Distance(new Vector2D((double)num488, (double)num489), GenVars.shimmerPosition) < (double)shimmerSafetyDistance))
						{
							int num490 = countTiles(num488, num489);
							while ((num490 >= 2500 || num490 < 10 || lavaCount > 0 || iceCount > 0 || rockCount == 0 || shroomCount > 0) && num487 < 1000)
							{
								num487++;
								num488 = genRand.Next(200, Main.maxTilesX - 200);
								num489 = genRand.Next((int)Main.rockLayer + 30, Main.maxTilesY - 230);
								num490 = countTiles(num488, num489);
							}
							if (num487 < 1000)
							{
								setMoss(num488, num489);
								Spread.Moss(num488, num489);
							}
						}
					}
					for (int num491 = 0; num491 < Main.maxTilesX; num491++)
					{
						int num492 = genRand.Next(50, Main.maxTilesX - 50);
						int num493 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
						if (!(Vector2D.Distance(new Vector2D((double)num492, (double)num493), GenVars.shimmerPosition) < (double)shimmerSafetyDistance) && Main.tile[num492, num493].type == 1)
						{
							setMoss(num492, num493);
							Main.tile[num492, num493].type = GenVars.mossTile;
						}
					}
					double num494 = (double)Main.maxTilesX * 0.05;
					while (num494 > 0.0)
					{
						int num495 = genRand.Next(50, Main.maxTilesX - 50);
						int num496 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
						if (!(Vector2D.Distance(new Vector2D((double)num495, (double)num496), GenVars.shimmerPosition) < (double)shimmerSafetyDistance) && Main.tile[num495, num496].type == 1 && (!Main.tile[num495 - 1, num496].active() || !Main.tile[num495 + 1, num496].active() || !Main.tile[num495, num496 - 1].active() || !Main.tile[num495, num496 + 1].active()))
						{
							setMoss(num495, num496);
							Main.tile[num495, num496].type = GenVars.mossTile;
							num494 -= 1.0;
						}
					}
					num494 = (double)Main.maxTilesX * 0.065;
					if (remixWorldGen)
					{
						num494 *= 2.0;
					}
					while (num494 > 0.0)
					{
						int num497 = genRand.Next(50, Main.maxTilesX - 50);
						int num498 = ((!remixWorldGen) ? genRand.Next(GenVars.waterLine, Main.UnderworldLayer) : genRand.Next(GenVars.lavaLine, (int)Main.rockLayer + 50));
						if (Main.tile[num497, num498].type == 1 && (!Main.tile[num497 - 1, num498].active() || !Main.tile[num497 + 1, num498].active() || !Main.tile[num497, num498 - 1].active() || !Main.tile[num497, num498 + 1].active()))
						{
							int num499 = 25;
							int num500 = 0;
							for (int num501 = num497 - num499; num501 < num497 + num499; num501++)
							{
								for (int num502 = num498 - num499; num502 < num498 + num499; num502++)
								{
									if (Main.tile[num501, num502].liquid > 0 && Main.tile[num501, num502].lava())
									{
										num500++;
									}
								}
							}
							if (num500 > 20)
							{
								Main.tile[num497, num498].type = 381;
								num494 -= 1.0;
							}
							else
							{
								num494 -= 0.002;
							}
						}
						num494 -= 0.001;
					}
					for (int num503 = 0; num503 < Main.maxTilesX; num503++)
					{
						for (int num504 = 0; num504 < Main.maxTilesY; num504++)
						{
							if (Main.tile[num503, num504].active() && Main.tileMoss[Main.tile[num503, num504].type])
							{
								for (int num505 = 0; num505 < 4; num505++)
								{
									int num506 = num503;
									int num507 = num504;
									if (num505 == 0)
									{
										num506--;
									}
									if (num505 == 1)
									{
										num506++;
									}
									if (num505 == 2)
									{
										num507--;
									}
									if (num505 == 3)
									{
										num507++;
									}
									try
									{
										grassSpread = 0;
										SpreadGrass(num506, num507, 1, Main.tile[num503, num504].type);
									}
									catch
									{
										grassSpread = 0;
										SpreadGrass(num506, num507, 1, Main.tile[num503, num504].type, repeat: false);
									}
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Temple", delegate
			{
				Main.tileSolid[162] = false;
				Main.tileSolid[226] = true;
				templePart2();
				Main.tileSolid[232] = false;
			});
			AddGenerationPass("Cave Walls", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[63].Value;
				maxTileCount = 1500;
				for (int num462 = 0; num462 < (int)((double)Main.maxTilesX * 0.04); num462++)
				{
					double num463 = (double)num462 / ((double)Main.maxTilesX * 0.04);
					progress.Set(num463 * 0.66);
					int num464 = 0;
					int x7 = genRand.Next(200, Main.maxTilesX - 200);
					int y5 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
					if (remixWorldGen)
					{
						y5 = genRand.Next((int)Main.worldSurface + 25, (int)Main.rockLayer);
					}
					int num465 = countTiles(x7, y5, jungle: false, lavaOk: true);
					while ((num465 >= maxTileCount || num465 < 10) && num464 < 500)
					{
						num464++;
						x7 = genRand.Next(200, Main.maxTilesX - 200);
						y5 = genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
						if (remixWorldGen)
						{
							y5 = genRand.Next((int)Main.worldSurface + 25, (int)Main.rockLayer);
						}
						num465 = countTiles(x7, y5, jungle: false, lavaOk: true);
					}
					if (num464 < 500)
					{
						int num466 = genRand.Next(2);
						if ((double)shroomCount > (double)rockCount * 0.75)
						{
							num466 = 80;
						}
						else if (iceCount > 0)
						{
							switch (num466)
							{
							case 0:
								num466 = 40;
								break;
							case 1:
								num466 = 71;
								break;
							}
						}
						else if (lavaCount > 0)
						{
							num466 = 79;
						}
						else
						{
							num466 = genRand.Next(4);
							switch (num466)
							{
							case 0:
								num466 = 59;
								break;
							case 1:
								num466 = 61;
								break;
							case 2:
								num466 = 170;
								break;
							case 3:
								num466 = 171;
								break;
							}
						}
						Spread.Wall(x7, y5, num466);
					}
				}
				if (remixWorldGen)
				{
					maxTileCount = 1500;
					for (int num467 = 0; num467 < (int)((double)Main.maxTilesX * 0.04); num467++)
					{
						double num468 = (double)num467 / ((double)Main.maxTilesX * 0.04);
						progress.Set(num468 * 0.66);
						int num469 = 0;
						int x8 = genRand.Next(200, Main.maxTilesX - 200);
						int y6 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						int num470 = countTiles(x8, y6, jungle: false, lavaOk: true);
						while ((num470 >= maxTileCount || num470 < 10) && num469 < 500)
						{
							num469++;
							x8 = genRand.Next(200, Main.maxTilesX - 200);
							y6 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
							num470 = countTiles(x8, y6, jungle: false, lavaOk: true);
						}
						if (num469 < 500 && iceCount == 0 && lavaCount == 0 && sandCount == 0)
						{
							int wallType2 = ((genRand.Next(2) != 0) ? 63 : 2);
							Spread.Wall(x8, y6, wallType2);
						}
					}
				}
				maxTileCount = 1500;
				double num471 = (double)Main.maxTilesX * 0.02;
				for (int num472 = 0; (double)num472 < num471; num472++)
				{
					double num473 = (double)num472 / ((double)Main.maxTilesX * 0.02);
					progress.Set(num473 * 0.33 + 0.66);
					int num474 = 0;
					int num475 = genRand.Next(200, Main.maxTilesX - 200);
					int num476 = genRand.Next((int)Main.worldSurface, GenVars.lavaLine);
					int num477 = 0;
					if (Main.tile[num475, num476].wall == 64)
					{
						num477 = countTiles(num475, num476, jungle: true);
					}
					while ((num477 >= maxTileCount || num477 < 10) && num474 < 1000)
					{
						num474++;
						num475 = genRand.Next(200, Main.maxTilesX - 200);
						num476 = genRand.Next((int)Main.worldSurface, GenVars.lavaLine);
						if (!Main.wallHouse[Main.tile[num475, num476].wall] && Main.tile[num475, num476].wall != 244)
						{
							num477 = ((Main.tile[num475, num476].wall == 64) ? countTiles(num475, num476, jungle: true) : 0);
						}
					}
					if (num474 < 1000)
					{
						Spread.Wall2(num475, num476, 15);
					}
				}
			});
			AddGenerationPass("Jungle Trees", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[83].Value;
				for (int num460 = 0; num460 < Main.maxTilesX; num460++)
				{
					progress.Set((double)num460 / (double)Main.maxTilesX);
					for (int num461 = (int)Main.worldSurface - 1; num461 < Main.maxTilesY - 350; num461++)
					{
						if (genRand.Next(10) == 0 || drunkWorldGen)
						{
							GrowUndergroundTree(num460, num461);
						}
					}
				}
			});
			AddGenerationPass("Floating Island Houses", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num459 = 0; num459 < GenVars.numIslandHouses; num459++)
				{
					if (!GenVars.skyLake[num459])
					{
						IslandHouse(GenVars.floatingIslandHouseX[num459], GenVars.floatingIslandHouseY[num459], GenVars.floatingIslandStyle[num459]);
					}
				}
			});
			AddGenerationPass("Quick Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				if (notTheBees)
				{
					NotTheBees();
				}
				Main.tileSolid[137] = false;
				Main.tileSolid[130] = false;
				for (int num452 = 20; num452 < Main.maxTilesX - 20; num452++)
				{
					for (int num453 = 20; num453 < Main.maxTilesY - 20; num453++)
					{
						if ((double)num453 < Main.worldSurface && oceanDepths(num452, num453) && Main.tile[num452, num453].type == 53 && Main.tile[num452, num453].active())
						{
							if (Main.tile[num452, num453].bottomSlope())
							{
								Main.tile[num452, num453].slope(0);
							}
							for (int num454 = num453 + 1; num454 < num453 + genRand.Next(4, 7) && (!Main.tile[num452, num454].active() || (Main.tile[num452, num454].type != 397 && Main.tile[num452, num454].type != 53)) && (!Main.tile[num452, num454 + 1].active() || (Main.tile[num452, num454 + 1].type != 397 && Main.tile[num452, num454 + 1].type != 53 && Main.tile[num452, num454 + 1].type != 495)) && (!Main.tile[num452, num454 + 2].active() || (Main.tile[num452, num454 + 2].type != 397 && Main.tile[num452, num454 + 2].type != 53 && Main.tile[num452, num454 + 2].type != 495)); num454++)
							{
								Main.tile[num452, num454].type = 0;
								Main.tile[num452, num454].active(active: true);
								Main.tile[num452, num454].halfBrick(halfBrick: false);
								Main.tile[num452, num454].slope(0);
							}
						}
						if (Main.tile[num452, num453].wall == 187 || Main.tile[num452, num453].wall == 216)
						{
							if (Main.tile[num452, num453].type == 59 || Main.tile[num452, num453].type == 123 || Main.tile[num452, num453].type == 224)
							{
								Main.tile[num452, num453].type = 397;
							}
							if (Main.tile[num452, num453].type == 368 || Main.tile[num452, num453].type == 367)
							{
								Main.tile[num452, num453].type = 397;
							}
							if ((double)num453 <= Main.rockLayer)
							{
								Main.tile[num452, num453].liquid = 0;
							}
							else if (Main.tile[num452, num453].liquid > 0)
							{
								Main.tile[num452, num453].liquid = byte.MaxValue;
								Main.tile[num452, num453].lava(lava: true);
							}
						}
						if ((double)num453 < Main.worldSurface && Main.tile[num452, num453].active() && Main.tile[num452, num453].type == 53 && Main.tile[num452, num453 + 1].wall == 0 && !SolidTile(num452, num453 + 1))
						{
							ushort num455 = 0;
							int num456 = 3;
							for (int num457 = num452 - num456; num457 <= num452 + num456; num457++)
							{
								for (int num458 = num453 - num456; num458 <= num453 + num456; num458++)
								{
									if (Main.tile[num457, num458].wall > 0)
									{
										num455 = Main.tile[num457, num458].wall;
										break;
									}
								}
							}
							if (num455 > 0)
							{
								Main.tile[num452, num453 + 1].wall = num455;
								if (Main.tile[num452, num453].wall == 0)
								{
									Main.tile[num452, num453].wall = num455;
								}
							}
						}
						if (Main.tile[num452, num453].type != 19 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[num452, num453].type])
						{
							if (Main.tile[num452, num453].topSlope() || Main.tile[num452, num453].halfBrick())
							{
								if (Main.tile[num452, num453].type != 225 || !Main.tile[num452, num453].halfBrick())
								{
									if (!SolidTile(num452, num453 + 1))
									{
										Main.tile[num452, num453].active(active: false);
									}
									if (Main.tile[num452 + 1, num453].type == 137 || Main.tile[num452 - 1, num453].type == 137)
									{
										Main.tile[num452, num453].active(active: false);
									}
								}
							}
							else if (Main.tile[num452, num453].bottomSlope())
							{
								if (!SolidTile(num452, num453 - 1))
								{
									Main.tile[num452, num453].active(active: false);
								}
								if (Main.tile[num452 + 1, num453].type == 137 || Main.tile[num452 - 1, num453].type == 137)
								{
									Main.tile[num452, num453].active(active: false);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Pots", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				Main.tileSolid[137] = true;
				Main.tileSolid[130] = true;
				progress.Message = Lang.gen[35].Value;
				if (noTrapsWorldGen)
				{
					Main.tileSolid[138] = true;
					int num439 = (int)((double)(Main.maxTilesX * Main.maxTilesY) * 0.0004);
					if (remixWorldGen)
					{
						num439 /= 2;
					}
					for (int num440 = 0; num440 < num439; num440++)
					{
						int num441 = genRand.Next(50, Main.maxTilesX - 50);
						int num442;
						for (num442 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 250); !Main.tile[num441, num442].active() && num442 < Main.maxTilesY - 250; num442++)
						{
						}
						num442--;
						if (!Main.tile[num441, num442].shimmer())
						{
							PlaceTile(num441, num442, 138, mute: true);
							PlaceTile(num441 + 2, num442, 138, mute: true);
							PlaceTile(num441 + 1, num442 - 2, 138, mute: true);
						}
					}
					Main.tileSolid[138] = false;
				}
				double num443 = (double)(Main.maxTilesX * Main.maxTilesY) * 0.0008;
				if (Main.starGame)
				{
					num443 *= Main.starGameMath(0.2);
				}
				for (int num444 = 0; (double)num444 < num443; num444++)
				{
					double num445 = (double)num444 / num443;
					progress.Set(num445);
					bool flag25 = false;
					int num446 = 0;
					while (!flag25)
					{
						int num447 = genRand.Next((int)GenVars.worldSurfaceHigh, Main.maxTilesY - 10);
						if (num445 > 0.93)
						{
							num447 = Main.maxTilesY - 150;
						}
						else if (num445 > 0.75)
						{
							num447 = (int)GenVars.worldSurfaceLow;
						}
						int num448 = genRand.Next(20, Main.maxTilesX - 20);
						bool flag26 = false;
						for (int num449 = num447; num449 < Main.maxTilesY - 20; num449++)
						{
							if (!flag26)
							{
								if (Main.tile[num448, num449].active() && Main.tileSolid[Main.tile[num448, num449].type] && !Main.tile[num448, num449 - 1].lava() && !Main.tile[num448, num449 - 1].shimmer())
								{
									flag26 = true;
								}
							}
							else if (!((double)num449 < Main.worldSurface) || Main.tile[num448, num449].wall != 0)
							{
								int style = genRand.Next(0, 4);
								int num450 = 0;
								int num451 = 0;
								if (num449 < Main.maxTilesY - 5)
								{
									num450 = Main.tile[num448, num449 + 1].type;
									num451 = Main.tile[num448, num449].wall;
								}
								if (num450 == 147 || num450 == 161 || num450 == 162)
								{
									style = genRand.Next(4, 7);
								}
								if (num450 == 60)
								{
									style = genRand.Next(7, 10);
								}
								if (Main.wallDungeon[Main.tile[num448, num449].wall])
								{
									style = genRand.Next(10, 13);
								}
								if (num450 == 41 || num450 == 43 || num450 == 44 || num450 == 481 || num450 == 482 || num450 == 483)
								{
									style = genRand.Next(10, 13);
								}
								if (num450 == 22 || num450 == 23 || num450 == 25)
								{
									style = genRand.Next(16, 19);
								}
								if (num450 == 199 || num450 == 203 || num450 == 204 || num450 == 200)
								{
									style = genRand.Next(22, 25);
								}
								if (num450 == 367)
								{
									style = genRand.Next(31, 34);
								}
								if (num450 == 226)
								{
									style = genRand.Next(28, 31);
								}
								if (num451 == 187 || num451 == 216)
								{
									style = genRand.Next(34, 37);
								}
								if (num449 > Main.UnderworldLayer)
								{
									style = genRand.Next(13, 16);
								}
								if (!oceanDepths(num448, num449) && !Main.tile[num448, num449].shimmer() && PlacePot(num448, num449, 28, style))
								{
									flag25 = true;
									break;
								}
								num446++;
								if (num446 >= 10000)
								{
									flag25 = true;
									break;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Hellforge", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[36].Value;
				for (int num435 = 0; num435 < Main.maxTilesX / 200; num435++)
				{
					double value2 = (double)num435 / (double)(Main.maxTilesX / 200);
					progress.Set(value2);
					bool flag24 = false;
					int num436 = 0;
					while (!flag24)
					{
						int num437 = genRand.Next(1, Main.maxTilesX);
						int num438 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 30);
						try
						{
							if (Main.tile[num437, num438].wall == 13 || Main.tile[num437, num438].wall == 14)
							{
								for (; !Main.tile[num437, num438].active() && num438 < Main.maxTilesY - 20; num438++)
								{
								}
								num438--;
								PlaceTile(num437, num438, 77);
								if (Main.tile[num437, num438].type == 77)
								{
									flag24 = true;
								}
								else
								{
									num436++;
									if (num436 >= 10000)
									{
										flag24 = true;
									}
								}
							}
						}
						catch
						{
							num436++;
							if (num436 >= 10000)
							{
								flag24 = true;
							}
						}
					}
				}
			});
			AddGenerationPass("Spreading Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees || remixWorldGen)
				{
					progress.Message = Lang.gen[37].Value;
					for (int num413 = 50; num413 < Main.maxTilesX - 50; num413++)
					{
						for (int num414 = 50; (double)num414 <= Main.worldSurface; num414++)
						{
							if (Main.tile[num413, num414].active())
							{
								int type5 = Main.tile[num413, num414].type;
								if (Main.tile[num413, num414].active() && type5 == 60)
								{
									for (int num415 = num413 - 1; num415 <= num413 + 1; num415++)
									{
										for (int num416 = num414 - 1; num416 <= num414 + 1; num416++)
										{
											if (Main.tile[num415, num416].active() && Main.tile[num415, num416].type == 0)
											{
												if (!Main.tile[num415, num416 - 1].active())
												{
													Main.tile[num415, num416].type = 60;
												}
												else
												{
													Main.tile[num415, num416].type = 59;
												}
											}
										}
									}
								}
								else if (type5 == 1 || type5 == 40 || TileID.Sets.Ore[type5])
								{
									int num417 = 3;
									bool flag22 = false;
									ushort num418 = 0;
									for (int num419 = num413 - num417; num419 <= num413 + num417; num419++)
									{
										for (int num420 = num414 - num417; num420 <= num414 + num417; num420++)
										{
											if (Main.tile[num419, num420].active())
											{
												if (Main.tile[num419, num420].type == 53 || num418 == 53)
												{
													num418 = 53;
												}
												else if (Main.tile[num419, num420].type == 59 || Main.tile[num419, num420].type == 60 || Main.tile[num419, num420].type == 147 || Main.tile[num419, num420].type == 161 || Main.tile[num419, num420].type == 199 || Main.tile[num419, num420].type == 23)
												{
													num418 = Main.tile[num419, num420].type;
												}
											}
											else if (num420 < num414 && Main.tile[num419, num420].wall == 0)
											{
												flag22 = true;
											}
										}
									}
									if (flag22)
									{
										switch (num418)
										{
										case 23:
										case 199:
											if (Main.tile[num413, num414 - 1].active())
											{
												num418 = 0;
											}
											break;
										case 59:
										case 60:
											if (num413 >= GenVars.jungleMinX && num413 <= GenVars.jungleMaxX)
											{
												num418 = (ushort)(Main.tile[num413, num414 - 1].active() ? 59 : 60);
											}
											break;
										}
										Main.tile[num413, num414].type = num418;
									}
								}
							}
						}
					}
					for (int num421 = 10; num421 < Main.maxTilesX - 10; num421++)
					{
						bool flag23 = true;
						for (int num422 = 0; (double)num422 < Main.worldSurface - 1.0; num422++)
						{
							if (Main.tile[num421, num422].active())
							{
								if (flag23 && Main.tile[num421, num422].type == 0)
								{
									try
									{
										grassSpread = 0;
										SpreadGrass(num421, num422);
									}
									catch
									{
										grassSpread = 0;
										SpreadGrass(num421, num422, 0, 2, repeat: false);
									}
								}
								if ((double)num422 > GenVars.worldSurfaceHigh)
								{
									break;
								}
								flag23 = false;
							}
							else if (Main.tile[num421, num422].wall == 0)
							{
								flag23 = true;
							}
						}
					}
					if (remixWorldGen)
					{
						for (int num423 = 5; num423 < Main.maxTilesX - 5; num423++)
						{
							for (int num424 = (int)GenVars.rockLayerLow + genRand.Next(-1, 2); num424 < Main.maxTilesY - 200; num424++)
							{
								if (Main.tile[num423, num424].type == 0 && Main.tile[num423, num424].active() && (!Main.tile[num423 - 1, num424 - 1].active() || !Main.tile[num423, num424 - 1].active() || !Main.tile[num423 + 1, num424 - 1].active() || !Main.tile[num423 - 1, num424].active() || !Main.tile[num423 + 1, num424].active() || !Main.tile[num423 - 1, num424 + 1].active() || !Main.tile[num423, num424 + 1].active() || !Main.tile[num423 + 1, num424 + 1].active()))
								{
									Main.tile[num423, num424].type = 2;
								}
							}
						}
						for (int num425 = 5; num425 < Main.maxTilesX - 5; num425++)
						{
							for (int num426 = (int)GenVars.rockLayerLow + genRand.Next(-1, 2); num426 < Main.maxTilesY - 200; num426++)
							{
								if (Main.tile[num425, num426].type == 2 && !Main.tile[num425, num426 - 1].active() && genRand.Next(20) == 0)
								{
									PlaceTile(num425, num426 - 1, 27, mute: true);
								}
							}
						}
						int conversionType = 1;
						if (crimson)
						{
							conversionType = 4;
						}
						int num427 = Main.maxTilesX / 7;
						for (int num428 = 10; num428 < Main.maxTilesX - 10; num428++)
						{
							for (int num429 = 10; num429 < Main.maxTilesY - 10; num429++)
							{
								if ((double)num429 < Main.worldSurface + (double)genRand.Next(3) || num428 < num427 + genRand.Next(3) || num428 >= Main.maxTilesX - num427 - genRand.Next(3))
								{
									if (drunkWorldGen)
									{
										if (GenVars.crimsonLeft)
										{
											if (num428 < Main.maxTilesX / 2 + genRand.Next(-2, 3))
											{
												Convert(num428, num429, 4, 1);
											}
											else
											{
												Convert(num428, num429, 1, 1);
											}
										}
										else if (num428 < Main.maxTilesX / 2 + genRand.Next(-2, 3))
										{
											Convert(num428, num429, 1, 1);
										}
										else
										{
											Convert(num428, num429, 4, 1);
										}
									}
									else
									{
										Convert(num428, num429, conversionType, 1);
									}
									Main.tile[num428, num429].color(0);
									Main.tile[num428, num429].wallColor(0);
								}
							}
						}
						if (remixWorldGen)
						{
							Main.tileSolid[225] = true;
							int num430 = (int)((double)Main.maxTilesX * 0.31);
							int num431 = (int)((double)Main.maxTilesX * 0.69);
							_ = Main.maxTilesY;
							int num432 = Main.maxTilesY - 135;
							_ = Main.maxTilesY;
							Liquid.QuickWater(-2);
							for (int num433 = num430; num433 < num431 + 15; num433++)
							{
								for (int num434 = Main.maxTilesY - 200; num434 < num432; num434++)
								{
									Main.tile[num433, num434].liquid = 0;
								}
							}
							Main.tileSolid[225] = false;
							Main.tileSolid[484] = false;
						}
					}
				}
			});
			AddGenerationPass("Surface Ore and Stone", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				int num404 = genRand.Next(Main.maxTilesX * 5 / 4200, Main.maxTilesX * 10 / 4200);
				for (int num405 = 0; num405 < num404; num405++)
				{
					int num406 = Main.maxTilesX / 420;
					while (num406 > 0)
					{
						num406--;
						int num407 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						while ((double)num407 >= (double)Main.maxTilesX * 0.48 && (double)num407 <= (double)Main.maxTilesX * 0.52)
						{
							num407 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						}
						int y3 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurface);
						bool flag20 = false;
						for (int num408 = 0; num408 < GenVars.numOrePatch; num408++)
						{
							if (Math.Abs(num407 - GenVars.orePatchX[num408]) < 200)
							{
								flag20 = true;
							}
						}
						if (!flag20 && OrePatch(num407, y3))
						{
							if (GenVars.numOrePatch < GenVars.maxOrePatch - 1)
							{
								GenVars.orePatchX[GenVars.numOrePatch] = num407;
								GenVars.numOrePatch++;
							}
							break;
						}
					}
				}
				num404 = genRand.Next(1, Main.maxTilesX * 7 / 4200);
				for (int num409 = 0; num409 < num404; num409++)
				{
					int num410 = Main.maxTilesX / 420;
					while (num410 > 0)
					{
						num410--;
						int num411 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						while ((double)num411 >= (double)Main.maxTilesX * 0.47 && (double)num411 <= (double)Main.maxTilesX * 0.53)
						{
							num411 = genRand.Next(beachDistance, Main.maxTilesX - beachDistance);
						}
						int y4 = genRand.Next((int)GenVars.worldSurfaceLow, (int)GenVars.worldSurface);
						bool flag21 = false;
						for (int num412 = 0; num412 < GenVars.numOrePatch; num412++)
						{
							if (Math.Abs(num411 - GenVars.orePatchX[num412]) < 100)
							{
								flag21 = true;
							}
						}
						if (!flag21 && StonePatch(num411, y4))
						{
							break;
						}
					}
				}
			});
			AddGenerationPass("Place Fallen Log", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[85].Value;
				int num390 = Main.maxTilesX / 2100;
				num390 = ((!remixWorldGen) ? (num390 + genRand.Next(-1, 2)) : (num390 + genRand.Next(0, 2)));
				for (int num391 = 0; num391 < num390; num391++)
				{
					progress.Set((double)num391 / (double)num390);
					int num392 = beachDistance + 20;
					int num393 = 50000;
					int num394 = 5000;
					while (num393 > 0)
					{
						num393--;
						int num395 = genRand.Next(num392, Main.maxTilesX - num392);
						int num396 = genRand.Next(10, (int)Main.worldSurface);
						if (remixWorldGen)
						{
							num396 = genRand.Next((int)GenVars.rockLayerLow, Main.maxTilesY - 350);
						}
						bool flag18 = false;
						if (num393 < num394)
						{
							flag18 = true;
						}
						if (num393 > num394 / 2)
						{
							while ((double)num395 > (double)Main.maxTilesX * 0.4 && (double)num395 < (double)Main.maxTilesX * 0.6)
							{
								num395 = genRand.Next(num392, Main.maxTilesX - num392);
							}
						}
						if (!Main.tile[num395, num396].active() && Main.tile[num395, num396].wall == 0)
						{
							bool flag19 = true;
							if (remixWorldGen)
							{
								for (; !Main.tile[num395, num396].active() && Main.tile[num395, num396].wall == 0 && num396 <= Main.maxTilesY - 350; num396++)
								{
								}
							}
							else
							{
								for (; !Main.tile[num395, num396].active() && Main.tile[num395, num396].wall == 0 && (double)num396 <= Main.worldSurface; num396++)
								{
								}
							}
							if ((double)num396 > Main.worldSurface - 10.0 && !remixWorldGen)
							{
								flag19 = false;
							}
							else if (!flag18)
							{
								int num397 = 50;
								for (int num398 = num395 - num397; num398 < num395 + num397; num398++)
								{
									if (num398 > 10 && num398 < Main.maxTilesX - 10)
									{
										for (int num399 = num396 - num397; num399 < num396 + num397; num399++)
										{
											if (num399 > 10 && num399 < Main.maxTilesY - 10)
											{
												int type4 = Main.tile[num398, num399].type;
												switch (type4)
												{
												case 189:
													flag19 = false;
													break;
												case 53:
													flag19 = false;
													break;
												default:
													if (Main.tileDungeon[type4])
													{
														flag19 = false;
													}
													else if (TileID.Sets.Crimson[type4])
													{
														flag19 = false;
													}
													else if (TileID.Sets.Corrupt[type4])
													{
														flag19 = false;
													}
													break;
												}
											}
										}
									}
								}
								if (flag19)
								{
									int num400 = 10;
									int num401 = 10;
									for (int num402 = num395 - num400; num402 < num395 + num400; num402++)
									{
										for (int num403 = num396 - num401; num403 < num396 - 1; num403++)
										{
											if (Main.tile[num402, num403].active() && Main.tileSolid[Main.tile[num402, num403].type])
											{
												flag19 = false;
											}
											if (Main.tile[num402, num403].wall != 0)
											{
												flag19 = false;
											}
										}
									}
								}
							}
							if (flag19 && (Main.tile[num395, num396 - 1].liquid == 0 || num393 < num394 / 5) && (Main.tile[num395, num396].type == 2 || (notTheBees && Main.tile[num395, num396].type == 60)) && (Main.tile[num395 - 1, num396].type == 2 || (notTheBees && Main.tile[num395 - 1, num396].type == 60)) && (Main.tile[num395 + 1, num396].type == 2 || (notTheBees && Main.tile[num395 + 1, num396].type == 60)))
							{
								num396--;
								PlaceTile(num395, num396, 488);
								if (Main.tile[num395, num396].active() && Main.tile[num395, num396].type == 488)
								{
									if (genRand.Next(2) == 0)
									{
										GenVars.logX = num395;
										GenVars.logY = num396;
									}
									num393 = -1;
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Traps", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!notTheBees || noTrapsWorldGen || remixWorldGen)
				{
					placingTraps = true;
					progress.Message = Lang.gen[34].Value;
					if (noTrapsWorldGen)
					{
						progress.Message = Lang.gen[91].Value;
					}
					double num376 = (double)Main.maxTilesX * 0.05;
					if (noTrapsWorldGen)
					{
						num376 = ((!tenthAnniversaryWorldGen && !notTheBees) ? (num376 * 100.0) : (num376 * 5.0));
					}
					else if (getGoodWorldGen)
					{
						num376 *= 1.5;
					}
					if (Main.starGame)
					{
						num376 *= Main.starGameMath(0.2);
					}
					for (int num377 = 0; (double)num377 < num376; num377++)
					{
						progress.Set((double)num377 / num376 / 2.0);
						for (int num378 = 0; num378 < 1150; num378++)
						{
							if (noTrapsWorldGen)
							{
								int num379 = genRand.Next(50, Main.maxTilesX - 50);
								int num380 = genRand.Next(50, Main.maxTilesY - 50);
								if (remixWorldGen)
								{
									num380 = genRand.Next(50, Main.maxTilesY - 210);
								}
								if (((double)num380 > Main.worldSurface || Main.tile[num379, num380].wall > 0) && placeTrap(num379, num380))
								{
									break;
								}
							}
							else
							{
								int num381 = genRand.Next(200, Main.maxTilesX - 200);
								int num382 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
								while (oceanDepths(num381, num382))
								{
									num381 = genRand.Next(200, Main.maxTilesX - 200);
									num382 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 210);
								}
								if (Main.tile[num381, num382].wall == 0 && placeTrap(num381, num382))
								{
									break;
								}
							}
						}
					}
					if (noTrapsWorldGen)
					{
						num376 = Main.maxTilesX * 3;
						if (Main.remixWorld)
						{
							num376 = Main.maxTilesX / 3;
						}
						if (Main.starGame)
						{
							num376 *= Main.starGameMath(0.2);
						}
						for (int num383 = 0; (double)num383 < num376; num383++)
						{
							if (Main.remixWorld)
							{
								placeTNTBarrel(genRand.Next(50, Main.maxTilesX - 50), genRand.Next((int)Main.worldSurface, (int)((double)(Main.maxTilesY - 350) + Main.rockLayer) / 2));
							}
							else
							{
								placeTNTBarrel(genRand.Next(50, Main.maxTilesX - 50), genRand.Next((int)Main.rockLayer, Main.maxTilesY - 200));
							}
						}
					}
					num376 = (double)Main.maxTilesX * 0.003;
					if (noTrapsWorldGen)
					{
						num376 *= 5.0;
					}
					else if (getGoodWorldGen)
					{
						num376 *= 1.5;
					}
					for (int num384 = 0; (double)num384 < num376; num384++)
					{
						progress.Set((double)num384 / num376 / 2.0 + 0.5);
						for (int num385 = 0; num385 < 20000; num385++)
						{
							int num386 = genRand.Next((int)((double)Main.maxTilesX * 0.15), (int)((double)Main.maxTilesX * 0.85));
							int num387 = genRand.Next((int)Main.worldSurface + 20, Main.maxTilesY - 210);
							if (Main.tile[num386, num387].wall == 187 && PlaceSandTrap(num386, num387))
							{
								break;
							}
						}
					}
					if (drunkWorldGen && !noTrapsWorldGen && !notTheBees)
					{
						for (int num388 = 0; num388 < 8; num388++)
						{
							progress.Message = Lang.gen[34].Value;
							num376 = 100.0;
							for (int num389 = 0; (double)num389 < num376; num389++)
							{
								progress.Set((double)num389 / num376);
								Thread.Sleep(10);
							}
						}
					}
					if (noTrapsWorldGen)
					{
						Main.tileSolid[138] = true;
					}
					placingTraps = false;
				}
			});
			AddGenerationPass("Piles", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[89].Value;
				Main.tileSolid[229] = false;
				Main.tileSolid[190] = false;
				Main.tileSolid[196] = false;
				Main.tileSolid[189] = false;
				Main.tileSolid[202] = false;
				Main.tileSolid[460] = false;
				Main.tileSolid[484] = false;
				if (noTrapsWorldGen)
				{
					Main.tileSolid[138] = false;
				}
				for (int num318 = 0; (double)num318 < (double)Main.maxTilesX * 0.06; num318++)
				{
					int num319 = Main.maxTilesX / 2;
					bool flag11 = false;
					while (!flag11 && num319 > 0)
					{
						num319--;
						int num320 = genRand.Next(25, Main.maxTilesX - 25);
						int num321 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						while (oceanDepths(num320, num321))
						{
							num320 = genRand.Next(25, Main.maxTilesX - 25);
							num321 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
						}
						if (!Main.tile[num320, num321].active())
						{
							int num322 = 186;
							for (; !Main.tile[num320, num321 + 1].active() && num321 < Main.maxTilesY - 5; num321++)
							{
							}
							int num323 = genRand.Next(22);
							if (num323 >= 16 && num323 <= 22)
							{
								num323 = genRand.Next(22);
							}
							if ((Main.tile[num320, num321 + 1].type == 0 || Main.tile[num320, num321 + 1].type == 1 || Main.tileMoss[Main.tile[num320, num321 + 1].type]) && genRand.Next(5) == 0)
							{
								num323 = genRand.Next(23, 29);
								num322 = 187;
							}
							if (num321 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num320, num321].wall] || Main.tile[num320, num321 + 1].type == 30 || Main.tile[num320, num321 + 1].type == 19 || Main.tile[num320, num321 + 1].type == 25 || Main.tile[num320, num321 + 1].type == 203)
							{
								num323 = genRand.Next(7);
								num322 = 186;
							}
							if (Main.tile[num320, num321 + 1].type == 147 || Main.tile[num320, num321 + 1].type == 161 || Main.tile[num320, num321 + 1].type == 162)
							{
								num323 = genRand.Next(26, 32);
								num322 = 186;
							}
							if (Main.tile[num320, num321 + 1].type == 60)
							{
								num322 = 187;
								num323 = genRand.Next(6);
							}
							if ((Main.tile[num320, num321 + 1].type == 57 || Main.tile[num320, num321 + 1].type == 58) && genRand.Next(3) < 2)
							{
								num322 = 187;
								num323 = genRand.Next(6, 9);
							}
							if (Main.tile[num320, num321 + 1].type == 226)
							{
								num322 = 187;
								num323 = genRand.Next(18, 23);
							}
							if (Main.tile[num320, num321 + 1].type == 70)
							{
								num323 = genRand.Next(32, 35);
								num322 = 186;
							}
							if (Main.tile[num320, num321 + 1].type == 396 || Main.tile[num320, num321 + 1].type == 397 || Main.tile[num320, num321 + 1].type == 404)
							{
								num323 = genRand.Next(29, 35);
								num322 = 187;
							}
							if (Main.tile[num320, num321 + 1].type == 368)
							{
								num323 = genRand.Next(35, 41);
								num322 = 187;
							}
							if (Main.tile[num320, num321 + 1].type == 367)
							{
								num323 = genRand.Next(41, 47);
								num322 = 187;
							}
							if (num322 == 186 && num323 >= 7 && num323 <= 15 && genRand.Next(75) == 0)
							{
								num322 = 187;
								num323 = 17;
							}
							if (Main.wallDungeon[Main.tile[num320, num321].wall] && genRand.Next(3) != 0)
							{
								flag11 = true;
							}
							else
							{
								if (!Main.tile[num320, num321].shimmer())
								{
									PlaceTile(num320, num321, num322, mute: true, forced: false, -1, num323);
								}
								if (Main.tile[num320, num321].type == 186 || Main.tile[num320, num321].type == 187)
								{
									flag11 = true;
								}
								if (flag11 && num322 == 186 && num323 <= 7)
								{
									int num324 = genRand.Next(1, 5);
									for (int num325 = 0; num325 < num324; num325++)
									{
										int num326 = num320 + genRand.Next(-10, 11);
										int num327 = num321 - genRand.Next(5);
										if (!Main.tile[num326, num327].active())
										{
											for (; !Main.tile[num326, num327 + 1].active() && num327 < Main.maxTilesY - 5; num327++)
											{
											}
											int x3 = genRand.Next(12, 36);
											PlaceSmallPile(num326, num327, x3, 0, 185);
										}
									}
								}
							}
						}
					}
				}
				for (int num328 = 0; (double)num328 < (double)Main.maxTilesX * 0.01; num328++)
				{
					int num329 = Main.maxTilesX / 2;
					bool flag12 = false;
					while (!flag12 && num329 > 0)
					{
						num329--;
						int num330 = genRand.Next(25, Main.maxTilesX - 25);
						int num331 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
						if (!Main.tile[num330, num331].active())
						{
							int num332 = 186;
							for (; !Main.tile[num330, num331 + 1].active() && num331 < Main.maxTilesY - 5; num331++)
							{
							}
							int num333 = genRand.Next(22);
							if (num333 >= 16 && num333 <= 22)
							{
								num333 = genRand.Next(22);
							}
							if (num331 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num330, num331].wall] || Main.tile[num330, num331 + 1].type == 30 || Main.tile[num330, num331 + 1].type == 19)
							{
								num333 = genRand.Next(7);
							}
							if ((Main.tile[num330, num331 + 1].type == 57 || Main.tile[num330, num331 + 1].type == 58) && genRand.Next(3) < 2)
							{
								num332 = 187;
								num333 = genRand.Next(6, 9);
							}
							if (Main.tile[num330, num331 + 1].type == 147 || Main.tile[num330, num331 + 1].type == 161 || Main.tile[num330, num331 + 1].type == 162)
							{
								num333 = genRand.Next(26, 32);
							}
							PlaceTile(num330, num331, num332, mute: true, forced: false, -1, num333);
							if (Main.tile[num330, num331].type == 186 || Main.tile[num330, num331].type == 187)
							{
								flag12 = true;
							}
							if (flag12 && num332 == 186 && num333 <= 7)
							{
								int num334 = genRand.Next(1, 5);
								for (int num335 = 0; num335 < num334; num335++)
								{
									int num336 = num330 + genRand.Next(-10, 11);
									int num337 = num331 - genRand.Next(5);
									if (!Main.tile[num336, num337].active())
									{
										for (; !Main.tile[num336, num337 + 1].active() && num337 < Main.maxTilesY - 5; num337++)
										{
										}
										int x4 = genRand.Next(12, 36);
										PlaceSmallPile(num336, num337, x4, 0, 185);
									}
								}
							}
						}
					}
				}
				for (int num338 = 0; (double)num338 < (double)Main.maxTilesX * 0.003; num338++)
				{
					int num339 = Main.maxTilesX / 2;
					bool flag13 = false;
					while (!flag13 && num339 > 0)
					{
						num339--;
						int num340 = 186;
						int num341 = genRand.Next(25, Main.maxTilesX - 25);
						int num342 = genRand.Next(10, (int)Main.worldSurface);
						while (oceanDepths(num341, num342))
						{
							num341 = genRand.Next(25, Main.maxTilesX - 25);
							num342 = genRand.Next(10, (int)Main.worldSurface);
						}
						if (!Main.tile[num341, num342].active())
						{
							for (; !Main.tile[num341, num342 + 1].active() && num342 < Main.maxTilesY - 5; num342++)
							{
							}
							int num343 = genRand.Next(7, 13);
							if (num342 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num341, num342].wall] || Main.tile[num341, num342 + 1].type == 30 || Main.tile[num341, num342 + 1].type == 19 || Main.tile[num341, num342 + 1].type == 25 || Main.tile[num341, num342 + 1].type == 203 || Main.tile[num341, num342 + 1].type == 234 || Main.tile[num341, num342 + 1].type == 112)
							{
								num343 = -1;
							}
							if (Main.tile[num341, num342 + 1].type == 147 || Main.tile[num341, num342 + 1].type == 161 || Main.tile[num341, num342 + 1].type == 162)
							{
								num343 = genRand.Next(26, 32);
							}
							if (Main.tile[num341, num342 + 1].type == 53)
							{
								num340 = 187;
								num343 = genRand.Next(52, 55);
							}
							if (Main.tile[num341, num342 + 1].type == 2 || Main.tile[num341 - 1, num342 + 1].type == 2 || Main.tile[num341 + 1, num342 + 1].type == 2)
							{
								num340 = 187;
								num343 = genRand.Next(14, 17);
							}
							if (Main.tile[num341, num342 + 1].type == 151 || Main.tile[num341, num342 + 1].type == 274)
							{
								num340 = 186;
								num343 = genRand.Next(7);
							}
							if (num343 >= 0)
							{
								PlaceTile(num341, num342, num340, mute: true, forced: false, -1, num343);
							}
							if (Main.tile[num341, num342].type == num340)
							{
								flag13 = true;
							}
						}
					}
				}
				for (int num344 = 0; (double)num344 < (double)Main.maxTilesX * 0.0035; num344++)
				{
					int num345 = Main.maxTilesX / 2;
					bool flag14 = false;
					while (!flag14 && num345 > 0)
					{
						num345--;
						int num346 = genRand.Next(25, Main.maxTilesX - 25);
						int num347 = genRand.Next(10, (int)Main.worldSurface);
						if (!Main.tile[num346, num347].active() && Main.tile[num346, num347].wall > 0)
						{
							int num348 = 186;
							for (; !Main.tile[num346, num347 + 1].active() && num347 < Main.maxTilesY - 5; num347++)
							{
							}
							int num349 = genRand.Next(7, 13);
							if (num347 > Main.maxTilesY - 300 || Main.wallDungeon[Main.tile[num346, num347].wall] || Main.tile[num346, num347 + 1].type == 30 || Main.tile[num346, num347 + 1].type == 19)
							{
								num349 = -1;
							}
							if (Main.tile[num346, num347 + 1].type == 25)
							{
								num349 = genRand.Next(7);
							}
							if (Main.tile[num346, num347 + 1].type == 147 || Main.tile[num346, num347 + 1].type == 161 || Main.tile[num346, num347 + 1].type == 162)
							{
								num349 = genRand.Next(26, 32);
							}
							if (Main.tile[num346, num347 + 1].type == 2 || Main.tile[num346 - 1, num347 + 1].type == 2 || Main.tile[num346 + 1, num347 + 1].type == 2)
							{
								num348 = 187;
								num349 = genRand.Next(14, 17);
							}
							if (Main.tile[num346, num347 + 1].type == 151 || Main.tile[num346, num347 + 1].type == 274)
							{
								num348 = 186;
								num349 = genRand.Next(7);
							}
							if (num349 >= 0)
							{
								PlaceTile(num346, num347, num348, mute: true, forced: false, -1, num349);
							}
							if (Main.tile[num346, num347].type == num348)
							{
								flag14 = true;
							}
							if (flag14 && num349 <= 7)
							{
								int num350 = genRand.Next(1, 5);
								for (int num351 = 0; num351 < num350; num351++)
								{
									int num352 = num346 + genRand.Next(-10, 11);
									int num353 = num347 - genRand.Next(5);
									if (!Main.tile[num352, num353].active())
									{
										for (; !Main.tile[num352, num353 + 1].active() && num353 < Main.maxTilesY - 5; num353++)
										{
										}
										int x5 = genRand.Next(12, 36);
										PlaceSmallPile(num352, num353, x5, 0, 185);
									}
								}
							}
						}
					}
				}
				for (int num354 = 0; (double)num354 < (double)Main.maxTilesX * 0.6; num354++)
				{
					int num355 = Main.maxTilesX / 2;
					bool flag15 = false;
					while (!flag15 && num355 > 0)
					{
						num355--;
						int num356 = genRand.Next(25, Main.maxTilesX - 25);
						int num357 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						if (Main.tile[num356, num357].wall == 87 && genRand.Next(2) == 0)
						{
							num356 = genRand.Next(25, Main.maxTilesX - 25);
							num357 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}
						while (oceanDepths(num356, num357))
						{
							num356 = genRand.Next(25, Main.maxTilesX - 25);
							num357 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20);
						}
						if (!Main.tile[num356, num357].active())
						{
							for (; !Main.tile[num356, num357 + 1].active() && num357 < Main.maxTilesY - 5; num357++)
							{
							}
							int num358 = genRand.Next(2);
							int num359 = genRand.Next(36);
							if (num359 >= 28 && num359 <= 35)
							{
								num359 = genRand.Next(36);
							}
							if (num358 == 1)
							{
								num359 = genRand.Next(25);
								if (num359 >= 16 && num359 <= 24)
								{
									num359 = genRand.Next(25);
								}
							}
							if (num357 > Main.maxTilesY - 300)
							{
								if (num358 == 0)
								{
									num359 = genRand.Next(12, 28);
								}
								if (num358 == 1)
								{
									num359 = genRand.Next(6, 16);
								}
							}
							if (Main.wallDungeon[Main.tile[num356, num357].wall] || Main.tile[num356, num357 + 1].type == 30 || Main.tile[num356, num357 + 1].type == 19 || Main.tile[num356, num357 + 1].type == 25 || Main.tile[num356, num357 + 1].type == 203 || Main.tile[num356, num357].wall == 87)
							{
								if (num358 == 0 && num359 < 12)
								{
									num359 += 12;
								}
								if (num358 == 1 && num359 < 6)
								{
									num359 += 6;
								}
								if (num358 == 1 && num359 >= 17)
								{
									num359 -= 10;
								}
							}
							if (Main.tile[num356, num357 + 1].type == 147 || Main.tile[num356, num357 + 1].type == 161 || Main.tile[num356, num357 + 1].type == 162)
							{
								if (num358 == 0 && num359 < 12)
								{
									num359 += 36;
								}
								if (num358 == 1 && num359 >= 20)
								{
									num359 += 6;
								}
								if (num358 == 1 && num359 < 6)
								{
									num359 += 25;
								}
							}
							if (Main.tile[num356, num357 + 1].type == 151 || Main.tile[num356, num357 + 1].type == 274)
							{
								if (num358 == 0)
								{
									num359 = genRand.Next(12, 28);
								}
								if (num358 == 1)
								{
									num359 = genRand.Next(12, 19);
								}
							}
							if (Main.tile[num356, num357 + 1].type == 368)
							{
								if (num358 == 0)
								{
									num359 = genRand.Next(60, 66);
								}
								if (num358 == 1)
								{
									num359 = genRand.Next(47, 53);
								}
							}
							if (Main.tile[num356, num357 + 1].type == 367)
							{
								if (num358 == 0)
								{
									num359 = genRand.Next(66, 72);
								}
								if (num358 == 1)
								{
									num359 = genRand.Next(53, 59);
								}
							}
							if (Main.wallDungeon[Main.tile[num356, num357].wall] && genRand.Next(3) != 0)
							{
								flag15 = true;
							}
							else if (!Main.tile[num356, num357].shimmer())
							{
								flag15 = PlaceSmallPile(num356, num357, num359, num358, 185);
							}
							if (flag15 && num358 == 1 && num359 >= 6 && num359 <= 15)
							{
								int num360 = genRand.Next(1, 5);
								for (int num361 = 0; num361 < num360; num361++)
								{
									int num362 = num356 + genRand.Next(-10, 11);
									int num363 = num357 - genRand.Next(5);
									if (!Main.tile[num362, num363].active())
									{
										for (; !Main.tile[num362, num363 + 1].active() && num363 < Main.maxTilesY - 5; num363++)
										{
										}
										int x6 = genRand.Next(12, 36);
										PlaceSmallPile(num362, num363, x6, 0, 185);
									}
								}
							}
						}
					}
				}
				for (int num364 = 0; (double)num364 < (double)Main.maxTilesX * 0.02; num364++)
				{
					int num365 = Main.maxTilesX / 2;
					bool flag16 = false;
					while (!flag16 && num365 > 0)
					{
						num365--;
						int num366 = genRand.Next(25, Main.maxTilesX - 25);
						int num367 = genRand.Next(15, (int)Main.worldSurface);
						while (oceanDepths(num366, num367))
						{
							num366 = genRand.Next(25, Main.maxTilesX - 25);
							num367 = genRand.Next(15, (int)Main.worldSurface);
						}
						if (!Main.tile[num366, num367].active())
						{
							for (; !Main.tile[num366, num367 + 1].active() && num367 < Main.maxTilesY - 5; num367++)
							{
							}
							int num368 = genRand.Next(2);
							int num369 = genRand.Next(11);
							if (num368 == 1)
							{
								num369 = genRand.Next(5);
							}
							if (Main.tile[num366, num367 + 1].type == 147 || Main.tile[num366, num367 + 1].type == 161 || Main.tile[num366, num367 + 1].type == 162)
							{
								if (num368 == 0 && num369 < 12)
								{
									num369 += 36;
								}
								if (num368 == 1 && num369 >= 20)
								{
									num369 += 6;
								}
								if (num368 == 1 && num369 < 6)
								{
									num369 += 25;
								}
							}
							if (Main.tile[num366, num367 + 1].type == 2 && num368 == 1)
							{
								num369 = genRand.Next(38, 41);
							}
							if (Main.tile[num366, num367 + 1].type == 151 || Main.tile[num366, num367 + 1].type == 274)
							{
								if (num368 == 0)
								{
									num369 = genRand.Next(12, 28);
								}
								if (num368 == 1)
								{
									num369 = genRand.Next(12, 19);
								}
							}
							if (!Main.wallDungeon[Main.tile[num366, num367].wall] && Main.tile[num366, num367 + 1].type != 30 && Main.tile[num366, num367 + 1].type != 19 && Main.tile[num366, num367 + 1].type != 41 && Main.tile[num366, num367 + 1].type != 43 && Main.tile[num366, num367 + 1].type != 44 && Main.tile[num366, num367 + 1].type != 481 && Main.tile[num366, num367 + 1].type != 482 && Main.tile[num366, num367 + 1].type != 483 && Main.tile[num366, num367 + 1].type != 45 && Main.tile[num366, num367 + 1].type != 46 && Main.tile[num366, num367 + 1].type != 47 && Main.tile[num366, num367 + 1].type != 175 && Main.tile[num366, num367 + 1].type != 176 && Main.tile[num366, num367 + 1].type != 177 && Main.tile[num366, num367 + 1].type != 53 && Main.tile[num366, num367 + 1].type != 25 && Main.tile[num366, num367 + 1].type != 203)
							{
								flag16 = PlaceSmallPile(num366, num367, num369, num368, 185);
							}
						}
					}
				}
				for (int num370 = 0; (double)num370 < (double)Main.maxTilesX * 0.15; num370++)
				{
					int num371 = Main.maxTilesX / 2;
					bool flag17 = false;
					while (!flag17 && num371 > 0)
					{
						num371--;
						int num372 = genRand.Next(25, Main.maxTilesX - 25);
						int num373 = genRand.Next(15, (int)Main.worldSurface);
						if (!Main.tile[num372, num373].active() && (Main.tile[num372, num373].wall == 2 || Main.tile[num372, num373].wall == 40))
						{
							for (; !Main.tile[num372, num373 + 1].active() && num373 < Main.maxTilesY - 5; num373++)
							{
							}
							int num374 = genRand.Next(2);
							int num375 = genRand.Next(11);
							if (num374 == 1)
							{
								num375 = genRand.Next(5);
							}
							if (Main.tile[num372, num373 + 1].type == 147 || Main.tile[num372, num373 + 1].type == 161 || Main.tile[num372, num373 + 1].type == 162)
							{
								if (num374 == 0 && num375 < 12)
								{
									num375 += 36;
								}
								if (num374 == 1 && num375 >= 20)
								{
									num375 += 6;
								}
								if (num374 == 1 && num375 < 6)
								{
									num375 += 25;
								}
							}
							if (Main.tile[num372, num373 + 1].type == 2 && num374 == 1)
							{
								num375 = genRand.Next(38, 41);
							}
							if (Main.tile[num372, num373 + 1].type == 151 || Main.tile[num372, num373 + 1].type == 274)
							{
								if (num374 == 0)
								{
									num375 = genRand.Next(12, 28);
								}
								if (num374 == 1)
								{
									num375 = genRand.Next(12, 19);
								}
							}
							if ((Main.tile[num372, num373].liquid != byte.MaxValue || Main.tile[num372, num373 + 1].type != 53 || Main.tile[num372, num373].wall != 0) && !Main.wallDungeon[Main.tile[num372, num373].wall] && Main.tile[num372, num373 + 1].type != 30 && Main.tile[num372, num373 + 1].type != 19 && Main.tile[num372, num373 + 1].type != 41 && Main.tile[num372, num373 + 1].type != 43 && Main.tile[num372, num373 + 1].type != 44 && Main.tile[num372, num373 + 1].type != 481 && Main.tile[num372, num373 + 1].type != 482 && Main.tile[num372, num373 + 1].type != 483 && Main.tile[num372, num373 + 1].type != 45 && Main.tile[num372, num373 + 1].type != 46 && Main.tile[num372, num373 + 1].type != 47 && Main.tile[num372, num373 + 1].type != 175 && Main.tile[num372, num373 + 1].type != 176 && Main.tile[num372, num373 + 1].type != 177 && Main.tile[num372, num373 + 1].type != 25 && Main.tile[num372, num373 + 1].type != 203)
							{
								flag17 = PlaceSmallPile(num372, num373, num375, num374, 185);
							}
						}
					}
				}
				Main.tileSolid[190] = true;
				Main.tileSolid[192] = true;
				Main.tileSolid[196] = true;
				Main.tileSolid[189] = true;
				Main.tileSolid[202] = true;
				Main.tileSolid[225] = true;
				Main.tileSolid[460] = true;
				Main.tileSolid[138] = true;
			});
			AddGenerationPass("Spawn Point", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				int num309 = 5;
				bool flag10 = true;
				int num310 = Main.maxTilesX / 2;
				if (Main.tenthAnniversaryWorld && !remixWorldGen)
				{
					int num311 = GenVars.beachBordersWidth + 15;
					num310 = ((genRand.Next(2) != 0) ? (Main.maxTilesX - num311) : num311);
				}
				while (flag10)
				{
					int num312 = num310 + genRand.Next(-num309, num309 + 1);
					for (int num313 = 0; num313 < Main.maxTilesY; num313++)
					{
						if (Main.tile[num312, num313].active())
						{
							Main.spawnTileX = num312;
							Main.spawnTileY = num313;
							break;
						}
					}
					flag10 = false;
					num309++;
					if ((double)Main.spawnTileY > Main.worldSurface)
					{
						flag10 = true;
					}
					if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > 0)
					{
						flag10 = true;
					}
				}
				int num314 = 10;
				while ((double)Main.spawnTileY > Main.worldSurface)
				{
					int num315 = genRand.Next(num310 - num314, num310 + num314);
					for (int num316 = 0; num316 < Main.maxTilesY; num316++)
					{
						if (Main.tile[num315, num316].active())
						{
							Main.spawnTileX = num315;
							Main.spawnTileY = num316;
							break;
						}
					}
					num314++;
				}
				if (remixWorldGen)
				{
					int num317 = Main.maxTilesY - 10;
					while (SolidTile(Main.spawnTileX, num317))
					{
						num317--;
					}
					Main.spawnTileY = num317 + 1;
				}
			});
			AddGenerationPass("Grass Wall", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				maxTileCount = 3500;
				progress.Set(1.0);
				for (int num297 = 50; num297 < Main.maxTilesX - 50; num297++)
				{
					for (int num298 = 0; (double)num298 < Main.worldSurface - 10.0; num298++)
					{
						if (genRand.Next(4) == 0)
						{
							bool flag8 = false;
							int num299 = -1;
							int num300 = -1;
							if (Main.tile[num297, num298].active() && Main.tile[num297, num298].type == 2 && (Main.tile[num297, num298].wall == 2 || Main.tile[num297, num298].wall == 63))
							{
								for (int num301 = num297 - 1; num301 <= num297 + 1; num301++)
								{
									for (int num302 = num298 - 1; num302 <= num298 + 1; num302++)
									{
										if (Main.tile[num301, num302].wall == 0 && !SolidTile(num301, num302))
										{
											flag8 = true;
										}
									}
								}
								if (flag8)
								{
									for (int num303 = num297 - 1; num303 <= num297 + 1; num303++)
									{
										for (int num304 = num298 - 1; num304 <= num298 + 1; num304++)
										{
											if ((Main.tile[num303, num304].wall == 2 || Main.tile[num303, num304].wall == 15) && !SolidTile(num303, num304))
											{
												num299 = num303;
												num300 = num304;
											}
										}
									}
								}
							}
							if (flag8 && num299 > -1 && num300 > -1 && countDirtTiles(num299, num300) < maxTileCount)
							{
								try
								{
									ushort wallType = 63;
									if (dontStarveWorldGen && genRand.Next(3) != 0)
									{
										wallType = 62;
									}
									Spread.Wall2(num299, num300, wallType);
								}
								catch
								{
								}
							}
						}
					}
				}
				for (int num305 = 5; num305 < Main.maxTilesX - 5; num305++)
				{
					for (int num306 = 10; (double)num306 < Main.worldSurface - 1.0; num306++)
					{
						if (Main.tile[num305, num306].wall == 63 && genRand.Next(10) == 0)
						{
							Main.tile[num305, num306].wall = 65;
						}
						if (Main.tile[num305, num306].active() && Main.tile[num305, num306].type == 0)
						{
							bool flag9 = false;
							for (int num307 = num305 - 1; num307 <= num305 + 1; num307++)
							{
								for (int num308 = num306 - 1; num308 <= num306 + 1; num308++)
								{
									if (Main.tile[num307, num308].wall == 63 || Main.tile[num307, num308].wall == 65)
									{
										flag9 = true;
										break;
									}
								}
							}
							if (flag9)
							{
								SpreadGrass(num305, num306);
							}
						}
					}
				}
			});
			AddGenerationPass("Guide", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				if (Main.tenthAnniversaryWorld)
				{
					BirthdayParty.GenuineParty = true;
					BirthdayParty.PartyDaysOnCooldown = 5;
					if (getGoodWorldGen)
					{
						Main.afterPartyOfDoom = true;
					}
					int num291;
					if (remixWorldGen)
					{
						num291 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
						NPC.savedTaxCollector = true;
					}
					else
					{
						num291 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
					}
					Main.npc[num291].homeTileX = Main.spawnTileX;
					Main.npc[num291].homeTileY = Main.spawnTileY;
					Main.npc[num291].direction = 1;
					Main.npc[num291].homeless = true;
					Main.npc[num291].GivenName = Language.GetTextValue("GuideNames.Andrew");
					BirthdayParty.CelebratingNPCs.Add(num291);
					Point adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 2, Main.spawnTileY);
					num291 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 178);
					Main.npc[num291].homeTileX = adjustedFloorPosition.X;
					Main.npc[num291].homeTileY = adjustedFloorPosition.Y;
					Main.npc[num291].direction = -1;
					Main.npc[num291].homeless = true;
					Main.npc[num291].GivenName = Language.GetTextValue("SteampunkerNames.Whitney");
					BirthdayParty.CelebratingNPCs.Add(num291);
					adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 2, Main.spawnTileY);
					num291 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 663);
					Main.npc[num291].homeTileX = adjustedFloorPosition.X;
					Main.npc[num291].homeTileY = adjustedFloorPosition.Y;
					Main.npc[num291].direction = 1;
					Main.npc[num291].homeless = true;
					Main.npc[num291].GivenName = Language.GetTextValue("PrincessNames.Yorai");
					BirthdayParty.CelebratingNPCs.Add(num291);
					NPC.unlockedPrincessSpawn = true;
					adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX + 4, Main.spawnTileY);
					num291 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 208);
					Main.npc[num291].homeTileX = adjustedFloorPosition.X;
					Main.npc[num291].homeTileY = adjustedFloorPosition.Y;
					Main.npc[num291].direction = -1;
					Main.npc[num291].homeless = true;
					Main.npc[num291].GivenName = Language.GetTextValue("PartyGirlNames.Amanda");
					BirthdayParty.CelebratingNPCs.Add(num291);
					NPC.unlockedPartyGirlSpawn = true;
					adjustedFloorPosition = GetAdjustedFloorPosition(Main.spawnTileX - 4, Main.spawnTileY);
					if (Main.remixWorld)
					{
						num291 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 681);
						Main.npc[num291].GivenName = Language.GetTextValue("SlimeNames_Rainbow.Slimestar");
						NPC.unlockedSlimeRainbowSpawn = true;
					}
					else
					{
						num291 = NPC.NewNPC(new EntitySource_WorldGen(), adjustedFloorPosition.X * 16, adjustedFloorPosition.Y * 16, 656);
						NPC.boughtBunny = true;
						Main.npc[num291].townNpcVariationIndex = 1;
					}
					Main.npc[num291].homeTileX = adjustedFloorPosition.X;
					Main.npc[num291].homeTileY = adjustedFloorPosition.Y;
					Main.npc[num291].direction = 1;
					Main.npc[num291].homeless = true;
				}
				else if (remixWorldGen)
				{
					int num292 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 441);
					Main.npc[num292].homeTileX = Main.spawnTileX;
					Main.npc[num292].homeTileY = Main.spawnTileY;
					Main.npc[num292].direction = 1;
					Main.npc[num292].homeless = true;
					NPC.savedTaxCollector = true;
				}
				else if (notTheBees)
				{
					int num293 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 17);
					Main.npc[num293].homeTileX = Main.spawnTileX;
					Main.npc[num293].homeTileY = Main.spawnTileY;
					Main.npc[num293].direction = 1;
					Main.npc[num293].homeless = true;
					NPC.unlockedMerchantSpawn = true;
				}
				else if (drunkWorldGen)
				{
					int num294 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 208);
					Main.npc[num294].homeTileX = Main.spawnTileX;
					Main.npc[num294].homeTileY = Main.spawnTileY;
					Main.npc[num294].direction = 1;
					Main.npc[num294].homeless = true;
					NPC.unlockedPartyGirlSpawn = true;
				}
				else if (getGoodWorldGen)
				{
					int num295 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 38);
					Main.npc[num295].homeTileX = Main.spawnTileX;
					Main.npc[num295].homeTileY = Main.spawnTileY;
					Main.npc[num295].direction = 1;
					Main.npc[num295].homeless = true;
					NPC.unlockedDemolitionistSpawn = true;
				}
				else
				{
					int num296 = NPC.NewNPC(new EntitySource_WorldGen(), Main.spawnTileX * 16, Main.spawnTileY * 16, 22);
					Main.npc[num296].homeTileX = Main.spawnTileX;
					Main.npc[num296].homeTileY = Main.spawnTileY;
					Main.npc[num296].direction = 1;
					Main.npc[num296].homeless = true;
				}
			});
			AddGenerationPass("Sunflowers", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[39].Value;
				double num282 = (double)Main.maxTilesX * 0.002;
				for (int num283 = 0; (double)num283 < num282; num283++)
				{
					progress.Set((double)num283 / num282);
					int num284 = 0;
					int num285 = 0;
					_ = Main.maxTilesX / 2;
					int num286 = genRand.Next(Main.maxTilesX);
					num284 = num286 - genRand.Next(10) - 7;
					num285 = num286 + genRand.Next(10) + 7;
					if (num284 < 0)
					{
						num284 = 0;
					}
					if (num285 > Main.maxTilesX - 1)
					{
						num285 = Main.maxTilesX - 1;
					}
					int num287 = 1;
					int num288 = (int)Main.worldSurface - 1;
					for (int num289 = num284; num289 < num285; num289++)
					{
						for (int num290 = num287; num290 < num288; num290++)
						{
							if (Main.tile[num289, num290].type == 2 && Main.tile[num289, num290].active() && !Main.tile[num289, num290 - 1].active())
							{
								PlaceTile(num289, num290 - 1, 27, mute: true);
							}
							if (Main.tile[num289, num290].active())
							{
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Planting Trees", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[40].Value;
				if (!drunkWorldGen && !Main.tenthAnniversaryWorld)
				{
					for (int num277 = 0; (double)num277 < (double)Main.maxTilesX * 0.003; num277++)
					{
						progress.Set((double)num277 / ((double)Main.maxTilesX * 0.003));
						int num278 = genRand.Next(50, Main.maxTilesX - 50);
						int num279 = genRand.Next(25, 50);
						for (int num280 = num278 - num279; num280 < num278 + num279; num280++)
						{
							for (int num281 = 20; (double)num281 < Main.worldSurface; num281++)
							{
								GrowEpicTree(num280, num281);
							}
						}
					}
				}
				AddTrees();
			});
			AddGenerationPass("Herbs", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				double num275 = (double)Main.maxTilesX * 1.7;
				if (remixWorldGen)
				{
					num275 *= 5.0;
				}
				progress.Message = Lang.gen[41].Value;
				for (int num276 = 0; (double)num276 < num275; num276++)
				{
					progress.Set((double)num276 / num275);
					PlantAlch();
				}
			});
			AddGenerationPass("Dye Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num274 = 0; num274 < Main.maxTilesX; num274++)
				{
					plantDye(genRand.Next(100, Main.maxTilesX - 100), genRand.Next(100, Main.UnderworldLayer));
				}
				MatureTheHerbPlants();
				GrowGlowTulips();
			});
			AddGenerationPass("Webs And Honey", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num264 = 100; num264 < Main.maxTilesX - 100; num264++)
				{
					int num265 = (int)Main.worldSurface;
					if (dontStarveWorldGen)
					{
						num265 = 50;
					}
					for (int num266 = num265; num266 < Main.maxTilesY - 100; num266++)
					{
						if (Main.tile[num264, num266].wall == 86)
						{
							if (Main.tile[num264, num266].liquid > 0)
							{
								Main.tile[num264, num266].honey(honey: true);
							}
							if (genRand.Next(3) == 0)
							{
								PlaceTight(num264, num266);
							}
						}
						if (Main.tile[num264, num266].wall == 62)
						{
							Main.tile[num264, num266].liquid = 0;
							Main.tile[num264, num266].lava(lava: false);
						}
						if (Main.tile[num264, num266].wall == 62 && !Main.tile[num264, num266].active() && genRand.Next(10) != 0)
						{
							int num267 = genRand.Next(2, 5);
							int num268 = num264 - num267;
							int num269 = num264 + num267;
							int num270 = num266 - num267;
							int num271 = num266 + num267;
							bool flag7 = false;
							for (int num272 = num268; num272 <= num269; num272++)
							{
								for (int num273 = num270; num273 <= num271; num273++)
								{
									if (SolidTile(num272, num273))
									{
										flag7 = true;
										break;
									}
								}
							}
							if (flag7)
							{
								PlaceTile(num264, num266, 51, mute: true);
								TileFrame(num264, num266);
							}
						}
					}
				}
			});
			AddGenerationPass("Weeds", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[42].Value;
				if (Main.halloween)
				{
					for (int num258 = 40; num258 < Main.maxTilesX - 40; num258++)
					{
						for (int num259 = 50; (double)num259 < Main.worldSurface; num259++)
						{
							if (Main.tile[num258, num259].active() && Main.tile[num258, num259].type == 2 && genRand.Next(15) == 0)
							{
								PlacePumpkin(num258, num259 - 1);
								int num260 = genRand.Next(5);
								for (int num261 = 0; num261 < num260; num261++)
								{
									GrowPumpkin(num258, num259 - 1, 254);
								}
							}
						}
					}
				}
				for (int num262 = 0; num262 < Main.maxTilesX; num262++)
				{
					progress.Set((double)num262 / (double)Main.maxTilesX);
					for (int num263 = 1; num263 < Main.maxTilesY; num263++)
					{
						if (Main.tile[num262, num263].type == 2 && Main.tile[num262, num263].nactive())
						{
							if (!Main.tile[num262, num263 - 1].active())
							{
								PlaceTile(num262, num263 - 1, 3, mute: true);
								Main.tile[num262, num263 - 1].CopyPaintAndCoating(Main.tile[num262, num263]);
							}
						}
						else if (Main.tile[num262, num263].type == 23 && Main.tile[num262, num263].nactive())
						{
							if (!Main.tile[num262, num263 - 1].active())
							{
								PlaceTile(num262, num263 - 1, 24, mute: true);
							}
						}
						else if (Main.tile[num262, num263].type == 199 && Main.tile[num262, num263].nactive())
						{
							if (!Main.tile[num262, num263 - 1].active())
							{
								PlaceTile(num262, num263 - 1, 201, mute: true);
							}
						}
						else if (Main.tile[num262, num263].type == 633 && Main.tile[num262, num263].nactive() && !Main.tile[num262, num263 - 1].active())
						{
							PlaceTile(num262, num263 - 1, 637, mute: true);
						}
					}
				}
			});
			AddGenerationPass("Glowing Mushrooms and Jungle Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num256 = 0; num256 < Main.maxTilesX; num256++)
				{
					for (int num257 = 0; num257 < Main.maxTilesY; num257++)
					{
						if (Main.tile[num256, num257].active())
						{
							if (num257 >= (int)Main.worldSurface && Main.tile[num256, num257].type == 70 && !Main.tile[num256, num257 - 1].active())
							{
								GrowTree(num256, num257);
								if (!Main.tile[num256, num257 - 1].active())
								{
									GrowTree(num256, num257);
									if (!Main.tile[num256, num257 - 1].active())
									{
										GrowTree(num256, num257);
										if (!Main.tile[num256, num257 - 1].active())
										{
											PlaceTile(num256, num257 - 1, 71, mute: true);
										}
									}
								}
							}
							if (Main.tile[num256, num257].type == 60 && !Main.tile[num256, num257 - 1].active())
							{
								PlaceTile(num256, num257 - 1, 61, mute: true);
							}
						}
					}
				}
			});
			AddGenerationPass("Jungle Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num253 = 0; num253 < Main.maxTilesX * 100; num253++)
				{
					int num254 = genRand.Next(40, Main.maxTilesX / 2 - 40);
					if (GenVars.dungeonSide < 0)
					{
						num254 += Main.maxTilesX / 2;
					}
					int num255;
					for (num255 = genRand.Next(Main.maxTilesY - 300); !Main.tile[num254, num255].active() && num255 < Main.maxTilesY - 300; num255++)
					{
					}
					if (Main.tile[num254, num255].active() && Main.tile[num254, num255].type == 60)
					{
						num255--;
						PlaceJunglePlant(num254, num255, 233, genRand.Next(8), 0);
						if (Main.tile[num254, num255].type != 233)
						{
							PlaceJunglePlant(num254, num255, 233, genRand.Next(12), 1);
						}
					}
				}
			});
			AddGenerationPass("Vines", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[43].Value;
				for (int num232 = 5; num232 < Main.maxTilesX - 5; num232++)
				{
					progress.Set((double)num232 / (double)Main.maxTilesX);
					int num233 = 0;
					ushort type3 = 52;
					int num234 = (int)Main.worldSurface;
					if (remixWorldGen)
					{
						num234 = Main.maxTilesY - 200;
					}
					for (int num235 = 0; num235 < num234; num235++)
					{
						if (num233 > 0 && !Main.tile[num232, num235].active())
						{
							Main.tile[num232, num235].active(active: true);
							Main.tile[num232, num235].type = type3;
							Main.tile[num232, num235].CopyPaintAndCoating(Main.tile[num232, num235 - 1]);
							num233--;
						}
						else
						{
							num233 = 0;
						}
						if (Main.tile[num232, num235].active() && !Main.tile[num232, num235].bottomSlope() && (Main.tile[num232, num235].type == 2 || (Main.tile[num232, num235].type == 192 && genRand.Next(4) == 0)) && GrowMoreVines(num232, num235))
						{
							type3 = 52;
							if (Main.tile[num232, num235].wall == 68 || Main.tile[num232, num235].wall == 65 || Main.tile[num232, num235].wall == 66 || Main.tile[num232, num235].wall == 63)
							{
								type3 = 382;
							}
							else if (Main.tile[num232, num235 + 1].wall == 68 || Main.tile[num232, num235 + 1].wall == 65 || Main.tile[num232, num235 + 1].wall == 66 || Main.tile[num232, num235 + 1].wall == 63)
							{
								type3 = 382;
							}
							if (remixWorldGen && genRand.Next(5) == 0)
							{
								type3 = 382;
							}
							if (genRand.Next(5) < 3)
							{
								num233 = genRand.Next(1, 10);
							}
						}
					}
					num233 = 0;
					for (int num236 = 5; num236 < Main.maxTilesY - 5; num236++)
					{
						if (num233 > 0 && !Main.tile[num232, num236].active())
						{
							Main.tile[num232, num236].active(active: true);
							Main.tile[num232, num236].type = 62;
							num233--;
						}
						else
						{
							num233 = 0;
						}
						if (Main.tile[num232, num236].active() && Main.tile[num232, num236].type == 60 && !Main.tile[num232, num236].bottomSlope() && GrowMoreVines(num232, num236))
						{
							if (notTheBees && num236 < Main.maxTilesY - 10 && Main.tile[num232, num236 - 1].active() && !Main.tile[num232, num236 - 1].bottomSlope() && Main.tile[num232 + 1, num236 - 1].active() && !Main.tile[num232 + 1, num236 - 1].bottomSlope() && (Main.tile[num232, num236 - 1].type == 60 || Main.tile[num232, num236 - 1].type == 444 || Main.tile[num232, num236 - 1].type == 230))
							{
								bool flag5 = true;
								for (int num237 = num232; num237 < num232 + 2; num237++)
								{
									for (int num238 = num236 + 1; num238 < num236 + 3; num238++)
									{
										if (Main.tile[num237, num238].active() && (!Main.tileCut[Main.tile[num237, num238].type] || Main.tile[num237, num238].type == 444))
										{
											flag5 = false;
											break;
										}
										if (Main.tile[num237, num238].liquid > 0 || Main.wallHouse[Main.tile[num237, num238].wall])
										{
											flag5 = false;
											break;
										}
									}
									if (!flag5)
									{
										break;
									}
								}
								if (flag5 && CountNearBlocksTypes(num232, num236, genRand.Next(3, 10), 1, 444) > 0)
								{
									flag5 = false;
								}
								if (flag5)
								{
									for (int num239 = num232; num239 < num232 + 2; num239++)
									{
										for (int num240 = num236 + 1; num240 < num236 + 3; num240++)
										{
											KillTile(num239, num240);
										}
									}
									for (int num241 = num232; num241 < num232 + 2; num241++)
									{
										for (int num242 = num236 + 1; num242 < num236 + 3; num242++)
										{
											Main.tile[num241, num242].active(active: true);
											Main.tile[num241, num242].type = 444;
											Main.tile[num241, num242].frameX = (short)((num241 - num232) * 18);
											Main.tile[num241, num242].frameY = (short)((num242 - num236 - 1) * 18);
										}
									}
									continue;
								}
							}
							else if (num232 < Main.maxTilesX - 1 && num236 < Main.maxTilesY - 2 && Main.tile[num232 + 1, num236].active() && Main.tile[num232 + 1, num236].type == 60 && !Main.tile[num232 + 1, num236].bottomSlope() && genRand.Next(40) == 0)
							{
								bool flag6 = true;
								for (int num243 = num232; num243 < num232 + 2; num243++)
								{
									for (int num244 = num236 + 1; num244 < num236 + 3; num244++)
									{
										if (Main.tile[num243, num244].active() && (!Main.tileCut[Main.tile[num243, num244].type] || Main.tile[num243, num244].type == 444))
										{
											flag6 = false;
											break;
										}
										if (Main.tile[num243, num244].liquid > 0 || Main.wallHouse[Main.tile[num243, num244].wall])
										{
											flag6 = false;
											break;
										}
									}
									if (!flag6)
									{
										break;
									}
								}
								if (flag6 && CountNearBlocksTypes(num232, num236, 20, 1, 444) > 0)
								{
									flag6 = false;
								}
								if (flag6)
								{
									for (int num245 = num232; num245 < num232 + 2; num245++)
									{
										for (int num246 = num236 + 1; num246 < num236 + 3; num246++)
										{
											KillTile(num245, num246);
										}
									}
									for (int num247 = num232; num247 < num232 + 2; num247++)
									{
										for (int num248 = num236 + 1; num248 < num236 + 3; num248++)
										{
											Main.tile[num247, num248].active(active: true);
											Main.tile[num247, num248].type = 444;
											Main.tile[num247, num248].frameX = (short)((num247 - num232) * 18);
											Main.tile[num247, num248].frameY = (short)((num248 - num236 - 1) * 18);
										}
									}
									continue;
								}
							}
							if (genRand.Next(5) < 3)
							{
								num233 = genRand.Next(1, 10);
							}
						}
					}
					num233 = 0;
					for (int num249 = 0; num249 < Main.maxTilesY; num249++)
					{
						if (num233 > 0 && !Main.tile[num232, num249].active())
						{
							Main.tile[num232, num249].active(active: true);
							Main.tile[num232, num249].type = 528;
							num233--;
						}
						else
						{
							num233 = 0;
						}
						if (Main.tile[num232, num249].active() && Main.tile[num232, num249].type == 70 && genRand.Next(5) == 0 && !Main.tile[num232, num249].bottomSlope() && GrowMoreVines(num232, num249) && genRand.Next(5) < 3)
						{
							num233 = genRand.Next(1, 10);
						}
					}
					num233 = 0;
					for (int num250 = 0; num250 < Main.maxTilesY; num250++)
					{
						if (num233 > 0 && !Main.tile[num232, num250].active())
						{
							Main.tile[num232, num250].active(active: true);
							Main.tile[num232, num250].type = 636;
							num233--;
						}
						else
						{
							num233 = 0;
						}
						if (Main.tile[num232, num250].active() && !Main.tile[num232, num250].bottomSlope() && Main.tile[num232, num250].type == 23 && GrowMoreVines(num232, num250) && genRand.Next(5) < 3)
						{
							num233 = genRand.Next(1, 10);
						}
					}
					num233 = 0;
					for (int num251 = 0; num251 < Main.maxTilesY; num251++)
					{
						if (num233 > 0 && !Main.tile[num232, num251].active())
						{
							Main.tile[num232, num251].active(active: true);
							Main.tile[num232, num251].type = 205;
							num233--;
						}
						else
						{
							num233 = 0;
						}
						if (Main.tile[num232, num251].active() && !Main.tile[num232, num251].bottomSlope() && Main.tile[num232, num251].type == 199 && GrowMoreVines(num232, num251) && genRand.Next(5) < 3)
						{
							num233 = genRand.Next(1, 10);
						}
					}
					num233 = 0;
					for (int num252 = 0; num252 < Main.maxTilesY; num252++)
					{
						if (num233 > 0 && !Main.tile[num232, num252].active())
						{
							Main.tile[num232, num252].active(active: true);
							Main.tile[num232, num252].type = 638;
							num233--;
						}
						else
						{
							num233 = 0;
						}
						if (Main.tile[num232, num252].active() && !Main.tile[num232, num252].bottomSlope() && Main.tile[num232, num252].type == 633 && GrowMoreVines(num232, num252) && genRand.Next(5) < 3)
						{
							num233 = genRand.Next(1, 10);
						}
					}
				}
			});
			AddGenerationPass("Flowers", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[44].Value;
				int num219 = (int)((double)Main.maxTilesX * 0.004);
				if (remixWorldGen)
				{
					num219 *= 6;
				}
				for (int num220 = 0; num220 < num219; num220++)
				{
					progress.Set((double)num220 / (double)num219);
					int num221 = genRand.Next(100, Main.maxTilesX - 100);
					int num222 = genRand.Next(15, 30);
					int num223 = genRand.Next(15, 30);
					if (remixWorldGen)
					{
						num222 = genRand.Next(15, 45);
						num223 = genRand.Next(15, 45);
						int num224 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						if (GenVars.logX >= 0)
						{
							num221 = GenVars.logX;
							num224 = GenVars.logY;
							GenVars.logX = -1;
						}
						int num225 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
						for (int num226 = num221 - num222; num226 < num221 + num222; num226++)
						{
							for (int num227 = num224 - num223; num227 < num224 + num223; num227++)
							{
								if (Main.tile[num226, num227].type != 488 && !Main.tileSolid[Main.tile[num226, num227].type])
								{
									if (Main.tile[num226, num227].type == 3)
									{
										Main.tile[num226, num227].frameX = (short)((num225 + genRand.Next(3)) * 18);
										if (genRand.Next(3) != 0)
										{
											Main.tile[num226, num227].type = 73;
										}
									}
									else if (Main.tile[num226, num227 + 1].wall == 0 && (Main.tile[num226, num227 + 1].type == 2 || ((Main.tile[num226, num227 + 1].type == 40 || Main.tile[num226, num227 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num226, num227 + 1].type]) && !Main.tile[num226, num227].active())) && (!Main.tile[num226, num227].active() || Main.tile[num226, num227].type == 185 || Main.tile[num226, num227].type == 186 || Main.tile[num226, num227].type == 187 || (Main.tile[num226, num227].type == 5 && (double)num226 < (double)Main.maxTilesX * 0.48) || (double)num226 > (double)Main.maxTilesX * 0.52))
									{
										if (Main.tile[num226, num227 + 1].type == 40 || Main.tile[num226, num227 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num226, num227 + 1].type])
										{
											Main.tile[num226, num227 + 1].type = 2;
											if (Main.tile[num226, num227 + 2].type == 40 || Main.tile[num226, num227 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num226, num227 + 2].type])
											{
												Main.tile[num226, num227 + 2].type = 2;
											}
										}
										KillTile(num226, num227);
										if (genRand.Next(2) == 0)
										{
											Main.tile[num226, num227 + 1].slope(0);
											Main.tile[num226, num227 + 1].halfBrick(halfBrick: false);
										}
										PlaceTile(num226, num227, 3);
										if (Main.tile[num226, num227].active() && Main.tile[num226, num227].type == 3)
										{
											Main.tile[num226, num227].frameX = (short)((num225 + genRand.Next(3)) * 18);
											if (genRand.Next(3) != 0)
											{
												Main.tile[num226, num227].type = 73;
											}
										}
										if (Main.tile[num226, num227 + 2].type == 40 || Main.tile[num226, num227 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num226, num227 + 2].type])
										{
											Main.tile[num226, num227 + 2].type = 0;
										}
									}
								}
							}
						}
					}
					else
					{
						for (int num228 = num223; (double)num228 < Main.worldSurface - (double)num223 - 1.0; num228++)
						{
							if (Main.tile[num221, num228].active())
							{
								if (GenVars.logX >= 0)
								{
									num221 = GenVars.logX;
									num228 = GenVars.logY;
									GenVars.logX = -1;
								}
								int num229 = genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
								for (int num230 = num221 - num222; num230 < num221 + num222; num230++)
								{
									for (int num231 = num228 - num223; num231 < num228 + num223; num231++)
									{
										if (Main.tile[num230, num231].type != 488 && !Main.tileSolid[Main.tile[num230, num231].type])
										{
											if (Main.tile[num230, num231].type == 3)
											{
												Main.tile[num230, num231].frameX = (short)((num229 + genRand.Next(3)) * 18);
												if (genRand.Next(3) != 0)
												{
													Main.tile[num230, num231].type = 73;
												}
											}
											else if (Main.tile[num230, num231 + 1].wall == 0 && (Main.tile[num230, num231 + 1].type == 2 || ((Main.tile[num230, num231 + 1].type == 40 || Main.tile[num230, num231 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num230, num231 + 1].type]) && !Main.tile[num230, num231].active())) && (!Main.tile[num230, num231].active() || Main.tile[num230, num231].type == 185 || Main.tile[num230, num231].type == 186 || Main.tile[num230, num231].type == 187 || (Main.tile[num230, num231].type == 5 && (double)num230 < (double)Main.maxTilesX * 0.48) || (double)num230 > (double)Main.maxTilesX * 0.52))
											{
												if (Main.tile[num230, num231 + 1].type == 40 || Main.tile[num230, num231 + 1].type == 1 || TileID.Sets.Ore[Main.tile[num230, num231 + 1].type])
												{
													Main.tile[num230, num231 + 1].type = 2;
													if (Main.tile[num230, num231 + 2].type == 40 || Main.tile[num230, num231 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num230, num231 + 2].type])
													{
														Main.tile[num230, num231 + 2].type = 2;
													}
												}
												KillTile(num230, num231);
												if (genRand.Next(2) == 0)
												{
													Main.tile[num230, num231 + 1].slope(0);
													Main.tile[num230, num231 + 1].halfBrick(halfBrick: false);
												}
												PlaceTile(num230, num231, 3);
												if (Main.tile[num230, num231].active() && Main.tile[num230, num231].type == 3)
												{
													Main.tile[num230, num231].frameX = (short)((num229 + genRand.Next(3)) * 18);
													if (genRand.Next(3) != 0)
													{
														Main.tile[num230, num231].type = 73;
													}
												}
												if (Main.tile[num230, num231 + 2].type == 40 || Main.tile[num230, num231 + 2].type == 1 || TileID.Sets.Ore[Main.tile[num230, num231 + 2].type])
												{
													Main.tile[num230, num231 + 2].type = 0;
												}
											}
										}
									}
								}
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Mushrooms", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[45].Value;
				int num208 = (int)((double)Main.maxTilesX * 0.002);
				if (remixWorldGen)
				{
					num208 *= 9;
				}
				for (int num209 = 0; num209 < num208; num209++)
				{
					progress.Set((double)num209 / (double)num208);
					int num210 = genRand.Next(20, Main.maxTilesX - 20);
					int num211 = genRand.Next(4, 10);
					int num212 = genRand.Next(15, 30);
					if (remixWorldGen)
					{
						num211 = genRand.Next(8, 17);
						num212 = genRand.Next(8, 17);
						int num213 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						if (Main.tile[num210, num213].active())
						{
							for (int num214 = num210 - num211; num214 < num210 + num211; num214++)
							{
								for (int num215 = num213 - num212; num215 < num213 + num212; num215++)
								{
									if (num214 < 10)
									{
										break;
									}
									if (num215 < 0)
									{
										break;
									}
									if (num214 > Main.maxTilesX - 10)
									{
										break;
									}
									if (num215 > Main.maxTilesY - 10)
									{
										break;
									}
									if (Main.tile[num214, num215].type == 3 || Main.tile[num214, num215].type == 24)
									{
										Main.tile[num214, num215].frameX = 144;
									}
									else if (Main.tile[num214, num215].type == 201)
									{
										Main.tile[num214, num215].frameX = 270;
									}
								}
							}
						}
					}
					else
					{
						for (int num216 = 1; (double)num216 < Main.worldSurface - 1.0; num216++)
						{
							if (Main.tile[num210, num216].active())
							{
								for (int num217 = num210 - num211; num217 < num210 + num211; num217++)
								{
									for (int num218 = num216 - num212; num218 < num216 + num212; num218++)
									{
										if (num217 < 10)
										{
											break;
										}
										if (num218 < 0)
										{
											break;
										}
										if (num217 > Main.maxTilesX - 10)
										{
											break;
										}
										if (num218 > Main.maxTilesY - 10)
										{
											break;
										}
										if (Main.tile[num217, num218].type == 3 || Main.tile[num217, num218].type == 24)
										{
											Main.tile[num217, num218].frameX = 144;
										}
										else if (Main.tile[num217, num218].type == 201)
										{
											Main.tile[num217, num218].frameX = 270;
										}
									}
								}
								break;
							}
						}
					}
				}
			});
			AddGenerationPass("Gems In Ice Biome", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num197 = 0; (double)num197 < (double)Main.maxTilesX * 0.25; num197++)
				{
					int num198 = ((!remixWorldGen) ? genRand.Next((int)(Main.worldSurface + Main.rockLayer) / 2, GenVars.lavaLine) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300));
					int num199 = genRand.Next(GenVars.snowMinX[num198], GenVars.snowMaxX[num198]);
					if (Main.tile[num199, num198].active() && (Main.tile[num199, num198].type == 147 || Main.tile[num199, num198].type == 161 || Main.tile[num199, num198].type == 162 || Main.tile[num199, num198].type == 224))
					{
						int num200 = genRand.Next(1, 4);
						int num201 = genRand.Next(1, 4);
						int num202 = genRand.Next(1, 4);
						int num203 = genRand.Next(1, 4);
						int num204 = genRand.Next(12);
						int num205 = 0;
						num205 = ((num204 >= 3) ? ((num204 < 6) ? 1 : ((num204 < 8) ? 2 : ((num204 < 10) ? 3 : ((num204 >= 11) ? 5 : 4)))) : 0);
						for (int num206 = num199 - num200; num206 < num199 + num201; num206++)
						{
							for (int num207 = num198 - num202; num207 < num198 + num203; num207++)
							{
								if (!Main.tile[num206, num207].active())
								{
									PlaceTile(num206, num207, 178, mute: true, forced: false, -1, num205);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Random Gems", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num183 = 0; num183 < Main.maxTilesX; num183++)
				{
					int num184 = genRand.Next(20, Main.maxTilesX - 20);
					int num185 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 300);
					if (!Main.tile[num184, num185].active() && !Main.tile[num184, num185].lava() && !Main.wallDungeon[Main.tile[num184, num185].wall] && Main.tile[num184, num185].wall != 27)
					{
						int num186 = genRand.Next(12);
						int num187 = 0;
						num187 = ((num186 >= 3) ? ((num186 < 6) ? 1 : ((num186 < 8) ? 2 : ((num186 < 10) ? 3 : ((num186 >= 11) ? 5 : 4)))) : 0);
						PlaceTile(num184, num185, 178, mute: true, forced: false, -1, num187);
					}
				}
				for (int num188 = 0; num188 < Main.maxTilesX; num188++)
				{
					int num189 = genRand.Next(20, Main.maxTilesX - 20);
					int num190 = genRand.Next((int)Main.worldSurface, Main.maxTilesY - 300);
					if (!Main.tile[num189, num190].active() && !Main.tile[num189, num190].lava() && (Main.tile[num189, num190].wall == 216 || Main.tile[num189, num190].wall == 187))
					{
						int num191 = genRand.Next(1, 4);
						int num192 = genRand.Next(1, 4);
						int num193 = genRand.Next(1, 4);
						int num194 = genRand.Next(1, 4);
						for (int num195 = num189 - num191; num195 < num189 + num192; num195++)
						{
							for (int num196 = num190 - num193; num196 < num190 + num194; num196++)
							{
								if (!Main.tile[num195, num196].active())
								{
									PlaceTile(num195, num196, 178, mute: true, forced: false, -1, 6);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Moss Grass", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num178 = 5; num178 < Main.maxTilesX - 5; num178++)
				{
					for (int num179 = 5; num179 < Main.maxTilesY - 5; num179++)
					{
						if (Main.tile[num178, num179].active() && Main.tileMoss[Main.tile[num178, num179].type])
						{
							for (int num180 = 0; num180 < 4; num180++)
							{
								int num181 = num178;
								int num182 = num179;
								if (num180 == 0)
								{
									num181--;
								}
								if (num180 == 1)
								{
									num181++;
								}
								if (num180 == 2)
								{
									num182--;
								}
								if (num180 == 3)
								{
									num182++;
								}
								if (!Main.tile[num181, num182].active())
								{
									PlaceTile(num181, num182, 184, mute: true);
								}
							}
						}
					}
				}
			});
			AddGenerationPass("Muds Walls In Jungle", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				int num170 = 0;
				int num171 = 0;
				bool flag4 = false;
				for (int num172 = 5; num172 < Main.maxTilesX - 5; num172++)
				{
					for (int num173 = 0; (double)num173 < Main.worldSurface + 20.0; num173++)
					{
						if (Main.tile[num172, num173].active() && Main.tile[num172, num173].type == 60)
						{
							num170 = num172;
							flag4 = true;
							break;
						}
					}
					if (flag4)
					{
						break;
					}
				}
				flag4 = false;
				for (int num174 = Main.maxTilesX - 5; num174 > 5; num174--)
				{
					for (int num175 = 0; (double)num175 < Main.worldSurface + 20.0; num175++)
					{
						if (Main.tile[num174, num175].active() && Main.tile[num174, num175].type == 60)
						{
							num171 = num174;
							flag4 = true;
							break;
						}
					}
					if (flag4)
					{
						break;
					}
				}
				GenVars.jungleMinX = num170;
				GenVars.jungleMaxX = num171;
				for (int num176 = num170; num176 <= num171; num176++)
				{
					for (int num177 = 0; (double)num177 < Main.worldSurface + 20.0; num177++)
					{
						if (((num176 >= num170 + 2 && num176 <= num171 - 2) || genRand.Next(2) != 0) && ((num176 >= num170 + 3 && num176 <= num171 - 3) || genRand.Next(3) != 0) && (Main.tile[num176, num177].wall == 2 || Main.tile[num176, num177].wall == 59))
						{
							Main.tile[num176, num177].wall = 15;
						}
					}
				}
			});
			AddGenerationPass("Larva", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				Main.tileSolid[229] = true;
				progress.Set(1.0);
				for (int num165 = 0; num165 < GenVars.numLarva; num165++)
				{
					int num166 = GenVars.larvaX[num165];
					int num167 = GenVars.larvaY[num165];
					for (int num168 = num166 - 1; num168 <= num166 + 1; num168++)
					{
						for (int num169 = num167 - 2; num169 <= num167 + 1; num169++)
						{
							if (num169 != num167 + 1)
							{
								Main.tile[num168, num169].active(active: false);
							}
							else
							{
								Main.tile[num168, num169].active(active: true);
								Main.tile[num168, num169].type = 225;
								Main.tile[num168, num169].slope(0);
								Main.tile[num168, num169].halfBrick(halfBrick: false);
							}
						}
					}
					PlaceTile(num166, num167, 231, mute: true);
				}
				Main.tileSolid[232] = true;
				Main.tileSolid[162] = true;
			});
			AddGenerationPass("Settle Liquids Again", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (getGoodWorldGen)
				{
					Main.tileSolid[56] = true;
				}
				progress.Message = Lang.gen[27].Value;
				if (notTheBees)
				{
					NotTheBees();
				}
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: true);
				Liquid.QuickWater(3);
				WaterCheck();
				int num159 = 0;
				Liquid.quickSettle = true;
				int num160 = 10;
				while (num159 < num160)
				{
					int num161 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
					num159++;
					double num162 = 0.0;
					int num163 = num161 * 5;
					while (Liquid.numLiquid > 0)
					{
						num163--;
						if (num163 < 0)
						{
							break;
						}
						double num164 = (double)(num161 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (double)num161;
						if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num161)
						{
							num161 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
						}
						if (num164 > num162)
						{
							num162 = num164;
						}
						else
						{
							num164 = num162;
						}
						if (num159 == 1)
						{
							progress.Set(num164 / 3.0 + 0.33);
						}
						Liquid.UpdateLiquid();
					}
					WaterCheck();
					progress.Set((double)num159 / (double)num160 / 3.0 + 0.66);
				}
				Liquid.quickSettle = false;
				Liquid.worldGenTilesIgnoreWater(ignoreSolids: false);
				Main.tileSolid[484] = false;
			});
			AddGenerationPass("Cactus, Palm Trees, & Coral", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[38].Value;
				int num131 = 8;
				if (remixWorldGen)
				{
					num131 = 2;
				}
				int num132 = 400;
				int num133 = genRand.Next(3, 13);
				int num134 = genRand.Next(3, 13);
				int num135 = genRand.Next(2, 6);
				int num136 = genRand.Next(2, 6);
				int num137 = 380;
				for (int num138 = 0; num138 < GenVars.numOasis; num138++)
				{
					int num139 = (int)((double)GenVars.oasisWidth[num138] * 1.5);
					for (int num140 = GenVars.oasisPosition[num138].X - num139; num140 <= GenVars.oasisPosition[num138].X + num139; num140++)
					{
						for (int num141 = GenVars.oasisPosition[num138].Y - GenVars.oasisHeight; num141 <= GenVars.oasisPosition[num138].Y + GenVars.oasisHeight; num141++)
						{
							double num142 = 1.0;
							int num143 = 8;
							for (int num144 = num140 - num143; num144 <= num140 + num143; num144++)
							{
								for (int num145 = num141 - num143; num145 <= num141 + num143; num145++)
								{
									if (InWorld(num144, num145) && Main.tile[num144, num145] != null && Main.tile[num144, num145].active() && Main.tile[num144, num145].type == 323)
									{
										num142 = 0.13;
									}
								}
							}
							if (genRand.NextDouble() < num142)
							{
								GrowPalmTree(num140, num141);
							}
							if (PlantSeaOat(num140, num141))
							{
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(num140, num141);
								}
								if (genRand.Next(2) == 0)
								{
									GrowSeaOat(num140, num141);
								}
							}
							PlaceOasisPlant(num140, num141, 530);
						}
					}
				}
				for (int num146 = 0; num146 < 3; num146++)
				{
					progress.Set((double)num146 / 3.0);
					int num147;
					int num148;
					bool flag3;
					int maxValue4;
					switch (num146)
					{
					default:
						num147 = 5;
						num148 = num137;
						flag3 = false;
						maxValue4 = num133;
						break;
					case 1:
						num147 = num132;
						num148 = Main.maxTilesX - num132;
						flag3 = true;
						maxValue4 = num131;
						break;
					case 2:
						num147 = Main.maxTilesX - num137;
						num148 = Main.maxTilesX - 5;
						flag3 = false;
						maxValue4 = num134;
						break;
					}
					double num149 = Main.worldSurface - 1.0;
					if (remixWorldGen)
					{
						num149 = Main.maxTilesY - 50;
					}
					for (int num150 = num147; num150 < num148; num150++)
					{
						if (genRand.Next(maxValue4) == 0)
						{
							for (int num151 = 0; (double)num151 < num149; num151++)
							{
								Tile tile4 = Main.tile[num150, num151];
								if (tile4.active() && (tile4.type == 53 || tile4.type == 112 || tile4.type == 234))
								{
									Tile tile5 = Main.tile[num150, num151 - 1];
									if (!tile5.active() && tile5.wall == 0)
									{
										if (flag3)
										{
											if (remixWorldGen)
											{
												if ((double)num151 > Main.worldSurface)
												{
													if (SolidTile(num150, num151) && Main.tile[num150, num151 + 1].type == 53 && Main.tile[num150, num151 + 2].type == 53)
													{
														int maxValue5 = 3;
														GrowPalmTree(num150, num151);
														if (!Main.tile[num150, num151 - 1].active() && genRand.Next(maxValue5) == 0)
														{
															PlantCactus(num150, num151);
														}
													}
												}
												else
												{
													int num152 = 0;
													for (int num153 = num150 - cactusWaterWidth; num153 < num150 + cactusWaterWidth; num153++)
													{
														for (int num154 = num151 - cactusWaterHeight; num154 < num151 + cactusWaterHeight; num154++)
														{
															num152 += Main.tile[num153, num154].liquid;
														}
													}
													if (num152 / 255 > cactusWaterLimit)
													{
														int maxValue6 = 4;
														if (genRand.Next(maxValue6) == 0)
														{
															GrowPalmTree(num150, num151);
														}
													}
													else
													{
														PlantCactus(num150, num151);
													}
												}
											}
											else
											{
												int num155 = 0;
												for (int num156 = num150 - cactusWaterWidth; num156 < num150 + cactusWaterWidth; num156++)
												{
													for (int num157 = num151 - cactusWaterHeight; num157 < num151 + cactusWaterHeight; num157++)
													{
														num155 += Main.tile[num156, num157].liquid;
													}
												}
												if (num155 / 255 > cactusWaterLimit)
												{
													int maxValue7 = 4;
													if (genRand.Next(maxValue7) == 0)
													{
														GrowPalmTree(num150, num151);
													}
												}
												else
												{
													PlantCactus(num150, num151);
												}
											}
										}
										else
										{
											if (Main.tile[num150, num151 - 2].liquid == byte.MaxValue && Main.tile[num150, num151 - 3].liquid == byte.MaxValue && Main.tile[num150, num151 - 4].liquid == byte.MaxValue)
											{
												if (genRand.Next(2) == 0)
												{
													PlaceTile(num150, num151 - 1, 81, mute: true);
												}
												else
												{
													PlaceTile(num150, num151 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
												}
												break;
											}
											if (Main.tile[num150, num151 - 2].liquid == 0 && (double)num151 < Main.worldSurface)
											{
												PlaceTile(num150, num151 - 1, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
												break;
											}
										}
									}
								}
							}
						}
						else
						{
							for (int num158 = 0; (double)num158 < num149; num158++)
							{
								if (PlantSeaOat(num150, num158))
								{
									if (genRand.Next(2) == 0)
									{
										GrowSeaOat(num150, num158);
									}
									if (genRand.Next(2) == 0)
									{
										GrowSeaOat(num150, num158);
									}
								}
								PlaceOasisPlant(num150, num158, 530);
							}
						}
					}
				}
			});
			AddGenerationPass("Tile Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[84].Value;
				for (int num63 = 40; num63 < Main.maxTilesX - 40; num63++)
				{
					progress.Set((double)(num63 - 40) / (double)(Main.maxTilesX - 80));
					for (int num64 = 40; num64 < Main.maxTilesY - 40; num64++)
					{
						if (Main.tile[num63, num64].active() && Main.tile[num63, num64].topSlope() && ((Main.tile[num63, num64].leftSlope() && Main.tile[num63 + 1, num64].halfBrick()) || (Main.tile[num63, num64].rightSlope() && Main.tile[num63 - 1, num64].halfBrick())))
						{
							Main.tile[num63, num64].slope(0);
							Main.tile[num63, num64].halfBrick(halfBrick: true);
						}
						if (Main.tile[num63, num64].active() && Main.tile[num63, num64].liquid > 0 && TileID.Sets.SlowlyDiesInWater[Main.tile[num63, num64].type])
						{
							KillTile(num63, num64);
						}
						if (!Main.tile[num63, num64].active() && Main.tile[num63, num64].liquid == 0 && genRand.Next(3) != 0 && SolidTile(num63, num64 - 1))
						{
							int num65 = genRand.Next(15, 21);
							for (int num66 = num64 - 2; num66 >= num64 - num65; num66--)
							{
								if (Main.tile[num63, num66].liquid >= 128 && !Main.tile[num63, num66].shimmer())
								{
									int num67 = 373;
									if (Main.tile[num63, num66].lava())
									{
										num67 = 374;
									}
									else if (Main.tile[num63, num66].honey())
									{
										num67 = 375;
									}
									int maxValue3 = num64 - num66;
									if (genRand.Next(maxValue3) <= 1)
									{
										if (Main.tile[num63, num64].wall == 86)
										{
											num67 = 375;
										}
										Main.tile[num63, num64].type = (ushort)num67;
										Main.tile[num63, num64].frameX = 0;
										Main.tile[num63, num64].frameY = 0;
										Main.tile[num63, num64].active(active: true);
										break;
									}
								}
							}
							if (!Main.tile[num63, num64].active())
							{
								num65 = genRand.Next(3, 11);
								for (int num68 = num64 + 1; num68 <= num64 + num65; num68++)
								{
									if (Main.tile[num63, num68].liquid >= 200 && !Main.tile[num63, num68].shimmer())
									{
										int num69 = 373;
										if (Main.tile[num63, num68].lava())
										{
											num69 = 374;
										}
										else if (Main.tile[num63, num68].honey())
										{
											num69 = 375;
										}
										int num70 = num68 - num64;
										if (genRand.Next(num70 * 3) <= 1)
										{
											Main.tile[num63, num64].type = (ushort)num69;
											Main.tile[num63, num64].frameX = 0;
											Main.tile[num63, num64].frameY = 0;
											Main.tile[num63, num64].active(active: true);
											break;
										}
									}
								}
							}
							if (!Main.tile[num63, num64].active() && genRand.Next(4) == 0)
							{
								Tile tile3 = Main.tile[num63, num64 - 1];
								if (TileID.Sets.Conversion.Sandstone[tile3.type] || TileID.Sets.Conversion.HardenedSand[tile3.type])
								{
									Main.tile[num63, num64].type = 461;
									Main.tile[num63, num64].frameX = 0;
									Main.tile[num63, num64].frameY = 0;
									Main.tile[num63, num64].active(active: true);
								}
							}
						}
						if (Main.tile[num63, num64].type == 137)
						{
							int num71 = Main.tile[num63, num64].frameY / 18;
							if (num71 <= 2 || num71 == 5)
							{
								int num72 = -1;
								if (Main.tile[num63, num64].frameX >= 18)
								{
									num72 = 1;
								}
								if (Main.tile[num63 + num72, num64].halfBrick() || Main.tile[num63 + num72, num64].slope() != 0)
								{
									Main.tile[num63 + num72, num64].active(active: false);
								}
							}
						}
						else if (Main.tile[num63, num64].type == 162 && Main.tile[num63, num64 + 1].liquid == 0 && CanKillTile(num63, num64))
						{
							Main.tile[num63, num64].active(active: false);
						}
						if (Main.tile[num63, num64].wall == 13 || Main.tile[num63, num64].wall == 14)
						{
							Main.tile[num63, num64].liquid = 0;
						}
						if (Main.tile[num63, num64].type == 31)
						{
							int num73 = Main.tile[num63, num64].frameX / 18;
							int num74 = 0;
							int num75 = num63;
							num74 += num73 / 2;
							num74 = ((!drunkWorldGen) ? (crimson ? 1 : 0) : ((Main.tile[num63, num64].wall == 83) ? 1 : 0));
							num73 %= 2;
							num75 -= num73;
							int num76 = Main.tile[num63, num64].frameY / 18;
							int num77 = 0;
							int num78 = num64;
							num77 += num76 / 2;
							num76 %= 2;
							num78 -= num76;
							for (int num79 = 0; num79 < 2; num79++)
							{
								for (int num80 = 0; num80 < 2; num80++)
								{
									int num81 = num75 + num79;
									int num82 = num78 + num80;
									Main.tile[num81, num82].active(active: true);
									Main.tile[num81, num82].slope(0);
									Main.tile[num81, num82].halfBrick(halfBrick: false);
									Main.tile[num81, num82].type = 31;
									Main.tile[num81, num82].frameX = (short)(num79 * 18 + 36 * num74);
									Main.tile[num81, num82].frameY = (short)(num80 * 18 + 36 * num77);
								}
							}
						}
						if (Main.tile[num63, num64].type == 12)
						{
							int num83 = Main.tile[num63, num64].frameX / 18;
							int num84 = 0;
							int num85 = num63;
							num84 += num83 / 2;
							num83 %= 2;
							num85 -= num83;
							int num86 = Main.tile[num63, num64].frameY / 18;
							int num87 = 0;
							int num88 = num64;
							num87 += num86 / 2;
							num86 %= 2;
							num88 -= num86;
							for (int num89 = 0; num89 < 2; num89++)
							{
								for (int num90 = 0; num90 < 2; num90++)
								{
									int num91 = num85 + num89;
									int num92 = num88 + num90;
									Main.tile[num91, num92].active(active: true);
									Main.tile[num91, num92].slope(0);
									Main.tile[num91, num92].halfBrick(halfBrick: false);
									Main.tile[num91, num92].type = 12;
									Main.tile[num91, num92].frameX = (short)(num89 * 18 + 36 * num84);
									Main.tile[num91, num92].frameY = (short)(num90 * 18 + 36 * num87);
								}
								if (!Main.tile[num89, num64 + 2].active())
								{
									Main.tile[num89, num64 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num89, num64 + 2].type] || Main.tileSolidTop[Main.tile[num89, num64 + 2].type])
									{
										Main.tile[num89, num64 + 2].type = 0;
									}
								}
								Main.tile[num89, num64 + 2].slope(0);
								Main.tile[num89, num64 + 2].halfBrick(halfBrick: false);
							}
						}
						if (Main.tile[num63, num64].type == 639)
						{
							int num93 = Main.tile[num63, num64].frameX / 18;
							int num94 = 0;
							int num95 = num63;
							num94 += num93 / 2;
							num93 %= 2;
							num95 -= num93;
							int num96 = Main.tile[num63, num64].frameY / 18;
							int num97 = 0;
							int num98 = num64;
							num97 += num96 / 2;
							num96 %= 2;
							num98 -= num96;
							for (int num99 = 0; num99 < 2; num99++)
							{
								for (int num100 = 0; num100 < 2; num100++)
								{
									int num101 = num95 + num99;
									int num102 = num98 + num100;
									Main.tile[num101, num102].active(active: true);
									Main.tile[num101, num102].slope(0);
									Main.tile[num101, num102].halfBrick(halfBrick: false);
									Main.tile[num101, num102].type = 639;
									Main.tile[num101, num102].frameX = (short)(num99 * 18 + 36 * num94);
									Main.tile[num101, num102].frameY = (short)(num100 * 18 + 36 * num97);
								}
								if (!Main.tile[num99, num64 + 2].active())
								{
									Main.tile[num99, num64 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num99, num64 + 2].type] || Main.tileSolidTop[Main.tile[num99, num64 + 2].type])
									{
										Main.tile[num99, num64 + 2].type = 0;
									}
								}
								Main.tile[num99, num64 + 2].slope(0);
								Main.tile[num99, num64 + 2].halfBrick(halfBrick: false);
							}
						}
						if (TileID.Sets.BasicChest[Main.tile[num63, num64].type])
						{
							int num103 = Main.tile[num63, num64].frameX / 18;
							int num104 = 0;
							ushort type2 = 21;
							int num105 = num63;
							int num106 = num64 - Main.tile[num63, num64].frameY / 18;
							if (Main.tile[num63, num64].type == 467)
							{
								type2 = 467;
							}
							while (num103 >= 2)
							{
								num104++;
								num103 -= 2;
							}
							num105 -= num103;
							int num107 = Chest.FindChest(num105, num106);
							if (num107 != -1)
							{
								switch (Main.chest[num107].item[0].type)
								{
								case 1156:
									num104 = 23;
									break;
								case 1571:
									num104 = 24;
									break;
								case 1569:
									num104 = 25;
									break;
								case 1260:
									num104 = 26;
									break;
								case 1572:
									num104 = 27;
									break;
								}
							}
							for (int num108 = 0; num108 < 2; num108++)
							{
								for (int num109 = 0; num109 < 2; num109++)
								{
									int num110 = num105 + num108;
									int num111 = num106 + num109;
									Main.tile[num110, num111].active(active: true);
									Main.tile[num110, num111].slope(0);
									Main.tile[num110, num111].halfBrick(halfBrick: false);
									Main.tile[num110, num111].type = type2;
									Main.tile[num110, num111].frameX = (short)(num108 * 18 + 36 * num104);
									Main.tile[num110, num111].frameY = (short)(num109 * 18);
								}
								if (!Main.tile[num108, num64 + 2].active())
								{
									Main.tile[num108, num64 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num108, num64 + 2].type] || Main.tileSolidTop[Main.tile[num108, num64 + 2].type])
									{
										Main.tile[num108, num64 + 2].type = 0;
									}
								}
								Main.tile[num108, num64 + 2].slope(0);
								Main.tile[num108, num64 + 2].halfBrick(halfBrick: false);
							}
						}
						if (Main.tile[num63, num64].type == 28)
						{
							int num112 = Main.tile[num63, num64].frameX / 18;
							int num113 = 0;
							int num114 = num63;
							while (num112 >= 2)
							{
								num113++;
								num112 -= 2;
							}
							num114 -= num112;
							int num115 = Main.tile[num63, num64].frameY / 18;
							int num116 = 0;
							int num117 = num64;
							while (num115 >= 2)
							{
								num116++;
								num115 -= 2;
							}
							num117 -= num115;
							for (int num118 = 0; num118 < 2; num118++)
							{
								for (int num119 = 0; num119 < 2; num119++)
								{
									int num120 = num114 + num118;
									int num121 = num117 + num119;
									Main.tile[num120, num121].active(active: true);
									Main.tile[num120, num121].slope(0);
									Main.tile[num120, num121].halfBrick(halfBrick: false);
									Main.tile[num120, num121].type = 28;
									Main.tile[num120, num121].frameX = (short)(num118 * 18 + 36 * num113);
									Main.tile[num120, num121].frameY = (short)(num119 * 18 + 36 * num116);
								}
								if (!Main.tile[num118, num64 + 2].active())
								{
									Main.tile[num118, num64 + 2].active(active: true);
									if (!Main.tileSolid[Main.tile[num118, num64 + 2].type] || Main.tileSolidTop[Main.tile[num118, num64 + 2].type])
									{
										Main.tile[num118, num64 + 2].type = 0;
									}
								}
								Main.tile[num118, num64 + 2].slope(0);
								Main.tile[num118, num64 + 2].halfBrick(halfBrick: false);
							}
						}
						if (Main.tile[num63, num64].type == 26)
						{
							int num122 = Main.tile[num63, num64].frameX / 18;
							int num123 = 0;
							int num124 = num63;
							int num125 = num64 - Main.tile[num63, num64].frameY / 18;
							while (num122 >= 3)
							{
								num123++;
								num122 -= 3;
							}
							num124 -= num122;
							num123 = (drunkWorldGen ? ((Main.tile[num63, num64].wall == 83) ? 1 : 0) : (crimson ? 1 : 0));
							for (int num126 = 0; num126 < 3; num126++)
							{
								for (int num127 = 0; num127 < 2; num127++)
								{
									int num128 = num124 + num126;
									int num129 = num125 + num127;
									Main.tile[num128, num129].active(active: true);
									Main.tile[num128, num129].slope(0);
									Main.tile[num128, num129].halfBrick(halfBrick: false);
									Main.tile[num128, num129].type = 26;
									Main.tile[num128, num129].frameX = (short)(num126 * 18 + 54 * num123);
									Main.tile[num128, num129].frameY = (short)(num127 * 18);
								}
								if (!Main.tile[num124 + num126, num125 + 2].active() || !Main.tileSolid[Main.tile[num124 + num126, num125 + 2].type] || Main.tileSolidTop[Main.tile[num124 + num126, num125 + 2].type])
								{
									Main.tile[num124 + num126, num125 + 2].active(active: true);
									if (!TileID.Sets.Platforms[Main.tile[num124 + num126, num125 + 2].type])
									{
										if (Main.tile[num124 + num126, num125 + 2].type == 484)
										{
											Main.tile[num124 + num126, num125 + 2].type = 397;
										}
										else if (TileID.Sets.Boulders[Main.tile[num124 + num126, num125 + 2].type] || !Main.tileSolid[Main.tile[num124 + num126, num125 + 2].type] || Main.tileSolidTop[Main.tile[num124 + num126, num125 + 2].type])
										{
											Main.tile[num124 + num126, num125 + 2].type = 0;
										}
									}
								}
								Main.tile[num124 + num126, num125 + 2].slope(0);
								Main.tile[num124 + num126, num125 + 2].halfBrick(halfBrick: false);
								if (Main.tile[num124 + num126, num125 + 3].type == 28 && Main.tile[num124 + num126, num125 + 3].frameY % 36 >= 18)
								{
									Main.tile[num124 + num126, num125 + 3].type = 0;
									Main.tile[num124 + num126, num125 + 3].active(active: false);
								}
							}
							for (int num130 = 0; num130 < 3; num130++)
							{
								if ((Main.tile[num124 - 1, num125 + num130].type == 28 || Main.tile[num124 - 1, num125 + num130].type == 12 || Main.tile[num124 - 1, num125 + num130].type == 639) && Main.tile[num124 - 1, num125 + num130].frameX % 36 < 18)
								{
									Main.tile[num124 - 1, num125 + num130].type = 0;
									Main.tile[num124 - 1, num125 + num130].active(active: false);
								}
								if ((Main.tile[num124 + 3, num125 + num130].type == 28 || Main.tile[num124 + 3, num125 + num130].type == 12 || Main.tile[num124 - 1, num125 + num130].type == 639) && Main.tile[num124 + 3, num125 + num130].frameX % 36 >= 18)
								{
									Main.tile[num124 + 3, num125 + num130].type = 0;
									Main.tile[num124 + 3, num125 + num130].active(active: false);
								}
							}
						}
						if (Main.tile[num63, num64].type == 237 && Main.tile[num63, num64 + 1].type == 232)
						{
							Main.tile[num63, num64 + 1].type = 226;
						}
						if (Main.tile[num63, num64].wall == 87)
						{
							Main.tile[num63, num64].liquid = 0;
						}
					}
				}
			});
			AddGenerationPass("Lihzahrd Altars", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num57 = 0; num57 < 3; num57++)
				{
					for (int num58 = 0; num58 < 2; num58++)
					{
						int num59 = GenVars.lAltarX + num57;
						int num60 = GenVars.lAltarY + num58;
						Main.tile[num59, num60].active(active: true);
						Main.tile[num59, num60].type = 237;
						Main.tile[num59, num60].frameX = (short)(num57 * 18);
						Main.tile[num59, num60].frameY = (short)(num58 * 18);
					}
					Main.tile[GenVars.lAltarX + num57, GenVars.lAltarY + 2].active(active: true);
					Main.tile[GenVars.lAltarX + num57, GenVars.lAltarY + 2].slope(0);
					Main.tile[GenVars.lAltarX + num57, GenVars.lAltarY + 2].halfBrick(halfBrick: false);
					Main.tile[GenVars.lAltarX + num57, GenVars.lAltarY + 2].type = 226;
				}
				for (int num61 = 0; num61 < 3; num61++)
				{
					for (int num62 = 0; num62 < 2; num62++)
					{
						int i2 = GenVars.lAltarX + num61;
						int j2 = GenVars.lAltarY + num62;
						SquareTileFrame(i2, j2);
					}
				}
			});
			AddGenerationPass("Micro Biomes", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[76].Value;
				_ = (double)(Main.maxTilesX * Main.maxTilesY) / 5040000.0;
				double num36 = 10.0;
				if (getGoodWorldGen || noTrapsWorldGen)
				{
					num36 *= 3.0;
				}
				DeadMansChestBiome deadMansChestBiome = GenVars.configuration.CreateBiome<DeadMansChestBiome>();
				List<int> possibleChestsToTrapify = deadMansChestBiome.GetPossibleChestsToTrapify(GenVars.structures);
				int random = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(genRand);
				int num37 = 0;
				while (num37 < random && possibleChestsToTrapify.Count > 0)
				{
					int num38 = possibleChestsToTrapify[genRand.Next(possibleChestsToTrapify.Count)];
					Point origin = new Point(Main.chest[num38].x, Main.chest[num38].y);
					deadMansChestBiome.Place(origin, GenVars.structures);
					num37++;
					possibleChestsToTrapify.Remove(num38);
				}
				progress.Set(1.0 / num36);
				if (!notTheBees || remixWorldGen)
				{
					ThinIceBiome thinIceBiome = GenVars.configuration.CreateBiome<ThinIceBiome>();
					int random2 = passConfig.Get<WorldGenRange>("ThinIcePatchCount").GetRandom(genRand);
					int num39 = 0;
					int num40 = 1000;
					int num41 = 0;
					while (num41 < random2)
					{
						if (thinIceBiome.Place(RandomWorldPoint((int)Main.worldSurface + 20, 50, 200, 50), GenVars.structures))
						{
							num41++;
							num39 = 0;
						}
						else
						{
							num39++;
							if (num39 > num40)
							{
								num41++;
								num39 = 0;
							}
						}
					}
				}
				progress.Set(0.1);
				progress.Set(2.0 / num36);
				EnchantedSwordBiome enchantedSwordBiome = GenVars.configuration.CreateBiome<EnchantedSwordBiome>();
				int num42 = passConfig.Get<WorldGenRange>("SwordShrineAttempts").GetRandom(genRand);
				double num43 = passConfig.Get<double>("SwordShrinePlacementChance");
				if (tenthAnniversaryWorldGen)
				{
					num42 *= 2;
					num43 /= 2.0;
				}
				Point origin2 = default(Point);
				for (int num44 = 0; num44 < num42; num44++)
				{
					if ((num44 == 0 && tenthAnniversaryWorldGen) || !(genRand.NextDouble() > num43))
					{
						int num45 = 0;
						while (num45++ <= Main.maxTilesX)
						{
							origin2.Y = (int)GenVars.worldSurface + genRand.Next(50, 100);
							if (genRand.Next(2) == 0)
							{
								origin2.X = genRand.Next(50, (int)((double)Main.maxTilesX * 0.3));
							}
							else
							{
								origin2.X = genRand.Next((int)((double)Main.maxTilesX * 0.7), Main.maxTilesX - 50);
							}
							if (enchantedSwordBiome.Place(origin2, GenVars.structures))
							{
								break;
							}
						}
					}
				}
				progress.Set(0.2);
				progress.Set(3.0 / num36);
				if (!notTheBees || remixWorldGen)
				{
					CampsiteBiome campsiteBiome = GenVars.configuration.CreateBiome<CampsiteBiome>();
					int random3 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(genRand);
					int num46 = 0;
					while (num46 < random3)
					{
						if (campsiteBiome.Place(RandomWorldPoint((int)Main.worldSurface, beachDistance, 200, beachDistance), GenVars.structures))
						{
							num46++;
						}
					}
				}
				progress.Set(4.0 / num36);
				if (!notTheBees || remixWorldGen)
				{
					MiningExplosivesBiome miningExplosivesBiome = GenVars.configuration.CreateBiome<MiningExplosivesBiome>();
					int num47 = passConfig.Get<WorldGenRange>("ExplosiveTrapCount").GetRandom(genRand);
					if ((getGoodWorldGen || noTrapsWorldGen) && !notTheBees)
					{
						num47 = (int)((double)num47 * 1.5);
					}
					int num48 = 0;
					while (num48 < num47)
					{
						if (remixWorldGen)
						{
							if (miningExplosivesBiome.Place(RandomWorldPoint((int)Main.worldSurface, beachDistance, (int)GenVars.rockLayer, beachDistance), GenVars.structures))
							{
								num48++;
							}
						}
						else if (miningExplosivesBiome.Place(RandomWorldPoint((int)GenVars.rockLayer, beachDistance, 200, beachDistance), GenVars.structures))
						{
							num48++;
						}
					}
				}
				progress.Set(0.3);
				progress.Set(5.0 / num36);
				MahoganyTreeBiome mahoganyTreeBiome = GenVars.configuration.CreateBiome<MahoganyTreeBiome>();
				int random4 = passConfig.Get<WorldGenRange>("LivingTreeCount").GetRandom(genRand);
				int num49 = 0;
				int num50 = 0;
				while (num49 < random4 && num50 < 20000)
				{
					if (mahoganyTreeBiome.Place(RandomWorldPoint((int)Main.worldSurface + 50, 50, 500, 50), GenVars.structures))
					{
						num49++;
					}
					num50++;
				}
				progress.Set(0.4);
				progress.Set(6.0 / num36);
				progress.Set(7.0 / num36);
				TrackGenerator trackGenerator = new TrackGenerator();
				int random5 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(genRand);
				WorldGenRange worldGenRange = passConfig.Get<WorldGenRange>("LongTrackLength");
				int maxTilesX = Main.maxTilesX;
				int num51 = 0;
				int num52 = 0;
				while (num52 < random5)
				{
					if (trackGenerator.Place(RandomWorldPoint((int)Main.worldSurface, 10, 200, 10), worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
					{
						num52++;
						num51 = 0;
					}
					else
					{
						num51++;
						if (num51 > maxTilesX)
						{
							num52++;
							num51 = 0;
						}
					}
				}
				progress.Set(8.0 / num36);
				random5 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(genRand);
				worldGenRange = passConfig.Get<WorldGenRange>("StandardTrackLength");
				num51 = 0;
				int num53 = 0;
				while (num53 < random5)
				{
					if (trackGenerator.Place(RandomWorldPoint((int)Main.worldSurface, 10, 200, 10), worldGenRange.ScaledMinimum, worldGenRange.ScaledMaximum))
					{
						num53++;
						num51 = 0;
					}
					else
					{
						num51++;
						if (num51 > maxTilesX)
						{
							num53++;
							num51 = 0;
						}
					}
				}
				progress.Set(9.0 / num36);
				if (!notTheBees)
				{
					double num54 = (double)Main.maxTilesX * 0.02;
					if (noTrapsWorldGen)
					{
						num36 *= 5.0;
					}
					else if (getGoodWorldGen)
					{
						num36 *= 2.0;
					}
					for (int num55 = 0; (double)num55 < num54; num55++)
					{
						for (int num56 = 0; num56 < 10150; num56++)
						{
							int x2 = genRand.Next(200, Main.maxTilesX - 200);
							int y2 = genRand.Next(GenVars.lavaLine - 100, Main.maxTilesY - 210);
							if (placeLavaTrap(x2, y2))
							{
								break;
							}
						}
					}
				}
				progress.Set(1.0);
			});
			AddGenerationPass("Water Plants", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Message = Lang.gen[88].Value;
				int num28 = (int)Main.worldSurface;
				if (remixWorldGen)
				{
					num28 = Main.maxTilesY - 200;
				}
				for (int num29 = 20; num29 < Main.maxTilesX - 20; num29++)
				{
					progress.Set((double)num29 / (double)Main.maxTilesX);
					for (int num30 = 1; num30 < num28; num30++)
					{
						if (genRand.Next(5) == 0 && Main.tile[num29, num30].liquid > 0)
						{
							if (!Main.tile[num29, num30].active())
							{
								if (genRand.Next(2) == 0)
								{
									PlaceLilyPad(num29, num30);
								}
								else
								{
									Point point = PlaceCatTail(num29, num30);
									if (InWorld(point.X, point.Y))
									{
										int num31 = genRand.Next(14);
										for (int num32 = 0; num32 < num31; num32++)
										{
											GrowCatTail(point.X, point.Y);
										}
										SquareTileFrame(point.X, point.Y);
									}
								}
							}
							if ((!Main.tile[num29, num30].active() || Main.tile[num29, num30].type == 61 || Main.tile[num29, num30].type == 74) && PlaceBamboo(num29, num30))
							{
								int num33 = genRand.Next(10, 20);
								for (int num34 = 0; num34 < num33 && PlaceBamboo(num29, num30 - num34); num34++)
								{
								}
							}
						}
					}
					int num35 = Main.UnderworldLayer;
					while ((double)num35 > Main.worldSurface)
					{
						if (Main.tile[num29, num35].type == 53 && genRand.Next(3) != 0)
						{
							GrowCheckSeaweed(num29, num35);
						}
						else if (Main.tile[num29, num35].type == 549)
						{
							GrowCheckSeaweed(num29, num35);
						}
						num35--;
					}
				}
			});
			AddGenerationPass("Stalac", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				progress.Set(1.0);
				for (int num24 = 20; num24 < Main.maxTilesX - 20; num24++)
				{
					for (int num25 = (int)Main.worldSurface; num25 < Main.maxTilesY - 20; num25++)
					{
						if ((Main.tenthAnniversaryWorld || drunkWorldGen || genRand.Next(5) == 0) && Main.tile[num24, num25 - 1].liquid == 0)
						{
							int num26 = genRand.Next(7);
							int treeTileType = 0;
							switch (num26)
							{
							case 0:
								treeTileType = 583;
								break;
							case 1:
								treeTileType = 584;
								break;
							case 2:
								treeTileType = 585;
								break;
							case 3:
								treeTileType = 586;
								break;
							case 4:
								treeTileType = 587;
								break;
							case 5:
								treeTileType = 588;
								break;
							case 6:
								treeTileType = 589;
								break;
							}
							TryGrowingTreeByType(treeTileType, num24, num25);
						}
						if (!oceanDepths(num24, num25) && !Main.tile[num24, num25].active() && genRand.Next(5) == 0)
						{
							if ((Main.tile[num24, num25 - 1].type == 1 || Main.tile[num24, num25 - 1].type == 147 || Main.tile[num24, num25 - 1].type == 161 || Main.tile[num24, num25 - 1].type == 25 || Main.tile[num24, num25 - 1].type == 203 || Main.tileStone[Main.tile[num24, num25 - 1].type] || Main.tileMoss[Main.tile[num24, num25 - 1].type]) && !Main.tile[num24, num25].active() && !Main.tile[num24, num25 + 1].active())
							{
								Main.tile[num24, num25 - 1].slope(0);
							}
							if ((Main.tile[num24, num25 + 1].type == 1 || Main.tile[num24, num25 + 1].type == 147 || Main.tile[num24, num25 + 1].type == 161 || Main.tile[num24, num25 + 1].type == 25 || Main.tile[num24, num25 + 1].type == 203 || Main.tileStone[Main.tile[num24, num25 + 1].type] || Main.tileMoss[Main.tile[num24, num25 + 1].type]) && !Main.tile[num24, num25].active() && !Main.tile[num24, num25 - 1].active())
							{
								Main.tile[num24, num25 + 1].slope(0);
							}
							PlaceTight(num24, num25);
						}
					}
					for (int num27 = 5; num27 < (int)Main.worldSurface; num27++)
					{
						if ((Main.tile[num24, num27 - 1].type == 147 || Main.tile[num24, num27 - 1].type == 161) && genRand.Next(5) == 0)
						{
							if (!Main.tile[num24, num27].active() && !Main.tile[num24, num27 + 1].active())
							{
								Main.tile[num24, num27 - 1].slope(0);
							}
							PlaceTight(num24, num27);
						}
						if ((Main.tile[num24, num27 - 1].type == 25 || Main.tile[num24, num27 - 1].type == 203) && genRand.Next(5) == 0)
						{
							if (!Main.tile[num24, num27].active() && !Main.tile[num24, num27 + 1].active())
							{
								Main.tile[num24, num27 - 1].slope(0);
							}
							PlaceTight(num24, num27);
						}
						if ((Main.tile[num24, num27 + 1].type == 25 || Main.tile[num24, num27 + 1].type == 203) && genRand.Next(5) == 0)
						{
							if (!Main.tile[num24, num27].active() && !Main.tile[num24, num27 - 1].active())
							{
								Main.tile[num24, num27 + 1].slope(0);
							}
							PlaceTight(num24, num27);
						}
					}
				}
			});
			AddGenerationPass("Remove Broken Traps", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				if (!noTrapsWorldGen || tenthAnniversaryWorldGen || notTheBees)
				{
					progress.Message = Lang.gen[82].Value;
					List<Point> list = new List<Point>();
					int num21 = 50;
					for (int num22 = num21; num22 < Main.maxTilesX - num21; num22++)
					{
						double value = (double)(num22 - num21) / (double)(Main.maxTilesX - num21 * 2);
						progress.Set(value);
						for (int num23 = 50; num23 < Main.maxTilesY - 50; num23++)
						{
							if (Main.tile[num22, num23].wire() && !list.Contains(new Point(num22, num23)))
							{
								ClearBrokenTraps(new Point(num22, num23), list);
							}
						}
					}
				}
			});
			AddGenerationPass("Final Cleanup", delegate(GenerationProgress progress, GameConfiguration passConfig)
			{
				Main.tileSolid[484] = false;
				FillWallHolesInArea(new Rectangle(0, 0, Main.maxTilesX, (int)Main.worldSurface));
				progress.Message = Lang.gen[86].Value;
				for (int i = 0; i < Main.maxTilesX; i++)
				{
					progress.Set((double)i / (double)Main.maxTilesX);
					for (int j = 0; j < Main.maxTilesY; j++)
					{
						if (Main.tile[i, j].active() && !SolidTile(i, j + 1) && (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 234 || Main.tile[i, j].type == 224 || Main.tile[i, j].type == 123))
						{
							if ((double)j < Main.worldSurface + 10.0 && !Main.tile[i, j + 1].active() && Main.tile[i, j + 1].wall != 191 && !oceanDepths(i, j))
							{
								int num = 10;
								int num2 = j + 1;
								for (int k = num2; k < num2 + 10; k++)
								{
									if (Main.tile[i, k].active() && Main.tile[i, k].type == 314)
									{
										num = 0;
										break;
									}
								}
								while (!Main.tile[i, num2].active() && num > 0 && num2 < Main.maxTilesY - 50)
								{
									Main.tile[i, num2 - 1].slope(0);
									Main.tile[i, num2 - 1].halfBrick(halfBrick: false);
									Main.tile[i, num2].active(active: true);
									Main.tile[i, num2].type = Main.tile[i, j].type;
									Main.tile[i, num2].slope(0);
									Main.tile[i, num2].halfBrick(halfBrick: false);
									num2++;
									num--;
								}
								if (num == 0 && !Main.tile[i, num2].active())
								{
									switch (Main.tile[i, j].type)
									{
									case 53:
										Main.tile[i, num2].type = 397;
										Main.tile[i, num2].active(active: true);
										break;
									case 112:
										Main.tile[i, num2].type = 398;
										Main.tile[i, num2].active(active: true);
										break;
									case 234:
										Main.tile[i, num2].type = 399;
										Main.tile[i, num2].active(active: true);
										break;
									case 224:
										Main.tile[i, num2].type = 147;
										Main.tile[i, num2].active(active: true);
										break;
									case 123:
										Main.tile[i, num2].type = 1;
										Main.tile[i, num2].active(active: true);
										break;
									}
								}
								else if (Main.tile[i, num2].active() && Main.tileSolid[Main.tile[i, num2].type] && !Main.tileSolidTop[Main.tile[i, num2].type])
								{
									Main.tile[i, num2].slope(0);
									Main.tile[i, num2].halfBrick(halfBrick: false);
								}
							}
							else if (Main.tileSolid[Main.tile[i, j + 1].type] && !Main.tileSolidTop[Main.tile[i, j + 1].type] && (Main.tile[i, j + 1].topSlope() || Main.tile[i, j + 1].halfBrick()))
							{
								Main.tile[i, j + 1].slope(0);
								Main.tile[i, j + 1].halfBrick(halfBrick: false);
							}
							else
							{
								switch (Main.tile[i, j].type)
								{
								case 53:
									Main.tile[i, j].type = 397;
									break;
								case 112:
									Main.tile[i, j].type = 398;
									break;
								case 234:
									Main.tile[i, j].type = 399;
									break;
								case 224:
									Main.tile[i, j].type = 147;
									break;
								case 123:
									Main.tile[i, j].type = 1;
									break;
								}
							}
							if (Main.tile[i, j - 1].type == 323)
							{
								TileFrame(i, j - 1);
							}
						}
						if ((Main.tile[i, j].wall == 187 || Main.tile[i, j].wall == 216) && Main.tile[i, j].liquid > 0 && !remixWorldGen)
						{
							Main.tile[i, j].liquid = byte.MaxValue;
							Main.tile[i, j].lava(lava: true);
						}
						if (Main.tile[i, j].type == 485 || Main.tile[i, j].type == 187 || Main.tile[i, j].type == 165)
						{
							TileFrame(i, j);
						}
						if (Main.tile[i, j].type == 28)
						{
							TileFrame(i, j);
						}
						if (Main.tile[i, j].type == 26)
						{
							TileFrame(i, j);
						}
						if (Main.tile[i, j].type == 137)
						{
							Main.tile[i, j].slope(0);
							Main.tile[i, j].halfBrick(halfBrick: false);
						}
						if (Main.tile[i, j].active() && TileID.Sets.Boulders[Main.tile[i, j].type])
						{
							int num3 = Main.tile[i, j].frameX / 18;
							int num4 = i;
							num4 -= num3;
							int num5 = Main.tile[i, j].frameY / 18;
							int num6 = j;
							num6 -= num5;
							bool flag = false;
							for (int l = 0; l < 2; l++)
							{
								Tile tile = Main.tile[num4 + l, num6 - 1];
								if (tile != null && tile.active() && tile.type == 26)
								{
									flag = true;
									break;
								}
								for (int m = 0; m < 2; m++)
								{
									int num7 = num4 + l;
									int num8 = num6 + m;
									Main.tile[num7, num8].active(active: true);
									Main.tile[num7, num8].slope(0);
									Main.tile[num7, num8].halfBrick(halfBrick: false);
									Main.tile[num7, num8].type = Main.tile[i, j].type;
									Main.tile[num7, num8].frameX = (short)(l * 18);
									Main.tile[num7, num8].frameY = (short)(m * 18);
								}
							}
							if (flag)
							{
								ushort type = 0;
								if (Main.tile[i, j].type == 484)
								{
									type = 397;
								}
								for (int n = 0; n < 2; n++)
								{
									for (int num9 = 0; num9 < 2; num9++)
									{
										int num10 = num4 + n;
										int num11 = num6 + num9;
										Main.tile[num10, num11].active(active: true);
										Main.tile[num10, num11].slope(0);
										Main.tile[num10, num11].halfBrick(halfBrick: false);
										Main.tile[num10, num11].type = type;
										Main.tile[num10, num11].frameX = 0;
										Main.tile[num10, num11].frameY = 0;
									}
								}
							}
						}
						if (Main.tile[i, j].type == 323 && Main.tile[i, j].liquid > 0)
						{
							KillTile(i, j);
						}
						if (Main.wallDungeon[Main.tile[i, j].wall])
						{
							Main.tile[i, j].lava(lava: false);
							if (Main.tile[i, j].active() && Main.tile[i, j].type == 56)
							{
								KillTile(i, j);
								Main.tile[i, j].lava(lava: false);
								Main.tile[i, j].liquid = byte.MaxValue;
							}
						}
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 314)
						{
							int num12 = 15;
							int num13 = 1;
							int num14 = j;
							while (j - num14 < num12)
							{
								Main.tile[i, num14].liquid = 0;
								num14--;
							}
							for (num14 = j; num14 - j < num13; num14++)
							{
								Main.tile[i, num14].liquid = 0;
							}
						}
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 332 && !Main.tile[i, j + 1].active())
						{
							Main.tile[i, j + 1].ClearEverything();
							Main.tile[i, j + 1].active(active: true);
							Main.tile[i, j + 1].type = 332;
						}
						if (i > beachDistance && i < Main.maxTilesX - beachDistance && (double)j < Main.worldSurface && Main.tile[i, j].liquid > 0 && Main.tile[i, j].liquid < byte.MaxValue && Main.tile[i - 1, j].liquid < byte.MaxValue && Main.tile[i + 1, j].liquid < byte.MaxValue && Main.tile[i, j + 1].liquid < byte.MaxValue && !TileID.Sets.Clouds[Main.tile[i - 1, j].type] && !TileID.Sets.Clouds[Main.tile[i + 1, j].type] && !TileID.Sets.Clouds[Main.tile[i, j + 1].type])
						{
							Main.tile[i, j].liquid = 0;
						}
					}
				}
				int num15 = 0;
				int num16 = 3;
				num16 = GetWorldSize() switch
				{
					1 => 6, 
					2 => 9, 
					_ => 3, 
				};
				if (tenthAnniversaryWorldGen)
				{
					num16 *= 5;
				}
				int num17 = 50;
				int minValue = num17;
				int minValue2 = num17;
				int maxValue = Main.maxTilesX - num17;
				int maxValue2 = Main.maxTilesY - 200;
				int num18 = 3000;
				while (num15 < num16)
				{
					num18--;
					if (num18 <= 0)
					{
						break;
					}
					int num19 = genRand.Next(minValue, maxValue);
					int num20 = genRand.Next(minValue2, maxValue2);
					Tile tile2 = Main.tile[num19, num20];
					if (tile2.active() && tile2.type >= 0 && tile2.type < 693)
					{
						bool flag2 = TileID.Sets.Dirt[tile2.type];
						if (notTheBees)
						{
							flag2 = flag2 || TileID.Sets.Mud[tile2.type];
						}
						if (flag2)
						{
							num15++;
							tile2.ClearTile();
							tile2.active(active: true);
							tile2.type = 668;
						}
					}
				}
				if (noTrapsWorldGen)
				{
					FinishNoTraps();
				}
				if (Main.tenthAnniversaryWorld)
				{
					FinishTenthAnniversaryWorld();
				}
				if (drunkWorldGen)
				{
					FinishDrunkGen();
				}
				if (notTheBees)
				{
					NotTheBees();
					FinishNotTheBees();
				}
				if (getGoodWorldGen)
				{
					FinishGetGoodWorld();
				}
				if (remixWorldGen)
				{
					FinishRemixWorld();
				}
				ShimmerCleanUp();
				notTheBees = false;
				getGoodWorldGen = false;
				noTileActions = false;
				Main.tileSolid[659] = true;
				Main.tileSolid[GenVars.crackedType] = true;
				Main.tileSolid[484] = true;
				gen = false;
				Main.AnglerQuestSwap();
				skipFramingDuringGen = false;
				progress.Message = Lang.gen[87].Value;
			});
			_generator.GenerateWorld(customProgressObject);
			ConsumePostGenActions(GenVars.structures);
			Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
			Main.NotifyOfEvent(GameNotificationType.WorldGen);
			drunkWorldGenText = false;
		}

		private static Point GetAdjustedFloorPosition(int x, int y)
		{
			int num = x - 1;
			int num2 = y - 2;
			bool isEmpty = false;
			bool hasFloor = false;
			while (!isEmpty && num2 > Main.spawnTileY - 10)
			{
				Scan3By3(num, num2, out isEmpty, out hasFloor);
				if (!isEmpty)
				{
					num2--;
				}
			}
			while (!hasFloor && num2 < Main.spawnTileY + 10)
			{
				Scan3By3(num, num2, out isEmpty, out hasFloor);
				if (!hasFloor)
				{
					num2++;
				}
			}
			return new Point(num + 1, num2 + 2);
		}

		private static void Scan3By3(int topLeftX, int topLeftY, out bool isEmpty, out bool hasFloor)
		{
			isEmpty = true;
			hasFloor = false;
			for (int i = 0; i < 3; i++)
			{
				int num = 0;
				while (num < 3)
				{
					int i2 = topLeftX + i;
					int j = topLeftY + num;
					if (!SolidTile(i2, j))
					{
						num++;
						continue;
					}
					goto IL_001e;
				}
				continue;
				IL_001e:
				isEmpty = false;
				break;
			}
			for (int k = 0; k < 3; k++)
			{
				int i3 = topLeftX + k;
				int j2 = topLeftY + 3;
				if (SolidTile(i3, j2))
				{
					hasFloor = true;
					break;
				}
			}
		}

		private static void FinishTenthAnniversaryWorld()
		{
			if (!remixWorldGen)
			{
				if (!getGoodWorldGen && !drunkWorldGen)
				{
					ConvertSkyIslands(2, growTrees: true);
				}
				PaintTheDungeon(24, 24);
				PaintTheLivingTrees(12, 12);
				PaintTheTemple(10, 5);
				PaintTheClouds(12, 12);
				PaintTheSand(7, 7);
				PaintThePyramids(12, 12);
			}
			PaintTheTrees();
			PaintTheMushrooms();
			if (!getGoodWorldGen)
			{
				for (int i = 50; i < Main.maxTilesX - 50; i++)
				{
					for (int j = 50; j < Main.maxTilesY - 50; j++)
					{
						Tile tile = Main.tile[i, j];
						if (genRand.Next(4) == 0 && tile.active() && tile.type == 138 && tile.frameX == 0 && tile.frameY == 0)
						{
							Main.tile[i, j].type = 665;
							Main.tile[i, j + 1].type = 665;
							Main.tile[i + 1, j].type = 665;
							Main.tile[i + 1, j + 1].type = 665;
						}
					}
				}
			}
			if (!getGoodWorldGen)
			{
				ImproveAllChestContents();
			}
		}

		private static void PaintTheMushrooms()
		{
			int num = Main.maxTilesY - 20;
			byte b = (byte)genRand.Next(1, 13);
			if (remixWorldGen)
			{
				b = 2;
				num = Main.maxTilesY - 500;
				int num2 = genRand.Next(5, 31);
				if (genRand.Next(2) == 0)
				{
					num2 = genRand.Next(5, 16);
				}
				for (int i = 20; i < Main.maxTilesX - 20; i++)
				{
					if (i % num2 == 0)
					{
						b = (byte)(b + 1);
						if (b > 12)
						{
							b = 1;
						}
					}
					for (int j = Main.maxTilesY - 450; j < Main.maxTilesY - 20; j++)
					{
						Tile tile = Main.tile[i, j];
						if (tile.active() && (tile.type == 70 || tile.type == 578 || tile.type == 190 || tile.type == 71 || tile.type == 528 || (tile.type == 519 && tile.frameY == 90)))
						{
							tile.color(b);
						}
						if (tile.wall == 80 || tile.wall == 74)
						{
							tile.wallColor(b);
						}
					}
				}
			}
			b = (byte)genRand.Next(1, 13);
			int num3 = 0;
			for (int k = 20; k < Main.maxTilesX - 20; k++)
			{
				for (int l = 20; l < num; l++)
				{
					Tile tile2 = Main.tile[k, l];
					if (tile2.active() && (tile2.type == 70 || tile2.type == 578 || tile2.type == 190 || tile2.type == 71 || tile2.type == 528 || (tile2.type == 519 && tile2.frameY == 90)))
					{
						tile2.color(b);
						num3 = 10;
					}
					if (tile2.wall == 80 || tile2.wall == 74)
					{
						tile2.wallColor(b);
						num3 = 10;
					}
				}
				num3--;
				if (num3 == 0)
				{
					b = (byte)(b + (byte)genRand.Next(1, 3));
					if (b > 12)
					{
						b = 1;
					}
				}
			}
		}

		private static void PaintTheTrees()
		{
			int num = 20;
			if (remixWorldGen)
			{
				num = (int)Main.worldSurface;
			}
			byte b = (byte)genRand.Next(1, 13);
			bool flag = false;
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				bool flag2 = false;
				for (int j = num; j < Main.maxTilesY - 20; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 5 || tile.type == 323 || tile.type == 596 || tile.type == 616))
					{
						tile.color(b);
						flag2 = true;
						flag = true;
					}
				}
				if (flag && !flag2)
				{
					flag = false;
					b = (byte)(b + 1);
					if (b > 12)
					{
						b = 1;
					}
				}
			}
		}

		private static void PaintTheSand(byte tilePaintColor, byte wallPaintColor)
		{
			for (int i = 20; i < Main.maxTilesX - 20; i++)
			{
				for (int j = 20; j < Main.maxTilesY - 20; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 53 || tile.type == 396 || tile.type == 397))
					{
						tile.color(tilePaintColor);
						if ((double)j > Main.worldSurface)
						{
							if (Main.tile[i, j - 1].type == 165 || Main.tile[i, j - 1].type == 185 || Main.tile[i, j - 1].type == 186 || Main.tile[i, j - 1].type == 187)
							{
								Main.tile[i, j - 1].color(tilePaintColor);
							}
							if (Main.tile[i, j - 2].type == 165 || Main.tile[i, j - 2].type == 185 || Main.tile[i, j - 2].type == 186 || Main.tile[i, j - 2].type == 187)
							{
								Main.tile[i, j - 2].color(tilePaintColor);
							}
							if (Main.tile[i, j + 1].type == 165)
							{
								Main.tile[i, j + 1].color(tilePaintColor);
							}
							if (Main.tile[i, j + 2].type == 165)
							{
								Main.tile[i, j + 2].color(tilePaintColor);
							}
						}
					}
					if (tile.wall == 187 || tile.wall == 216)
					{
						tile.wallColor(tilePaintColor);
					}
				}
			}
		}

		private static void PaintThePurityGrass(byte tilePaintColor, byte wallPaintColor)
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active())
					{
						if (tile.type == 2)
						{
							tile.color(tilePaintColor);
						}
						else if (tile.type == 185 || tile.type == 186 || tile.type == 187)
						{
							Tile tile2 = tile;
							int num = j;
							while (num < Main.maxTilesY - 20 && (tile2.type == 185 || tile2.type == 186 || tile2.type == 187 || tile2.type == 3 || tile2.type == 73))
							{
								tile2 = Main.tile[i, ++num];
							}
							if (tile2.type == 2)
							{
								tile.color(tilePaintColor);
							}
						}
					}
					if (tile.wall == 66 || tile.wall == 63)
					{
						tile.wallColor(wallPaintColor);
					}
				}
			}
		}

		private static void PaintThePyramids(byte tilePaintColor, byte wallPaintColor)
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && tile.type == 151)
					{
						tile.color(tilePaintColor);
					}
					if (tile.wall == 34)
					{
						tile.wallColor(wallPaintColor);
					}
				}
			}
		}

		private static void PaintTheTemple(byte tilePaintColor, byte wallPaintColor)
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active())
					{
						bool flag = false;
						if (tile.type == 226)
						{
							flag = true;
						}
						if (tile.type == 137)
						{
							int num = tile.frameY / 18;
							if (num >= 1 && num <= 4)
							{
								flag = true;
							}
						}
						if (flag)
						{
							tile.color(tilePaintColor);
						}
					}
					if (tile.wall == 87)
					{
						tile.wallColor(wallPaintColor);
					}
				}
			}
		}

		private static void PaintTheClouds(byte tilePaintColor, byte wallPaintColor)
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && (tile.type == 189 || tile.type == 196 || tile.type == 460))
					{
						tile.color(tilePaintColor);
					}
					if (tile.wall == 73)
					{
						tile.wallColor(wallPaintColor);
					}
				}
			}
		}

		private static void PaintTheDungeon(byte tilePaintColor, byte wallPaintColor)
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active())
					{
						if (Main.tileDungeon[tile.type] || TileID.Sets.CrackedBricks[tile.type])
						{
							tile.color(tilePaintColor);
						}
						if (tile.type == 19)
						{
							int num = tile.frameY / 18;
							if (num >= 6 && num <= 12)
							{
								tile.color(tilePaintColor);
							}
						}
					}
					if (Main.wallDungeon[tile.wall])
					{
						tile.wallColor(wallPaintColor);
					}
				}
			}
		}

		private static void PaintTheLivingTrees(byte livingTreePaintColor, byte livingTreeWallPaintColor)
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active())
					{
						if (tile.wall == 244)
						{
							tile.color(livingTreePaintColor);
						}
						else if (tile.type == 192 || tile.type == 191)
						{
							tile.color(livingTreePaintColor);
						}
						else if (tile.type == 52 || tile.type == 382)
						{
							int x = i;
							int y = j;
							GetVineTop(i, j, out x, out y);
							if (Main.tile[x, y].type == 192)
							{
								tile.color(livingTreePaintColor);
							}
						}
						else if (tile.type == 187)
						{
							Tile tile2 = tile;
							int num = 0;
							while (tile2.type == 187)
							{
								num++;
								tile2 = Main.tile[i, j + num];
							}
							if (tile2.type == 192)
							{
								tile.color(livingTreePaintColor);
							}
						}
					}
					if (tile.wall == 244)
					{
						tile.wallColor(livingTreeWallPaintColor);
					}
				}
			}
		}

		private static void ConvertSkyIslands(int convertType, bool growTrees)
		{
			int num = 0;
			for (int i = 20; (double)i < Main.worldSurface; i++)
			{
				for (int j = 20; j < Main.maxTilesX - 20; j++)
				{
					Tile tile = Main.tile[j, i];
					if (tile.active() && TileID.Sets.Clouds[tile.type])
					{
						num = i;
						break;
					}
				}
			}
			for (int k = 20; k <= Main.maxTilesX - 20; k++)
			{
				for (int l = 20; l < num; l++)
				{
					Tile tile2 = Main.tile[k, l];
					Tile tile3 = Main.tile[k, l - 1];
					if (tile2.active() && tile2.type == 2)
					{
						if (tile3.type == 596 || tile3.type == 616)
						{
							KillTile(k, l - 1);
						}
						Convert(k, l, convertType, 1);
						ushort type = tile3.type;
						if ((uint)(type - 82) <= 1u || (uint)(type - 185) <= 2u || type == 227)
						{
							KillTile(k, l - 1);
						}
						if (growTrees && _genRand.Next(3) == 0)
						{
							GrowTree(k, l);
						}
					}
				}
			}
		}

		private static void ImproveAllChestContents()
		{
			for (int i = 0; i < 8000; i++)
			{
				Chest chest = Main.chest[i];
				if (chest == null)
				{
					continue;
				}
				for (int j = 0; j < 40; j++)
				{
					Item item = chest.item[j];
					if (item != null && !item.IsAir)
					{
						GiveItemGoodPrefixes(item);
					}
				}
			}
		}

		private static void GiveItemGoodPrefixes(Item item)
		{
			if (item.accessory)
			{
				PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForAccessory);
			}
			if (item.melee)
			{
				PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForMeleeWeapon);
			}
			if (item.ranged)
			{
				PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForRangedWeapon);
			}
			if (item.magic)
			{
				PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForMagicWeapon);
			}
			if (item.summon)
			{
				PrefixItemFromOptions(item, TenthAnniversaryWorldInfo.GoodPrefixIdsForSummonerWeapon);
			}
		}

		private static void PrefixItemFromOptions(Item item, int[] options)
		{
			byte prefix = item.prefix;
			if (!item.Prefix(-3))
			{
				return;
			}
			List<int> list = new List<int>(options);
			while (list.Count > 0)
			{
				int index = _genRand.Next(list.Count);
				int num = list[index];
				item.Prefix(num);
				if (item.prefix == num)
				{
					return;
				}
				list.RemoveAt(index);
			}
			item.Prefix(prefix);
		}

		private static void NotTheBees()
		{
			int num = Main.maxTilesX / 7;
			if (!notTheBees)
			{
				return;
			}
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY - 180; j++)
				{
					if (remixWorldGen && (i < num + genRand.Next(3) || i >= Main.maxTilesX - num - genRand.Next(3) || ((double)j > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 + (double)genRand.Next(3) && j < Main.maxTilesY - 350 - genRand.Next(3))))
					{
						continue;
					}
					if (Main.tile[i, j].type == 52)
					{
						Main.tile[i, j].type = 62;
					}
					if ((SolidOrSlopedTile(i, j) || TileID.Sets.CrackedBricks[Main.tile[i, j].type]) && !TileID.Sets.Ore[Main.tile[i, j].type] && Main.tile[i, j].type != 123 && Main.tile[i, j].type != 40)
					{
						if (Main.tile[i, j].type == 191 || Main.tile[i, j].type == 383)
						{
							if (!remixWorldGen)
							{
								Main.tile[i, j].type = 383;
							}
						}
						else if (Main.tile[i, j].type == 192 || Main.tile[i, j].type == 384)
						{
							if (!remixWorldGen)
							{
								Main.tile[i, j].type = 384;
							}
						}
						else if (Main.tile[i, j].type != 151 && Main.tile[i, j].type != 662 && Main.tile[i, j].type != 661 && Main.tile[i, j].type != 189 && Main.tile[i, j].type != 196 && Main.tile[i, j].type != 120 && Main.tile[i, j].type != 158 && Main.tile[i, j].type != 175 && Main.tile[i, j].type != 45 && Main.tile[i, j].type != 119)
						{
							if (Main.tile[i, j].type >= 63 && Main.tile[i, j].type <= 68)
							{
								Main.tile[i, j].type = 230;
							}
							else if (Main.tile[i, j].type != 57 && Main.tile[i, j].type != 76 && Main.tile[i, j].type != 75 && Main.tile[i, j].type != 229 && Main.tile[i, j].type != 230 && Main.tile[i, j].type != 407 && Main.tile[i, j].type != 404)
							{
								if (Main.tile[i, j].type == 224)
								{
									Main.tile[i, j].type = 229;
								}
								else if (Main.tile[i, j].type == 53)
								{
									if (i < beachDistance + genRand.Next(3) || i > Main.maxTilesX - beachDistance - genRand.Next(3))
									{
										Main.tile[i, j].type = 229;
									}
								}
								else if ((i <= beachDistance - genRand.Next(3) || i >= Main.maxTilesX - beachDistance + genRand.Next(3) || (Main.tile[i, j].type != 397 && Main.tile[i, j].type != 396)) && Main.tile[i, j].type != 10 && Main.tile[i, j].type != 203 && Main.tile[i, j].type != 25 && Main.tile[i, j].type != 137 && Main.tile[i, j].type != 138 && Main.tile[i, j].type != 141)
								{
									if (Main.tileDungeon[Main.tile[i, j].type] || TileID.Sets.CrackedBricks[Main.tile[i, j].type])
									{
										Main.tile[i, j].color(14);
									}
									else if (Main.tile[i, j].type == 226)
									{
										Main.tile[i, j].color(15);
									}
									else if (Main.tile[i, j].type != 202 && Main.tile[i, j].type != 70 && Main.tile[i, j].type != 48 && Main.tile[i, j].type != 232)
									{
										if (TileID.Sets.Conversion.Grass[Main.tile[i, j].type] || Main.tile[i, j].type == 60 || Main.tile[i, j].type == 70)
										{
											if (j > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
											{
												Main.tile[i, j].type = 70;
											}
											else
											{
												Main.tile[i, j].type = 60;
											}
										}
										else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 59)
										{
											Main.tile[i, j].type = 59;
										}
										else if (Main.tile[i, j].type != 633)
										{
											if (j > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
											{
												Main.tile[i, j].type = 230;
											}
											else if (!remixWorldGen || (double)j > Main.worldSurface + (double)genRand.Next(-1, 2))
											{
												Main.tile[i, j].type = 225;
											}
										}
									}
								}
							}
						}
					}
					if (Main.tile[i, j].wall != 15 && Main.tile[i, j].wall != 64 && Main.tile[i, j].wall != 204 && Main.tile[i, j].wall != 205 && Main.tile[i, j].wall != 206 && Main.tile[i, j].wall != 207 && Main.tile[i, j].wall != 23 && Main.tile[i, j].wall != 24 && Main.tile[i, j].wall != 42 && Main.tile[i, j].wall != 10 && Main.tile[i, j].wall != 21 && Main.tile[i, j].wall != 82 && Main.tile[i, j].wall != 187 && Main.tile[i, j].wall != 216 && Main.tile[i, j].wall != 34 && Main.tile[i, j].wall != 244)
					{
						if (Main.tile[i, j].wall == 87)
						{
							Main.tile[i, j].wallColor(15);
						}
						else if (Main.wallDungeon[Main.tile[i, j].wall])
						{
							Main.tile[i, j].wallColor(14);
						}
						else if (Main.tile[i, j].wall == 2)
						{
							Main.tile[i, j].wall = 2;
						}
						else if (Main.tile[i, j].wall == 196)
						{
							Main.tile[i, j].wall = 196;
						}
						else if (Main.tile[i, j].wall == 197)
						{
							Main.tile[i, j].wall = 197;
						}
						else if (Main.tile[i, j].wall == 198)
						{
							Main.tile[i, j].wall = 198;
						}
						else if (Main.tile[i, j].wall == 199)
						{
							Main.tile[i, j].wall = 199;
						}
						else if (Main.tile[i, j].wall == 63)
						{
							Main.tile[i, j].wall = 64;
						}
						else if (Main.tile[i, j].wall != 3 && Main.tile[i, j].wall != 83 && Main.tile[i, j].wall != 73 && Main.tile[i, j].wall != 62 && Main.tile[i, j].wall != 13 && Main.tile[i, j].wall != 14 && Main.tile[i, j].wall > 0 && (!remixWorldGen || (double)j > Main.worldSurface + (double)genRand.Next(-1, 2)))
						{
							Main.tile[i, j].wall = 86;
						}
					}
					if (Main.tile[i, j].liquid > 0 && j <= GenVars.lavaLine + 2)
					{
						if ((double)j > Main.rockLayer && (i < beachDistance + 200 || i > Main.maxTilesX - beachDistance - 200))
						{
							Main.tile[i, j].honey(honey: false);
						}
						else if (Main.wallDungeon[Main.tile[i, j].wall])
						{
							Main.tile[i, j].honey(honey: false);
						}
						else
						{
							Main.tile[i, j].honey(honey: true);
						}
					}
				}
			}
		}

		private static void FinishNotTheBees()
		{
			if (!notTheBees)
			{
				return;
			}
			int num = 0;
			for (int i = 20; (double)i < Main.worldSurface; i++)
			{
				for (int j = 20; j < Main.maxTilesX - 20; j++)
				{
					if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
					{
						num = i;
						break;
					}
				}
			}
			for (int k = 25; k < Main.maxTilesX - 25; k++)
			{
				for (int l = 25; l < Main.maxTilesY - 25; l++)
				{
					if (Main.tile[k, l].type == 571)
					{
						TileFrame(k, l);
					}
					int num2 = 20;
					if (remixWorldGen)
					{
						num2 = 10;
					}
					if (Main.tile[k, l].type == 25 || (remixWorldGen && Main.tile[k, l].type == 23 && (double)l < Main.worldSurface))
					{
						for (int m = k - num2; m <= k + num2; m++)
						{
							for (int n = l - num2; n <= l + num2; n++)
							{
								if (Main.tile[m, n].type == 60)
								{
									if (Main.tile[m, n + 1].type == 444)
									{
										KillTile(m, n + 1);
									}
									Main.tile[m, n].type = 661;
									if (Main.tile[m, n - 1].type == 61 || Main.tile[m, n - 1].type == 74)
									{
										Main.tile[m, n - 1].active(active: false);
										PlaceTile(m, n - 1, 24);
									}
								}
								else if (Main.tile[m, n - 1].type == 233 || Main.tile[m, n - 1].type == 82)
								{
									KillTile(m, n - 1);
								}
							}
						}
					}
					else if (Main.tile[k, l].type == 203 || (remixWorldGen && Main.tile[k, l].type == 199 && (double)l < Main.worldSurface))
					{
						for (int num3 = k - num2; num3 <= k + num2; num3++)
						{
							for (int num4 = l - num2; num4 <= l + num2; num4++)
							{
								if (Main.tile[num3, num4].type == 60)
								{
									if (Main.tile[num3, num4 + 1].type == 444)
									{
										KillTile(num3, num4 + 1);
									}
									Main.tile[num3, num4].type = 662;
									if (Main.tile[num3, num4 - 1].type == 61 || Main.tile[num3, num4 - 1].type == 74)
									{
										Main.tile[num3, num4 - 1].active(active: false);
										PlaceTile(num3, num4 - 1, 201);
									}
									else if (Main.tile[num3, num4 - 1].type == 233 || Main.tile[num3, num4 - 1].type == 82)
									{
										KillTile(num3, num4 - 1);
									}
								}
							}
						}
					}
					if (Main.tile[k, l].type == 382 || Main.tile[k, l].type == 52)
					{
						Main.tile[k, l].type = 62;
					}
					if (l > GenVars.lavaLine + genRand.Next(-2, 3) + 2)
					{
						if (!remixWorldGen)
						{
							SpreadGrass(k, l, 59, 70);
						}
					}
					else
					{
						SpreadGrass(k, l, 59, 60);
					}
					if ((double)l > Main.rockLayer + 20.0 + (double)genRand.Next(-2, 3) && l <= GenVars.lavaLine + 2 - 20 - genRand.Next(-2, 3) && (k < beachDistance + 200 - 20 - genRand.Next(-2, 3) || k > Main.maxTilesX - beachDistance - 200 + 20 + genRand.Next(-2, 3)))
					{
						if (Main.tile[k, l].liquid > 0)
						{
							Main.tile[k, l].honey(honey: false);
							Main.tile[k, l].lava(lava: false);
						}
						if (Main.tile[k, l].type == 59)
						{
							bool flag = false;
							for (int num5 = k - 1; num5 <= k + 1; num5++)
							{
								for (int num6 = l - 1; num6 <= l + 1; num6++)
								{
									if (Main.tile[num5, num6].type == 60)
									{
										flag = true;
									}
								}
							}
							if (!flag)
							{
								if ((double)l < (Main.rockLayer + (double)GenVars.lavaLine) / 2.0)
								{
									Main.tile[k, l].type = 161;
								}
								else
								{
									Main.tile[k, l].type = 147;
								}
							}
						}
					}
					if (!remixWorldGen)
					{
						if ((Main.tile[k, l].type == 7 || Main.tile[k, l].type == 166 || Main.tile[k, l].type == 6 || Main.tile[k, l].type == 167) && (double)l > ((double)GenVars.lavaLine + Main.rockLayer * 2.0) / 3.0 + (double)genRand.Next(-2, 3) + 2.0)
						{
							Main.tile[k, l].type = 0;
						}
					}
					else if (!remixWorldGen && (Main.tile[k, l].type == 123 || Main.tile[k, l].type == 40) && (double)l > ((double)GenVars.lavaLine + Main.rockLayer) / 2.0 + (double)genRand.Next(-2, 3) + 2.0)
					{
						Main.tile[k, l].type = 1;
					}
					if (l <= num || (Main.tile[k, l].liquid != 0 && (Main.tile[k, l].lava() || Main.tile[k, l].shimmer())))
					{
						continue;
					}
					if (getGoodWorldGen)
					{
						if (genRand.Next(150) == 0)
						{
							PlaceTile(k, l, 231, mute: true);
						}
					}
					else if (genRand.Next(25) == 0)
					{
						PlaceTile(k, l, 231, mute: true);
					}
				}
			}
			for (int num7 = 20; num7 < num; num7++)
			{
				for (int num8 = 20; num8 <= Main.maxTilesX - 20; num8++)
				{
					Main.tile[num8, num7].honey(honey: false);
					if (Main.tile[num8, num7].type == 375)
					{
						Main.tile[num8, num7].type = 373;
					}
					if (!remixWorldGen)
					{
						if (Main.tile[num8, num7].type == 60)
						{
							Main.tile[num8, num7].type = 2;
							if (genRand.Next(2) == 0)
							{
								GrowTreeWithSettings(num8, num7, GrowTreeSettings.Profiles.VanityTree_Willow);
							}
							else
							{
								GrowTreeWithSettings(num8, num7, GrowTreeSettings.Profiles.VanityTree_Sakura);
							}
							if (!Main.tile[num8, num7 - 1].active())
							{
								PlaceTile(num8, num7 - 1, 3);
							}
						}
						if (Main.tile[num8, num7].type == 59)
						{
							Main.tile[num8, num7].type = 0;
						}
					}
					else
					{
						GrowTree(num8, num7);
					}
				}
			}
		}

		private static void FinishGetGoodWorld()
		{
			int num = 0;
			for (int i = 20; (double)i < Main.worldSurface; i++)
			{
				for (int j = 20; j < Main.maxTilesX - 20; j++)
				{
					if (Main.tile[j, i].active() && TileID.Sets.Clouds[Main.tile[j, i].type])
					{
						num = i;
						break;
					}
				}
			}
			byte b = (byte)genRand.Next(13, 25);
			for (int k = 0; k < Main.maxTilesX; k++)
			{
				bool flag = false;
				for (int l = 0; l < Main.maxTilesY; l++)
				{
					if (!Main.tile[k, l].active() || !Main.tileDungeon[Main.tile[k, l].type])
					{
						continue;
					}
					if (Main.tile[k, l].type == 44)
					{
						b = (byte)genRand.Next(13, 15);
						if (genRand.Next(2) == 0)
						{
							b = (byte)genRand.Next(23, 25);
						}
					}
					if (Main.tile[k, l].type == 43)
					{
						b = (byte)genRand.Next(15, 19);
					}
					if (Main.tile[k, l].type == 41)
					{
						b = (byte)genRand.Next(19, 23);
					}
				}
				if (flag)
				{
					break;
				}
			}
			for (int m = 0; m < Main.maxTilesX; m++)
			{
				for (int n = 5; n < Main.maxTilesY - 5; n++)
				{
					if (Main.tile[m, n].active() && (Main.tileDungeon[Main.tile[m, n].type] || TileID.Sets.CrackedBricks[Main.tile[m, n].type]))
					{
						Main.tile[m, n].color(b);
					}
					if (Main.wallDungeon[Main.tile[m, n].wall])
					{
						Main.tile[m, n].wallColor(b);
					}
					if (Main.tile[m, n].active())
					{
						bool flag2 = false;
						if (Main.tile[m, n].type == 226)
						{
							flag2 = true;
						}
						if (Main.tile[m, n].type == 137)
						{
							int num2 = Main.tile[m, n].frameY / 18;
							if (num2 >= 1 && num2 <= 4)
							{
								flag2 = true;
							}
						}
						if (flag2)
						{
							Main.tile[m, n].color(17);
						}
					}
					if (Main.tile[m, n].wall == 87)
					{
						Main.tile[m, n].wallColor(25);
					}
					if (!Main.tile[m, n].active())
					{
						continue;
					}
					if (!remixWorldGen && Main.tile[m, n].type == 57 && genRand.Next(15) == 0)
					{
						if (Main.tile[m, n - 1].type == 57)
						{
							Main.tile[m, n].active(active: false);
						}
						Main.tile[m, n].liquid = byte.MaxValue;
						Main.tile[m, n].lava(lava: true);
					}
					if (n < num && Main.tile[m, n].type == 2)
					{
						if (crimson)
						{
							Main.tile[m, n].type = 199;
						}
						else
						{
							Main.tile[m, n].type = 23;
						}
						if (Main.tile[m, n - 1].type == 3)
						{
							Main.tile[m, n - 1].active(active: false);
						}
						if (Main.tile[m, n - 1].type == 73)
						{
							Main.tile[m, n - 1].active(active: false);
						}
						if (Main.tile[m, n - 1].type == 27)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 596)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 616)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 82)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 83)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 186)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 187)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 185)
						{
							KillTile(m, n - 1);
						}
						if (Main.tile[m, n - 1].type == 227)
						{
							KillTile(m, n - 1);
						}
					}
				}
			}
			for (int num3 = 0; num3 < 8000 && Main.chest[num3] != null; num3++)
			{
				if (genRand.Next(10) != 0 || Main.chest[num3].item[1].stack == 0)
				{
					continue;
				}
				for (int num4 = 1; num4 < 40; num4++)
				{
					if (Main.chest[num3].item[num4].stack == 0)
					{
						Main.chest[num3].item[num4].SetDefaults(678);
						break;
					}
				}
			}
		}

		private static void FinishNoTraps()
		{
			Main.tileSolid[138] = false;
			for (int i = 50; i < Main.maxTilesX - 50; i++)
			{
				for (int j = 50; j < Main.maxTilesY - 50; j++)
				{
					Tile tile = Main.tile[i, j];
					if (genRand.Next(5) == 0 && tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
					{
						Main.tile[i, j].type = 665;
						Main.tile[i, j + 1].type = 665;
						Main.tile[i + 1, j].type = 665;
						Main.tile[i + 1, j + 1].type = 665;
					}
					if (i % 2 != 0 || j % 2 != 0 || !Main.tile[i, j].active() || (Main.tile[i, j].type != 105 && (Main.tile[i, j].type != 467 || (Main.tile[i, j].frameX != 144 && Main.tile[i, j].frameX != 162))))
					{
						continue;
					}
					bool flag = false;
					for (int k = i - 1; k <= i + 1; k++)
					{
						for (int l = j - 1; l <= j + 1; l++)
						{
							if (Main.tile[k, l].wire())
							{
								flag = true;
							}
						}
					}
					if (!flag)
					{
						bool flag2 = false;
						int num = 25;
						int num2 = -1;
						int num3 = -1;
						for (int m = 0; m < num * num; m++)
						{
							num2 = genRand.Next(i - num, i + num + 1);
							num3 = genRand.Next(j - num, j + num + 1);
							if (Main.tile[num2, num3].wire())
							{
								flag2 = true;
								break;
							}
						}
						if (flag2)
						{
							int num4 = i;
							int num5 = j;
							Main.tile[num4, num5].wire(wire: true);
							while (num4 != num2)
							{
								if (num4 < num2)
								{
									num4++;
								}
								if (num4 > num2)
								{
									num4--;
								}
								Main.tile[num4, num5].wire(wire: true);
							}
							while (num5 != num3)
							{
								if (num5 < num3)
								{
									num5++;
								}
								if (num5 > num3)
								{
									num5--;
								}
								Main.tile[num4, num5].wire(wire: true);
							}
						}
						else if (Main.tile[i, j].type == 105)
						{
							num = 15;
							bool flag3 = false;
							for (int n = 0; n < num * num; n++)
							{
								num2 = i + genRand.Next(-num, num + 1);
								num3 = j + genRand.Next(-num, num + 1);
								PlaceTile(num2, num3, 135, mute: true, forced: true, -1, genRand.Next(2, 4));
								if (Main.tile[num2, num3].type == 135)
								{
									flag3 = true;
									break;
								}
							}
							if (flag3)
							{
								int num6 = i;
								int num7 = j;
								Main.tile[num6, num7].wire(wire: true);
								while (num6 != num2)
								{
									if (num6 < num2)
									{
										num6++;
									}
									if (num6 > num2)
									{
										num6--;
									}
									Main.tile[num6, num7].wire(wire: true);
								}
								while (num7 != num3)
								{
									if (num7 < num3)
									{
										num7++;
									}
									if (num7 > num3)
									{
										num7--;
									}
									Main.tile[num6, num7].wire(wire: true);
								}
							}
						}
					}
					if (Main.tile[i, j].type == 467)
					{
						int num8 = 8;
						for (int num9 = 0; num9 < num8 * num8; num9++)
						{
							int num10 = i + genRand.Next(-num8, num8 + 1);
							int num11 = j + genRand.Next(-num8, num8 + 1);
							if (Main.tile[num10, num11].type != 0 && Main.tile[num10, num11].type != 1 && !TileID.Sets.Ore[Main.tile[num10, num11].type] && Main.tile[num10, num11].type != 59 && Main.tile[num10, num11].type != 151)
							{
								continue;
							}
							bool flag4 = true;
							for (int num12 = num10 - 1; num12 <= num10 + 1; num12++)
							{
								for (int num13 = num11 - 1; num13 <= num11 + 1; num13++)
								{
									if (!SolidTile(num12, num13))
									{
										flag4 = false;
									}
								}
							}
							if (!flag4)
							{
								continue;
							}
							Tile tile2 = Main.tile[num10, num11];
							tile2.type = 141;
							tile2.frameX = (tile2.frameY = 0);
							tile2.slope(0);
							tile2.halfBrick(halfBrick: false);
							TileFrame(num10, num11, resetFrame: true);
							if (Main.tile[num10, num11].type != 141)
							{
								continue;
							}
							int num14 = i;
							int num15 = j;
							Main.tile[num14, num15].wire(wire: true);
							while (num14 != num10)
							{
								if (num14 < num10)
								{
									num14++;
								}
								if (num14 > num10)
								{
									num14--;
								}
								Main.tile[num14, num15].wire(wire: true);
							}
							while (num15 != num11)
							{
								if (num15 < num11)
								{
									num15++;
								}
								if (num15 > num11)
								{
									num15--;
								}
								Main.tile[num14, num15].wire(wire: true);
							}
							break;
						}
					}
					else
					{
						j++;
					}
				}
			}
			Main.tileSolid[138] = true;
			for (int num16 = 0; num16 < 8000 && Main.chest[num16] != null; num16++)
			{
				if (genRand.Next(20) != 0 || Main.chest[num16].item[1].stack == 0)
				{
					continue;
				}
				for (int num17 = 1; num17 < 40; num17++)
				{
					if (Main.chest[num16].item[num17].stack == 0)
					{
						Main.chest[num16].item[num17].SetDefaults(5346);
						break;
					}
				}
			}
		}

		private static void FinishDrunkGen()
		{
			byte color = (byte)genRand.Next(13, 25);
			byte b = 16;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				bool flag = false;
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (!Main.tile[i, j].active() || !Main.tileDungeon[Main.tile[i, j].type])
					{
						continue;
					}
					if (Main.tile[i, j].type == 44)
					{
						color = (byte)genRand.Next(13, 15);
						if (genRand.Next(2) == 0)
						{
							color = (byte)genRand.Next(23, 25);
						}
					}
					if (Main.tile[i, j].type == 43)
					{
						color = (byte)genRand.Next(15, 19);
					}
					if (Main.tile[i, j].type == 41)
					{
						color = (byte)genRand.Next(19, 23);
					}
				}
				if (flag)
				{
					break;
				}
			}
			for (int k = 10; k < Main.maxTilesX - 10; k++)
			{
				for (int l = 10; l < Main.maxTilesY - 10; l++)
				{
					if (Main.tile[k, l].active() && (Main.tileDungeon[Main.tile[k, l].type] || TileID.Sets.CrackedBricks[Main.tile[k, l].type]))
					{
						Main.tile[k, l].color(color);
					}
					if (Main.wallDungeon[Main.tile[k, l].wall])
					{
						Main.tile[k, l].wallColor(25);
					}
					if (Main.tile[k, l].active())
					{
						if (Main.tile[k, l].type == 60)
						{
							int num = 1;
							for (int m = k - num; m <= k + num; m++)
							{
								for (int n = l - num; n <= l + num; n++)
								{
									if (Main.tile[m, n].type == 147 || Main.tile[m, n].type == 161)
									{
										Main.tile[m, n].type = 59;
									}
								}
							}
						}
						bool flag2 = false;
						if (Main.tile[k, l].type == 226)
						{
							flag2 = true;
						}
						if (Main.tile[k, l].type == 137)
						{
							int num2 = Main.tile[k, l].frameY / 18;
							if (num2 >= 1 && num2 <= 4)
							{
								flag2 = true;
							}
						}
						if (flag2)
						{
							Main.tile[k, l].color(b);
						}
					}
					if (Main.tile[k, l].wall == 87)
					{
						Main.tile[k, l].wallColor(b);
					}
				}
			}
			for (int num3 = 0; num3 < 8000 && Main.chest[num3] != null; num3++)
			{
				if (genRand.Next(15) == 0 && Main.chest[num3].item[1].stack != 0)
				{
					for (int num4 = 1; num4 < 40; num4++)
					{
						if (Main.chest[num3].item[num4].stack == 0)
						{
							Main.chest[num3].item[num4].SetDefaults(5001);
							break;
						}
					}
				}
				if (genRand.Next(30) != 0 || Main.chest[num3].item[1].stack == 0)
				{
					continue;
				}
				for (int num5 = 1; num5 < 40; num5++)
				{
					if (Main.chest[num3].item[num5].stack == 0)
					{
						Main.chest[num3].item[num5].SetDefaults(678);
						break;
					}
				}
			}
		}

		private static void FinishRemixWorld()
		{
			for (int i = 25; i < Main.maxTilesX - 25; i++)
			{
				for (int j = 25; j < Main.maxTilesY - 25; j++)
				{
					int conversionType = 1;
					if (crimson)
					{
						conversionType = 4;
					}
					if (notTheBees && (double)j < Main.worldSurface)
					{
						if (Main.tile[i, j].honey())
						{
							if (Main.tileLavaDeath[Main.tile[i, j].type])
							{
								KillTile(i, j);
							}
							Main.tile[i, j].lava(lava: true);
						}
						if (Main.tile[i, j].type == 375)
						{
							Main.tile[i, j].type = 374;
						}
						if (Main.tile[i, j].type == 230 || Main.tile[i, j].type == 229 || Main.tile[i, j].type == 659 || Main.tile[i, j].type == 56)
						{
							KillTile(i, j);
						}
						if (Main.tile[i, j].type == 82 || Main.tile[i, j].type == 83 || Main.tile[i, j].type == 84)
						{
							TileFrame(i, j);
						}
					}
					if ((double)j < Main.worldSurface + (double)genRand.Next(3))
					{
						if (drunkWorldGen)
						{
							if (GenVars.crimsonLeft)
							{
								if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
								{
									Convert(i, j, 4, 1);
								}
								else
								{
									Convert(i, j, 1, 1);
								}
							}
							else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Convert(i, j, 1, 1);
							}
							else
							{
								Convert(i, j, 4, 1);
							}
						}
						else
						{
							Convert(i, j, conversionType, 1);
						}
					}
					if ((double)j < Main.worldSurface - (double)genRand.Next(19, 22) && (Main.tile[i, j].wall == 178 || Main.tile[i, j].wall == 180))
					{
						Main.tile[i, j].wall = 0;
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 56)
					{
						KillTile(i, j);
					}
					if (Main.tile[i, j].type == 189 || Main.tile[i, j].type == 196 || Main.tile[i, j].type == 202)
					{
						if (drunkWorldGen)
						{
							if (GenVars.crimsonLeft)
							{
								if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
								{
									Main.tile[i, j].type = 195;
								}
								else
								{
									Main.tile[i, j].type = 474;
								}
							}
							else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Main.tile[i, j].type = 474;
							}
							else
							{
								Main.tile[i, j].type = 195;
							}
						}
						else if (crimson)
						{
							Main.tile[i, j].type = 195;
						}
						else
						{
							Main.tile[i, j].type = 474;
						}
					}
					if (Main.tile[i, j].wall == 73 || Main.tile[i, j].wall == 82)
					{
						if (drunkWorldGen)
						{
							if (GenVars.crimsonLeft)
							{
								if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
								{
									Main.tile[i, j].wall = 77;
								}
								else
								{
									Main.tile[i, j].wall = 233;
								}
							}
							else if (i < Main.maxTilesX / 2 + genRand.Next(-2, 3))
							{
								Main.tile[i, j].wall = 233;
							}
							else
							{
								Main.tile[i, j].wall = 77;
							}
						}
						else if (crimson)
						{
							Main.tile[i, j].wall = 77;
						}
						else
						{
							Main.tile[i, j].wall = 233;
						}
					}
					if ((double)j > Main.rockLayer && j < Main.maxTilesY - 350 && Main.tile[i, j].type == 0 && Main.tile[i, j].active() && (!Main.tile[i - 1, j - 1].active() || !SolidTile(i, j - 1) || !Main.tile[i + 1, j - 1].active() || !Main.tile[i - 1, j].active() || !Main.tile[i + 1, j].active() || !Main.tile[i - 1, j + 1].active() || !Main.tile[i, j + 1].active() || !Main.tile[i + 1, j + 1].active()))
					{
						Main.tile[i, j].type = 2;
					}
				}
			}
			Liquid.QuickWater(-2);
			int num = (int)((double)Main.maxTilesX * 0.38);
			int num2 = (int)((double)Main.maxTilesX * 0.62);
			_ = Main.maxTilesY;
			int num3 = Main.maxTilesY - 135;
			_ = Main.maxTilesY;
			for (int k = num; k < num2 + 15; k++)
			{
				for (int l = Main.maxTilesY - 200; l < num3 + 10; l++)
				{
					Main.tile[k, l].liquid = 0;
					if (Main.tile[k, l].type == 58)
					{
						Main.tile[k, l].type = 57;
					}
				}
			}
			AddTrees(undergroundOnly: true);
			for (int m = 0; m < Main.maxTilesX; m++)
			{
				byte color = 22;
				byte color2 = 22;
				if (drunkWorldGen)
				{
					if ((GenVars.crimsonLeft && m < Main.maxTilesX / 2) || (!GenVars.crimsonLeft && m > Main.maxTilesX / 2))
					{
						color2 = 13;
						color = 13;
					}
				}
				else if (crimson)
				{
					color2 = 13;
					color = 13;
				}
				for (int n = 0; n < Main.maxTilesY; n++)
				{
					if (Main.tile[m, n].active() && (Main.tileDungeon[Main.tile[m, n].type] || TileID.Sets.CrackedBricks[Main.tile[m, n].type]))
					{
						Main.tile[m, n].color(color);
					}
					if (Main.wallDungeon[Main.tile[m, n].wall])
					{
						Main.tile[m, n].wallColor(25);
						if (Main.tile[m, n].type == 19 && Main.tile[m, n].frameY != 180)
						{
							Main.tile[m, n].color(color);
						}
					}
					if (Main.tile[m, n].active())
					{
						bool flag = false;
						if (Main.tenthAnniversaryWorld)
						{
							if (Main.tile[m, n].type == 191)
							{
								flag = true;
							}
							if (Main.tile[m, n].active() && Main.tile[m, n].type == 151)
							{
								Main.tile[m, n].color(color);
							}
						}
						if (Main.tile[m, n].type == 226)
						{
							flag = true;
						}
						if (Main.tile[m, n].type == 137)
						{
							int num4 = Main.tile[m, n].frameY / 18;
							if (num4 >= 1 && num4 <= 4)
							{
								flag = true;
							}
						}
						if (flag)
						{
							Main.tile[m, n].color(color2);
						}
					}
					if (Main.tile[m, n].wall == 244)
					{
						Main.tile[m, n].wallColor(25);
					}
					if (Main.tile[m, n].wall == 34)
					{
						Main.tile[m, n].wallColor(25);
					}
					if (Main.tile[m, n].wall == 87)
					{
						Main.tile[m, n].wallColor(25);
						Main.tile[m, n].color(color2);
					}
				}
			}
			double num5 = (double)Main.maxTilesX / 4200.0;
			num5 *= (double)genRand.Next(2, 5);
			for (int num6 = 0; (double)num6 < num5; num6++)
			{
				int num7 = genRand.Next((int)((double)Main.maxTilesX * 0.39), (int)((double)Main.maxTilesX * 0.61));
				int num8 = genRand.Next(10, 31);
				for (int num9 = num7 - num8; num9 <= num7 + num8; num9++)
				{
					for (int num10 = Main.maxTilesY - 250; num10 < Main.maxTilesY - 25; num10++)
					{
						if (Main.tile[num9, num10].type == 637)
						{
							Main.tile[num9, num10].frameX = (short)(18 * Main.rand.Next(6, 11));
						}
					}
				}
			}
			if (notTheBees)
			{
				for (int num11 = 3; num11 < Main.maxTilesX - 3; num11++)
				{
					bool flag2 = true;
					for (int num12 = 0; (double)num12 < Main.worldSurface; num12++)
					{
						if (flag2)
						{
							if (Main.tile[num11, num12].wall == 86)
							{
								Main.tile[num11, num12].wall = 0;
							}
							if (Main.tile[num11, num12].active())
							{
								flag2 = false;
							}
						}
						else if (Main.tile[num11, num12].wall == 0 && Main.tile[num11, num12 + 1].wall == 0 && Main.tile[num11, num12 + 2].wall == 0 && Main.tile[num11, num12 + 3].wall == 0 && Main.tile[num11, num12 + 4].wall == 0 && Main.tile[num11 - 1, num12].wall == 0 && Main.tile[num11 + 1, num12].wall == 0 && Main.tile[num11 - 2, num12].wall == 0 && Main.tile[num11 + 2, num12].wall == 0 && !Main.tile[num11, num12].active() && !Main.tile[num11, num12 + 1].active() && !Main.tile[num11, num12 + 2].active() && !Main.tile[num11, num12 + 3].active())
						{
							flag2 = true;
						}
					}
				}
			}
			Liquid.QuickWater(-2);
			for (int num13 = 0; num13 < Main.maxTilesX; num13++)
			{
				for (int num14 = 0; num14 < Main.maxTilesY; num14++)
				{
					if (Main.tile[num13, num14].type == 518)
					{
						CheckLilyPad(num13, num14);
					}
				}
			}
		}

		public static bool IsItATrap(Tile tile)
		{
			if (tile.actuator())
			{
				return true;
			}
			if (tile.active() && TileID.Sets.IsAMechanism[tile.type])
			{
				return true;
			}
			return false;
		}

		public static bool IsItATrigger(Tile tile)
		{
			if (tile.active())
			{
				if (TileID.Sets.IsATrigger[tile.type])
				{
					return true;
				}
				if (tile.type == 467 && tile.frameX / 36 == 4)
				{
					return true;
				}
				if (tile.type == 314 && Minecart.IsPressurePlate(tile))
				{
					return true;
				}
			}
			return false;
		}

		public static void ClearAllBrokenTraps()
		{
			List<Point> list = new List<Point>();
			for (int i = 50; i < Main.maxTilesX - 50; i++)
			{
				for (int j = 50; j < Main.maxTilesY - 50; j++)
				{
					if (Main.tile[i, j].wire() && !list.Contains(new Point(i, j)))
					{
						ClearBrokenTraps(new Point(i, j), list);
					}
				}
			}
		}

		public static void ClearBrokenTraps(Point startTileCoords, List<Point> pointsWeAlreadyWentOver)
		{
			List<Point> t = new List<Point>();
			List<Point> t2 = new List<Point>();
			List<Point> list = new List<Point>();
			bool flag = false;
			bool flag2 = false;
			t2.Add(startTileCoords);
			while (t2.Count > 0)
			{
				Utils.Swap(ref t, ref t2);
				while (t.Count > 0)
				{
					Point item = t[0];
					t.RemoveAt(0);
					if (!InWorld(item.X, item.Y, 5))
					{
						continue;
					}
					Tile tile = Main.tile[item.X, item.Y];
					if (tile.wire())
					{
						pointsWeAlreadyWentOver.Add(item);
						list.Add(item);
						if (IsItATrap(tile))
						{
							flag = true;
						}
						if (IsItATrigger(tile))
						{
							flag2 = true;
						}
						if (flag2 && flag)
						{
							break;
						}
						Point item2 = new Point(item.X - 1, item.Y);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
						item2 = new Point(item.X + 1, item.Y);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
						item2 = new Point(item.X, item.Y - 1);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
						item2 = new Point(item.X, item.Y + 1);
						if (!list.Contains(item2))
						{
							t2.Add(item2);
						}
					}
				}
				if (flag2 && flag)
				{
					break;
				}
			}
			if (flag2 && flag)
			{
				return;
			}
			foreach (Point item3 in list)
			{
				Tile tile2 = Main.tile[item3.X, item3.Y];
				tile2.wire(wire: false);
				if (IsItATrap(tile2))
				{
					if (tile2.actuator())
					{
						Main.tile[item3.X, item3.Y].actuator(actuator: false);
					}
					else if (tile2.type != 105)
					{
						KillTile(item3.X, item3.Y);
					}
				}
				else if (IsItATrigger(tile2))
				{
					if (tile2.type == 314)
					{
						tile2.frameX = 1;
					}
					else
					{
						KillTile(item3.X, item3.Y);
					}
				}
			}
		}

		private static double TuneOceanDepth(int count, double depth, bool floridaStyle = false)
		{
			if (!floridaStyle)
			{
				if (count < 3)
				{
					depth += (double)genRand.Next(10, 20) * 0.2;
				}
				else if (count < 6)
				{
					depth += (double)genRand.Next(10, 20) * 0.15;
				}
				else if (count < 9)
				{
					depth += (double)genRand.Next(10, 20) * 0.1;
				}
				else if (count < 15)
				{
					depth += (double)genRand.Next(10, 20) * 0.07;
				}
				else if (count < 50)
				{
					depth += (double)genRand.Next(10, 20) * 0.05;
				}
				else if (count < 75)
				{
					depth += (double)genRand.Next(10, 20) * 0.04;
				}
				else if (count < 100)
				{
					depth += (double)genRand.Next(10, 20) * 0.03;
				}
				else if (count < 125)
				{
					depth += (double)genRand.Next(10, 20) * 0.02;
				}
				else if (count < 150)
				{
					depth += (double)genRand.Next(10, 20) * 0.01;
				}
				else if (count < 175)
				{
					depth += (double)genRand.Next(10, 20) * 0.005;
				}
				else if (count < 200)
				{
					depth += (double)genRand.Next(10, 20) * 0.001;
				}
				else if (count < 230)
				{
					depth += (double)genRand.Next(10, 20) * 0.01;
				}
				else if (count < 235)
				{
					depth += (double)genRand.Next(10, 20) * 0.05;
				}
				else if (count < 240)
				{
					depth += (double)genRand.Next(10, 20) * 0.1;
				}
				else if (count < 245)
				{
					depth += (double)genRand.Next(10, 20) * 0.05;
				}
				else if (count < 255)
				{
					depth += (double)genRand.Next(10, 20) * 0.01;
				}
			}
			else if (count < 3)
			{
				depth += (double)genRand.Next(10, 20) * 0.001;
			}
			else if (count < 6)
			{
				depth += (double)genRand.Next(10, 20) * 0.002;
			}
			else if (count < 9)
			{
				depth += (double)genRand.Next(10, 20) * 0.004;
			}
			else if (count < 15)
			{
				depth += (double)genRand.Next(10, 20) * 0.007;
			}
			else if (count < 50)
			{
				depth += (double)genRand.Next(10, 20) * 0.01;
			}
			else if (count < 75)
			{
				depth += (double)genRand.Next(10, 20) * 0.014;
			}
			else if (count < 100)
			{
				depth += (double)genRand.Next(10, 20) * 0.019;
			}
			else if (count < 125)
			{
				depth += (double)genRand.Next(10, 20) * 0.027;
			}
			else if (count < 150)
			{
				depth += (double)genRand.Next(10, 20) * 0.038;
			}
			else if (count < 175)
			{
				depth += (double)genRand.Next(10, 20) * 0.052;
			}
			else if (count < 200)
			{
				depth += (double)genRand.Next(10, 20) * 0.08;
			}
			else if (count < 230)
			{
				depth += (double)genRand.Next(10, 20) * 0.12;
			}
			else if (count < 235)
			{
				depth += (double)genRand.Next(10, 20) * 0.16;
			}
			else if (count < 240)
			{
				depth += (double)genRand.Next(10, 20) * 0.27;
			}
			else if (count < 245)
			{
				depth += (double)genRand.Next(10, 20) * 0.43;
			}
			else if (count < 255)
			{
				depth += (double)genRand.Next(10, 20) * 0.6;
			}
			return depth;
		}

		public static void QueuePostGenAction(Action<StructureMap> action)
		{
			_postGenActions.Enqueue(action);
		}

		public static void ConsumePostGenActions(StructureMap structures)
		{
			while (_postGenActions.Count > 0)
			{
				_postGenActions.Dequeue()(structures);
			}
		}

		public static Point RandomRectanglePoint(Rectangle rectangle)
		{
			return new Point(genRand.Next(rectangle.X, rectangle.X + rectangle.Width), genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
		}

		public static Point RandomRectanglePoint(int x, int y, int width, int height)
		{
			return new Point(genRand.Next(x, x + width), genRand.Next(y, y + height));
		}

		public static Point RandomWorldPoint(int padding)
		{
			return RandomWorldPoint(padding, padding, padding, padding);
		}

		public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0)
		{
			return new Point(genRand.Next(left, Main.maxTilesX - right), genRand.Next(top, Main.maxTilesY - bottom));
		}

		public static bool GrowPalmTree(int i, int y)
		{
			int num = y;
			if (!InWorld(i, y))
			{
				return false;
			}
			while (Main.tile[i, num].type == 20)
			{
				num++;
				if (Main.tile[i, num] == null)
				{
					return false;
				}
			}
			Tile tile = Main.tile[i, num];
			Tile tile2 = Main.tile[i, num - 1];
			byte color = 0;
			if (Main.tenthAnniversaryWorld && !gen)
			{
				color = (byte)genRand.Next(1, 13);
			}
			tile.slope();
			tile.halfBrick();
			if (!tile.active() || tile.halfBrick() || tile.slope() != 0)
			{
				return false;
			}
			if (tile2.wall != 0 || tile2.liquid != 0)
			{
				return false;
			}
			if (tile.type != 53 && tile.type != 234 && tile.type != 116 && tile.type != 112)
			{
				return false;
			}
			if (!EmptyTileCheck(i, i, num - 2, num - 1, 20))
			{
				return false;
			}
			if (!EmptyTileCheck(i - 1, i + 1, num - 30, num - 3, 20))
			{
				return false;
			}
			int num2 = genRand.Next(10, 21);
			int num3 = genRand.Next(-8, 9);
			num3 *= 2;
			short num4 = 0;
			for (int j = 0; j < num2; j++)
			{
				tile = Main.tile[i, num - 1 - j];
				if (j == 0)
				{
					tile.active(active: true);
					tile.type = 323;
					tile.frameX = 66;
					tile.frameY = 0;
					tile.color(color);
					continue;
				}
				if (j == num2 - 1)
				{
					tile.active(active: true);
					tile.type = 323;
					tile.frameX = (short)(22 * genRand.Next(4, 7));
					tile.frameY = num4;
					tile.color(color);
					continue;
				}
				if (num4 != num3)
				{
					double num5 = (double)j / (double)num2;
					bool flag = false;
					if (!(num5 < 0.25) && ((num5 < 0.5 && genRand.Next(13) == 0) || (num5 < 0.7 && genRand.Next(9) == 0) || !(num5 < 0.95) || genRand.Next(5) != 0 || true))
					{
						short num6 = (short)Math.Sign(num3);
						num4 = (short)(num4 + (short)(num6 * 2));
					}
				}
				tile.active(active: true);
				tile.type = 323;
				tile.frameX = (short)(22 * genRand.Next(0, 3));
				tile.frameY = num4;
				tile.color(color);
			}
			RangeFrame(i - 2, num - num2 - 1, i + 2, num + 1);
			NetMessage.SendTileSquare(-1, i, num - num2, 1, num2);
			return true;
		}

		public static bool IsPalmOasisTree(int x)
		{
			if (x >= beachDistance)
			{
				return x <= Main.maxTilesX - beachDistance;
			}
			return false;
		}

		public static bool GrowEpicTree(int i, int y)
		{
			int j;
			for (j = y; Main.tile[i, j].type == 20; j++)
			{
			}
			if (Main.tile[i, j].active() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && Main.tile[i, j].type == 2 && Main.tile[i, j - 1].wall == 0 && Main.tile[i, j - 1].liquid == 0 && ((Main.tile[i - 1, j].active() && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109)) || (Main.tile[i + 1, j].active() && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))))
			{
				int num = 2;
				if (EmptyTileCheck(i - num, i + num, j - 55, j - 1, 20))
				{
					bool flag = false;
					bool flag2 = false;
					int num2 = genRand.Next(20, 30);
					if (drunkWorldGen)
					{
						num2 = genRand.Next(3, 7);
					}
					int num3;
					for (int k = j - num2; k < j; k++)
					{
						Main.tile[i, k].frameNumber((byte)genRand.Next(3));
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						num3 = genRand.Next(3);
						int num4 = genRand.Next(10);
						if (k == j - 1 || k == j - num2)
						{
							num4 = 0;
						}
						while (((num4 == 5 || num4 == 7) && flag) || ((num4 == 6 || num4 == 7) && flag2))
						{
							num4 = genRand.Next(10);
						}
						flag = false;
						flag2 = false;
						if (num4 == 5 || num4 == 7)
						{
							flag = true;
						}
						if (num4 == 6 || num4 == 7)
						{
							flag2 = true;
						}
						switch (num4)
						{
						case 1:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 2:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 3:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 4:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 5:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 6:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 7:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 110;
							}
							break;
						default:
							if (num3 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 0;
							}
							if (num3 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 22;
							}
							if (num3 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 44;
							}
							break;
						}
						if (num4 == 5 || num4 == 7)
						{
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							num3 = genRand.Next(3);
							if (genRand.Next(3) < 2)
							{
								if (num3 == 0)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}
								if (num3 == 1)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}
								if (num3 == 2)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else
							{
								if (num3 == 0)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}
								if (num3 == 1)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}
								if (num3 == 2)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}
						if (num4 != 6 && num4 != 7)
						{
							continue;
						}
						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						num3 = genRand.Next(3);
						if (genRand.Next(3) < 2)
						{
							if (num3 == 0)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}
							if (num3 == 1)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}
							if (num3 == 2)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else
						{
							if (num3 == 0)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}
							if (num3 == 1)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}
							if (num3 == 2)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}
					int num5 = genRand.Next(3);
					bool flag3 = false;
					bool flag4 = false;
					if (Main.tile[i - 1, j].active() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && (Main.tile[i - 1, j].type == 2 || Main.tile[i - 1, j].type == 23 || Main.tile[i - 1, j].type == 60 || Main.tile[i - 1, j].type == 109))
					{
						flag3 = true;
					}
					if (Main.tile[i + 1, j].active() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && (Main.tile[i + 1, j].type == 2 || Main.tile[i + 1, j].type == 23 || Main.tile[i + 1, j].type == 60 || Main.tile[i + 1, j].type == 109))
					{
						flag4 = true;
					}
					if (!flag3)
					{
						if (num5 == 0)
						{
							num5 = 2;
						}
						if (num5 == 1)
						{
							num5 = 3;
						}
					}
					if (!flag4)
					{
						if (num5 == 0)
						{
							num5 = 1;
						}
						if (num5 == 2)
						{
							num5 = 3;
						}
					}
					if (flag3 && !flag4)
					{
						num5 = 2;
					}
					if (flag4 && !flag3)
					{
						num5 = 1;
					}
					if (num5 == 0 || num5 == 1)
					{
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}
					if (num5 == 0 || num5 == 2)
					{
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}
					num3 = genRand.Next(3);
					switch (num5)
					{
					case 0:
						if (num3 == 0)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 1:
						if (num3 == 0)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 2:
						if (num3 == 0)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					}
					if (genRand.Next(13) != 0)
					{
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					else
					{
						num3 = genRand.Next(3);
						if (num3 == 0)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num3 == 1)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num3 == 2)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, (int)((double)j - (double)num2 * 0.5), num2 + 1);
					}
					return true;
				}
			}
			return false;
		}

		public static bool Pyramid(int i, int j)
		{
			ushort num = 151;
			if (Main.tile[i, j].type == 151 || Main.tile[i, j].wall == 151)
			{
				return false;
			}
			int num2 = j - genRand.Next(0, 7);
			int num3 = genRand.Next(9, 13);
			int num4 = 1;
			int num5 = j + genRand.Next(75, 125);
			for (int k = num2; k < num5; k++)
			{
				for (int l = i - num4; l < i + num4 - 1; l++)
				{
					Main.tile[l, k].type = num;
					Main.tile[l, k].active(active: true);
					Main.tile[l, k].halfBrick(halfBrick: false);
					Main.tile[l, k].slope(0);
				}
				num4++;
			}
			for (int m = i - num4 - 5; m <= i + num4 + 5; m++)
			{
				for (int n = j - 1; n <= num5 + 1; n++)
				{
					bool flag = true;
					for (int num6 = m - 1; num6 <= m + 1; num6++)
					{
						for (int num7 = n - 1; num7 <= n + 1; num7++)
						{
							if (Main.tile[num6, num7].type != num)
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[m, n].wall = 34;
						SquareWallFrame(m, n);
					}
				}
			}
			int num8 = 1;
			if (genRand.Next(2) == 0)
			{
				num8 = -1;
			}
			int num9 = i - num3 * num8;
			int num10 = j + num3;
			int num11 = genRand.Next(5, 8);
			bool flag2 = true;
			int num12 = genRand.Next(20, 30);
			while (flag2)
			{
				flag2 = false;
				bool flag3 = false;
				for (int num13 = num10; num13 <= num10 + num11; num13++)
				{
					int num14 = num9;
					if (Main.tile[num14, num13 - 1].type == 53)
					{
						flag3 = true;
					}
					if (Main.tile[num14, num13].type == num)
					{
						Main.tile[num14, num13 + 1].wall = 34;
						Main.tile[num14 + num8, num13].wall = 34;
						Main.tile[num14, num13].active(active: false);
						flag2 = true;
					}
					if (flag3)
					{
						Main.tile[num14, num13].type = 53;
						Main.tile[num14, num13].active(active: true);
						Main.tile[num14, num13].halfBrick(halfBrick: false);
						Main.tile[num14, num13].slope(0);
					}
				}
				num9 -= num8;
			}
			num9 = i - num3 * num8;
			bool flag4 = true;
			bool flag5 = false;
			flag2 = true;
			while (flag2)
			{
				for (int num15 = num10; num15 <= num10 + num11; num15++)
				{
					int num16 = num9;
					Main.tile[num16, num15].active(active: false);
				}
				num9 += num8;
				num10++;
				num12--;
				if (num10 >= num5 - num11 * 2)
				{
					num12 = 10;
				}
				if (num12 <= 0)
				{
					bool flag6 = false;
					if (!flag4 && !flag5)
					{
						flag5 = true;
						flag6 = true;
						int num17 = genRand.Next(7, 13);
						int num18 = genRand.Next(23, 28);
						int num19 = num18;
						int num20 = num9;
						while (num18 > 0)
						{
							for (int num21 = num10 - num17 + num11; num21 <= num10 + num11; num21++)
							{
								if (num18 == num19 || num18 == 1)
								{
									if (num21 >= num10 - num17 + num11 + 2)
									{
										Main.tile[num9, num21].active(active: false);
									}
								}
								else if (num18 == num19 - 1 || num18 == 2 || num18 == num19 - 2 || num18 == 3)
								{
									if (num21 >= num10 - num17 + num11 + 1)
									{
										Main.tile[num9, num21].active(active: false);
									}
								}
								else
								{
									Main.tile[num9, num21].active(active: false);
								}
							}
							num18--;
							num9 += num8;
						}
						int num22 = num9 - num8;
						int num23 = num22;
						int num24 = num20;
						if (num22 > num20)
						{
							num23 = num20;
							num24 = num22;
						}
						int num25 = genRand.Next(3);
						if (num25 == 0)
						{
							num25 = genRand.Next(3);
						}
						if (Main.tenthAnniversaryWorld && num25 == 0)
						{
							num25 = 1;
						}
						switch (num25)
						{
						case 0:
							num25 = 848;
							break;
						case 1:
							num25 = 857;
							break;
						case 2:
							num25 = 934;
							break;
						}
						AddBuriedChest((num23 + num24) / 2, num10, num25, notNearOtherChests: false, 1, trySlope: false, 0);
						int num26 = genRand.Next(1, 10);
						for (int num27 = 0; num27 < num26; num27++)
						{
							int i2 = genRand.Next(num23, num24);
							int j2 = num10 + num11;
							PlaceSmallPile(i2, j2, genRand.Next(16, 19), 1, 185);
						}
						PlaceTile(num23 + 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num23 + 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num24 - 2, num10 - num17 + num11 + 1, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						PlaceTile(num24 - 3, num10 - num17 + num11, 91, mute: true, forced: false, -1, genRand.Next(4, 7));
						for (int num28 = num23; num28 <= num24; num28++)
						{
							PlacePot(num28, num10 + num11, 28, genRand.Next(25, 28));
						}
					}
					if (flag4)
					{
						flag4 = false;
						num8 *= -1;
						num12 = genRand.Next(15, 20);
					}
					else if (flag6)
					{
						num12 = genRand.Next(10, 15);
					}
					else
					{
						num8 *= -1;
						num12 = genRand.Next(20, 40);
					}
				}
				if (num10 >= num5 - num11)
				{
					flag2 = false;
				}
			}
			int num29 = genRand.Next(100, 200);
			int num30 = genRand.Next(500, 800);
			flag2 = true;
			int num31 = num11;
			num12 = genRand.Next(10, 50);
			if (num8 == 1)
			{
				num9 -= num31;
			}
			int num32 = genRand.Next(5, 10);
			while (flag2)
			{
				num29--;
				num30--;
				num12--;
				for (int num33 = num9 - num32 - genRand.Next(0, 2); num33 <= num9 + num31 + num32 + genRand.Next(0, 2); num33++)
				{
					int num34 = num10;
					if (num33 >= num9 && num33 <= num9 + num31)
					{
						Main.tile[num33, num34].active(active: false);
					}
					else
					{
						Main.tile[num33, num34].type = num;
						Main.tile[num33, num34].active(active: true);
						Main.tile[num33, num34].halfBrick(halfBrick: false);
						Main.tile[num33, num34].slope(0);
					}
					if (num33 >= num9 - 1 && num33 <= num9 + 1 + num31)
					{
						Main.tile[num33, num34].wall = 34;
					}
				}
				num10++;
				num9 += num8;
				if (num29 <= 0)
				{
					flag2 = false;
					for (int num35 = num9 + 1; num35 <= num9 + num31 - 1; num35++)
					{
						if (Main.tile[num35, num10].active())
						{
							flag2 = true;
						}
					}
				}
				if (num12 < 0)
				{
					num12 = genRand.Next(10, 50);
					num8 *= -1;
				}
				if (num30 <= 0)
				{
					flag2 = false;
				}
			}
			return true;
		}

		public static bool GrowLivingTree(int i, int j, bool patch = false)
		{
			//IL_0d1f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d2a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d2f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d34: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			int[] array = new int[1000];
			int[] array2 = new int[1000];
			int[] array3 = new int[1000];
			int[] array4 = new int[1000];
			int num2 = 0;
			int[] array5 = new int[2000];
			int[] array6 = new int[2000];
			bool[] array7 = new bool[2000];
			if (!SolidTile(i, j + 1))
			{
				return false;
			}
			if (Main.tile[i, j].active())
			{
				return false;
			}
			if (Main.tile[i, j + 1].type != 0 && Main.tile[i, j + 1].type != 2 && Main.tile[i, j + 1].type != 1 && Main.tile[i, j + 1].type != 40 && !TileID.Sets.Ore[Main.tile[i, j + 1].type] && (!remixWorldGen || !notTheBees || (Main.tile[i, j + 1].type != 60 && Main.tile[i, j + 1].type != 59)))
			{
				return false;
			}
			if (j < 150)
			{
				return false;
			}
			int num3 = i - genRand.Next(2, 3);
			int num4 = i + genRand.Next(2, 3);
			if (genRand.Next(5) == 0)
			{
				if (genRand.Next(2) == 0)
				{
					num3--;
				}
				else
				{
					num4++;
				}
			}
			int num5 = num4 - num3;
			bool flag = num5 >= 4;
			int num6 = i - 50;
			int num7 = i + 50;
			if (patch)
			{
				num6 = i - 20;
				num7 = i + 20;
				num3 = i - genRand.Next(1, 3);
				num4 = i + genRand.Next(1, 3);
				flag = num5 >= 4;
			}
			for (int k = num6; k <= num7; k++)
			{
				for (int l = 5; l < j - 5; l++)
				{
					if (Main.tile[k, l].active())
					{
						if (!patch)
						{
							return false;
						}
						int type = Main.tile[k, l].type;
						if (type != 2 && type != 0 && type != 1 && type != 191 && type != 192)
						{
							return false;
						}
					}
				}
			}
			int num8 = num3;
			int num9 = num4;
			int minl = num3;
			int minr = num4;
			bool flag2 = true;
			int num10 = genRand.Next(-8, -4);
			int num11 = genRand.Next(2);
			int num12 = j;
			int num13 = genRand.Next(5, 15);
			Main.tileSolid[48] = false;
			while (flag2)
			{
				num10++;
				if (num10 > num13)
				{
					num13 = genRand.Next(5, 15);
					num10 = 0;
					array2[num] = num12 + genRand.Next(5);
					if (genRand.Next(5) == 0)
					{
						num11 = ((num11 == 0) ? 1 : 0);
					}
					if (num11 == 0)
					{
						array3[num] = -1;
						array[num] = num3;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num3++;
						}
						num8++;
						num11 = 1;
					}
					else
					{
						array3[num] = 1;
						array[num] = num4;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num4--;
						}
						num9--;
						num11 = 0;
					}
					if (num8 == num9)
					{
						flag2 = false;
					}
					num++;
				}
				for (int m = num3; m <= num4; m++)
				{
					Main.tile[m, num12].type = 191;
					Main.tile[m, num12].active(active: true);
					Main.tile[m, num12].halfBrick(halfBrick: false);
				}
				num12--;
			}
			for (int n = 0; n < num - 1; n++)
			{
				int num14 = array[n] + array3[n];
				int num15 = array2[n];
				int num16 = (int)((double)array4[n] * (1.0 + (double)genRand.Next(20, 30) * 0.1));
				Main.tile[num14, num15 + 1].type = 191;
				Main.tile[num14, num15 + 1].active(active: true);
				Main.tile[num14, num15 + 1].halfBrick(halfBrick: false);
				int num17 = genRand.Next(3, 5);
				while (num16 > 0)
				{
					num16--;
					Main.tile[num14, num15].type = 191;
					Main.tile[num14, num15].active(active: true);
					Main.tile[num14, num15].halfBrick(halfBrick: false);
					if (genRand.Next(10) == 0)
					{
						num15 = ((genRand.Next(2) != 0) ? (num15 + 1) : (num15 - 1));
					}
					else
					{
						num14 += array3[n];
					}
					if (num17 > 0)
					{
						num17--;
					}
					else if (genRand.Next(2) == 0)
					{
						num17 = genRand.Next(2, 5);
						if (genRand.Next(2) == 0)
						{
							Main.tile[num14, num15].type = 191;
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].halfBrick(halfBrick: false);
							Main.tile[num14, num15 - 1].type = 191;
							Main.tile[num14, num15 - 1].active(active: true);
							Main.tile[num14, num15 - 1].halfBrick(halfBrick: false);
							array5[num2] = num14;
							array6[num2] = num15;
							num2++;
						}
						else
						{
							Main.tile[num14, num15].type = 191;
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].halfBrick(halfBrick: false);
							Main.tile[num14, num15 + 1].type = 191;
							Main.tile[num14, num15 + 1].active(active: true);
							Main.tile[num14, num15 + 1].halfBrick(halfBrick: false);
							array5[num2] = num14;
							array6[num2] = num15;
							num2++;
						}
					}
					if (num16 == 0)
					{
						array5[num2] = num14;
						array6[num2] = num15;
						num2++;
					}
				}
			}
			int num18 = (num3 + num4) / 2;
			int num19 = num12;
			int num20 = genRand.Next(num5 * 3, num5 * 5);
			int num21 = 0;
			int num22 = 0;
			while (num20 > 0)
			{
				Main.tile[num18, num19].type = 191;
				Main.tile[num18, num19].active(active: true);
				Main.tile[num18, num19].halfBrick(halfBrick: false);
				if (num21 > 0)
				{
					num21--;
				}
				if (num22 > 0)
				{
					num22--;
				}
				for (int num23 = -1; num23 < 2; num23++)
				{
					if (num23 == 0 || ((num23 >= 0 || num21 != 0) && (num23 <= 0 || num22 != 0)) || genRand.Next(2) != 0)
					{
						continue;
					}
					int num24 = num18;
					int num25 = num19;
					int num26 = genRand.Next(num5, num5 * 3);
					if (num23 < 0)
					{
						num21 = genRand.Next(3, 5);
					}
					if (num23 > 0)
					{
						num22 = genRand.Next(3, 5);
					}
					int num27 = 0;
					while (num26 > 0)
					{
						num26--;
						num24 += num23;
						Main.tile[num24, num25].type = 191;
						Main.tile[num24, num25].active(active: true);
						Main.tile[num24, num25].halfBrick(halfBrick: false);
						if (num26 == 0)
						{
							array5[num2] = num24;
							array6[num2] = num25;
							array7[num2] = true;
							num2++;
						}
						if (genRand.Next(5) == 0)
						{
							num25 = ((genRand.Next(2) != 0) ? (num25 + 1) : (num25 - 1));
							Main.tile[num24, num25].type = 191;
							Main.tile[num24, num25].active(active: true);
							Main.tile[num24, num25].halfBrick(halfBrick: false);
						}
						if (num27 > 0)
						{
							num27--;
						}
						else if (genRand.Next(3) == 0)
						{
							num27 = genRand.Next(2, 4);
							int num28 = num24;
							int num29 = num25;
							num29 = ((genRand.Next(2) != 0) ? (num29 + 1) : (num29 - 1));
							Main.tile[num28, num29].type = 191;
							Main.tile[num28, num29].active(active: true);
							Main.tile[num28, num29].halfBrick(halfBrick: false);
							array5[num2] = num28;
							array6[num2] = num29;
							array7[num2] = true;
							num2++;
							array5[num2] = num28 + genRand.Next(-5, 6);
							array6[num2] = num29 + genRand.Next(-5, 6);
							array7[num2] = true;
							num2++;
						}
					}
				}
				array5[num2] = num18;
				array6[num2] = num19;
				num2++;
				if (genRand.Next(4) == 0)
				{
					num18 = ((genRand.Next(2) != 0) ? (num18 + 1) : (num18 - 1));
					Main.tile[num18, num19].type = 191;
					Main.tile[num18, num19].active(active: true);
					Main.tile[num18, num19].halfBrick(halfBrick: false);
				}
				num19--;
				num20--;
			}
			for (int num30 = minl; num30 <= minr; num30++)
			{
				int num31 = genRand.Next(1, 6);
				int num32 = j + 1;
				while (num31 > 0)
				{
					if (SolidTile(num30, num32))
					{
						num31--;
					}
					Main.tile[num30, num32].type = 191;
					Main.tile[num30, num32].active(active: true);
					Main.tile[num30, num32].halfBrick(halfBrick: false);
					num32++;
				}
				int num33 = num32;
				int num34 = genRand.Next(2, num5 + 1);
				for (int num35 = 0; num35 < num34; num35++)
				{
					num32 = num33;
					int num36 = (minl + minr) / 2;
					int num37 = 0;
					int num38 = 1;
					num37 = ((num30 >= num36) ? 1 : (-1));
					if (num30 == num36 || (num5 > 6 && (num30 == num36 - 1 || num30 == num36 + 1)))
					{
						num37 = 0;
					}
					int num39 = num37;
					int num40 = num30;
					num31 = genRand.Next((int)((double)num5 * 3.5), num5 * 6);
					while (num31 > 0)
					{
						num31--;
						num40 += num37;
						if (Main.tile[num40, num32].wall != 244)
						{
							Main.tile[num40, num32].type = 191;
							Main.tile[num40, num32].active(active: true);
							Main.tile[num40, num32].halfBrick(halfBrick: false);
						}
						num32 += num38;
						if (Main.tile[num40, num32].wall != 244)
						{
							Main.tile[num40, num32].type = 191;
							Main.tile[num40, num32].active(active: true);
							Main.tile[num40, num32].halfBrick(halfBrick: false);
						}
						if (!Main.tile[num40, num32 + 1].active())
						{
							num37 = 0;
							num38 = 1;
						}
						if (genRand.Next(3) == 0)
						{
							num37 = ((num39 < 0) ? ((num37 == 0) ? (-1) : 0) : ((num39 <= 0) ? genRand.Next(-1, 2) : ((num37 == 0) ? 1 : 0)));
						}
						if (genRand.Next(3) == 0)
						{
							num38 = ((num38 == 0) ? 1 : 0);
						}
					}
				}
			}
			if (remixWorldGen)
			{
				num2 = 0;
			}
			for (int num41 = 0; num41 < num2; num41++)
			{
				int num42 = genRand.Next(5, 8);
				num42 = (int)((double)num42 * (1.0 + (double)num5 * 0.05));
				if (array7[num41])
				{
					num42 = genRand.Next(6, 12) + num5;
				}
				int num43 = array5[num41] - num42 * 2;
				int num44 = array5[num41] + num42 * 2;
				int num45 = array6[num41] - num42 * 2;
				int num46 = array6[num41] + num42 * 2;
				double num47 = 2.0 - (double)genRand.Next(5) * 0.1;
				for (int num48 = num43; num48 <= num44; num48++)
				{
					for (int num49 = num45; num49 <= num46; num49++)
					{
						if (Main.tile[num48, num49].type == 191)
						{
							continue;
						}
						if (array7[num41])
						{
							Vector2D val = new Vector2D((double)array5[num41], (double)array6[num41]) - new Vector2D((double)num48, (double)num49);
							if (((Vector2D)(ref val)).Length() < (double)num42 * 0.9)
							{
								Main.tile[num48, num49].type = 192;
								Main.tile[num48, num49].active(active: true);
								Main.tile[num48, num49].halfBrick(halfBrick: false);
							}
						}
						else if ((double)Math.Abs(array5[num41] - num48) + (double)Math.Abs(array6[num41] - num49) * num47 < (double)num42)
						{
							Main.tile[num48, num49].type = 192;
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].halfBrick(halfBrick: false);
						}
					}
					if (genRand.Next(30) == 0)
					{
						int num50 = num45;
						if (!Main.tile[num48, num50].active())
						{
							for (; !Main.tile[num48, num50 + 1].active() && num50 < num46; num50++)
							{
							}
							if (Main.tile[num48, num50 + 1].type == 192)
							{
								PlaceTile(num48, num50, 187, mute: true, forced: false, -1, genRand.Next(50, 52));
							}
						}
					}
					if (array7[num41] || genRand.Next(15) != 0)
					{
						continue;
					}
					int num51 = num46;
					int num52 = num51 + 100;
					if (Main.tile[num48, num51].active())
					{
						continue;
					}
					for (; !Main.tile[num48, num51 + 1].active() && num51 < num52; num51++)
					{
					}
					if (Main.tile[num48, num51 + 1].type == 192)
					{
						continue;
					}
					if (genRand.Next(2) == 0)
					{
						PlaceTile(num48, num51, 187, mute: true, forced: false, -1, genRand.Next(47, 50));
						continue;
					}
					int num53 = genRand.Next(2);
					int x = 72;
					if (num53 == 1)
					{
						x = genRand.Next(59, 62);
					}
					PlaceSmallPile(num48, num51, x, num53, 185);
				}
			}
			if (flag)
			{
				bool flag3 = false;
				for (int num54 = j; num54 < j + 20 && !((double)num54 >= Main.worldSurface - 2.0); num54++)
				{
					for (int num55 = minl; num55 <= minr; num55++)
					{
						if (Main.tile[num55, num54].wall == 0 && !SolidTile(num55, num54))
						{
							flag3 = true;
						}
					}
				}
				if (!flag3)
				{
					GrowLivingTree_MakePassage(j, num5, ref minl, ref minr, patch);
				}
			}
			Main.tileSolid[48] = true;
			return true;
		}

		public static bool GrowDungeonTree(int i, int j, bool patch = false)
		{
			//IL_0d08: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d13: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d18: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d1d: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			int[] array = new int[1000];
			int[] array2 = new int[1000];
			int[] array3 = new int[1000];
			int[] array4 = new int[1000];
			int num2 = 0;
			int[] array5 = new int[2000];
			int[] array6 = new int[2000];
			bool[] array7 = new bool[2000];
			int num3 = i - genRand.Next(2, 3);
			int num4 = i + genRand.Next(2, 3);
			if (genRand.Next(5) == 0)
			{
				if (genRand.Next(2) == 0)
				{
					num3--;
				}
				else
				{
					num4++;
				}
			}
			int num5 = num4 - num3;
			int num6 = num3;
			int num7 = num4;
			int minl = num3;
			int minr = num4;
			bool flag = true;
			int num8 = genRand.Next(-8, -4);
			int num9 = genRand.Next(2);
			int num10 = j;
			int num11 = genRand.Next(5, 15);
			Main.tileSolid[48] = false;
			while (flag)
			{
				num8++;
				if (num8 > num11)
				{
					num11 = genRand.Next(5, 15);
					num8 = 0;
					array2[num] = num10 + genRand.Next(5);
					if (genRand.Next(5) == 0)
					{
						num9 = ((num9 == 0) ? 1 : 0);
					}
					if (num9 == 0)
					{
						array3[num] = -1;
						array[num] = num3;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num3++;
						}
						num6++;
						num9 = 1;
					}
					else
					{
						array3[num] = 1;
						array[num] = num4;
						array4[num] = num4 - num3;
						if (genRand.Next(2) == 0)
						{
							num4--;
						}
						num7--;
						num9 = 0;
					}
					if (num6 == num7)
					{
						flag = false;
					}
					num++;
				}
				for (int k = num3; k <= num4; k++)
				{
					Main.tile[k, num10].type = 191;
					Main.tile[k, num10].active(active: true);
					Main.tile[k, num10].halfBrick(halfBrick: false);
					Main.tile[k, num10].slope(0);
					Main.tile[k, num10].color(28);
				}
				num10--;
			}
			for (int l = 0; l < num - 1; l++)
			{
				int num12 = array[l] + array3[l];
				int num13 = array2[l];
				int num14 = (int)((double)array4[l] * (1.0 + (double)genRand.Next(20, 30) * 0.1));
				Main.tile[num12, num13 + 1].type = 191;
				Main.tile[num12, num13 + 1].active(active: true);
				Main.tile[num12, num13 + 1].halfBrick(halfBrick: false);
				Main.tile[num12, num13 + 1].color(28);
				int num15 = genRand.Next(3, 5);
				while (num14 > 0)
				{
					num14--;
					Main.tile[num12, num13].type = 191;
					Main.tile[num12, num13].active(active: true);
					Main.tile[num12, num13].halfBrick(halfBrick: false);
					Main.tile[num12, num13].color(28);
					Main.tile[num12, num13].slope(0);
					if (genRand.Next(10) == 0)
					{
						num13 = ((genRand.Next(2) != 0) ? (num13 + 1) : (num13 - 1));
					}
					else
					{
						num12 += array3[l];
					}
					if (num15 > 0)
					{
						num15--;
					}
					else if (genRand.Next(2) == 0)
					{
						num15 = genRand.Next(2, 5);
						if (genRand.Next(2) == 0)
						{
							Main.tile[num12, num13].type = 191;
							Main.tile[num12, num13].active(active: true);
							Main.tile[num12, num13].halfBrick(halfBrick: false);
							Main.tile[num12, num13].color(28);
							Main.tile[num12, num13].slope(0);
							Main.tile[num12, num13 - 1].type = 191;
							Main.tile[num12, num13 - 1].active(active: true);
							Main.tile[num12, num13 - 1].halfBrick(halfBrick: false);
							Main.tile[num12, num13 - 1].color(28);
							array5[num2] = num12;
							array6[num2] = num13;
							num2++;
						}
						else
						{
							Main.tile[num12, num13].type = 191;
							Main.tile[num12, num13].active(active: true);
							Main.tile[num12, num13].halfBrick(halfBrick: false);
							Main.tile[num12, num13].color(28);
							Main.tile[num12, num13].slope(0);
							Main.tile[num12, num13 + 1].type = 191;
							Main.tile[num12, num13 + 1].active(active: true);
							Main.tile[num12, num13 + 1].halfBrick(halfBrick: false);
							Main.tile[num12, num13 + 1].color(28);
							array5[num2] = num12;
							array6[num2] = num13;
							num2++;
						}
					}
					if (num14 == 0)
					{
						array5[num2] = num12;
						array6[num2] = num13;
						num2++;
					}
				}
			}
			int num16 = (num3 + num4) / 2;
			int num17 = num10;
			int num18 = genRand.Next(num5 * 3, num5 * 5);
			int num19 = 0;
			int num20 = 0;
			while (num18 > 0)
			{
				Main.tile[num16, num17].type = 191;
				Main.tile[num16, num17].active(active: true);
				Main.tile[num16, num17].halfBrick(halfBrick: false);
				Main.tile[num16, num17].color(28);
				if (num19 > 0)
				{
					num19--;
				}
				if (num20 > 0)
				{
					num20--;
				}
				for (int m = -1; m < 2; m++)
				{
					if (m == 0 || ((m >= 0 || num19 != 0) && (m <= 0 || num20 != 0)) || genRand.Next(2) != 0)
					{
						continue;
					}
					int num21 = num16;
					int num22 = num17;
					int num23 = genRand.Next(num5, num5 * 3);
					if (m < 0)
					{
						num19 = genRand.Next(3, 5);
					}
					if (m > 0)
					{
						num20 = genRand.Next(3, 5);
					}
					int num24 = 0;
					while (num23 > 0)
					{
						num23--;
						num21 += m;
						Main.tile[num21, num22].type = 191;
						Main.tile[num21, num22].active(active: true);
						Main.tile[num21, num22].halfBrick(halfBrick: false);
						Main.tile[num21, num22].color(28);
						if (num23 == 0)
						{
							array5[num2] = num21;
							array6[num2] = num22;
							array7[num2] = true;
							num2++;
						}
						if (genRand.Next(5) == 0)
						{
							num22 = ((genRand.Next(2) != 0) ? (num22 + 1) : (num22 - 1));
							Main.tile[num21, num22].type = 191;
							Main.tile[num21, num22].active(active: true);
							Main.tile[num21, num22].halfBrick(halfBrick: false);
							Main.tile[num21, num22].color(28);
						}
						if (num24 > 0)
						{
							num24--;
						}
						else if (genRand.Next(3) == 0)
						{
							num24 = genRand.Next(2, 4);
							int num25 = num21;
							int num26 = num22;
							num26 = ((genRand.Next(2) != 0) ? (num26 + 1) : (num26 - 1));
							Main.tile[num25, num26].type = 191;
							Main.tile[num25, num26].active(active: true);
							Main.tile[num25, num26].halfBrick(halfBrick: false);
							Main.tile[num25, num26].color(28);
							array5[num2] = num25;
							array6[num2] = num26;
							array7[num2] = true;
							num2++;
							array5[num2] = num25 + genRand.Next(-5, 6);
							array6[num2] = num26 + genRand.Next(-5, 6);
							array7[num2] = true;
							num2++;
						}
					}
				}
				array5[num2] = num16;
				array6[num2] = num17;
				num2++;
				if (genRand.Next(4) == 0)
				{
					num16 = ((genRand.Next(2) != 0) ? (num16 + 1) : (num16 - 1));
					Main.tile[num16, num17].type = 191;
					Main.tile[num16, num17].active(active: true);
					Main.tile[num16, num17].halfBrick(halfBrick: false);
					Main.tile[num16, num17].color(28);
				}
				num17--;
				num18--;
			}
			for (int n = minl; n <= minr; n++)
			{
				int num27 = genRand.Next(1, 6);
				int num28 = j + 1;
				while (num27 > 0)
				{
					if (SolidTile(n, num28))
					{
						num27--;
					}
					Main.tile[n, num28].type = 191;
					Main.tile[n, num28].active(active: true);
					Main.tile[n, num28].halfBrick(halfBrick: false);
					Main.tile[n, num28].slope(0);
					num28++;
				}
				int num29 = num28;
				int num30 = genRand.Next(2, num5 + 1);
				for (int num31 = 0; num31 < num30; num31++)
				{
					num28 = num29;
					int num32 = (minl + minr) / 2;
					int num33 = 0;
					int num34 = 1;
					num33 = ((n >= num32) ? 1 : (-1));
					if (n == num32 || (num5 > 6 && (n == num32 - 1 || n == num32 + 1)))
					{
						num33 = 0;
					}
					int num35 = num33;
					int num36 = n;
					num27 = genRand.Next((int)((double)num5 * 3.5), num5 * 6);
					while (num27 > 0)
					{
						num27--;
						num36 += num33;
						if (Main.tile[num36, num28].wall != 244)
						{
							Main.tile[num36, num28].type = 191;
							Main.tile[num36, num28].active(active: true);
							Main.tile[num36, num28].halfBrick(halfBrick: false);
							Main.tile[num36, num28].slope(0);
						}
						num28 += num34;
						if (Main.tile[num36, num28].wall != 244)
						{
							Main.tile[num36, num28].type = 191;
							Main.tile[num36, num28].active(active: true);
							Main.tile[num36, num28].halfBrick(halfBrick: false);
							Main.tile[num36, num28].slope(0);
						}
						if (!Main.tile[num36, num28 + 1].active())
						{
							num33 = 0;
							num34 = 1;
						}
						if (genRand.Next(3) == 0)
						{
							num33 = ((num35 < 0) ? ((num33 == 0) ? (-1) : 0) : ((num35 <= 0) ? genRand.Next(-1, 2) : ((num33 == 0) ? 1 : 0)));
						}
						if (genRand.Next(3) == 0)
						{
							num34 = ((num34 == 0) ? 1 : 0);
						}
					}
				}
			}
			if (!remixWorldGen)
			{
				for (int num37 = 0; num37 < num2; num37++)
				{
					int num38 = genRand.Next(5, 8);
					num38 = (int)((double)num38 * (1.0 + (double)num5 * 0.05));
					if (array7[num37])
					{
						num38 = genRand.Next(6, 12) + num5;
					}
					int num39 = array5[num37] - num38 * 2;
					int num40 = array5[num37] + num38 * 2;
					int num41 = array6[num37] - num38 * 2;
					int num42 = array6[num37] + num38 * 2;
					double num43 = 2.0 - (double)genRand.Next(5) * 0.1;
					for (int num44 = num39; num44 <= num40; num44++)
					{
						for (int num45 = num41; num45 <= num42; num45++)
						{
							if (Main.tile[num44, num45].type == 191)
							{
								continue;
							}
							if (array7[num37])
							{
								Vector2D val = new Vector2D((double)array5[num37], (double)array6[num37]) - new Vector2D((double)num44, (double)num45);
								if (((Vector2D)(ref val)).Length() < (double)num38 * 0.9)
								{
									Main.tile[num44, num45].type = 192;
									Main.tile[num44, num45].active(active: true);
									Main.tile[num44, num45].halfBrick(halfBrick: false);
									Main.tile[num44, num45].color(28);
								}
							}
							else if ((double)Math.Abs(array5[num37] - num44) + (double)Math.Abs(array6[num37] - num45) * num43 < (double)num38)
							{
								Main.tile[num44, num45].type = 192;
								Main.tile[num44, num45].active(active: true);
								Main.tile[num44, num45].halfBrick(halfBrick: false);
								Main.tile[num44, num45].color(28);
							}
						}
					}
				}
			}
			GrowDungeonTree_MakePassage(j, num5, ref minl, ref minr, patch);
			Main.tileSolid[48] = true;
			return true;
		}

		private static bool GrowLivingTree_HorizontalTunnel(int i, int j)
		{
			int num = i;
			int num2 = i;
			int num3 = 80;
			bool flag = false;
			int num4 = 1;
			if (genRand.Next(2) == 0)
			{
				num4 *= -1;
			}
			for (int k = 0; k < 2; k++)
			{
				flag = false;
				if (num == i && num4 > 0)
				{
					for (int l = i + 5; l < i + num3; l++)
					{
						if (!InWorld(l, j, 10))
						{
							return false;
						}
						if ((double)j < Main.worldSurface)
						{
							for (int m = j - 7; m <= j + 7 && Main.tile[l, m].wall != 0; m++)
							{
							}
						}
						if (Main.tile[l, j].type == 48)
						{
							flag = true;
							break;
						}
						if (Main.tile[l, j].type == 191)
						{
							for (int n = j - 2; n <= j; n++)
							{
								if (Main.tile[l + 2, n].wall != 244)
								{
									flag = true;
								}
							}
							if (!flag)
							{
								k = 2;
								num2 = l + 2;
							}
							break;
						}
						if (Main.tile[l, j].active())
						{
							continue;
						}
						bool flag2 = true;
						for (int num5 = j - 2; num5 <= j; num5++)
						{
							if ((double)j < Main.worldSurface + 3.0 && (Main.tile[l + 1, num5].wall == 0 || Main.tile[l + 2, num5].wall == 0 || Main.tile[l + 3, num5].wall == 0))
							{
								return false;
							}
							if (Main.tile[l, num5].active() || Main.tile[l + 1, num5].active() || Main.tile[l + 2, num5].active())
							{
								flag2 = false;
							}
						}
						if (flag2)
						{
							k = 2;
							num2 = l;
							break;
						}
					}
				}
				flag = false;
				if (num2 == i && num4 < 0)
				{
					for (int num6 = i - 5; num6 > i - num3; num6--)
					{
						if (!InWorld(num6, j, 10))
						{
							return false;
						}
						if ((double)j < Main.worldSurface)
						{
							for (int num7 = j - 7; num7 <= j + 7 && Main.tile[num6, num7].wall != 0; num7++)
							{
							}
						}
						if (Main.tile[num6, j].type == 48)
						{
							flag = true;
							break;
						}
						if (Main.tile[num6, j].type == 191)
						{
							for (int num8 = j - 2; num8 <= j; num8++)
							{
								if (Main.tile[num6 - 3, num8].wall != 244)
								{
									flag = true;
								}
							}
							if (!flag)
							{
								k = 2;
								num = num6 - 2;
							}
							break;
						}
						if (!Main.tile[num6, j].active())
						{
							bool flag3 = true;
							for (int num9 = j - 2; num9 <= j; num9++)
							{
								if ((double)j < Main.worldSurface + 3.0 && (Main.tile[num6 - 1, num9].wall == 0 || Main.tile[num6 - 2, num9].wall == 0 || Main.tile[num6 - 3, num9].wall == 0))
								{
									return false;
								}
								if (Main.tile[num6, num9].active() || Main.tile[num6 - 1, num9].active() || Main.tile[num6 - 2, num9].active())
								{
									flag3 = false;
								}
							}
							if (flag3)
							{
								k = 2;
								num = num6;
								break;
							}
						}
					}
				}
				num4 *= -1;
			}
			if (num == num2)
			{
				return false;
			}
			bool flag4 = false;
			bool flag5 = false;
			for (int num10 = j - 5; num10 <= j + 1; num10++)
			{
				for (int num11 = num; num11 <= num2; num11++)
				{
					int num12 = 2;
					if (Math.Abs(num11 - num2) > 3 && Math.Abs(num11 - num) > 3)
					{
						num12 = 4;
					}
					if (Main.tile[num11, num10].wall != 244 && Main.tile[num11, num10].type != 19 && Main.tile[num11, num10].type != 15 && Main.tile[num11, num10].type != 304 && Main.tile[num11, num10].type != 21 && Main.tile[num11, num10].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[num11, num10].wall] && (!Main.tile[num11, num10].active() || (!Main.wallDungeon[Main.tile[num11, num10 - 1].wall] && !Main.wallDungeon[Main.tile[num11, num10 + 1].wall])))
						{
							Main.tile[num11, num10].active(active: true);
							Main.tile[num11, num10].type = 191;
							Main.tile[num11, num10].halfBrick(halfBrick: false);
						}
						if (Main.tile[num11, num10 - 1].type == 40)
						{
							Main.tile[num11, num10 - 1].type = 0;
						}
						if (Main.tile[num11, num10 + 1].type == 40)
						{
							Main.tile[num11, num10 + 1].type = 0;
						}
					}
					if (num10 >= j - num12 && num10 <= j && Main.tile[num11, num10].type != 19 && Main.tile[num11, num10].type != 15 && Main.tile[num11, num10].type != 304 && Main.tile[num11, num10].type != 21 && Main.tile[num11, num10].type != 10 && Main.tile[num11, num10 - 1].type != 15 && Main.tile[num11, num10 - 1].type != 304 && Main.tile[num11, num10 - 1].type != 21 && Main.tile[num11, num10 - 1].type != 10 && Main.tile[num11, num10 + 1].type != 10)
					{
						if (!Main.wallDungeon[Main.tile[num11, num10].wall])
						{
							Main.tile[num11, num10].wall = 244;
						}
						Main.tile[num11, num10].liquid = 0;
						Main.tile[num11, num10].active(active: false);
					}
					if (num10 != j)
					{
						continue;
					}
					int style = 7;
					if (Main.wallDungeon[Main.tile[num11, num10].wall] || Main.wallDungeon[Main.tile[num11, num10 - 1].wall] || Main.wallDungeon[Main.tile[num11, num10 - 2].wall])
					{
						style = 13;
					}
					if (num11 <= num + 4 && !flag4)
					{
						if (Main.tile[num11 - 1, num10].type == 10 || Main.tile[num11 + 1, num10].type == 10)
						{
							flag4 = true;
						}
						else if (genRand.Next(3) == 0)
						{
							PlaceTile(num11, num10, 10, mute: true, forced: false, -1, style);
							if (Main.tile[num11, num10].type == 10)
							{
								flag4 = true;
							}
						}
					}
					if (num11 < num2 - 4 || flag5)
					{
						continue;
					}
					if (Main.tile[num11 - 1, num10].type == 10 || Main.tile[num11 + 1, num10].type == 10)
					{
						flag5 = true;
					}
					else if (genRand.Next(3) == 0)
					{
						PlaceTile(num11, num10, 10, mute: true, forced: false, -1, style);
						if (Main.tile[num11, num10].type == 10)
						{
							flag5 = true;
						}
					}
				}
			}
			return true;
		}

		private static void GrowDungeonTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false)
		{
			int num = minl;
			int num2 = minr;
			_ = (minl + minr) / 2;
			int num3 = 5;
			int num4 = j - 6;
			int num5 = 0;
			bool flag = true;
			genRand.Next(5, 16);
			while (true)
			{
				num4++;
				if (num4 > GenVars.dungeonY - 5)
				{
					break;
				}
				int num6 = (minl + minr) / 2;
				int num7 = 1;
				if (num4 > j && W <= 4)
				{
					num7++;
				}
				for (int i = minl - num7; i <= minr + num7; i++)
				{
					if (i > num6 - 2 && i <= num6 + 1)
					{
						if (num4 > j - 4)
						{
							if (Main.tile[i, num4].type != 19 && Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i, num4 - 1].type != 15 && Main.tile[i, num4 - 1].type != 304 && Main.tile[i, num4 - 1].type != 21 && Main.tile[i, num4 - 1].type != 10 && Main.tile[i, num4 + 1].type != 10)
							{
								Main.tile[i, num4].active(active: false);
							}
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i - 1, num4].wall] && (Main.tile[i - 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i - 1, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i + 1, num4].wall] && (Main.tile[i + 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i + 1, num4].wall = 244;
							}
							if (num4 == j && i > num6 - 2 && i <= num6 + 1)
							{
								Main.tile[i, num4 + 1].active(active: false);
								PlaceTile(i, num4 + 1, 19, mute: true, forced: false, -1, 23);
							}
						}
					}
					else
					{
						if (Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i - 1, num4].type != 10 && Main.tile[i + 1, num4].type != 10)
						{
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].type = 191;
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
							}
							if (Main.tile[i - 1, num4].type == 40)
							{
								Main.tile[i - 1, num4].type = 0;
							}
							if (Main.tile[i + 1, num4].type == 40)
							{
								Main.tile[i + 1, num4].type = 0;
							}
						}
						if (num4 <= j && num4 > j - 4 && i > minl - num7 && i <= minr + num7 - 1)
						{
							Main.tile[i, num4].wall = 244;
						}
					}
					if (!gen)
					{
						SquareTileFrame(i, num4);
						SquareWallFrame(i, num4);
					}
				}
				num5++;
				if (num5 < 6)
				{
					continue;
				}
				num5 = 0;
				int num8 = genRand.Next(3);
				if (num8 == 0)
				{
					num8 = -1;
				}
				if (flag)
				{
					num8 = 2;
				}
				if (num8 == -1 && Main.tile[minl - num3, num4].wall == 244)
				{
					num8 = 1;
				}
				else if (num8 == 1 && Main.tile[minr + num3, num4].wall == 244)
				{
					num8 = -1;
				}
				if (num8 == 2)
				{
					flag = false;
					int num9 = 23;
					if (Main.wallDungeon[Main.tile[minl, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num4 + 1].wall])
					{
						num9 = 12;
					}
					if (!SolidTile(minl - 1, num4 + 1) && !SolidTile(minr + 1, num4 + 1) && num9 == 12)
					{
						continue;
					}
					for (int k = minl; k <= minr; k++)
					{
						if (k > num6 - 2 && k <= num6 + 1)
						{
							Main.tile[k, num4 + 1].active(active: false);
							Main.tile[k, num4 + 1].halfBrick(halfBrick: false);
							Main.tile[k, num4 + 1].slope(0);
							PlaceTile(k, num4 + 1, 19, mute: true, forced: false, -1, num9);
						}
					}
				}
				else
				{
					minl += num8;
					minr += num8;
				}
			}
			minl = num;
			minr = num2;
			_ = (minl + minr) / 2;
			for (int l = minl; l <= minr; l++)
			{
				for (int m = j - 3; m <= j; m++)
				{
					Main.tile[l, m].active(active: false);
					if (!Main.wallDungeon[Main.tile[l, m].wall])
					{
						Main.tile[l, m].wall = 244;
					}
				}
			}
		}

		private static void GrowLivingTree_MakePassage(int j, int W, ref int minl, ref int minr, bool noSecretRoom = false)
		{
			bool flag = noSecretRoom;
			int num = minl;
			int num2 = minr;
			bool flag2 = false;
			_ = (minl + minr) / 2;
			int num3 = 5;
			int num4 = j - 6;
			int num5 = 50;
			int num6 = genRand.Next(400, 700);
			int num7 = 0;
			bool flag3 = true;
			int num8 = genRand.Next(5, 16);
			while (num6 > 0)
			{
				num4++;
				num6--;
				num5--;
				int num9 = (minl + minr) / 2;
				if (!Main.tile[minl, num4].active() && Main.tile[minl, num4].wall == 244 && !Main.tile[minr, num4].active() && Main.tile[minr, num4].wall == 244)
				{
					num6 = 0;
					break;
				}
				int num10 = 1;
				if (num4 > j && W <= 4)
				{
					num10++;
				}
				for (int i = minl - num10; i <= minr + num10; i++)
				{
					if (Main.wallDungeon[Main.tile[i, num4].wall])
					{
						flag = true;
						flag2 = true;
					}
					if (i > num9 - 2 && i <= num9 + 1)
					{
						if (num4 > j - 4)
						{
							if (Main.tile[i, num4].type != 19 && Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i, num4 - 1].type != 15 && Main.tile[i, num4 - 1].type != 304 && Main.tile[i, num4 - 1].type != 21 && Main.tile[i, num4 - 1].type != 10 && Main.tile[i, num4 + 1].type != 10)
							{
								Main.tile[i, num4].active(active: false);
							}
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i - 1, num4].wall] && (Main.tile[i - 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i - 1, num4].wall = 244;
							}
							if (!Main.wallDungeon[Main.tile[i + 1, num4].wall] && (Main.tile[i + 1, num4].wall > 0 || (double)num4 >= Main.worldSurface))
							{
								Main.tile[i + 1, num4].wall = 244;
							}
							if (num4 == j && i > num9 - 2 && i <= num9 + 1)
							{
								Main.tile[i, num4 + 1].active(active: false);
								PlaceTile(i, num4 + 1, 19, mute: true, forced: false, -1, 23);
							}
						}
					}
					else
					{
						if (Main.tile[i, num4].type != 15 && Main.tile[i, num4].type != 304 && Main.tile[i, num4].type != 21 && Main.tile[i, num4].type != 10 && Main.tile[i - 1, num4].type != 10 && Main.tile[i + 1, num4].type != 10)
						{
							if (!Main.wallDungeon[Main.tile[i, num4].wall])
							{
								Main.tile[i, num4].type = 191;
								Main.tile[i, num4].active(active: true);
								Main.tile[i, num4].halfBrick(halfBrick: false);
							}
							if (Main.tile[i - 1, num4].type == 40)
							{
								Main.tile[i - 1, num4].type = 0;
							}
							if (Main.tile[i + 1, num4].type == 40)
							{
								Main.tile[i + 1, num4].type = 0;
							}
						}
						if (num4 <= j && num4 > j - 4 && i > minl - num10 && i <= minr + num10 - 1)
						{
							Main.tile[i, num4].wall = 244;
						}
					}
					if (!gen)
					{
						SquareTileFrame(i, num4);
						SquareWallFrame(i, num4);
					}
				}
				num7++;
				if (num7 >= 6)
				{
					num7 = 0;
					int num11 = genRand.Next(3);
					if (num11 == 0)
					{
						num11 = -1;
					}
					if (flag3)
					{
						num11 = 2;
					}
					if (num11 == -1 && Main.tile[minl - num3, num4].wall == 244)
					{
						num11 = 1;
					}
					else if (num11 == 1 && Main.tile[minr + num3, num4].wall == 244)
					{
						num11 = -1;
					}
					if (num11 == 2)
					{
						flag3 = false;
						int style = 23;
						if (Main.wallDungeon[Main.tile[minl, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 1, num4 + 1].wall] || Main.wallDungeon[Main.tile[minl + 2, num4 + 1].wall])
						{
							style = 12;
						}
						for (int k = minl; k <= minr; k++)
						{
							if (k > num9 - 2 && k <= num9 + 1)
							{
								Main.tile[k, num4 + 1].active(active: false);
								PlaceTile(k, num4 + 1, 19, mute: true, forced: false, -1, style);
							}
						}
					}
					else
					{
						minl += num11;
						minr += num11;
					}
					if (noSecretRoom)
					{
						num8--;
						if (num8 <= 0)
						{
							num8 = ((!GrowLivingTree_HorizontalTunnel(num9, num4)) ? genRand.Next(2, 11) : genRand.Next(5, 21));
						}
					}
					if (num5 <= 0 && !flag)
					{
						flag = true;
						GrowLivingTreePassageRoom(minl, minr, num4);
					}
				}
				if (flag2)
				{
					bool flag4 = true;
					for (int l = minl; l <= minr; l++)
					{
						for (int m = num4 + 1; m <= num4 + 2; m++)
						{
							if (SolidTile(l, m))
							{
								flag4 = false;
							}
						}
					}
					if (flag4)
					{
						num6 = 0;
					}
				}
				else
				{
					if (num5 > 0)
					{
						continue;
					}
					bool flag5 = true;
					for (int n = minl; n <= minr; n++)
					{
						for (int num12 = num4 + 1; num12 <= num4 + 4; num12++)
						{
							if (SolidTile(n, num12))
							{
								flag5 = false;
							}
						}
					}
					if (flag5)
					{
						num6 = 0;
					}
				}
			}
			minl = num;
			minr = num2;
			_ = (minl + minr) / 2;
			for (int num13 = minl; num13 <= minr; num13++)
			{
				for (int num14 = j - 3; num14 <= j; num14++)
				{
					Main.tile[num13, num14].active(active: false);
					bool flag6 = true;
					for (int num15 = num13 - 1; num15 <= num13 + 1; num15++)
					{
						for (int num16 = num14 - 1; num16 <= num14 + 1; num16++)
						{
							if (!Main.tile[num15, num16].active() && Main.tile[num15, num16].wall == 0)
							{
								flag6 = false;
							}
						}
					}
					if (flag6 && !Main.wallDungeon[Main.tile[num13, num14].wall])
					{
						Main.tile[num13, num14].wall = 244;
					}
				}
			}
		}

		private static void GrowLivingTreePassageRoom(int minl, int minr, int Y)
		{
			int num = genRand.Next(2);
			if (num == 0)
			{
				num = -1;
			}
			int num2 = Y - 2;
			int num3 = (minl + minr) / 2;
			if (num < 0)
			{
				num3--;
			}
			if (num > 0)
			{
				num3++;
			}
			int num4 = genRand.Next(15, 30);
			int num5 = num3 + num4;
			if (num < 0)
			{
				num5 = num3;
				num3 -= num4;
			}
			for (int i = num3; i < num5; i++)
			{
				for (int j = Y - 20; j < Y + 10; j++)
				{
					if (Main.tile[i, j].wall == 0 && !Main.tile[i, j].active() && (double)j < Main.worldSurface)
					{
						return;
					}
				}
			}
			GenVars.dMinX = num3;
			GenVars.dMaxX = num5;
			if (num < 0)
			{
				GenVars.dMinX -= 40;
			}
			else
			{
				GenVars.dMaxX += 40;
			}
			for (int k = num3; k <= num5; k++)
			{
				for (int l = num2 - 2; l <= Y + 2; l++)
				{
					if (Main.tile[k - 1, l].type == 40)
					{
						Main.tile[k - 1, l].type = 0;
					}
					if (Main.tile[k + 1, l].type == 40)
					{
						Main.tile[k + 1, l].type = 0;
					}
					if (Main.tile[k, l - 1].type == 40)
					{
						Main.tile[k, l - 1].type = 0;
					}
					if (Main.tile[k, l + 1].type == 40)
					{
						Main.tile[k, l + 1].type = 0;
					}
					if (Main.tile[k, l].wall != 244 && Main.tile[k, l].type != 19)
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = 191;
						Main.tile[k, l].halfBrick(halfBrick: false);
					}
					if (l >= num2 && l <= Y)
					{
						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].wall = 244;
						Main.tile[k, l].active(active: false);
					}
				}
			}
			int i2 = (minl + minr) / 2 + 3 * num;
			PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
			int num6 = genRand.Next(5, 9);
			int num7 = genRand.Next(4, 6);
			if (num < 0)
			{
				num5 = num3 + num6;
				num3 -= num6;
			}
			else
			{
				num3 = num5 - num6;
				num5 += num6;
			}
			num2 = Y - num7;
			for (int m = num3 - 2; m <= num5 + 2; m++)
			{
				for (int n = num2 - 2; n <= Y + 2; n++)
				{
					if (Main.tile[m - 1, n].type == 40)
					{
						Main.tile[m - 1, n].type = 40;
					}
					if (Main.tile[m + 1, n].type == 40)
					{
						Main.tile[m + 1, n].type = 40;
					}
					if (Main.tile[m, n - 1].type == 40)
					{
						Main.tile[m, n - 1].type = 40;
					}
					if (Main.tile[m, n + 1].type == 40)
					{
						Main.tile[m, n + 1].type = 40;
					}
					if (Main.tile[m, n].wall != 244 && Main.tile[m, n].type != 19)
					{
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = 191;
						Main.tile[m, n].halfBrick(halfBrick: false);
					}
					if (n >= num2 && n <= Y && m >= num3 && m <= num5)
					{
						Main.tile[m, n].liquid = 0;
						Main.tile[m, n].wall = 244;
						Main.tile[m, n].active(active: false);
					}
				}
			}
			i2 = num3 - 2;
			if (num < 0)
			{
				i2 = num5 + 2;
			}
			PlaceTile(i2, Y, 10, mute: true, forced: false, -1, 7);
			int num8 = num5;
			if (num < 0)
			{
				num8 = num3;
			}
			int num9 = 2;
			if (genRand.Next(num9) == 0)
			{
				num9 += 2;
				PlaceTile(num8, Y, 15, mute: true, forced: false, -1, 5);
				if (num < 0)
				{
					Main.tile[num8, Y - 1].frameX += 18;
					Main.tile[num8, Y].frameX += 18;
				}
			}
			num8 = num5 - 2;
			if (num < 0)
			{
				num8 = num3 + 2;
			}
			PlaceTile(num8, Y, 304, mute: true);
			num8 = num5 - 4;
			if (num < 0)
			{
				num8 = num3 + 4;
			}
			if (genRand.Next(num9) == 0)
			{
				PlaceTile(num8, Y, 15, mute: true, forced: false, -1, 5);
				if (num > 0)
				{
					Main.tile[num8, Y - 1].frameX += 18;
					Main.tile[num8, Y].frameX += 18;
				}
			}
			num8 = num5 - 7;
			if (num < 0)
			{
				num8 = num3 + 8;
			}
			int contain = 832;
			if (genRand.Next(3) == 0)
			{
				contain = 4281;
			}
			if (remixWorldGen)
			{
				int num10 = genRand.Next(1, 3);
				for (int num11 = 0; num11 < num10; num11++)
				{
					bool flag = false;
					while (!flag)
					{
						int num12 = genRand.Next(Main.maxTilesX / 8, Main.maxTilesX - Main.maxTilesX / 8);
						int num13 = genRand.Next((int)Main.rockLayer, Main.maxTilesY - 350);
						if (!IsTileNearby(num12, num13, 53, 20) && !IsTileNearby(num12, num13, 147, 20) && !IsTileNearby(num12, num13, 59, 20))
						{
							flag = AddBuriedChest(num12, num13, contain, notNearOtherChests: false, 12, trySlope: false, 0);
						}
					}
				}
				if (crimson)
				{
					AddBuriedChest(num8, Y, 0, notNearOtherChests: false, 14, trySlope: false, 0);
				}
				else
				{
					AddBuriedChest(num8, Y, 0, notNearOtherChests: false, 7, trySlope: false, 0);
				}
			}
			else
			{
				AddBuriedChest(num8, Y, contain, notNearOtherChests: false, 12, trySlope: false, 0);
			}
		}

		public static void TreeGrowFXCheck(int x, int y)
		{
			int treeHeight = 1;
			int passStyle = -1;
			Tile topTile = null;
			for (int num = -1; num > -100; num--)
			{
				Tile tile = Main.tile[x, y + num];
				if (!tile.active() || !TileID.Sets.GetsCheckedForLeaves[tile.type])
				{
					break;
				}
				topTile = tile;
				treeHeight++;
			}
			for (int i = 1; i < 5; i++)
			{
				Tile tile2 = Main.tile[x, y + i];
				if (tile2.active() && TileID.Sets.GetsCheckedForLeaves[tile2.type])
				{
					treeHeight++;
					continue;
				}
				GetTreeLeaf(x, topTile, tile2, ref treeHeight, out var _, out passStyle);
				break;
			}
			if (treeHeight > 0 && passStyle > 0)
			{
				if (Main.netMode == 2)
				{
					NetMessage.SendData(112, -1, -1, null, 1, x, y, treeHeight, passStyle);
				}
				if (Main.netMode == 0)
				{
					TreeGrowFX(x, y, treeHeight, passStyle);
				}
			}
		}

		public static void GetTreeLeaf(int x, Tile topTile, Tile t, ref int treeHeight, out int treeFrame, out int passStyle)
		{
			treeFrame = 0;
			passStyle = -1;
			if (topTile.frameX == 22 || topTile.frameX == 44 || topTile.frameX == 66)
			{
				if (topTile.frameY == 220)
				{
					treeFrame = 1;
				}
				else if (topTile.frameY == 242)
				{
					treeFrame = 2;
				}
			}
			if (topTile.frameX == 44 || topTile.frameX == 66)
			{
				if (topTile.frameY == 220)
				{
					treeFrame = 1;
				}
				else if (topTile.frameY == 242)
				{
					treeFrame = 2;
				}
			}
			switch (topTile.type)
			{
			case 596:
				passStyle = 1248;
				break;
			case 616:
				passStyle = 1257;
				break;
			case 634:
				passStyle = 1278;
				break;
			case 583:
			case 584:
			case 585:
			case 586:
			case 587:
			case 588:
			case 589:
				passStyle = 1249 + (topTile.type - 583);
				break;
			}
			if (passStyle > -1)
			{
				return;
			}
			switch (t.type)
			{
			case 2:
			case 477:
				passStyle = 910;
				break;
			case 60:
				passStyle = 914;
				break;
			case 70:
				passStyle = 912;
				break;
			case 23:
			case 112:
				passStyle = 915;
				break;
			case 199:
			case 234:
				passStyle = 916;
				break;
			case 53:
				passStyle = 911;
				break;
			case 116:
				passStyle = 919;
				break;
			case 147:
				passStyle = 913;
				break;
			case 633:
				passStyle = 1278;
				break;
			case 109:
			case 492:
			{
				int num = 917;
				int hollowTreeFoliageStyle = GetHollowTreeFoliageStyle();
				if (hollowTreeFoliageStyle != 20)
				{
					if (x % 3 == 1)
					{
						treeFrame += 3;
					}
					if (x % 3 == 2)
					{
						treeFrame += 6;
					}
					switch (treeFrame)
					{
					case 0:
						passStyle = 2;
						break;
					case 1:
						passStyle = 1;
						break;
					case 2:
						passStyle = 7;
						break;
					case 3:
						passStyle = 4;
						break;
					case 4:
						passStyle = 5;
						break;
					case 5:
						passStyle = 6;
						break;
					case 6:
						passStyle = 3;
						break;
					case 7:
						passStyle = 8;
						break;
					case 8:
						passStyle = 0;
						break;
					}
				}
				else
				{
					int num2 = 196;
					if (x % 6 == 1)
					{
						treeFrame += 3;
					}
					else if (x % 6 == 2)
					{
						treeFrame += 6;
					}
					else if (x % 6 == 3)
					{
						treeFrame += 9;
					}
					else if (x % 6 == 4)
					{
						treeFrame += 12;
					}
					else if (x % 6 == 5)
					{
						treeFrame += 15;
					}
					switch (treeFrame)
					{
					case 0:
						passStyle = num2;
						break;
					case 1:
						passStyle = num2;
						break;
					case 2:
						passStyle = num2;
						break;
					case 3:
						passStyle = num2 + 1;
						break;
					case 4:
						passStyle = num2 + 2;
						break;
					case 5:
						passStyle = num2 + 1;
						break;
					case 6:
						passStyle = num2 + 3;
						break;
					case 7:
						passStyle = num2 + 4;
						break;
					case 8:
						passStyle = num2 + 5;
						break;
					case 9:
						passStyle = num2 + 6;
						break;
					case 10:
						passStyle = num2 + 6;
						break;
					case 11:
						passStyle = num2 + 6;
						break;
					case 12:
						passStyle = num2 + 7;
						break;
					case 13:
						passStyle = num2 + 7;
						break;
					case 14:
						passStyle = num2 + 7;
						break;
					case 15:
						passStyle = num2 + 8;
						break;
					case 16:
						passStyle = num2 + 8;
						break;
					case 17:
						passStyle = num2 + 8;
						break;
					}
				}
				passStyle += num;
				treeHeight += 5;
				break;
			}
			}
		}

		public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
		{
			Vector2 vector = new Vector2(x, y) * 16f + new Vector2(8f, 8f);
			if (treeGore == 1278)
			{
				TreeGrowFX_AshShake(x, y, height, hitTree);
				return;
			}
			for (int num = 0; num > -height; num--)
			{
				float num2 = 10f;
				Vector2 vector2 = new Vector2(5f, 7f);
				Gore.NewGore(vector + new Vector2(-16f, num * 16) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
				Gore.NewGore(vector + new Vector2(0f, num * 16) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
				Gore.NewGore(vector + new Vector2(16f, num * 16) - vector2, Utils.RandomVector2(Main.rand, 0f - num2, num2), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
				if (num == -height + 1)
				{
					int num3 = 20;
					if (hitTree)
					{
						num3 = 5;
					}
					for (int i = 0; i < num3; i++)
					{
						Gore.NewGore(vector + new Vector2(0f, num * 16 - 40) + Utils.RandomVector2(Main.rand, -40f, 40f) - vector2, Utils.RandomVector2(Main.rand, -10f, 10f), treeGore, 0.7f + Main.rand.NextFloat() * 0.6f);
					}
				}
			}
		}

		private static void TreeGrowFX_AshShake(int x, int y, int height, bool hitTree = false)
		{
			Vector2 vector = new Vector2(x, y) * 16f + new Vector2(8f, 8f);
			for (int num = 0; num > -height; num--)
			{
				if (num >= -height / 2 && Main.rand.Next(3) != 0)
				{
					int num2 = (hitTree ? 10 : 5);
					for (int i = 0; i < num2; i++)
					{
						Dust.NewDustDirect(vector + new Vector2(-16f, num * 16) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 31, 0f, -3f, 100).velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0f, -0.6f);
					}
				}
				if ((float)num >= (float)(-height) * 0.7f && Main.rand.Next(3) != 0)
				{
					int num3 = (hitTree ? 16 : 10);
					for (int j = 0; j < num3; j++)
					{
						Dust dust = Dust.NewDustDirect(vector + new Vector2(-16f, num * 16) + Utils.RandomVector2(Main.rand, -30f, 30f), 4, 4, 6, 0f, -4f, 0, default(Color), 1f + 0.7f * Main.rand.NextFloat());
						dust.velocity = Main.rand.NextVector2Circular(2f, 2f) + new Vector2(0f, -0.6f);
						if (Main.rand.Next(2) == 0)
						{
							dust.velocity *= 2f;
							dust.noGravity = true;
						}
						dust.velocity += new Vector2(0f, hitTree ? (-1f) : (-2f));
					}
				}
				if (!hitTree)
				{
					Gore.NewGoreDirect(vector + new Vector2(-16f, num * 16 - 40) + Utils.RandomVector2(Main.rand, -40f, 40f) * new Vector2(0.5f, 1f), Vector2.Zero, 61 + Main.rand.Next(3)).velocity *= 0.5f;
				}
			}
		}

		public static bool IsTileALeafyTreeTop(int i, int j)
		{
			Tile tileSafely = Framing.GetTileSafely(i, j);
			if (tileSafely.active() && TileID.Sets.GetsCheckedForLeaves[tileSafely.type])
			{
				if (tileSafely.type == 323 && tileSafely.frameX >= 88)
				{
					return true;
				}
				if (tileSafely.frameX == 22 && tileSafely.frameY >= 198 && tileSafely.frameY <= 242)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsTileTypeFitForTree(ushort type)
		{
			switch (type)
			{
			case 2:
			case 23:
			case 60:
			case 70:
			case 109:
			case 147:
			case 199:
			case 477:
			case 492:
			case 633:
			case 661:
			case 662:
				return true;
			default:
				return false;
			}
		}

		public static bool GrowTree(int i, int y)
		{
			int j;
			for (j = y; Main.tile[i, j].type == 20; j++)
			{
			}
			if ((Main.tile[i - 1, j - 1].liquid != 0 || Main.tile[i, j - 1].liquid != 0 || Main.tile[i + 1, j - 1].liquid != 0) && !notTheBees)
			{
				return false;
			}
			if (Main.tile[i, j].nactive() && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i, j].type) && ((Main.remixWorld && (double)j > Main.worldSurface) || Main.tile[i, j - 1].wall == 0 || DefaultTreeWallTest(Main.tile[i, j - 1].wall)) && ((Main.tile[i - 1, j].active() && IsTileTypeFitForTree(Main.tile[i - 1, j].type)) || (Main.tile[i + 1, j].active() && IsTileTypeFitForTree(Main.tile[i + 1, j].type))))
			{
				TileColorCache cache = Main.tile[i, j].BlockColorAndCoating();
				if (Main.tenthAnniversaryWorld && !gen)
				{
					cache.Color = (byte)genRand.Next(1, 13);
				}
				int num = 2;
				int num2 = genRand.Next(5, 17);
				int num3 = num2 + 4;
				if (Main.tile[i, j].type == 60)
				{
					num3 += 5;
				}
				bool flag = false;
				if (Main.tile[i, j].type == 70 && EmptyTileCheck(i - num, i + num, j - num3, j - 3, 20) && EmptyTileCheck(i - 1, i + 1, j - 2, j - 1, 20))
				{
					flag = true;
				}
				if (EmptyTileCheck(i - num, i + num, j - num3, j - 1, 20))
				{
					flag = true;
				}
				if (flag)
				{
					bool flag2 = Main.remixWorld && (double)j < Main.worldSurface;
					bool flag3 = false;
					bool flag4 = false;
					int num4;
					for (int k = j - num2; k < j; k++)
					{
						Main.tile[i, k].frameNumber((byte)genRand.Next(3));
						Main.tile[i, k].active(active: true);
						Main.tile[i, k].type = 5;
						Main.tile[i, k].UseBlockColors(cache);
						num4 = genRand.Next(3);
						int num5 = genRand.Next(10);
						if (k == j - 1 || k == j - num2)
						{
							num5 = 0;
						}
						while (((num5 == 5 || num5 == 7) && flag3) || ((num5 == 6 || num5 == 7) && flag4))
						{
							num5 = genRand.Next(10);
						}
						flag3 = false;
						flag4 = false;
						if (num5 == 5 || num5 == 7)
						{
							flag3 = true;
						}
						if (num5 == 6 || num5 == 7)
						{
							flag4 = true;
						}
						switch (num5)
						{
						case 1:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 2:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 3:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 44;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 4:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 22;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 5:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 88;
								Main.tile[i, k].frameY = 44;
							}
							break;
						case 6:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 66;
								Main.tile[i, k].frameY = 110;
							}
							break;
						case 7:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 110;
								Main.tile[i, k].frameY = 110;
							}
							break;
						default:
							if (num4 == 0)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 0;
							}
							if (num4 == 1)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 22;
							}
							if (num4 == 2)
							{
								Main.tile[i, k].frameX = 0;
								Main.tile[i, k].frameY = 44;
							}
							break;
						}
						if (num5 == 5 || num5 == 7)
						{
							Main.tile[i - 1, k].active(active: true);
							Main.tile[i - 1, k].type = 5;
							Main.tile[i - 1, k].UseBlockColors(cache);
							num4 = genRand.Next(3);
							if (genRand.Next(3) < 2 && !flag2)
							{
								if (num4 == 0)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 198;
								}
								if (num4 == 1)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 220;
								}
								if (num4 == 2)
								{
									Main.tile[i - 1, k].frameX = 44;
									Main.tile[i - 1, k].frameY = 242;
								}
							}
							else
							{
								if (num4 == 0)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 0;
								}
								if (num4 == 1)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 22;
								}
								if (num4 == 2)
								{
									Main.tile[i - 1, k].frameX = 66;
									Main.tile[i - 1, k].frameY = 44;
								}
							}
						}
						if (num5 != 6 && num5 != 7)
						{
							continue;
						}
						Main.tile[i + 1, k].active(active: true);
						Main.tile[i + 1, k].type = 5;
						Main.tile[i + 1, k].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (genRand.Next(3) < 2 && !flag2)
						{
							if (num4 == 0)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 198;
							}
							if (num4 == 1)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 220;
							}
							if (num4 == 2)
							{
								Main.tile[i + 1, k].frameX = 66;
								Main.tile[i + 1, k].frameY = 242;
							}
						}
						else
						{
							if (num4 == 0)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 66;
							}
							if (num4 == 1)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 88;
							}
							if (num4 == 2)
							{
								Main.tile[i + 1, k].frameX = 88;
								Main.tile[i + 1, k].frameY = 110;
							}
						}
					}
					int num6 = genRand.Next(3);
					bool flag5 = false;
					bool flag6 = false;
					if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && Main.tile[i - 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i - 1, j].type))
					{
						flag5 = true;
					}
					if (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && Main.tile[i + 1, j].slope() == 0 && IsTileTypeFitForTree(Main.tile[i + 1, j].type))
					{
						flag6 = true;
					}
					if (!flag5)
					{
						if (num6 == 0)
						{
							num6 = 2;
						}
						if (num6 == 1)
						{
							num6 = 3;
						}
					}
					if (!flag6)
					{
						if (num6 == 0)
						{
							num6 = 1;
						}
						if (num6 == 2)
						{
							num6 = 3;
						}
					}
					if (flag5 && !flag6)
					{
						num6 = 2;
					}
					if (flag6 && !flag5)
					{
						num6 = 1;
					}
					if (num6 == 0 || num6 == 1)
					{
						Main.tile[i + 1, j - 1].active(active: true);
						Main.tile[i + 1, j - 1].type = 5;
						Main.tile[i + 1, j - 1].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i + 1, j - 1].frameX = 22;
							Main.tile[i + 1, j - 1].frameY = 176;
						}
					}
					if (num6 == 0 || num6 == 2)
					{
						Main.tile[i - 1, j - 1].active(active: true);
						Main.tile[i - 1, j - 1].type = 5;
						Main.tile[i - 1, j - 1].UseBlockColors(cache);
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j - 1].frameX = 44;
							Main.tile[i - 1, j - 1].frameY = 176;
						}
					}
					num4 = genRand.Next(3);
					switch (num6)
					{
					case 0:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 88;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 1:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 0;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					case 2:
						if (num4 == 0)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 132;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 154;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - 1].frameX = 66;
							Main.tile[i, j - 1].frameY = 176;
						}
						break;
					}
					if (genRand.Next(13) != 0 && !flag2)
					{
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - num2].frameX = 22;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					else
					{
						num4 = genRand.Next(3);
						if (num4 == 0)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i, j - num2].frameX = 0;
							Main.tile[i, j - num2].frameY = 242;
						}
					}
					RangeFrame(i - 2, j - num2 - 1, i + 2, j + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i - 1, j - num2, 3, num2);
					}
					return true;
				}
			}
			return false;
		}

		public static bool DefaultTreeWallTest(int wallType)
		{
			if (wallType >= 0 && wallType < 347 && WallID.Sets.AllowsPlantsToGrow[wallType])
			{
				return true;
			}
			return false;
		}

		public static bool GemTreeWallTest(int wallType)
		{
			if (DefaultTreeWallTest(wallType))
			{
				return true;
			}
			switch (wallType)
			{
			case 2:
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 59:
			case 61:
			case 185:
			case 196:
			case 197:
			case 198:
			case 199:
			case 208:
			case 209:
			case 210:
			case 211:
			case 212:
			case 213:
			case 214:
			case 215:
				return true;
			default:
				return false;
			}
		}

		public static bool GemTreeGroundTest(int tileType)
		{
			if (tileType < 0)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Stone[tileType] || TileID.Sets.Conversion.Moss[tileType])
			{
				return true;
			}
			return false;
		}

		public static bool VanityTreeGroundTest(int tileType)
		{
			if (tileType < 0)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Grass[tileType])
			{
				return true;
			}
			return false;
		}

		public static bool AshTreeGroundTest(int tileType)
		{
			if (tileType < 0)
			{
				return false;
			}
			if (tileType == 633)
			{
				return true;
			}
			return false;
		}

		public static bool TryGrowingTreeByType(int treeTileType, int checkedX, int checkedY)
		{
			bool result = false;
			switch (treeTileType)
			{
			case 5:
				result = GrowTree(checkedX, checkedY);
				break;
			case 587:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Ruby);
				break;
			case 588:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Diamond);
				break;
			case 583:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Topaz);
				break;
			case 584:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amethyst);
				break;
			case 589:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Amber);
				break;
			case 586:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Emerald);
				break;
			case 585:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.GemTree_Sappphire);
				break;
			case 596:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Sakura);
				break;
			case 616:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.VanityTree_Willow);
				break;
			case 634:
				result = GrowTreeWithSettings(checkedX, checkedY, GrowTreeSettings.Profiles.Tree_Ash);
				break;
			}
			return result;
		}

		public static bool GrowTreeWithSettings(int checkedX, int checkedY, GrowTreeSettings settings)
		{
			int i;
			for (i = checkedY; Main.tile[checkedX, i].type == settings.SaplingTileType; i++)
			{
			}
			if (Main.tile[checkedX - 1, i - 1].liquid != 0 || Main.tile[checkedX, i - 1].liquid != 0 || Main.tile[checkedX + 1, i - 1].liquid != 0)
			{
				return false;
			}
			Tile tile = Main.tile[checkedX, i];
			if (!tile.nactive() || tile.halfBrick() || tile.slope() != 0)
			{
				return false;
			}
			bool flag = settings.WallTest(Main.tile[checkedX, i - 1].wall);
			if (!settings.GroundTest(tile.type) || !flag)
			{
				return false;
			}
			if ((!Main.tile[checkedX - 1, i].active() || !settings.GroundTest(Main.tile[checkedX - 1, i].type)) && (!Main.tile[checkedX + 1, i].active() || !settings.GroundTest(Main.tile[checkedX + 1, i].type)))
			{
				return false;
			}
			TileColorCache cache = Main.tile[checkedX, i].BlockColorAndCoating();
			if (Main.tenthAnniversaryWorld && !gen && (settings.TreeTileType == 596 || settings.TreeTileType == 616))
			{
				cache.Color = (byte)genRand.Next(1, 13);
			}
			int num = 2;
			int num2 = genRand.Next(settings.TreeHeightMin, settings.TreeHeightMax + 1);
			int num3 = num2 + settings.TreeTopPaddingNeeded;
			if (!EmptyTileCheck(checkedX - num, checkedX + num, i - num3, i - 1, 20))
			{
				return false;
			}
			bool flag2 = false;
			bool flag3 = false;
			int num4;
			for (int j = i - num2; j < i; j++)
			{
				Tile tile2 = Main.tile[checkedX, j];
				tile2.frameNumber((byte)genRand.Next(3));
				tile2.active(active: true);
				tile2.type = settings.TreeTileType;
				tile2.UseBlockColors(cache);
				num4 = genRand.Next(3);
				int num5 = genRand.Next(10);
				if (j == i - 1 || j == i - num2)
				{
					num5 = 0;
				}
				while (((num5 == 5 || num5 == 7) && flag2) || ((num5 == 6 || num5 == 7) && flag3))
				{
					num5 = genRand.Next(10);
				}
				flag2 = false;
				flag3 = false;
				if (num5 == 5 || num5 == 7)
				{
					flag2 = true;
				}
				if (num5 == 6 || num5 == 7)
				{
					flag3 = true;
				}
				switch (num5)
				{
				case 1:
					if (num4 == 0)
					{
						tile2.frameX = 0;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 0;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 0;
						tile2.frameY = 110;
					}
					break;
				case 2:
					if (num4 == 0)
					{
						tile2.frameX = 22;
						tile2.frameY = 0;
					}
					if (num4 == 1)
					{
						tile2.frameX = 22;
						tile2.frameY = 22;
					}
					if (num4 == 2)
					{
						tile2.frameX = 22;
						tile2.frameY = 44;
					}
					break;
				case 3:
					if (num4 == 0)
					{
						tile2.frameX = 44;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 44;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 44;
						tile2.frameY = 110;
					}
					break;
				case 4:
					if (num4 == 0)
					{
						tile2.frameX = 22;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 22;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 22;
						tile2.frameY = 110;
					}
					break;
				case 5:
					if (num4 == 0)
					{
						tile2.frameX = 88;
						tile2.frameY = 0;
					}
					if (num4 == 1)
					{
						tile2.frameX = 88;
						tile2.frameY = 22;
					}
					if (num4 == 2)
					{
						tile2.frameX = 88;
						tile2.frameY = 44;
					}
					break;
				case 6:
					if (num4 == 0)
					{
						tile2.frameX = 66;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 66;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 66;
						tile2.frameY = 110;
					}
					break;
				case 7:
					if (num4 == 0)
					{
						tile2.frameX = 110;
						tile2.frameY = 66;
					}
					if (num4 == 1)
					{
						tile2.frameX = 110;
						tile2.frameY = 88;
					}
					if (num4 == 2)
					{
						tile2.frameX = 110;
						tile2.frameY = 110;
					}
					break;
				default:
					if (num4 == 0)
					{
						tile2.frameX = 0;
						tile2.frameY = 0;
					}
					if (num4 == 1)
					{
						tile2.frameX = 0;
						tile2.frameY = 22;
					}
					if (num4 == 2)
					{
						tile2.frameX = 0;
						tile2.frameY = 44;
					}
					break;
				}
				if (num5 == 5 || num5 == 7)
				{
					Tile tile3 = Main.tile[checkedX - 1, j];
					tile3.active(active: true);
					tile3.type = settings.TreeTileType;
					tile3.UseBlockColors(cache);
					num4 = genRand.Next(3);
					if (genRand.Next(3) < 2)
					{
						if (num4 == 0)
						{
							tile3.frameX = 44;
							tile3.frameY = 198;
						}
						if (num4 == 1)
						{
							tile3.frameX = 44;
							tile3.frameY = 220;
						}
						if (num4 == 2)
						{
							tile3.frameX = 44;
							tile3.frameY = 242;
						}
					}
					else
					{
						if (num4 == 0)
						{
							tile3.frameX = 66;
							tile3.frameY = 0;
						}
						if (num4 == 1)
						{
							tile3.frameX = 66;
							tile3.frameY = 22;
						}
						if (num4 == 2)
						{
							tile3.frameX = 66;
							tile3.frameY = 44;
						}
					}
				}
				if (num5 != 6 && num5 != 7)
				{
					continue;
				}
				Tile tile4 = Main.tile[checkedX + 1, j];
				tile4.active(active: true);
				tile4.type = settings.TreeTileType;
				tile4.UseBlockColors(cache);
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						tile4.frameX = 66;
						tile4.frameY = 198;
					}
					if (num4 == 1)
					{
						tile4.frameX = 66;
						tile4.frameY = 220;
					}
					if (num4 == 2)
					{
						tile4.frameX = 66;
						tile4.frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						tile4.frameX = 88;
						tile4.frameY = 66;
					}
					if (num4 == 1)
					{
						tile4.frameX = 88;
						tile4.frameY = 88;
					}
					if (num4 == 2)
					{
						tile4.frameX = 88;
						tile4.frameY = 110;
					}
				}
			}
			bool flag4 = false;
			bool flag5 = false;
			if (Main.tile[checkedX - 1, i].nactive() && !Main.tile[checkedX - 1, i].halfBrick() && Main.tile[checkedX - 1, i].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX - 1, i].type))
			{
				flag4 = true;
			}
			if (Main.tile[checkedX + 1, i].nactive() && !Main.tile[checkedX + 1, i].halfBrick() && Main.tile[checkedX + 1, i].slope() == 0 && IsTileTypeFitForTree(Main.tile[checkedX + 1, i].type))
			{
				flag5 = true;
			}
			if (genRand.Next(3) == 0)
			{
				flag4 = false;
			}
			if (genRand.Next(3) == 0)
			{
				flag5 = false;
			}
			if (flag5)
			{
				Main.tile[checkedX + 1, i - 1].active(active: true);
				Main.tile[checkedX + 1, i - 1].type = settings.TreeTileType;
				Main.tile[checkedX + 1, i - 1].UseBlockColors(cache);
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX + 1, i - 1].frameX = 22;
					Main.tile[checkedX + 1, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX + 1, i - 1].frameX = 22;
					Main.tile[checkedX + 1, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX + 1, i - 1].frameX = 22;
					Main.tile[checkedX + 1, i - 1].frameY = 176;
				}
			}
			if (flag4)
			{
				Main.tile[checkedX - 1, i - 1].active(active: true);
				Main.tile[checkedX - 1, i - 1].type = settings.TreeTileType;
				Main.tile[checkedX - 1, i - 1].UseBlockColors(cache);
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX - 1, i - 1].frameX = 44;
					Main.tile[checkedX - 1, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX - 1, i - 1].frameX = 44;
					Main.tile[checkedX - 1, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX - 1, i - 1].frameX = 44;
					Main.tile[checkedX - 1, i - 1].frameY = 176;
				}
			}
			num4 = genRand.Next(3);
			if (flag4 && flag5)
			{
				if (num4 == 0)
				{
					Main.tile[checkedX, i - 1].frameX = 88;
					Main.tile[checkedX, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - 1].frameX = 88;
					Main.tile[checkedX, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - 1].frameX = 88;
					Main.tile[checkedX, i - 1].frameY = 176;
				}
			}
			else if (flag4)
			{
				if (num4 == 0)
				{
					Main.tile[checkedX, i - 1].frameX = 0;
					Main.tile[checkedX, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - 1].frameX = 0;
					Main.tile[checkedX, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - 1].frameX = 0;
					Main.tile[checkedX, i - 1].frameY = 176;
				}
			}
			else if (flag5)
			{
				if (num4 == 0)
				{
					Main.tile[checkedX, i - 1].frameX = 66;
					Main.tile[checkedX, i - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - 1].frameX = 66;
					Main.tile[checkedX, i - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - 1].frameX = 66;
					Main.tile[checkedX, i - 1].frameY = 176;
				}
			}
			if (genRand.Next(13) != 0)
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX, i - num2].frameX = 22;
					Main.tile[checkedX, i - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - num2].frameX = 22;
					Main.tile[checkedX, i - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - num2].frameX = 22;
					Main.tile[checkedX, i - num2].frameY = 242;
				}
			}
			else
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[checkedX, i - num2].frameX = 0;
					Main.tile[checkedX, i - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[checkedX, i - num2].frameX = 0;
					Main.tile[checkedX, i - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[checkedX, i - num2].frameX = 0;
					Main.tile[checkedX, i - num2].frameY = 242;
				}
			}
			RangeFrame(checkedX - 2, i - num2 - 1, checkedX + 2, i + 1);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, checkedX - 1, i - num2, 3, num2);
			}
			return true;
		}

		public static void GrowUndergroundTree(int i, int y)
		{
			if (Main.tile[i, y].type != 60 || !Main.tile[i, y].nactive() || Main.tile[i, y].halfBrick() || Main.tile[i, y].slope() != 0 || Main.tile[i, y].type != 60 || ((!Main.tile[i - 1, y].active() || Main.tile[i - 1, y].type != 60) && (!Main.tile[i + 1, y].active() || Main.tile[i + 1, y].type != 60)))
			{
				return;
			}
			int num = 1;
			int num2 = genRand.Next(5, 15);
			int num3 = num2 + 2;
			if (Main.tile[i, y].type == 60)
			{
				num3 += 5;
			}
			if (!EmptyTileCheck(i - num, i + num, y - num3, y - 1, 20))
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			int num4;
			for (int j = y - num2; j < y; j++)
			{
				Main.tile[i, j].frameNumber((byte)genRand.Next(3));
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].type = 5;
				num4 = genRand.Next(3);
				int num5 = genRand.Next(10);
				if (j == y - 1 || j == y - num2)
				{
					num5 = 0;
				}
				while (((num5 == 5 || num5 == 7) && flag) || ((num5 == 6 || num5 == 7) && flag2))
				{
					num5 = genRand.Next(10);
				}
				flag = false;
				flag2 = false;
				if (num5 == 5 || num5 == 7)
				{
					flag = true;
				}
				if (num5 == 6 || num5 == 7)
				{
					flag2 = true;
				}
				switch (num5)
				{
				case 1:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 2:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 44;
					}
					break;
				case 3:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 44;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 44;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 44;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 4:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 22;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 5:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 44;
					}
					break;
				case 6:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 110;
					}
					break;
				case 7:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 110;
					}
					break;
				default:
					if (num4 == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (num4 == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}
					if (num4 == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
					break;
				}
				if (num5 == 5 || num5 == 7)
				{
					Main.tile[i - 1, j].active(active: true);
					Main.tile[i - 1, j].type = 5;
					num4 = genRand.Next(3);
					if (genRand.Next(3) < 2)
					{
						if (num4 == 0)
						{
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 198;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 220;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j].frameX = 44;
							Main.tile[i - 1, j].frameY = 242;
						}
					}
					else
					{
						if (num4 == 0)
						{
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 0;
						}
						if (num4 == 1)
						{
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 22;
						}
						if (num4 == 2)
						{
							Main.tile[i - 1, j].frameX = 66;
							Main.tile[i - 1, j].frameY = 44;
						}
					}
				}
				if (num5 != 6 && num5 != 7)
				{
					continue;
				}
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].type = 5;
				num4 = genRand.Next(3);
				if (genRand.Next(3) < 2)
				{
					if (num4 == 0)
					{
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 198;
					}
					if (num4 == 1)
					{
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 220;
					}
					if (num4 == 2)
					{
						Main.tile[i + 1, j].frameX = 66;
						Main.tile[i + 1, j].frameY = 242;
					}
				}
				else
				{
					if (num4 == 0)
					{
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 66;
					}
					if (num4 == 1)
					{
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 88;
					}
					if (num4 == 2)
					{
						Main.tile[i + 1, j].frameX = 88;
						Main.tile[i + 1, j].frameY = 110;
					}
				}
			}
			int num6 = genRand.Next(3);
			bool flag3 = false;
			bool flag4 = false;
			if (Main.tile[i - 1, y].nactive() && !Main.tile[i - 1, y].halfBrick() && Main.tile[i - 1, y].slope() == 0 && (Main.tile[i - 1, y].type == 2 || Main.tile[i - 1, y].type == 23 || Main.tile[i - 1, y].type == 60 || Main.tile[i - 1, y].type == 109 || Main.tile[i - 1, y].type == 147))
			{
				flag3 = true;
			}
			if (Main.tile[i + 1, y].nactive() && !Main.tile[i + 1, y].halfBrick() && Main.tile[i + 1, y].slope() == 0 && (Main.tile[i + 1, y].type == 2 || Main.tile[i + 1, y].type == 23 || Main.tile[i + 1, y].type == 60 || Main.tile[i + 1, y].type == 109 || Main.tile[i + 1, y].type == 147))
			{
				flag4 = true;
			}
			if (!flag3)
			{
				if (num6 == 0)
				{
					num6 = 2;
				}
				if (num6 == 1)
				{
					num6 = 3;
				}
			}
			if (!flag4)
			{
				if (num6 == 0)
				{
					num6 = 1;
				}
				if (num6 == 2)
				{
					num6 = 3;
				}
			}
			if (flag3 && !flag4)
			{
				num6 = 2;
			}
			if (flag4 && !flag3)
			{
				num6 = 1;
			}
			if (num6 == 0 || num6 == 1)
			{
				Main.tile[i + 1, y - 1].active(active: true);
				Main.tile[i + 1, y - 1].type = 5;
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i + 1, y - 1].frameX = 22;
					Main.tile[i + 1, y - 1].frameY = 176;
				}
			}
			if (num6 == 0 || num6 == 2)
			{
				Main.tile[i - 1, y - 1].active(active: true);
				Main.tile[i - 1, y - 1].type = 5;
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i - 1, y - 1].frameX = 44;
					Main.tile[i - 1, y - 1].frameY = 176;
				}
			}
			num4 = genRand.Next(3);
			switch (num6)
			{
			case 0:
				if (num4 == 0)
				{
					Main.tile[i, y - 1].frameX = 88;
					Main.tile[i, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - 1].frameX = 88;
					Main.tile[i, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - 1].frameX = 88;
					Main.tile[i, y - 1].frameY = 176;
				}
				break;
			case 1:
				if (num4 == 0)
				{
					Main.tile[i, y - 1].frameX = 0;
					Main.tile[i, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - 1].frameX = 0;
					Main.tile[i, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - 1].frameX = 0;
					Main.tile[i, y - 1].frameY = 176;
				}
				break;
			case 2:
				if (num4 == 0)
				{
					Main.tile[i, y - 1].frameX = 66;
					Main.tile[i, y - 1].frameY = 132;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - 1].frameX = 66;
					Main.tile[i, y - 1].frameY = 154;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - 1].frameX = 66;
					Main.tile[i, y - 1].frameY = 176;
				}
				break;
			}
			if (genRand.Next(8) != 0)
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - num2].frameX = 22;
					Main.tile[i, y - num2].frameY = 242;
				}
			}
			else
			{
				num4 = genRand.Next(3);
				if (num4 == 0)
				{
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 198;
				}
				if (num4 == 1)
				{
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 220;
				}
				if (num4 == 2)
				{
					Main.tile[i, y - num2].frameX = 0;
					Main.tile[i, y - num2].frameY = 242;
				}
			}
			RangeFrame(i - 2, y - num2 - 1, i + 2, y + 1);
			if (Main.netMode == 2 && !gen)
			{
				NetMessage.SendTileSquare(-1, i - 1, y - num2, 3, num2);
			}
		}

		public static bool GrowShroom(int i, int y)
		{
			if (Main.tile[i - 1, y - 1].lava() || Main.tile[i - 1, y - 1].lava() || Main.tile[i + 1, y - 1].lava())
			{
				return false;
			}
			if (Main.tile[i, y].nactive() && Main.tile[i, y].type == 70 && Main.tile[i, y - 1].wall == 0 && Main.tile[i - 1, y].active() && Main.tile[i - 1, y].type == 70 && Main.tile[i + 1, y].active() && Main.tile[i + 1, y].type == 70 && EmptyTileCheck(i - 2, i + 2, y - 13, y - 3, 71) && EmptyTileCheck(i - 1, i + 1, y - 3, y - 1, 71))
			{
				if (gen && genRand.Next(3) != 0)
				{
					Main.tile[i, y].halfBrick(halfBrick: false);
					Main.tile[i, y].slope(0);
				}
				if (!Main.tile[i, y].halfBrick() && Main.tile[i, y].slope() == 0)
				{
					int num = genRand.Next(4, 11);
					for (int j = y - num; j < y; j++)
					{
						Main.tile[i, j].frameNumber((byte)genRand.Next(3));
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 72;
						int num2 = genRand.Next(3);
						if (num2 == 0)
						{
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 0;
						}
						if (num2 == 1)
						{
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 18;
						}
						if (num2 == 2)
						{
							Main.tile[i, j].frameX = 0;
							Main.tile[i, j].frameY = 36;
						}
					}
					int num3 = genRand.Next(3);
					if (num3 == 0)
					{
						Main.tile[i, y - num].frameX = 36;
						Main.tile[i, y - num].frameY = 0;
					}
					if (num3 == 1)
					{
						Main.tile[i, y - num].frameX = 36;
						Main.tile[i, y - num].frameY = 18;
					}
					if (num3 == 2)
					{
						Main.tile[i, y - num].frameX = 36;
						Main.tile[i, y - num].frameY = 36;
					}
					RangeFrame(i - 2, y - num - 1, i + 2, y + 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i - 1, y - num, 3, num);
					}
					return true;
				}
			}
			return false;
		}

		public static void AddTrees(bool undergroundOnly = false)
		{
			double num = 0.1 + genRand.NextDouble() * 0.35;
			double num2 = 0.1 + genRand.NextDouble() * 0.35;
			int num3 = 20;
			int num4 = (int)Main.worldSurface;
			if (!undergroundOnly)
			{
				for (int i = 1; i < Main.maxTilesX - 1; i++)
				{
					for (int j = num3; j < num4; j++)
					{
						if (i < 380)
						{
							if (genRand.NextDouble() < num && Main.tile[i, j].liquid == 0)
							{
								GrowPalmTree(i, j);
							}
						}
						else if (i > Main.maxTilesX - 380 && genRand.NextDouble() < num2 && Main.tile[i, j].liquid == 0)
						{
							GrowPalmTree(i, j);
						}
						int num5 = 20;
						if (drunkWorldGen)
						{
							num5 /= 3;
						}
						if (remixWorldGen)
						{
							num5 /= 2;
						}
						if (Main.tile[i, j].type == 2 && (Main.tenthAnniversaryWorld || genRand.Next(num5) == 0))
						{
							if (genRand.Next(2) == 0)
							{
								GrowTreeWithSettings(i, j, GrowTreeSettings.Profiles.VanityTree_Willow);
							}
							else
							{
								GrowTreeWithSettings(i, j, GrowTreeSettings.Profiles.VanityTree_Sakura);
							}
						}
						else
						{
							GrowTree(i, j);
						}
					}
					if (genRand.Next(3) == 0)
					{
						i++;
					}
					if (genRand.Next(4) == 0)
					{
						i++;
					}
				}
			}
			if (!remixWorldGen)
			{
				return;
			}
			num3 = (int)Main.worldSurface;
			num4 = Main.maxTilesY - 300;
			for (int k = 1; k < Main.maxTilesX - 1; k++)
			{
				for (int l = num3; l < num4; l++)
				{
					int maxValue = 7;
					if (Main.tile[k, l].type == 2 && (Main.tenthAnniversaryWorld || genRand.Next(maxValue) == 0))
					{
						if (genRand.Next(2) == 0)
						{
							GrowTreeWithSettings(k, l, GrowTreeSettings.Profiles.VanityTree_Willow);
						}
						else
						{
							GrowTreeWithSettings(k, l, GrowTreeSettings.Profiles.VanityTree_Sakura);
						}
					}
					else
					{
						GrowTree(k, l);
					}
				}
			}
		}

		public static void ExplodeMine(int i, int j, bool fromWiring)
		{
			_ = Main.tile[i, j].type;
			KillTile(i, j, fail: false, effectOnly: false, noItem: true);
			NetMessage.SendTileSquare(-1, i, j);
			Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(i, j, fromWiring, Main.LocalPlayer), i * 16 + 8, j * 16 + 8, 0f, 0f, 164, 250, 10f, Main.myPlayer);
		}

		public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1)
		{
			if (startX < 0)
			{
				return false;
			}
			if (endX >= Main.maxTilesX)
			{
				return false;
			}
			if (startY < 0)
			{
				return false;
			}
			if (endY >= Main.maxTilesY)
			{
				return false;
			}
			bool flag = false;
			if (ignoreID != -1 && TileID.Sets.CommonSapling[ignoreID])
			{
				flag = true;
			}
			for (int i = startX; i < endX + 1; i++)
			{
				for (int j = startY; j < endY + 1; j++)
				{
					if (!Main.tile[i, j].active())
					{
						continue;
					}
					switch (ignoreID)
					{
					case -1:
						return false;
					case 11:
					{
						ushort type = Main.tile[i, j].type;
						if (type == 11)
						{
							continue;
						}
						return false;
					}
					case 71:
					{
						ushort type = Main.tile[i, j].type;
						if (type == 71)
						{
							continue;
						}
						return false;
					}
					}
					if (flag)
					{
						if (TileID.Sets.CommonSapling[Main.tile[i, j].type])
						{
							break;
						}
						switch (Main.tile[i, j].type)
						{
						case 3:
						case 24:
						case 32:
						case 61:
						case 62:
						case 69:
						case 71:
						case 73:
						case 74:
						case 82:
						case 83:
						case 84:
						case 110:
						case 113:
						case 201:
						case 233:
						case 352:
						case 485:
						case 529:
						case 530:
						case 637:
						case 655:
							continue;
						}
						return false;
					}
				}
			}
			return true;
		}

		public static void StartHardmode()
		{
			if (Main.netMode != 1 && !Main.hardMode)
			{
				Main.hardMode = true;
				ThreadPool.QueueUserWorkItem(smCallBack, 1);
			}
		}

		public static void smCallBack(object threadContext)
		{
			IsGeneratingHardMode = true;
			if (Main.rand == null)
			{
				Main.rand = new UnifiedRandom((int)DateTime.Now.Ticks);
			}
			double num = (double)genRand.Next(300, 400) * 0.001;
			double num2 = (double)genRand.Next(200, 300) * 0.001;
			int num3 = (int)((double)Main.maxTilesX * num);
			int num4 = (int)((double)Main.maxTilesX * (1.0 - num));
			int num5 = 1;
			if (genRand.Next(2) == 0)
			{
				num4 = (int)((double)Main.maxTilesX * num);
				num3 = (int)((double)Main.maxTilesX * (1.0 - num));
				num5 = -1;
			}
			int num6 = 1;
			if (GenVars.dungeonX < Main.maxTilesX / 2)
			{
				num6 = -1;
			}
			if (num6 < 0)
			{
				if (num4 < num3)
				{
					num4 = (int)((double)Main.maxTilesX * num2);
				}
				else
				{
					num3 = (int)((double)Main.maxTilesX * num2);
				}
			}
			else if (num4 > num3)
			{
				num4 = (int)((double)Main.maxTilesX * (1.0 - num2));
			}
			else
			{
				num3 = (int)((double)Main.maxTilesX * (1.0 - num2));
			}
			if (Main.remixWorld)
			{
				int num7 = Main.maxTilesX / 7;
				int num8 = Main.maxTilesX / 14;
				if (Main.dungeonX < Main.maxTilesX / 2)
				{
					for (int i = Main.maxTilesX - num7 - num8; i < Main.maxTilesX; i++)
					{
						for (int j = (int)Main.worldSurface + genRand.Next(-1, 2); j < Main.maxTilesY - 10; j++)
						{
							if (i > Main.maxTilesX - num7)
							{
								Convert(i, j, 2, 1);
							}
							else if (TileID.Sets.Crimson[Main.tile[i, j].type] || TileID.Sets.Corrupt[Main.tile[i, j].type])
							{
								Convert(i, j, 2, 1);
							}
						}
					}
				}
				else
				{
					for (int k = 0; k < num7 + num8; k++)
					{
						for (int l = (int)Main.worldSurface + genRand.Next(-1, 2); l < Main.maxTilesY - 10; l++)
						{
							if (k < num7)
							{
								Convert(k, l, 2, 1);
							}
							else if (TileID.Sets.Crimson[Main.tile[k, l].type] || TileID.Sets.Corrupt[Main.tile[k, l].type])
							{
								Convert(k, l, 2, 1);
							}
						}
					}
				}
			}
			else
			{
				GERunner(num3, 0, 3 * num5, 5.0);
				GERunner(num4, 0, 3 * -num5, 5.0, good: false);
			}
			double num9 = (double)Main.maxTilesX / 4200.0;
			int num10 = (int)(25.0 * num9);
			ShapeData shapeData = new ShapeData();
			int num11 = 0;
			while (num10 > 0)
			{
				if (++num11 % 15000 == 0)
				{
					num10--;
				}
				Point point = RandomWorldPoint((int)Main.worldSurface - 100, 1, 190, 1);
				Tile tile = Main.tile[point.X, point.Y];
				Tile tile2 = Main.tile[point.X, point.Y - 1];
				ushort num12 = 0;
				if (TileID.Sets.Crimson[tile.type])
				{
					num12 = (ushort)(192 + genRand.Next(4));
				}
				else if (TileID.Sets.Corrupt[tile.type])
				{
					num12 = (ushort)(188 + genRand.Next(4));
				}
				else if (TileID.Sets.Hallow[tile.type])
				{
					num12 = (ushort)(200 + genRand.Next(4));
				}
				if (tile.active() && num12 != 0 && !tile2.active())
				{
					bool flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), new ShapeFloodFill(1000), Actions.Chain(new Modifiers.IsNotSolid(), new Modifiers.OnlyWalls(0, 54, 55, 56, 57, 58, 59, 61, 185, 212, 213, 214, 215, 2, 196, 197, 198, 199, 15, 40, 71, 64, 204, 205, 206, 207, 208, 209, 210, 211, 71), new Actions.Blank().Output(shapeData)));
					if (shapeData.Count > 50 && flag)
					{
						WorldUtils.Gen(new Point(point.X, point.Y), new ModShapes.OuterOutline(shapeData, useDiagonals: true, useInterior: true), new Actions.PlaceWall(num12));
						num10--;
					}
					shapeData.Clear();
				}
			}
			if (Main.netMode == 0)
			{
				Main.NewText(Lang.misc[15].Value, 50, byte.MaxValue, 130);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, 255, 130));
			}
			AchievementsHelper.NotifyProgressionEvent(9);
			if (Main.netMode == 2)
			{
				Netplay.ResetSections();
			}
			IsGeneratingHardMode = false;
		}

		public static bool PlaceDoor(int i, int j, int type, int style = 0)
		{
			int num = style / 36;
			int num2 = style % 36;
			int num3 = 54 * num;
			int num4 = 54 * num2;
			try
			{
				if (Main.tile[i, j - 2].nactive() && Main.tileSolid[Main.tile[i, j - 2].type] && SolidTile(i, j + 2))
				{
					Main.tile[i, j - 1].active(active: true);
					Main.tile[i, j - 1].type = 10;
					Main.tile[i, j - 1].frameY = (short)num4;
					Main.tile[i, j - 1].frameX = (short)(num3 + genRand.Next(3) * 18);
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].type = 10;
					Main.tile[i, j].frameY = (short)(num4 + 18);
					Main.tile[i, j].frameX = (short)(num3 + genRand.Next(3) * 18);
					Main.tile[i, j + 1].active(active: true);
					Main.tile[i, j + 1].type = 10;
					Main.tile[i, j + 1].frameY = (short)(num4 + 36);
					Main.tile[i, j + 1].frameX = (short)(num3 + genRand.Next(3) * 18);
					return true;
				}
				return false;
			}
			catch
			{
				return false;
			}
		}

		public static bool CloseDoor(int i, int j, bool forced = false)
		{
			int num = 0;
			int num2 = i;
			int num3 = j;
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			int frameX = Main.tile[i, j].frameX;
			Tile tile = Main.tile[i, j];
			if (tile.type != 11)
			{
				return false;
			}
			int num4 = tile.frameY;
			int num5 = 0;
			int num6 = 0;
			while (num4 >= 54)
			{
				num4 -= 54;
				num5++;
			}
			if (frameX >= 72)
			{
				num5 += 36 * (frameX / 72);
				num6 += 54 * (frameX / 72);
			}
			num3 = j - num4 / 18;
			switch (frameX % 72)
			{
			case 0:
				num2 = i;
				num = 1;
				break;
			case 18:
				num2 = i - 1;
				num = 1;
				break;
			case 36:
				num2 = i + 1;
				num = -1;
				break;
			case 54:
				num2 = i;
				num = -1;
				break;
			}
			int num7 = num2;
			if (num == -1)
			{
				num7 = num2 - 1;
			}
			if (!forced)
			{
				for (int k = num3; k < num3 + 3; k++)
				{
					if (!Collision.EmptyTile(num2, k, ignoreTiles: true))
					{
						return false;
					}
				}
			}
			for (int l = num7; l < num7 + 2; l++)
			{
				for (int m = num3; m < num3 + 3; m++)
				{
					if (l == num2)
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						Main.tile[l, m].type = 10;
						Main.tile[l, m].frameX = (short)(genRand.Next(3) * 18 + num6);
					}
					else
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						Main.tile[l, m].active(active: false);
					}
				}
			}
			if (Main.netMode != 1 && Wiring.running)
			{
				Wiring.SkipWire(num2, num3);
				Wiring.SkipWire(num2, num3 + 1);
				Wiring.SkipWire(num2, num3 + 2);
			}
			for (int n = num2 - 1; n <= num2 + 1; n++)
			{
				for (int num8 = num3 - 1; num8 <= num3 + 2; num8++)
				{
					TileFrame(n, num8);
				}
			}
			SoundEngine.PlaySound(9, i * 16, j * 16);
			return true;
		}

		public static bool AddLifeCrystal(int i, int j)
		{
			for (int k = j; k < Main.maxTilesY; k++)
			{
				if (Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type])
				{
					int num = k - 1;
					if (Main.tile[i, num - 1].lava() || Main.tile[i - 1, num - 1].lava())
					{
						return false;
					}
					if (Main.tile[i, num - 1].shimmer())
					{
						return false;
					}
					if (!EmptyTileCheck(i - 1, i, num - 1, num))
					{
						return false;
					}
					if (Main.wallDungeon[Main.tile[i, num].wall])
					{
						return false;
					}
					Tile tile = Main.tile[i - 1, num + 1];
					Tile tile2 = Main.tile[i, num + 1];
					if (!tile.nactive() || !Main.tileSolid[tile.type])
					{
						return false;
					}
					if (!tile2.nactive() || !Main.tileSolid[tile2.type])
					{
						return false;
					}
					if (tile.blockType() != 0)
					{
						tile.slope(0);
						tile.halfBrick(halfBrick: false);
					}
					if (tile2.blockType() != 0)
					{
						tile2.slope(0);
						tile2.halfBrick(halfBrick: false);
					}
					Main.tile[i - 1, num - 1].active(active: true);
					Main.tile[i - 1, num - 1].type = 12;
					Main.tile[i - 1, num - 1].frameX = 0;
					Main.tile[i - 1, num - 1].frameY = 0;
					Main.tile[i, num - 1].active(active: true);
					Main.tile[i, num - 1].type = 12;
					Main.tile[i, num - 1].frameX = 18;
					Main.tile[i, num - 1].frameY = 0;
					Main.tile[i - 1, num].active(active: true);
					Main.tile[i - 1, num].type = 12;
					Main.tile[i - 1, num].frameX = 0;
					Main.tile[i - 1, num].frameY = 18;
					Main.tile[i, num].active(active: true);
					Main.tile[i, num].type = 12;
					Main.tile[i, num].frameX = 18;
					Main.tile[i, num].frameY = 18;
					return true;
				}
			}
			return false;
		}

		public static void AddShadowOrb(int x, int y)
		{
			if (x < 10 || x > Main.maxTilesX - 10 || y < 10 || y > Main.maxTilesY - 10)
			{
				return;
			}
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 31)
					{
						return;
					}
				}
			}
			short num = 0;
			if (crimson)
			{
				num = (short)(num + 36);
			}
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].type = 31;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].type = 31;
			Main.tile[x, y - 1].frameX = (short)(18 + num);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].type = 31;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].type = 31;
			Main.tile[x, y].frameX = (short)(18 + num);
			Main.tile[x, y].frameY = 18;
		}

		public static void AddHellHouses()
		{
			int num = (int)((double)Main.maxTilesX * 0.25);
			for (int i = 100; i < Main.maxTilesX - 100; i++)
			{
				if (((drunkWorldGen || remixWorldGen) && i > num && i < Main.maxTilesX - num) || (!drunkWorldGen && !remixWorldGen && (i < num || i > Main.maxTilesX - num)))
				{
					continue;
				}
				int num2 = Main.maxTilesY - 40;
				while (Main.tile[i, num2].active() || Main.tile[i, num2].liquid > 0)
				{
					num2--;
				}
				if (Main.tile[i, num2 + 1].active())
				{
					ushort num3 = (ushort)genRand.Next(75, 77);
					byte wallType = 13;
					if (genRand.Next(5) > 0)
					{
						num3 = 75;
					}
					if (num3 == 75)
					{
						wallType = 14;
					}
					if (getGoodWorldGen)
					{
						num3 = 76;
					}
					HellFort(i, num2, num3, wallType);
					i += genRand.Next(30, 130);
					if (genRand.Next(10) == 0)
					{
						i += genRand.Next(0, 200);
					}
				}
			}
			float num4 = Main.maxTilesX / 4200;
			for (int j = 0; (float)j < 200f * num4; j++)
			{
				int num5 = 0;
				bool flag = false;
				while (!flag)
				{
					num5++;
					int num6 = genRand.Next((int)((double)Main.maxTilesX * 0.2), (int)((double)Main.maxTilesX * 0.8));
					int num7 = genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
					if (Main.tile[num6, num7].active() && (Main.tile[num6, num7].type == 75 || Main.tile[num6, num7].type == 76))
					{
						int num8 = 0;
						if (Main.tile[num6 - 1, num7].wall > 0)
						{
							num8 = -1;
						}
						else if (Main.tile[num6 + 1, num7].wall > 0)
						{
							num8 = 1;
						}
						if (!Main.tile[num6 + num8, num7].active() && !Main.tile[num6 + num8, num7 + 1].active())
						{
							bool flag2 = false;
							for (int k = num6 - 8; k < num6 + 8; k++)
							{
								for (int l = num7 - 8; l < num7 + 8; l++)
								{
									if (Main.tile[k, l].active() && Main.tile[k, l].type == 4)
									{
										flag2 = true;
										break;
									}
								}
							}
							if (!flag2)
							{
								PlaceTile(num6 + num8, num7, 4, mute: true, forced: true, -1, 7);
								flag = true;
							}
						}
					}
					if (num5 > 1000)
					{
						flag = true;
					}
				}
			}
			double num9 = 4200000.0 / (double)Main.maxTilesX;
			for (int m = 0; (double)m < num9; m++)
			{
				int num10 = 0;
				int num11 = genRand.Next(num, Main.maxTilesX - num);
				int n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				while ((Main.tile[num11, n].wall != 13 && Main.tile[num11, n].wall != 14) || Main.tile[num11, n].active())
				{
					num11 = genRand.Next(num, Main.maxTilesX - num);
					n = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
					if (drunkWorldGen || remixWorldGen)
					{
						num11 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
					}
					num10++;
					if (num10 > 100000)
					{
						break;
					}
				}
				if (num10 > 100000 || (Main.tile[num11, n].wall != 13 && Main.tile[num11, n].wall != 14) || Main.tile[num11, n].active())
				{
					continue;
				}
				for (; !SolidTile(num11, n) && n < Main.maxTilesY - 20; n++)
				{
				}
				n--;
				int num12 = num11;
				int num13 = num11;
				while (!Main.tile[num12, n].active() && SolidTile(num12, n + 1))
				{
					num12--;
				}
				num12++;
				for (; !Main.tile[num13, n].active() && SolidTile(num13, n + 1); num13++)
				{
				}
				num13--;
				int num14 = num13 - num12;
				int num15 = (num13 + num12) / 2;
				if (Main.tile[num15, n].active() || (Main.tile[num15, n].wall != 13 && Main.tile[num15, n].wall != 14) || !SolidTile(num15, n + 1))
				{
					continue;
				}
				int style = 16;
				int style2 = 13;
				int style3 = 14;
				int style4 = 49;
				int style5 = 4;
				int style6 = 8;
				int style7 = 15;
				int style8 = 9;
				int style9 = 10;
				int style10 = 17;
				int style11 = 25;
				int style12 = 25;
				int style13 = 23;
				int style14 = 25;
				int num16 = genRand.Next(13);
				int num17 = 0;
				int num18 = 0;
				if (num16 == 0)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 1)
				{
					num17 = 4;
					num18 = 3;
				}
				if (num16 == 2)
				{
					num17 = 3;
					num18 = 5;
				}
				if (num16 == 3)
				{
					num17 = 4;
					num18 = 6;
				}
				if (num16 == 4)
				{
					num17 = 3;
					num18 = 3;
				}
				if (num16 == 5)
				{
					num17 = 5;
					num18 = 3;
				}
				if (num16 == 6)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 7)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 8)
				{
					num17 = 5;
					num18 = 4;
				}
				if (num16 == 9)
				{
					num17 = 3;
					num18 = 5;
				}
				if (num16 == 10)
				{
					num17 = 5;
					num18 = 3;
				}
				if (num16 == 11)
				{
					num17 = 2;
					num18 = 4;
				}
				if (num16 == 12)
				{
					num17 = 3;
					num18 = 3;
				}
				for (int num19 = num15 - num17; num19 <= num15 + num17; num19++)
				{
					for (int num20 = n - num18; num20 <= n; num20++)
					{
						if (Main.tile[num19, num20].active())
						{
							num16 = -1;
							break;
						}
					}
				}
				if ((double)num14 < (double)num17 * 1.75)
				{
					num16 = -1;
				}
				switch (num16)
				{
				case 0:
				{
					PlaceTile(num15, n, 14, mute: true, forced: false, -1, style2);
					int num22 = genRand.Next(6);
					if (num22 < 3)
					{
						PlaceTile(num15 + num22, n - 2, 33, mute: true, forced: false, -1, style12);
					}
					if (!Main.tile[num15, n].active())
					{
						break;
					}
					if (!Main.tile[num15 - 2, n].active())
					{
						PlaceTile(num15 - 2, n, 15, mute: true, forced: false, -1, style);
						if (Main.tile[num15 - 2, n].active())
						{
							Main.tile[num15 - 2, n].frameX += 18;
							Main.tile[num15 - 2, n - 1].frameX += 18;
						}
					}
					if (!Main.tile[num15 + 2, n].active())
					{
						PlaceTile(num15 + 2, n, 15, mute: true, forced: false, -1, style);
					}
					break;
				}
				case 1:
				{
					PlaceTile(num15, n, 18, mute: true, forced: false, -1, style3);
					int num21 = genRand.Next(4);
					if (num21 < 2)
					{
						PlaceTile(num15 + num21, n - 1, 33, mute: true, forced: false, -1, style12);
					}
					if (!Main.tile[num15, n].active())
					{
						break;
					}
					if (genRand.Next(2) == 0)
					{
						if (!Main.tile[num15 - 1, n].active())
						{
							PlaceTile(num15 - 1, n, 15, mute: true, forced: false, -1, style);
							if (Main.tile[num15 - 1, n].active())
							{
								Main.tile[num15 - 1, n].frameX += 18;
								Main.tile[num15 - 1, n - 1].frameX += 18;
							}
						}
					}
					else if (!Main.tile[num15 + 2, n].active())
					{
						PlaceTile(num15 + 2, n, 15, mute: true, forced: false, -1, style);
					}
					break;
				}
				case 2:
					PlaceTile(num15, n, 105, mute: true, forced: false, -1, style4);
					break;
				case 3:
					PlaceTile(num15, n, 101, mute: true, forced: false, -1, style5);
					break;
				case 4:
					if (genRand.Next(2) == 0)
					{
						PlaceTile(num15, n, 15, mute: true, forced: false, -1, style);
						Main.tile[num15, n].frameX += 18;
						Main.tile[num15, n - 1].frameX += 18;
					}
					else
					{
						PlaceTile(num15, n, 15, mute: true, forced: false, -1, style);
					}
					break;
				case 5:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num15, n, 79, 1, style6);
					}
					else
					{
						Place4x2(num15, n, 79, -1, style6);
					}
					break;
				case 6:
					PlaceTile(num15, n, 87, mute: true, forced: false, -1, style7);
					break;
				case 7:
					PlaceTile(num15, n, 88, mute: true, forced: false, -1, style8);
					break;
				case 8:
					PlaceTile(num15, n, 89, mute: true, forced: false, -1, style9);
					break;
				case 9:
					PlaceTile(num15, n, 104, mute: true, forced: false, -1, style10);
					break;
				case 10:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num15, n, 90, 1, style14);
					}
					else
					{
						Place4x2(num15, n, 90, -1, style14);
					}
					break;
				case 11:
					PlaceTile(num15, n, 93, mute: true, forced: false, -1, style13);
					break;
				case 12:
					PlaceTile(num15, n, 100, mute: true, forced: false, -1, style11);
					break;
				}
			}
			num9 = 420000.0 / (double)Main.maxTilesX;
			for (int num23 = 0; (double)num23 < num9; num23++)
			{
				int num24 = 0;
				int num25 = genRand.Next(num, Main.maxTilesX - num);
				int num26 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
				while ((Main.tile[num25, num26].wall != 13 && Main.tile[num25, num26].wall != 14) || Main.tile[num25, num26].active())
				{
					num25 = genRand.Next(num, Main.maxTilesX - num);
					num26 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
					if (drunkWorldGen || remixWorldGen)
					{
						num25 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
					}
					num24++;
					if (num24 > 100000)
					{
						break;
					}
				}
				if (num24 > 100000)
				{
					continue;
				}
				int num27 = num25;
				int num28 = num25;
				int num29 = num26;
				int num30 = num26;
				int num31 = 0;
				for (int num32 = 0; num32 < 2; num32++)
				{
					num27 = num25;
					num28 = num25;
					while (!Main.tile[num27, num26].active() && (Main.tile[num27, num26].wall == 13 || Main.tile[num27, num26].wall == 14))
					{
						num27--;
					}
					num27++;
					for (; !Main.tile[num28, num26].active() && (Main.tile[num28, num26].wall == 13 || Main.tile[num28, num26].wall == 14); num28++)
					{
					}
					num28--;
					num25 = (num27 + num28) / 2;
					num29 = num26;
					num30 = num26;
					while (!Main.tile[num25, num29].active() && (Main.tile[num25, num29].wall == 13 || Main.tile[num25, num29].wall == 14))
					{
						num29--;
					}
					num29++;
					for (; !Main.tile[num25, num30].active() && (Main.tile[num25, num30].wall == 13 || Main.tile[num25, num30].wall == 14); num30++)
					{
					}
					num30--;
					num26 = (num29 + num30) / 2;
				}
				num27 = num25;
				num28 = num25;
				while (!Main.tile[num27, num26].active() && !Main.tile[num27, num26 - 1].active() && !Main.tile[num27, num26 + 1].active())
				{
					num27--;
				}
				num27++;
				for (; !Main.tile[num28, num26].active() && !Main.tile[num28, num26 - 1].active() && !Main.tile[num28, num26 + 1].active(); num28++)
				{
				}
				num28--;
				num29 = num26;
				num30 = num26;
				while (!Main.tile[num25, num29].active() && !Main.tile[num25 - 1, num29].active() && !Main.tile[num25 + 1, num29].active())
				{
					num29--;
				}
				num29++;
				for (; !Main.tile[num25, num30].active() && !Main.tile[num25 - 1, num30].active() && !Main.tile[num25 + 1, num30].active(); num30++)
				{
				}
				num30--;
				num25 = (num27 + num28) / 2;
				num26 = (num29 + num30) / 2;
				int num33 = num28 - num27;
				num31 = num30 - num29;
				if (num33 <= 7 || num31 <= 5)
				{
					continue;
				}
				int num34 = 0;
				if (nearPicture2(num25, num26))
				{
					num34 = -1;
				}
				if (num34 == 0)
				{
					PaintingEntry paintingEntry = RandHellPicture();
					if (!nearPicture(num25, num26))
					{
						PlaceTile(num25, num26, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
					}
				}
			}
			int[] array = new int[3]
			{
				genRand.Next(16, 22),
				genRand.Next(16, 22),
				genRand.Next(16, 22)
			};
			while (array[1] == array[0])
			{
				array[1] = genRand.Next(16, 22);
			}
			while (array[2] == array[0] || array[2] == array[1])
			{
				array[2] = genRand.Next(16, 22);
			}
			num9 = 420000.0 / (double)Main.maxTilesX;
			for (int num35 = 0; (double)num35 < num9; num35++)
			{
				int num36 = 0;
				int num37;
				int num38;
				do
				{
					num37 = genRand.Next(num, Main.maxTilesX - num);
					num38 = genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
					if (drunkWorldGen || remixWorldGen)
					{
						num37 = ((genRand.Next(2) != 0) ? genRand.Next(Main.maxTilesX - num, Main.maxTilesX - 50) : genRand.Next(50, num));
					}
					num36++;
				}
				while (num36 <= 100000 && ((Main.tile[num37, num38].wall != 13 && Main.tile[num37, num38].wall != 14) || Main.tile[num37, num38].active()));
				if (num36 > 100000)
				{
					continue;
				}
				while (!SolidTile(num37, num38) && num38 > 10)
				{
					num38--;
				}
				num38++;
				if (Main.tile[num37, num38].wall != 13 && Main.tile[num37, num38].wall != 14)
				{
					continue;
				}
				int num39 = genRand.Next(3);
				int style15 = 32;
				int style16 = 32;
				int num40;
				int num41;
				switch (num39)
				{
				default:
					num40 = 1;
					num41 = 3;
					break;
				case 1:
					num40 = 3;
					num41 = 3;
					break;
				case 2:
					num40 = 1;
					num41 = 2;
					break;
				}
				for (int num42 = num37 - 1; num42 <= num37 + num40; num42++)
				{
					for (int num43 = num38; num43 <= num38 + num41; num43++)
					{
						Tile tile = Main.tile[num37, num38];
						if (num42 < num37 || num42 == num37 + num40)
						{
							if (tile.active())
							{
								switch (tile.type)
								{
								case 10:
								case 11:
								case 34:
								case 42:
								case 91:
									num39 = -1;
									break;
								}
							}
						}
						else if (tile.active())
						{
							num39 = -1;
						}
					}
				}
				switch (num39)
				{
				case 0:
					PlaceTile(num37, num38, 91, mute: true, forced: false, -1, array[genRand.Next(3)]);
					break;
				case 1:
					PlaceTile(num37, num38, 34, mute: true, forced: false, -1, style15);
					break;
				case 2:
					PlaceTile(num37, num38, 42, mute: true, forced: false, -1, style16);
					break;
				}
			}
		}

		public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14)
		{
			int[] array = new int[5];
			int[] array2 = new int[5];
			int[] array3 = new int[10];
			int[] array4 = new int[10];
			int num = 8;
			int num2 = 20;
			if (drunkWorldGen)
			{
				num /= 2;
				num2 *= 2;
			}
			array[2] = i - genRand.Next(num / 2, num2 / 2);
			array2[2] = i + genRand.Next(num / 2, num2 / 2);
			array[3] = array2[2];
			array2[3] = array[3] + genRand.Next(num, num2);
			array[4] = array2[3];
			array2[4] = array[4] + genRand.Next(num, num2);
			array2[1] = array[2];
			array[1] = array2[1] - genRand.Next(num, num2);
			array2[0] = array[1];
			array[0] = array2[0] - genRand.Next(num, num2);
			num = 6;
			num2 = 12;
			array3[3] = j - genRand.Next(num, num2);
			array4[3] = j;
			for (int k = 4; k < 10; k++)
			{
				array3[k] = array4[k - 1];
				array4[k] = array3[k] + genRand.Next(num, num2);
			}
			for (int num3 = 2; num3 >= 0; num3--)
			{
				array4[num3] = array3[num3 + 1];
				array3[num3] = array4[num3] - genRand.Next(num, num2);
			}
			bool flag = false;
			bool flag2 = false;
			bool[,] array5 = new bool[5, 10];
			int num4 = 3;
			int num5 = 3;
			for (int l = 0; l < 2; l++)
			{
				if (genRand.Next(3) == 0 || drunkWorldGen)
				{
					flag = true;
					int num6 = genRand.Next(10);
					if (num6 < num4)
					{
						num4 = num6;
					}
					if (num6 > num5)
					{
						num5 = num6;
					}
					int num7 = 1;
					if (genRand.Next(2) == 0 || drunkWorldGen)
					{
						array5[0, num6] = true;
						array5[1, num6] = true;
						num7 = 0;
					}
					else
					{
						array5[1, num6] = true;
					}
					int num8 = genRand.Next(2);
					if (num8 == 0)
					{
						num8 = -1;
					}
					int num9 = genRand.Next(10);
					while (num9 > 0 && num6 >= 0 && num6 < 10)
					{
						array5[num7, num6] = true;
						num6 += num8;
					}
				}
				if (genRand.Next(3) == 0 || drunkWorldGen)
				{
					flag2 = true;
					int num10 = genRand.Next(10);
					if (num10 < num4)
					{
						num4 = num10;
					}
					if (num10 > num5)
					{
						num5 = num10;
					}
					int num11 = 3;
					if (genRand.Next(2) == 0 || drunkWorldGen)
					{
						array5[3, num10] = true;
						array5[4, num10] = true;
						num11 = 4;
					}
					else
					{
						array5[3, num10] = true;
					}
					int num12 = genRand.Next(2);
					if (num12 == 0)
					{
						num12 = -1;
					}
					int num13 = genRand.Next(10);
					while (num13 > 0 && num10 >= 0 && num10 < 10)
					{
						array5[num11, num10] = true;
						num10 += num12;
					}
				}
			}
			for (int m = 0; m < 5; m++)
			{
				int num14 = array[m];
				bool flag3 = false;
				if (num14 < 10 || num14 > Main.maxTilesX - 10)
				{
					flag3 = true;
				}
				else
				{
					for (int n = Main.UnderworldLayer; n < Main.maxTilesY; n++)
					{
						if (Main.tile[num14, n].wall > 0)
						{
							flag3 = true;
						}
					}
				}
				if (flag3)
				{
					for (int num15 = 0; num15 < 10; num15++)
					{
						array5[m, num15] = false;
					}
				}
			}
			int num16 = genRand.Next(10);
			if (num16 < num4)
			{
				num4 = num16;
			}
			num16 = genRand.Next(10);
			if (num16 > num5)
			{
				num5 = num16;
			}
			if (!flag && !flag2)
			{
				while (num5 - num4 < 5)
				{
					num16 = genRand.Next(10);
					if (num16 < num4)
					{
						num4 = num16;
					}
					num16 = genRand.Next(10);
					if (num16 > num5)
					{
						num5 = num16;
					}
				}
			}
			for (int num17 = num4; num17 <= num5; num17++)
			{
				array5[2, num17] = true;
			}
			for (int num18 = 0; num18 < 5; num18++)
			{
				for (int num19 = 0; num19 < 10; num19++)
				{
					if (array5[num18, num19] && (array3[num19] < Main.UnderworldLayer || array4[num19] > Main.maxTilesY - 20))
					{
						array5[num18, num19] = false;
					}
				}
			}
			for (int num20 = 0; num20 < 5; num20++)
			{
				for (int num21 = 0; num21 < 10; num21++)
				{
					if (!array5[num20, num21])
					{
						continue;
					}
					for (int num22 = array[num20]; num22 <= array2[num20]; num22++)
					{
						for (int num23 = array3[num21]; num23 <= array4[num21]; num23++)
						{
							if (num22 < 10)
							{
								break;
							}
							if (num22 > Main.maxTilesX - 10)
							{
								break;
							}
							Main.tile[num22, num23].liquid = 0;
							if (num22 == array[num20] || num22 == array2[num20] || num23 == array3[num21] || num23 == array4[num21])
							{
								Main.tile[num22, num23].active(active: true);
								Main.tile[num22, num23].type = tileType;
								Main.tile[num22, num23].halfBrick(halfBrick: false);
								Main.tile[num22, num23].slope(0);
							}
							else
							{
								Main.tile[num22, num23].wall = wallType;
								Main.tile[num22, num23].active(active: false);
							}
						}
					}
				}
			}
			int style = 19;
			int style2 = 13;
			for (int num24 = 0; num24 < 4; num24++)
			{
				bool[] array6 = new bool[10];
				bool flag4 = false;
				for (int num25 = 0; num25 < 10; num25++)
				{
					if (array5[num24, num25] && array5[num24 + 1, num25])
					{
						array6[num25] = true;
						flag4 = true;
					}
				}
				while (flag4)
				{
					int num26 = genRand.Next(10);
					if (array6[num26])
					{
						flag4 = false;
						Main.tile[array2[num24], array4[num26] - 1].active(active: false);
						Main.tile[array2[num24], array4[num26] - 2].active(active: false);
						Main.tile[array2[num24], array4[num26] - 3].active(active: false);
						Main.tile[array2[num24], array4[num26] - 1].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 2].wall = wallType;
						Main.tile[array2[num24], array4[num26] - 3].wall = wallType;
						PlaceTile(array2[num24], array4[num26] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}
			for (int num27 = 0; num27 < 5; num27++)
			{
				for (int num28 = 0; num28 < 10; num28++)
				{
					if (!array5[num27, num28])
					{
						continue;
					}
					if (num28 > 0 && array5[num27, num28 - 1])
					{
						int num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						int num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
						int num31 = 0;
						while (num30 - num29 < 2 || num30 - num29 > 5)
						{
							num29 = genRand.Next(array[num27] + 2, array2[num27] - 1);
							num30 = genRand.Next(array[num27] + 2, array2[num27] - 1);
							num31++;
							if (num31 > 10000)
							{
								break;
							}
						}
						if (num31 > 10000)
						{
							break;
						}
						for (int num32 = num29; num32 <= num30 && num32 >= 20 && num32 <= Main.maxTilesX - 20; num32++)
						{
							Main.tile[num32, array3[num28]].active(active: false);
							PlaceTile(num32, array3[num28], 19, mute: true, forced: true, -1, style2);
							Main.tile[num32, array3[num28]].wall = wallType;
						}
					}
					if (num27 < 4 && array5[num27 + 1, num28] && genRand.Next(3) == 0)
					{
						Main.tile[array2[num27], array4[num28] - 1].active(active: false);
						Main.tile[array2[num27], array4[num28] - 2].active(active: false);
						Main.tile[array2[num27], array4[num28] - 3].active(active: false);
						Main.tile[array2[num27], array4[num28] - 1].wall = wallType;
						Main.tile[array2[num27], array4[num28] - 2].wall = wallType;
						Main.tile[array2[num27], array4[num28] - 3].wall = wallType;
						PlaceTile(array2[num27], array4[num28] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
			}
			bool flag5 = false;
			for (int num33 = 0; num33 < 5; num33++)
			{
				bool[] array7 = new bool[10];
				for (int num34 = 0; num34 < 10; num34++)
				{
					if (array5[num33, num34])
					{
						flag5 = true;
						array7[num34] = true;
					}
				}
				if (!flag5)
				{
					continue;
				}
				bool flag6 = false;
				for (int num35 = 0; num35 < 10; num35++)
				{
					if (array7[num35])
					{
						if (!Main.tile[array[num33] - 1, array4[num35] - 1].active() && !Main.tile[array[num33] - 1, array4[num35] - 2].active() && !Main.tile[array[num33] - 1, array4[num35] - 3].active() && Main.tile[array[num33] - 1, array4[num35] - 1].liquid == 0 && Main.tile[array[num33] - 1, array4[num35] - 2].liquid == 0 && Main.tile[array[num33] - 1, array4[num35] - 3].liquid == 0)
						{
							flag6 = true;
						}
						else
						{
							array7[num35] = false;
						}
					}
				}
				while (flag6)
				{
					int num36 = genRand.Next(10);
					if (array7[num36])
					{
						flag6 = false;
						Main.tile[array[num33], array4[num36] - 1].active(active: false);
						Main.tile[array[num33], array4[num36] - 2].active(active: false);
						Main.tile[array[num33], array4[num36] - 3].active(active: false);
						PlaceTile(array[num33], array4[num36] - 1, 10, mute: true, forced: false, -1, style);
					}
				}
				break;
			}
			bool flag7 = false;
			for (int num37 = 4; num37 >= 0; num37--)
			{
				bool[] array8 = new bool[10];
				for (int num38 = 0; num38 < 10; num38++)
				{
					if (array5[num37, num38])
					{
						flag7 = true;
						array8[num38] = true;
					}
				}
				if (flag7)
				{
					bool flag8 = false;
					for (int num39 = 0; num39 < 10; num39++)
					{
						if (array8[num39])
						{
							if (num37 < 20 || num37 > Main.maxTilesX - 20)
							{
								break;
							}
							if (!Main.tile[array2[num37] + 1, array4[num39] - 1].active() && !Main.tile[array2[num37] + 1, array4[num39] - 2].active() && !Main.tile[array2[num37] + 1, array4[num39] - 3].active() && Main.tile[array2[num37] + 1, array4[num39] - 1].liquid == 0 && Main.tile[array2[num37] + 1, array4[num39] - 2].liquid == 0 && Main.tile[array2[num37] + 1, array4[num39] - 3].liquid == 0)
							{
								flag8 = true;
							}
							else
							{
								array8[num39] = false;
							}
						}
					}
					while (flag8)
					{
						int num40 = genRand.Next(10);
						if (array8[num40])
						{
							flag8 = false;
							Main.tile[array2[num37], array4[num40] - 1].active(active: false);
							Main.tile[array2[num37], array4[num40] - 2].active(active: false);
							Main.tile[array2[num37], array4[num40] - 3].active(active: false);
							PlaceTile(array2[num37], array4[num40] - 1, 10, mute: true, forced: false, -1, style);
						}
					}
					break;
				}
			}
			bool flag9 = false;
			for (int num41 = 0; num41 < 10; num41++)
			{
				bool[] array9 = new bool[10];
				for (int num42 = 0; num42 < 5; num42++)
				{
					if (array5[num42, num41])
					{
						flag9 = true;
						array9[num42] = true;
					}
				}
				if (!flag9)
				{
					continue;
				}
				bool flag10 = true;
				while (flag10)
				{
					int num43 = genRand.Next(5);
					if (!array9[num43])
					{
						continue;
					}
					int num44 = genRand.Next(array[num43] + 2, array2[num43] - 1);
					int num45 = genRand.Next(array[num43] + 2, array2[num43] - 1);
					int num46 = 0;
					while (num45 - num44 < 2 || num45 - num44 > 5)
					{
						num44 = genRand.Next(array[num43] + 2, array2[num43] - 1);
						num45 = genRand.Next(array[num43] + 2, array2[num43] - 1);
						num46++;
						if (num46 > 10000)
						{
							break;
						}
					}
					if (num46 > 10000)
					{
						break;
					}
					for (int num47 = num44; num47 <= num45 && num47 >= 10 && num47 <= Main.maxTilesX - 10; num47++)
					{
						if (Main.tile[num47, array3[num41] - 1].active() || Main.tile[num47, array3[num41] - 1].liquid > 0)
						{
							flag10 = false;
						}
					}
					if (flag10)
					{
						for (int num48 = num44; num48 <= num45 && num48 >= 10 && num48 <= Main.maxTilesX - 10; num48++)
						{
							Main.tile[num48, array3[num41]].active(active: false);
							PlaceTile(num48, array3[num41], 19, mute: true, forced: true, -1, style2);
						}
					}
					flag10 = false;
				}
				break;
			}
		}

		public static void HellHouse(int i, int j, byte type = 76, byte wall = 13)
		{
			int num = genRand.Next(8, 20);
			int num2 = genRand.Next(1, 3);
			int num3 = genRand.Next(4, 13);
			int num4 = j;
			for (int k = 0; k < num2; k++)
			{
				int num5 = genRand.Next(5, 9);
				HellRoom(i, num4, num, num5, type, wall);
				num4 -= num5;
			}
			num4 = j;
			for (int l = 0; l < num3; l++)
			{
				int num6 = genRand.Next(5, 9);
				num4 += num6;
				HellRoom(i, num4, num, num6, type, wall);
			}
			for (int m = i - num / 2; m <= i + num / 2; m++)
			{
				for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[m, num4].active() && (Main.tile[m, num4].type == 76 || Main.tile[m, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++)
				{
				}
				int num7 = 6 + genRand.Next(3);
				while (num4 < Main.maxTilesY && !Main.tile[m, num4].active())
				{
					num7--;
					Main.tile[m, num4].active(active: true);
					Main.tile[m, num4].type = 57;
					num4++;
					if (num7 <= 0)
					{
						break;
					}
				}
			}
			int num8 = 0;
			int num9 = 0;
			for (num4 = j; num4 < Main.maxTilesY && ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14); num4++)
			{
			}
			num4--;
			num9 = num4;
			while ((Main.tile[i, num4].active() && (Main.tile[i, num4].type == 76 || Main.tile[i, num4].type == 75)) || Main.tile[i, num4].wall == 13 || Main.tile[i, num4].wall == 14)
			{
				num4--;
				if (!Main.tile[i, num4].active() || (Main.tile[i, num4].type != 76 && Main.tile[i, num4].type != 75))
				{
					continue;
				}
				int num10 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
				int num11 = genRand.Next(i - num / 2 + 1, i + num / 2 - 1);
				if (num10 > num11)
				{
					int num12 = num10;
					num10 = num11;
					num11 = num12;
				}
				if (num10 == num11)
				{
					if (num10 < i)
					{
						num11++;
					}
					else
					{
						num10--;
					}
				}
				for (int n = num10; n <= num11; n++)
				{
					if (Main.tile[n, num4 - 1].wall == 13)
					{
						Main.tile[n, num4].wall = 13;
					}
					if (Main.tile[n, num4 - 1].wall == 14)
					{
						Main.tile[n, num4].wall = 14;
					}
					Main.tile[n, num4].type = 19;
					Main.tile[n, num4].active(active: true);
				}
				num4--;
			}
			num8 = num4;
			double num13 = (double)((num9 - num8) * num) * 0.02;
			for (int num14 = 0; (double)num14 < num13; num14++)
			{
				int num15 = genRand.Next(i - num / 2, i + num / 2 + 1);
				int num16 = genRand.Next(num8, num9);
				int num17 = genRand.Next(3, 8);
				for (int num18 = num15 - num17; num18 <= num15 + num17; num18++)
				{
					for (int num19 = num16 - num17; num19 <= num16 + num17; num19++)
					{
						double num20 = Math.Abs(num18 - num15);
						double num21 = Math.Abs(num19 - num16);
						if (!(Math.Sqrt(num20 * num20 + num21 * num21) < (double)num17 * 0.4))
						{
							continue;
						}
						try
						{
							if (Main.tile[num18, num19].type == 76 || Main.tile[num18, num19].type == 19)
							{
								Main.tile[num18, num19].active(active: false);
							}
							Main.tile[num18, num19].wall = 0;
						}
						catch
						{
						}
					}
				}
			}
		}

		public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13)
		{
			if (j > Main.maxTilesY - 40)
			{
				return;
			}
			for (int k = i - width / 2; k <= i + width / 2; k++)
			{
				for (int l = j - height; l <= j; l++)
				{
					try
					{
						Main.tile[k, l].active(active: true);
						Main.tile[k, l].type = type;
						Main.tile[k, l].liquid = 0;
						Main.tile[k, l].lava(lava: false);
					}
					catch
					{
					}
				}
			}
			for (int m = i - width / 2 + 1; m <= i + width / 2 - 1; m++)
			{
				for (int n = j - height + 1; n <= j - 1; n++)
				{
					try
					{
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = wall;
						Main.tile[m, n].liquid = 0;
						Main.tile[m, n].lava(lava: false);
					}
					catch
					{
					}
				}
			}
		}

		public static void templeCleaner(int x, int y)
		{
			int num = 0;
			if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == 226)
			{
				num++;
			}
			if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == 226)
			{
				num++;
			}
			if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == 226)
			{
				num++;
			}
			if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == 226)
			{
				num++;
			}
			if (Main.tile[x, y].active() && Main.tile[x, y].type == 226)
			{
				if (num <= 1)
				{
					Main.tile[x, y].active(active: false);
					Main.tile[x, y].wall = 87;
				}
			}
			else if (!Main.tile[x, y].active() && num == 3)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = 226;
				Main.tile[x, y].liquid = 0;
				Main.tile[x, y].slope(0);
				Main.tile[x, y].halfBrick(halfBrick: false);
			}
		}

		public static Vector2D templePather(Vector2D templePath, int destX, int destY)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			int num = (int)templePath.X;
			int num2 = (int)templePath.Y;
			int num3 = genRand.Next(5, 20);
			int num4 = genRand.Next(2, 5);
			while (num3 > 0 && (num != destX || num2 != destY))
			{
				num3--;
				if (num > destX)
				{
					num--;
				}
				if (num < destX)
				{
					num++;
				}
				if (num2 > destY)
				{
					num2--;
				}
				if (num2 < destY)
				{
					num2++;
				}
				for (int i = num - num4; i < num + num4; i++)
				{
					for (int j = num2 - num4; j < num2 + num4; j++)
					{
						Main.tile[i, j].active(active: false);
						Main.tile[i, j].wall = 87;
					}
				}
			}
			return new Vector2D((double)num, (double)num2);
		}

		public static void outerTempled(int x, int y)
		{
			if ((Main.tile[x, y].active() & (Main.tile[x, y].type == 226)) || Main.tile[x, y].wall == 87)
			{
				return;
			}
			int num = 6;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (!Main.tile[i, j].active() && Main.tile[i, j].wall == 87)
					{
						i = x;
						j = y;
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 226;
						Main.tile[i, j].liquid = 0;
						Main.tile[i, j].slope(0);
						Main.tile[i, j].halfBrick(halfBrick: false);
						return;
					}
				}
			}
		}

		public static void makeTemple(int x, int y)
		{
			//IL_0940: Unknown result type (might be due to invalid IL or missing references)
			//IL_0946: Unknown result type (might be due to invalid IL or missing references)
			//IL_094b: Unknown result type (might be due to invalid IL or missing references)
			//IL_094d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0959: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b55: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b5b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b60: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b62: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b6e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c37: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c3d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c42: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c44: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c50: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e97: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ea4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f60: Unknown result type (might be due to invalid IL or missing references)
			Rectangle[] array = new Rectangle[100];
			double num = (double)Main.maxTilesX / 4200.0;
			int num2 = genRand.Next((int)(num * 10.0), (int)(num * 16.0));
			if (drunkWorldGen)
			{
				num2 *= 3;
			}
			else if (getGoodWorldGen)
			{
				num2 *= 3;
			}
			else if (remixWorldGen)
			{
				num2 *= 2;
			}
			int num3 = 1;
			if (genRand.Next(2) == 0)
			{
				num3 = -1;
			}
			int num4 = num3;
			int num5 = x;
			int num6 = y;
			int num7 = x;
			int num8 = y;
			int num9 = genRand.Next(1, 3);
			int num10 = 0;
			for (int i = 0; i < num2; i++)
			{
				num10++;
				int num11 = num3;
				int num12 = num7;
				int num13 = num8;
				bool flag = true;
				int num14 = 0;
				int num15 = 0;
				int num16 = -10;
				Rectangle rectangle = new Rectangle(num12 - num14 / 2, num13 - num15 / 2, num14, num15);
				while (flag)
				{
					num12 = num7;
					num13 = num8;
					num14 = genRand.Next(25, 50);
					num15 = genRand.Next(20, 35);
					if (num15 > num14)
					{
						num15 = num14;
					}
					if (i == num2 - 1)
					{
						num14 = genRand.Next(55, 65);
						num15 = genRand.Next(45, 50);
						if (num15 > num14)
						{
							num15 = num14;
						}
						num14 = (int)((double)num14 * 1.6);
						num15 = (int)((double)num15 * 1.35);
						num13 += genRand.Next(5, 10);
					}
					if (num10 > num9)
					{
						num13 += genRand.Next(num15 + 1, num15 + 3) + num16;
						num12 += genRand.Next(-5, 6);
						num11 = num3 * -1;
					}
					else
					{
						num12 += (genRand.Next(num14 + 1, num14 + 3) + num16) * num11;
						num13 += genRand.Next(-5, 6);
					}
					flag = false;
					rectangle = new Rectangle(num12 - num14 / 2, num13 - num15 / 2, num14, num15);
					for (int j = 0; j < i; j++)
					{
						if (rectangle.Intersects(array[j]))
						{
							flag = true;
						}
						if (genRand.Next(100) == 0)
						{
							num16++;
						}
					}
				}
				if (num10 > num9)
				{
					num9++;
					num10 = 1;
				}
				array[i] = rectangle;
				num3 = num11;
				num7 = num12;
				num8 = num13;
			}
			for (int k = 0; k < num2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					for (int m = 0; m < num2; m++)
					{
						for (int n = 0; n < 2; n++)
						{
							int num17 = array[k].X;
							if (l == 1)
							{
								num17 += array[k].Width - 1;
							}
							int num18 = array[k].Y;
							int num19 = num18 + array[k].Height;
							int num20 = array[m].X;
							if (n == 1)
							{
								num20 += array[m].Width - 1;
							}
							int y2 = array[m].Y;
							int num21 = y2 + array[m].Height;
							while (num17 != num20 || num18 != y2 || num19 != num21)
							{
								if (num17 < num20)
								{
									num17++;
								}
								if (num17 > num20)
								{
									num17--;
								}
								if (num18 < y2)
								{
									num18++;
								}
								if (num18 > y2)
								{
									num18--;
								}
								if (num19 < num21)
								{
									num19++;
								}
								if (num19 > num21)
								{
									num19--;
								}
								int num22 = num17;
								for (int num23 = num18; num23 < num19; num23++)
								{
									Main.tile[num22, num23].active(active: true);
									Main.tile[num22, num23].type = 226;
									Main.tile[num22, num23].liquid = 0;
									Main.tile[num22, num23].slope(0);
									Main.tile[num22, num23].halfBrick(halfBrick: false);
								}
							}
						}
					}
				}
			}
			for (int num24 = 0; num24 < num2; num24++)
			{
				if (false)
				{
					continue;
				}
				for (int num25 = array[num24].X; num25 < array[num24].X + array[num24].Width; num25++)
				{
					for (int num26 = array[num24].Y; num26 < array[num24].Y + array[num24].Height; num26++)
					{
						Main.tile[num25, num26].active(active: true);
						Main.tile[num25, num26].type = 226;
						Main.tile[num25, num26].liquid = 0;
						Main.tile[num25, num26].slope(0);
						Main.tile[num25, num26].halfBrick(halfBrick: false);
					}
				}
				int x2 = array[num24].X;
				int num27 = x2 + array[num24].Width;
				int y3 = array[num24].Y;
				int num28 = y3 + array[num24].Height;
				x2 += genRand.Next(3, 8);
				num27 -= genRand.Next(3, 8);
				y3 += genRand.Next(3, 8);
				num28 -= genRand.Next(3, 8);
				int num29 = x2;
				int num30 = num27;
				int num31 = y3;
				int num32 = num28;
				int num33 = (x2 + num27) / 2;
				int num34 = (y3 + num28) / 2;
				for (int num35 = x2; num35 < num27; num35++)
				{
					for (int num36 = y3; num36 < num28; num36++)
					{
						if (genRand.Next(20) == 0)
						{
							num31 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num32 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num29 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num30 += genRand.Next(-1, 2);
						}
						if (num29 < x2)
						{
							num29 = x2;
						}
						if (num30 > num27)
						{
							num30 = num27;
						}
						if (num31 < y3)
						{
							num31 = y3;
						}
						if (num32 > num28)
						{
							num32 = num28;
						}
						if (num29 > num33)
						{
							num29 = num33;
						}
						if (num30 < num33)
						{
							num30 = num33;
						}
						if (num31 > num34)
						{
							num31 = num34;
						}
						if (num32 < num34)
						{
							num32 = num34;
						}
						if (num35 >= num29 && num35 < num30 && num36 >= num31 && num36 <= num32)
						{
							Main.tile[num35, num36].active(active: false);
							Main.tile[num35, num36].wall = 87;
						}
					}
				}
				for (int num37 = num28; num37 > y3; num37--)
				{
					for (int num38 = num27; num38 > x2; num38--)
					{
						if (genRand.Next(20) == 0)
						{
							num31 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num32 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num29 += genRand.Next(-1, 2);
						}
						if (genRand.Next(20) == 0)
						{
							num30 += genRand.Next(-1, 2);
						}
						if (num29 < x2)
						{
							num29 = x2;
						}
						if (num30 > num27)
						{
							num30 = num27;
						}
						if (num31 < y3)
						{
							num31 = y3;
						}
						if (num32 > num28)
						{
							num32 = num28;
						}
						if (num29 > num33)
						{
							num29 = num33;
						}
						if (num30 < num33)
						{
							num30 = num33;
						}
						if (num31 > num34)
						{
							num31 = num34;
						}
						if (num32 < num34)
						{
							num32 = num34;
						}
						if (num38 >= num29 && num38 < num30 && num37 >= num31 && num37 <= num32)
						{
							Main.tile[num38, num37].active(active: false);
							Main.tile[num38, num37].wall = 87;
						}
					}
				}
			}
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)num5, (double)num6);
			for (int num39 = 0; num39 < num2; num39++)
			{
				Rectangle rectangle2 = array[num39];
				rectangle2.X += 8;
				rectangle2.Y += 8;
				rectangle2.Width -= 16;
				rectangle2.Height -= 16;
				bool flag2 = true;
				while (flag2)
				{
					int num40 = genRand.Next(rectangle2.X, rectangle2.X + rectangle2.Width);
					int num41 = genRand.Next(rectangle2.Y, rectangle2.Y + rectangle2.Height);
					if (num39 == num2 - 1)
					{
						num40 = rectangle2.X + rectangle2.Width / 2 + genRand.Next(-10, 10);
						num41 = rectangle2.Y + rectangle2.Height / 2 + genRand.Next(-10, 10);
					}
					val = templePather(val, num40, num41);
					if (val.X == (double)num40 && val.Y == (double)num41)
					{
						flag2 = false;
					}
				}
				if (num39 >= num2 - 1)
				{
					continue;
				}
				if (genRand.Next(3) != 0)
				{
					int num42 = num39 + 1;
					if (array[num42].Y >= array[num39].Y + array[num39].Height)
					{
						rectangle2.X = array[num42].X;
						if (num39 == 0)
						{
							if (num3 > 0)
							{
								rectangle2.X += (int)((double)array[num42].Width * 0.8);
							}
							else
							{
								rectangle2.X += (int)((double)array[num42].Width * 0.2);
							}
						}
						else if (array[num42].X < array[num39].X)
						{
							rectangle2.X += (int)((double)array[num42].Width * 0.2);
						}
						else
						{
							rectangle2.X += (int)((double)array[num42].Width * 0.8);
						}
						rectangle2.Y = array[num42].Y;
					}
					else
					{
						rectangle2.X = (array[num39].X + array[num39].Width / 2 + array[num42].X + array[num42].Width / 2) / 2;
						rectangle2.Y = (int)((double)array[num42].Y + (double)array[num42].Height * 0.8);
					}
					int x3 = rectangle2.X;
					int y4 = rectangle2.Y;
					flag2 = true;
					while (flag2)
					{
						int num43 = genRand.Next(x3 - 6, x3 + 7);
						int num44 = genRand.Next(y4 - 6, y4 + 7);
						val = templePather(val, num43, num44);
						if (val.X == (double)num43 && val.Y == (double)num44)
						{
							flag2 = false;
						}
					}
					continue;
				}
				int num45 = num39 + 1;
				int num46 = (array[num39].X + array[num39].Width / 2 + array[num45].X + array[num45].Width / 2) / 2;
				int num47 = (array[num39].Y + array[num39].Height / 2 + array[num45].Y + array[num45].Height / 2) / 2;
				flag2 = true;
				while (flag2)
				{
					int num48 = genRand.Next(num46 - 6, num46 + 7);
					int num49 = genRand.Next(num47 - 6, num47 + 7);
					val = templePather(val, num48, num49);
					if (val.X == (double)num48 && val.Y == (double)num49)
					{
						flag2 = false;
					}
				}
			}
			int num50 = Main.maxTilesX - 20;
			int num51 = 20;
			int num52 = Main.maxTilesY - 20;
			int num53 = 20;
			for (int num54 = 0; num54 < num2; num54++)
			{
				if (array[num54].X < num50)
				{
					num50 = array[num54].X;
				}
				if (array[num54].X + array[num54].Width > num51)
				{
					num51 = array[num54].X + array[num54].Width;
				}
				if (array[num54].Y < num52)
				{
					num52 = array[num54].Y;
				}
				if (array[num54].Y + array[num54].Height > num53)
				{
					num53 = array[num54].Y + array[num54].Height;
				}
			}
			num50 -= 10;
			num51 += 10;
			num52 -= 10;
			num53 += 10;
			for (int num55 = num50; num55 < num51; num55++)
			{
				for (int num56 = num52; num56 < num53; num56++)
				{
					outerTempled(num55, num56);
				}
			}
			for (int num57 = num51; num57 >= num50; num57--)
			{
				for (int num58 = num52; num58 < num53 / 2; num58++)
				{
					outerTempled(num57, num58);
				}
			}
			for (int num59 = num52; num59 < num53; num59++)
			{
				for (int num60 = num50; num60 < num51; num60++)
				{
					outerTempled(num60, num59);
				}
			}
			for (int num61 = num53; num61 >= num52; num61--)
			{
				for (int num62 = num50; num62 < num51; num62++)
				{
					outerTempled(num62, num61);
				}
			}
			num3 = -num4;
			Vector2D val2 = default(Vector2D);
			((Vector2D)(ref val2))._002Ector((double)num5, (double)num6);
			int num63 = genRand.Next(2, 5);
			bool flag3 = true;
			int num64 = 0;
			int num65 = genRand.Next(9, 14);
			while (flag3)
			{
				num64++;
				if (num64 >= num65)
				{
					num64 = 0;
					val2.Y -= 1.0;
				}
				val2.X += num3;
				int num66 = (int)val2.X;
				flag3 = false;
				for (int num67 = (int)val2.Y - num63; (double)num67 < val2.Y + (double)num63; num67++)
				{
					if (Main.tile[num66, num67].wall == 87 || (Main.tile[num66, num67].active() && Main.tile[num66, num67].type == 226))
					{
						flag3 = true;
					}
					if (Main.tile[num66, num67].active() && Main.tile[num66, num67].type == 226)
					{
						Main.tile[num66, num67].active(active: false);
						Main.tile[num66, num67].wall = 87;
					}
				}
			}
			int num68 = num5;
			int num69;
			for (num69 = num6; !Main.tile[num68, num69].active(); num69++)
			{
			}
			num69 -= 4;
			int num70 = num69;
			while ((Main.tile[num68, num70].active() && Main.tile[num68, num70].type == 226) || Main.tile[num68, num70].wall == 87)
			{
				num70--;
			}
			num70 += 2;
			for (int num71 = num68 - 1; num71 <= num68 + 1; num71++)
			{
				for (int num72 = num70; num72 <= num69; num72++)
				{
					Main.tile[num71, num72].active(active: true);
					Main.tile[num71, num72].type = 226;
					Main.tile[num71, num72].liquid = 0;
					Main.tile[num71, num72].slope(0);
					Main.tile[num71, num72].halfBrick(halfBrick: false);
				}
			}
			for (int num73 = num68 - 4; num73 <= num68 + 4; num73++)
			{
				for (int num74 = num69 - 1; num74 < num69 + 3; num74++)
				{
					Main.tile[num73, num74].active(active: false);
					Main.tile[num73, num74].wall = 87;
				}
			}
			for (int num75 = num68 - 1; num75 <= num68 + 1; num75++)
			{
				for (int num76 = num69 - 5; num76 <= num69 + 8; num76++)
				{
					Main.tile[num75, num76].active(active: true);
					Main.tile[num75, num76].type = 226;
					Main.tile[num75, num76].liquid = 0;
					Main.tile[num75, num76].slope(0);
					Main.tile[num75, num76].halfBrick(halfBrick: false);
				}
			}
			for (int num77 = num68 - 3; num77 <= num68 + 3; num77++)
			{
				for (int num78 = num69 - 2; num78 < num69 + 3; num78++)
				{
					if (num78 >= num69 || num77 < num5 - 1 || num77 > num5 + 1)
					{
						Main.tile[num77, num78].active(active: false);
						Main.tile[num77, num78].wall = 87;
					}
				}
			}
			PlaceTile(num68, num69, 10, mute: true, forced: false, -1, 11);
			for (int num79 = num50; num79 < num51; num79++)
			{
				for (int num80 = num52; num80 < num53; num80++)
				{
					templeCleaner(num79, num80);
				}
			}
			for (int num81 = num53; num81 >= num52; num81--)
			{
				for (int num82 = num51; num82 >= num50; num82--)
				{
					templeCleaner(num82, num81);
				}
			}
			for (int num83 = num50; num83 < num51; num83++)
			{
				for (int num84 = num52; num84 < num53; num84++)
				{
					bool flag4 = true;
					for (int num85 = num83 - 1; num85 <= num83 + 1; num85++)
					{
						for (int num86 = num84 - 1; num86 <= num84 + 1; num86++)
						{
							if ((!Main.tile[num85, num86].active() || Main.tile[num85, num86].type != 226) && Main.tile[num85, num86].wall != 87)
							{
								flag4 = false;
								break;
							}
						}
					}
					if (flag4)
					{
						Main.tile[num83, num84].wall = 87;
					}
				}
			}
			int num87 = 0;
			Rectangle rectangle3 = array[num2 - 1];
			int num88 = rectangle3.Width / 2;
			int num89 = rectangle3.Height / 2;
			while (true)
			{
				num87++;
				int num90 = rectangle3.X + num88 + 15 - genRand.Next(30);
				int num91 = rectangle3.Y + num89 + 15 - genRand.Next(30);
				PlaceTile(num90, num91, 237);
				if (Main.tile[num90, num91].type == 237)
				{
					GenVars.lAltarX = num90 - Main.tile[num90, num91].frameX / 18;
					GenVars.lAltarY = num91 - Main.tile[num90, num91].frameY / 18;
					break;
				}
				if (num87 < 1000)
				{
					continue;
				}
				num90 = rectangle3.X + num88;
				num91 = rectangle3.Y + num89;
				num90 += genRand.Next(-10, 11);
				for (num91 += genRand.Next(-10, 11); !Main.tile[num90, num91].active(); num91++)
				{
				}
				Main.tile[num90 - 1, num91].active(active: true);
				Main.tile[num90 - 1, num91].slope(0);
				Main.tile[num90 - 1, num91].halfBrick(halfBrick: false);
				Main.tile[num90 - 1, num91].type = 226;
				Main.tile[num90, num91].active(active: true);
				Main.tile[num90, num91].slope(0);
				Main.tile[num90, num91].halfBrick(halfBrick: false);
				Main.tile[num90, num91].type = 226;
				Main.tile[num90 + 1, num91].active(active: true);
				Main.tile[num90 + 1, num91].slope(0);
				Main.tile[num90 + 1, num91].halfBrick(halfBrick: false);
				Main.tile[num90 + 1, num91].type = 226;
				num91 -= 2;
				num90--;
				for (int num92 = -1; num92 <= 3; num92++)
				{
					for (int num93 = -1; num93 <= 1; num93++)
					{
						x = num90 + num92;
						y = num91 + num93;
						Main.tile[x, y].active(active: false);
					}
				}
				GenVars.lAltarX = num90;
				GenVars.lAltarY = num91;
				for (int num94 = 0; num94 <= 2; num94++)
				{
					for (int num95 = 0; num95 <= 1; num95++)
					{
						x = num90 + num94;
						y = num91 + num95;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].type = 237;
						Main.tile[x, y].frameX = (short)(num94 * 18);
						Main.tile[x, y].frameY = (short)(num95 * 18);
					}
				}
				for (int num96 = 0; num96 <= 2; num96++)
				{
					for (int num97 = 0; num97 <= 1; num97++)
					{
						x = num90 + num96;
						y = num91 + num97;
						SquareTileFrame(x, y);
					}
				}
				break;
			}
			double num98 = (double)num2 * 1.1;
			num98 *= 1.0 + (double)genRand.Next(-25, 26) * 0.01;
			if (drunkWorldGen)
			{
				num98 *= 1.5;
			}
			int num99 = 0;
			while (num98 > 0.0)
			{
				num99++;
				int num100 = genRand.Next(num2);
				int num101 = genRand.Next(array[num100].X, array[num100].X + array[num100].Width);
				int num102 = genRand.Next(array[num100].Y, array[num100].Y + array[num100].Height);
				if (Main.tile[num101, num102].wall == 87 && !Main.tile[num101, num102].active())
				{
					bool flag5 = false;
					if (genRand.Next(2) == 0)
					{
						int num103 = 1;
						if (genRand.Next(2) == 0)
						{
							num103 = -1;
						}
						for (; !Main.tile[num101, num102].active(); num102 += num103)
						{
						}
						num102 -= num103;
						int num104 = genRand.Next(2);
						int num105 = genRand.Next(3, 10);
						bool flag6 = true;
						for (int num106 = num101 - num105; num106 < num101 + num105; num106++)
						{
							for (int num107 = num102 - num105; num107 < num102 + num105; num107++)
							{
								if (Main.tile[num106, num107].active() && (Main.tile[num106, num107].type == 10 || Main.tile[num106, num107].type == 237))
								{
									flag6 = false;
									break;
								}
							}
						}
						if (flag6)
						{
							for (int num108 = num101 - num105; num108 < num101 + num105; num108++)
							{
								for (int num109 = num102 - num105; num109 < num102 + num105; num109++)
								{
									if (!SolidTile(num108, num109) || Main.tile[num108, num109].type == 232 || SolidTile(num108, num109 - num103))
									{
										continue;
									}
									Main.tile[num108, num109].type = 232;
									flag5 = true;
									if (num104 == 0)
									{
										Main.tile[num108, num109 - 1].type = 232;
										Main.tile[num108, num109 - 1].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num108, num109 - 2].type = 232;
											Main.tile[num108, num109 - 2].active(active: true);
										}
									}
									else
									{
										Main.tile[num108, num109 + 1].type = 232;
										Main.tile[num108, num109 + 1].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num108, num109 + 2].type = 232;
											Main.tile[num108, num109 + 2].active(active: true);
										}
									}
									num104++;
									if (num104 > 1)
									{
										num104 = 0;
									}
								}
							}
						}
						if (flag5)
						{
							num99 = 0;
							num98 -= 1.0;
						}
					}
					else
					{
						int num110 = 1;
						if (genRand.Next(2) == 0)
						{
							num110 = -1;
						}
						for (; !Main.tile[num101, num102].active(); num101 += num110)
						{
						}
						num101 -= num110;
						int num111 = genRand.Next(2);
						int num112 = genRand.Next(3, 10);
						bool flag7 = true;
						for (int num113 = num101 - num112; num113 < num101 + num112; num113++)
						{
							for (int num114 = num102 - num112; num114 < num102 + num112; num114++)
							{
								if (Main.tile[num113, num114].active() && Main.tile[num113, num114].type == 10)
								{
									flag7 = false;
									break;
								}
							}
						}
						if (flag7)
						{
							for (int num115 = num101 - num112; num115 < num101 + num112; num115++)
							{
								for (int num116 = num102 - num112; num116 < num102 + num112; num116++)
								{
									if (!SolidTile(num115, num116) || Main.tile[num115, num116].type == 232 || SolidTile(num115 - num110, num116))
									{
										continue;
									}
									Main.tile[num115, num116].type = 232;
									flag5 = true;
									if (num111 == 0)
									{
										Main.tile[num115 - 1, num116].type = 232;
										Main.tile[num115 - 1, num116].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num115 - 2, num116].type = 232;
											Main.tile[num115 - 2, num116].active(active: true);
										}
									}
									else
									{
										Main.tile[num115 + 1, num116].type = 232;
										Main.tile[num115 + 1, num116].active(active: true);
										if (drunkWorldGen)
										{
											Main.tile[num115 - 2, num116].type = 232;
											Main.tile[num115 - 2, num116].active(active: true);
										}
									}
									num111++;
									if (num111 > 1)
									{
										num111 = 0;
									}
								}
							}
						}
						if (flag5)
						{
							num99 = 0;
							num98 -= 1.0;
						}
					}
				}
				if (num99 > 1000)
				{
					num99 = 0;
					num98 -= 1.0;
				}
			}
			GenVars.tLeft = num50;
			GenVars.tRight = num51;
			GenVars.tTop = num52;
			GenVars.tBottom = num53;
			GenVars.tRooms = num2;
		}

		public static void templePart2()
		{
			int tLeft = GenVars.tLeft;
			int tRight = GenVars.tRight;
			int tTop = GenVars.tTop;
			int tBottom = GenVars.tBottom;
			int tRooms = GenVars.tRooms;
			double num = (double)tRooms * 1.9;
			num *= 1.0 + (double)genRand.Next(-15, 16) * 0.01;
			int num2 = 0;
			while (num > 0.0)
			{
				int num3 = genRand.Next(tLeft, tRight);
				int num4 = genRand.Next(tTop, tBottom);
				if (Main.tile[num3, num4].wall == 87 && !Main.tile[num3, num4].active())
				{
					if (mayanTrap(num3, num4))
					{
						num -= 1.0;
						num2 = 0;
					}
					else
					{
						num2++;
					}
				}
				else
				{
					num2++;
				}
				if (num2 > 100)
				{
					num2 = 0;
					num -= 1.0;
				}
			}
			Main.tileSolid[232] = false;
			double num5 = (double)tRooms * 0.35;
			num5 *= 1.0 + (double)genRand.Next(-15, 16) * 0.01;
			int contain = 1293;
			num2 = 0;
			while (num5 > 0.0)
			{
				int num6 = genRand.Next(tLeft, tRight);
				int num7 = genRand.Next(tTop, tBottom);
				if (Main.tile[num6, num7].wall == 87 && !Main.tile[num6, num7].active() && AddBuriedChest(num6, num7, contain, notNearOtherChests: true, 16, trySlope: false, 0))
				{
					num5 -= 1.0;
					num2 = 0;
				}
				num2++;
				if (num2 > 10000)
				{
					break;
				}
			}
			double num8 = (double)tRooms * 1.25;
			num8 *= 1.0 + (double)genRand.Next(-25, 36) * 0.01;
			num2 = 0;
			while (num8 > 0.0)
			{
				num2++;
				int num9 = genRand.Next(tLeft, tRight);
				int num10 = genRand.Next(tTop, tBottom);
				if (Main.tile[num9, num10].wall != 87 || Main.tile[num9, num10].active())
				{
					continue;
				}
				int num11 = num9;
				int num12 = num10;
				while (!Main.tile[num11, num12].active())
				{
					num12++;
					if (num12 > tBottom)
					{
						break;
					}
				}
				num12--;
				if (num12 <= tBottom)
				{
					PlaceTile(num11, num12, 105, mute: true, forced: false, -1, genRand.Next(43, 46));
					if (Main.tile[num11, num12].type == 105)
					{
						num8 -= 1.0;
					}
				}
			}
			double num13 = (double)tRooms * 1.35;
			num13 *= 1.0 + (double)genRand.Next(-15, 26) * 0.01;
			num2 = 0;
			while (num13 > 0.0)
			{
				num2++;
				int num14 = genRand.Next(tLeft, tRight);
				int num15 = genRand.Next(tTop, tBottom);
				if (Main.tile[num14, num15].wall == 87 && !Main.tile[num14, num15].active())
				{
					int num16 = num14;
					int num17 = num15;
					while (!Main.tile[num16, num17].active())
					{
						num17++;
						if (num17 > tBottom)
						{
							break;
						}
					}
					num17--;
					if (num17 <= tBottom)
					{
						switch (genRand.Next(3))
						{
						case 0:
							PlaceTile(num16, num17, 18, mute: true, forced: false, -1, 10);
							if (Main.tile[num16, num17].type == 18)
							{
								num13 -= 1.0;
							}
							break;
						case 1:
							PlaceTile(num16, num17, 14, mute: true, forced: false, -1, 9);
							if (Main.tile[num16, num17].type == 14)
							{
								num13 -= 1.0;
							}
							break;
						case 2:
							PlaceTile(num16, num17, 15, mute: true, forced: false, -1, 12);
							if (Main.tile[num16, num17].type == 15)
							{
								num13 -= 1.0;
							}
							break;
						}
					}
				}
				if (num2 > 10000)
				{
					break;
				}
			}
			int num18 = 1;
			if (Main.maxTilesX > 4200)
			{
				num18++;
			}
			if (Main.maxTilesX > 6400)
			{
				num18 += genRand.Next(2);
			}
			num2 = 0;
			while (num18 > 0)
			{
				num2++;
				int num19 = genRand.Next(tLeft, tRight);
				int num20 = genRand.Next(tTop, tBottom);
				if (Main.tile[num19, num20].wall == 87 && !Main.tile[num19, num20].active())
				{
					bool flag = false;
					for (int i = -70; i <= 70; i++)
					{
						for (int j = -70; j <= 70; j++)
						{
							int num21 = i + num19;
							int num22 = j + num20;
							if (!InWorld(num21, num22, 5))
							{
								continue;
							}
							Tile tile = Main.tile[num21, num22];
							if (tile.active())
							{
								if (tile.type == 240)
								{
									flag = true;
									break;
								}
								if (i >= -4 && i <= 4 && j >= -4 && j <= 4 && tile.type == 226)
								{
									flag = true;
									break;
								}
							}
						}
						if (flag)
						{
							break;
						}
					}
					if (flag)
					{
						continue;
					}
					if (PlaceTile(num19, num20, 240, mute: true, forced: false, -1, 88))
					{
						num18--;
					}
				}
				if (num2 > 10000)
				{
					break;
				}
			}
			Main.tileSolid[232] = true;
		}

		public static bool nearPicture(int x, int y)
		{
			for (int i = x - 4; i <= x + 3; i++)
			{
				for (int j = y - 3; j <= y + 2; j++)
				{
					if (Main.tile[i, j].active())
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool nearPicture2(int x, int y)
		{
			if (Main.tile[x, y].wall != 7 && Main.tile[x, y].wall != 8 && Main.tile[x, y].wall != 9)
			{
				for (int i = x - 8; i <= x + 8; i++)
				{
					for (int j = y - 5; j <= y + 5; j++)
					{
						if (Main.tile[i, j].active() && (Main.tile[i, j].type == 240 || Main.tile[i, j].type == 241 || Main.tile[i, j].type == 242))
						{
							return true;
						}
					}
				}
			}
			else
			{
				for (int k = x - 15; k <= x + 15; k++)
				{
					for (int l = y - 10; l <= y + 10; l++)
					{
						if (Main.tile[k, l].active() && (Main.tile[k, l].type == 240 || Main.tile[k, l].type == 241 || Main.tile[k, l].type == 242))
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private static void ShimmerCleanUp()
		{
			ShimmerRemoveWater();
			int num = 120;
			int num2 = 90;
			int num3 = (int)GenVars.shimmerPosition.X - num;
			int num4 = (int)GenVars.shimmerPosition.X + num;
			int num5 = (int)GenVars.shimmerPosition.Y - num;
			int num6 = (int)GenVars.shimmerPosition.Y + num;
			_ = num / 4;
			for (int i = num5; i <= num6; i++)
			{
				for (int j = num3; j <= num4; j++)
				{
					int num7 = (int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y), 2.0));
					if (num7 < num)
					{
						if (Main.tile[j, i].type == 22 || Main.tile[j, i].type == 204)
						{
							Main.tile[j, i].type = 1;
						}
						if (Main.tile[j, i].type == 51 || Main.tile[j, i].type == 56 || Main.tile[j, i].type == 229 || Main.tile[j, i].type == 230 || Main.tile[j, i].type == 659)
						{
							Main.tile[j, i].active(active: false);
						}
						if (TileID.Sets.Conversion.Moss[Main.tile[j, i].type])
						{
							Main.tile[j, i].type = 1;
						}
						if (Main.tile[j, i].type == 184)
						{
							Main.tile[j, i].active(active: false);
						}
					}
					num7 = ((!((double)i > GenVars.shimmerPosition.Y)) ? ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y) * 1.4 * (1.0 + genRand.NextDouble() * 0.02), 2.0))) : ((int)Math.Sqrt(Math.Pow(Math.Abs((double)j - GenVars.shimmerPosition.X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow(Math.Abs((double)i - GenVars.shimmerPosition.Y) * 1.2 * (1.0 + genRand.NextDouble() * 0.02), 2.0))));
					if (num7 < num2)
					{
						Convert(j, i, 0, 3);
					}
				}
			}
			int num8 = (int)GenVars.shimmerPosition.X;
			int num9 = (int)GenVars.shimmerPosition.Y;
			byte b = 127;
			Liquid.tilesIgnoreWater(ignoreSolids: true);
			while (Main.tile[num8, num9].liquid <= b || !Main.tile[num8, num9].shimmer())
			{
				while (!Main.tile[num8, num9].active())
				{
					Main.tile[num8, num9].liquid = b;
					Main.tile[num8, num9].shimmer(shimmer: true);
					num8--;
				}
				for (num8 = (int)GenVars.shimmerPosition.X; !Main.tile[num8, num9].active(); num8++)
				{
					Main.tile[num8, num9].liquid = b;
					Main.tile[num8, num9].shimmer(shimmer: true);
				}
				num8 = (int)GenVars.shimmerPosition.X;
				num9++;
				b = byte.MaxValue;
				if (Main.tile[num8, num9].active())
				{
					break;
				}
			}
			if (tenthAnniversaryWorldGen)
			{
				int num10 = 170;
				for (int k = (int)GenVars.shimmerPosition.X - num10; (double)k <= GenVars.shimmerPosition.X + (double)num10; k++)
				{
					for (int l = (int)GenVars.shimmerPosition.Y + 40; l < Main.maxTilesY - 330 - 100; l++)
					{
						if (InWorld(k, l))
						{
							if (Main.tile[k, l].type == 375 || Main.tile[k, l].type == 374 || Main.tile[k, l].type == 373)
							{
								Main.tile[k, l].active(active: false);
							}
							if (Main.tile[k, l].liquid > 0 && !Main.tile[k, l].shimmer())
							{
								Shimmerator(k, l);
							}
						}
					}
				}
			}
			Liquid.tilesIgnoreWater(ignoreSolids: false);
			for (int m = 10; m < Main.maxTilesX - 10; m++)
			{
				for (int n = 10; n < Main.maxTilesY - 10; n++)
				{
					if (Main.tile[m, n].liquid > 0 && Main.tile[m, n].shimmer() && Main.tile[m, n].type == 5)
					{
						KillTile(m, n);
					}
				}
			}
		}

		public static void ShimmerRemoveWater()
		{
			int num = 150;
			int num2 = (int)GenVars.shimmerPosition.X - num;
			int num3 = (int)GenVars.shimmerPosition.X + num;
			int num4 = (int)GenVars.shimmerPosition.Y - num;
			int num5 = (int)GenVars.shimmerPosition.Y + num / 2;
			for (int i = num4; i <= num5; i++)
			{
				for (int j = num2; j <= num3; j++)
				{
					if (InWorld(j, i) && (int)Math.Sqrt(Math.Pow(Math.Abs(j - (int)GenVars.shimmerPosition.X), 2.0) + Math.Pow(Math.Abs(i - (int)GenVars.shimmerPosition.Y), 2.0)) < num && !Main.tile[j, i].shimmer())
					{
						Main.tile[j, i].liquid = 0;
					}
				}
			}
		}

		public static bool ShimmerMakeBiome(int X, int Y)
		{
			int num = genRand.Next(2);
			double num2 = 0.6;
			double num3 = 1.3;
			double num4 = 0.3;
			if (num == 0)
			{
				num2 = 0.55;
				num3 = 2.0;
			}
			num2 *= 1.05 - genRand.NextDouble() * 0.1;
			num3 *= 1.05 - genRand.NextDouble() * 0.1;
			num4 *= 1.0 - genRand.NextDouble() * 0.1;
			int num5 = genRand.Next(105, 125);
			int num6 = (int)((double)num5 * num4);
			int num7 = (int)((double)num5 * num2);
			int num8 = genRand.Next(9, 13);
			int num9 = X - num5;
			int num10 = X + num5;
			int num11 = Y - num5;
			int num12 = Y + num5;
			for (int i = num11; i <= num12; i++)
			{
				for (int j = num9; j <= num10; j++)
				{
					if (!InWorld(j, i, 50))
					{
						return false;
					}
					if (Main.tile[j, i].type == 203 || Main.tile[j, i].type == 25)
					{
						return false;
					}
				}
			}
			int num13 = Y;
			if (genRand.Next(4) == 0)
			{
				num13 = Y - genRand.Next(2);
			}
			int num14 = Y - num8;
			if (genRand.Next(4) == 0)
			{
				num14 = Y - num8 - genRand.Next(2);
			}
			for (int k = num11; k <= num12; k++)
			{
				for (int l = num9; l <= num10; l++)
				{
					Main.tile[l, k].liquid = 0;
					if (genRand.Next(4) == 0)
					{
						num13 = Y - genRand.Next(2);
					}
					if (genRand.Next(4) == 0)
					{
						num14 = Y - num8 + genRand.Next(2);
					}
					int num15 = ((k <= Y) ? ((int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * 1.4 * (1.0 + genRand.NextDouble() * 0.02), 2.0))) : ((int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * 1.2 * (1.0 + genRand.NextDouble() * 0.02), 2.0))));
					if (num15 < num5)
					{
						Main.tile[l, k].color(0);
						Main.tile[l, k].wallColor(0);
						Main.tile[l, k].slope(0);
						Main.tile[l, k].halfBrick(halfBrick: false);
						Main.tile[l, k].type = 1;
						if (l > num9 + 5 + genRand.Next(2) && l < num10 - 5 - genRand.Next(2))
						{
							Main.tile[l, k].active(active: true);
						}
						if ((double)num15 < (double)num5 * 0.9)
						{
							Main.tile[l, k].wall = 0;
						}
					}
					num15 = (int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)Math.Abs(k - Y) * num3 * (1.0 + genRand.NextDouble() * 0.02), 2.0));
					if (k > num14 && k < num13)
					{
						Main.tile[l, k].active(active: false);
					}
					if (k < num13 && num15 < (int)((double)num7 * (1.0 + genRand.NextDouble() * 0.02)))
					{
						Main.tile[l, k].active(active: false);
					}
					num15 = (int)Math.Sqrt(Math.Pow((double)Math.Abs(l - X) * (1.0 + genRand.NextDouble() * 0.02), 2.0) + Math.Pow((double)(Math.Abs(k - Y) * 2) * (1.0 + genRand.NextDouble() * 0.02), 2.0));
					if (k < Y - 1 || num15 >= (int)((double)num6 * (1.0 + genRand.NextDouble() * 0.025)))
					{
						continue;
					}
					if (k <= Y + 2 || num15 != num6 - 1 || genRand.Next(2) != 0)
					{
						Main.tile[l, k].active(active: false);
					}
					if (k >= Y)
					{
						if (k == Y)
						{
							Main.tile[l, k].liquid = 127;
						}
						else
						{
							Main.tile[l, k].liquid = byte.MaxValue;
						}
						Main.tile[l, k].shimmer(shimmer: true);
					}
				}
			}
			if (num == 0)
			{
				num9 = (int)((double)X - (double)num5 * num4) - genRand.Next(-15, 1) - 5;
				num10 = (int)((double)X + (double)num5 * num4) + genRand.Next(0, 16);
				int m = num9;
				int num16 = 0;
				for (; m < num10; m += genRand.Next(9, 14))
				{
					int num17 = Y - 3;
					while (!Main.tile[m, num17].active())
					{
						num17--;
					}
					num17 -= 4;
					int num18 = genRand.Next(5, 10);
					int num19 = genRand.Next(15, 21);
					int n = m - num18;
					while (num18 > 0)
					{
						for (n = m - num18; n < m + num18; n++)
						{
							Main.tile[n, num17].active(active: true);
							Main.tile[n, num17].type = 1;
						}
						num16++;
						if (genRand.Next(3) < num16)
						{
							num16 = 0;
							num18--;
							m += genRand.Next(-1, 2);
						}
						if (num19 <= 0)
						{
							num18--;
						}
						num19--;
						num17++;
					}
					n -= genRand.Next(1, 3);
					Main.tile[n, num17 - 2].active(active: true);
					Main.tile[n, num17 - 2].type = 1;
					Main.tile[n, num17 - 1].active(active: true);
					Main.tile[n, num17 - 1].type = 1;
					Main.tile[n, num17].active(active: true);
					Main.tile[n, num17].type = 1;
					if (genRand.Next(2) == 0)
					{
						Main.tile[n, num17 + 1].active(active: true);
						Main.tile[n, num17 + 1].type = 1;
						PlaceTight(n, num17 + 2);
					}
					else
					{
						PlaceTight(n, num17 + 1);
					}
				}
			}
			ShimmerMakeBiomeOpening(-1, X - num5, Y, num8);
			ShimmerMakeBiomeOpening(1, X + num5, Y, num8);
			int num20 = 70;
			for (int num21 = 0; num21 < 500; num21++)
			{
				int num22 = genRand.Next(X - num20, X + num20);
				int num23 = genRand.Next(Y - 2, Y + 3);
				int num24 = genRand.Next(7);
				int treeTileType = 0;
				switch (num24)
				{
				case 0:
					treeTileType = 583;
					break;
				case 1:
					treeTileType = 584;
					break;
				case 2:
					treeTileType = 585;
					break;
				case 3:
					treeTileType = 586;
					break;
				case 4:
					treeTileType = 587;
					break;
				case 5:
					treeTileType = 588;
					break;
				case 6:
					treeTileType = 589;
					break;
				}
				if (SolidTile(num22 - 1, num23) && SolidTile(num22 + 1, num23))
				{
					TryGrowingTreeByType(treeTileType, num22, num23);
				}
			}
			return true;
		}

		private static void ShimmerMakeBiomeOpening(int direction, int X, int Y, int caveOpenningSize)
		{
			int num = X;
			caveOpenningSize--;
			bool flag;
			do
			{
				num += direction;
				flag = true;
				for (int i = Y - caveOpenningSize + 1; i < Y - 1; i++)
				{
					if (SolidTile(num, i))
					{
						flag = false;
					}
					if (SolidTile(num + direction, i))
					{
						flag = false;
					}
					if (SolidTile(num + direction * 2, i))
					{
						flag = false;
					}
					Main.tile[num, i].active(active: false);
				}
				for (int j = Y - caveOpenningSize; j < Y; j++)
				{
					Main.tile[num - direction, j].active(active: false);
				}
				if (SolidTile(num - direction, Y - caveOpenningSize - 1))
				{
					Main.tile[num - direction, Y - caveOpenningSize - 1].wall = 0;
				}
				if (SolidTile(num - direction, Y))
				{
					Main.tile[num - direction, Y].wall = 0;
				}
				if (genRand.Next(2) == 0)
				{
					Y += genRand.Next(-1, 2);
				}
			}
			while (!flag && num >= 50 && num <= Main.maxTilesX - 50 && Math.Abs(num - X) <= 100);
		}

		private static void Shimminate()
		{
			foreach (KeyValuePair<Point, bool> countedTile in CountedTiles)
			{
				Point key = countedTile.Key;
				Main.tile[key.X, key.Y].shimmer(shimmer: true);
				Main.tile[key.X, key.Y].liquid = byte.MaxValue;
				if (Main.tile[key.X, key.Y].type == 5 || Main.tile[key.X, key.Y].type == 56 || (Main.tileCut[Main.tile[key.X, key.Y].type] && Main.tile[key.X, key.Y].type != 28))
				{
					KillTile(key.X, key.Y);
				}
			}
		}

		public static void Shimmerator(int x, int y, bool jungle = false, bool lavaOk = false)
		{
			numTileCount = 0;
			CountedTiles.Clear();
			ShimmeratorNext(x, y);
			if (numTileCount > 0 && numTileCount < maxTileCount)
			{
				Shimminate();
			}
		}

		private static void ShimmeratorNext(int x, int y)
		{
			if (numTileCount < maxTileCount)
			{
				if (x <= 1 || x >= Main.maxTilesX - 1 || y <= 1 || y >= Main.maxTilesY - 1)
				{
					numTileCount = maxTileCount;
				}
				else if (!CountedTiles.ContainsKey(new Point(x, y)) && ((!SolidTile(x, y) && !Main.tile[x, y].shimmer() && Main.tile[x, y].liquid > 0) || (Main.tile[x, y].active() && Main.tile[x, y].type == 56)))
				{
					CountedTiles.Add(new Point(x, y), value: true);
					numTileCount++;
					ShimmeratorNext(x - 1, y);
					ShimmeratorNext(x + 1, y);
					ShimmeratorNext(x, y - 1);
					ShimmeratorNext(x, y + 1);
				}
			}
		}

		public static void MakeDungeon(int x, int y)
		{
			GenVars.dEnteranceX = 0;
			GenVars.numDRooms = 0;
			GenVars.numDDoors = 0;
			GenVars.numDungeonPlatforms = 0;
			int num = genRand.Next(3);
			genRand.Next(3);
			if (remixWorldGen)
			{
				num = (crimson ? 2 : 0);
			}
			ushort num2;
			int num3;
			switch (num)
			{
			case 0:
				num2 = 41;
				num3 = 7;
				GenVars.crackedType = 481;
				break;
			case 1:
				num2 = 43;
				num3 = 8;
				GenVars.crackedType = 482;
				break;
			default:
				num2 = 44;
				num3 = 9;
				GenVars.crackedType = 483;
				break;
			}
			Main.tileSolid[GenVars.crackedType] = false;
			GenVars.dungeonLake = true;
			GenVars.numDDoors = 0;
			GenVars.numDungeonPlatforms = 0;
			GenVars.numDRooms = 0;
			GenVars.dungeonX = x;
			GenVars.dungeonY = y;
			GenVars.dMinX = x;
			GenVars.dMaxX = x;
			GenVars.dMinY = y;
			GenVars.dMaxY = y;
			GenVars.dxStrength1 = genRand.Next(25, 30);
			GenVars.dyStrength1 = genRand.Next(20, 25);
			GenVars.dxStrength2 = genRand.Next(35, 50);
			GenVars.dyStrength2 = genRand.Next(10, 15);
			double num4 = Main.maxTilesX / 60;
			num4 += (double)genRand.Next(0, (int)(num4 / 3.0));
			double num5 = num4;
			int num6 = 5;
			DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
			while (num4 > 0.0)
			{
				if (GenVars.dungeonX < GenVars.dMinX)
				{
					GenVars.dMinX = GenVars.dungeonX;
				}
				if (GenVars.dungeonX > GenVars.dMaxX)
				{
					GenVars.dMaxX = GenVars.dungeonX;
				}
				if (GenVars.dungeonY > GenVars.dMaxY)
				{
					GenVars.dMaxY = GenVars.dungeonY;
				}
				num4 -= 1.0;
				Main.statusText = Lang.gen[58].Value + " " + (int)((num5 - num4) / num5 * 60.0) + "%";
				if (num6 > 0)
				{
					num6--;
				}
				if ((num6 == 0) & (genRand.Next(3) == 0))
				{
					num6 = 5;
					if (genRand.Next(2) == 0)
					{
						int dungeonX = GenVars.dungeonX;
						int dungeonY = GenVars.dungeonY;
						DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
						if (genRand.Next(2) == 0)
						{
							DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
						}
						DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
						GenVars.dungeonX = dungeonX;
						GenVars.dungeonY = dungeonY;
					}
					else
					{
						DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
					}
				}
				else
				{
					DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
				}
			}
			DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
			int num7 = GenVars.dRoomX[0];
			int num8 = GenVars.dRoomY[0];
			for (int i = 0; i < GenVars.numDRooms; i++)
			{
				if (GenVars.dRoomY[i] < num8)
				{
					num7 = GenVars.dRoomX[i];
					num8 = GenVars.dRoomY[i];
				}
			}
			GenVars.dungeonX = num7;
			GenVars.dungeonY = num8;
			GenVars.dEnteranceX = num7;
			GenVars.dSurface = false;
			num6 = 5;
			if (drunkWorldGen)
			{
				GenVars.dSurface = true;
			}
			while (!GenVars.dSurface)
			{
				if (num6 > 0)
				{
					num6--;
				}
				if (num6 == 0 && genRand.Next(5) == 0 && (double)GenVars.dungeonY > Main.worldSurface + 100.0)
				{
					num6 = 10;
					int dungeonX2 = GenVars.dungeonX;
					int dungeonY2 = GenVars.dungeonY;
					DungeonHalls(GenVars.dungeonX, GenVars.dungeonY, num2, num3, forceX: true);
					DungeonRoom(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
					GenVars.dungeonX = dungeonX2;
					GenVars.dungeonY = dungeonY2;
				}
				DungeonStairs(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
			}
			DungeonEnt(GenVars.dungeonX, GenVars.dungeonY, num2, num3);
			Main.statusText = Lang.gen[58].Value + " 65%";
			int num9 = Main.maxTilesX * 2;
			int num10;
			for (num10 = 0; num10 < num9; num10++)
			{
				int i2 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num11 = GenVars.dMinY;
				if ((double)num11 < Main.worldSurface)
				{
					num11 = (int)Main.worldSurface;
				}
				int j = genRand.Next(num11, GenVars.dMaxY);
				num10 = ((!DungeonPitTrap(i2, j, num2, num3)) ? (num10 + 1) : (num10 + 1500));
			}
			for (int k = 0; k < GenVars.numDRooms; k++)
			{
				for (int l = GenVars.dRoomL[k]; l <= GenVars.dRoomR[k]; l++)
				{
					if (!Main.tile[l, GenVars.dRoomT[k] - 1].active())
					{
						GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = l;
						GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = GenVars.dRoomT[k] - 1;
						GenVars.numDungeonPlatforms++;
						break;
					}
				}
				for (int m = GenVars.dRoomL[k]; m <= GenVars.dRoomR[k]; m++)
				{
					if (!Main.tile[m, GenVars.dRoomB[k] + 1].active())
					{
						GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = m;
						GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = GenVars.dRoomB[k] + 1;
						GenVars.numDungeonPlatforms++;
						break;
					}
				}
				for (int n = GenVars.dRoomT[k]; n <= GenVars.dRoomB[k]; n++)
				{
					if (!Main.tile[GenVars.dRoomL[k] - 1, n].active())
					{
						GenVars.DDoorX[GenVars.numDDoors] = GenVars.dRoomL[k] - 1;
						GenVars.DDoorY[GenVars.numDDoors] = n;
						GenVars.DDoorPos[GenVars.numDDoors] = -1;
						GenVars.numDDoors++;
						break;
					}
				}
				for (int num12 = GenVars.dRoomT[k]; num12 <= GenVars.dRoomB[k]; num12++)
				{
					if (!Main.tile[GenVars.dRoomR[k] + 1, num12].active())
					{
						GenVars.DDoorX[GenVars.numDDoors] = GenVars.dRoomR[k] + 1;
						GenVars.DDoorY[GenVars.numDDoors] = num12;
						GenVars.DDoorPos[GenVars.numDDoors] = 1;
						GenVars.numDDoors++;
						break;
					}
				}
			}
			Main.statusText = Lang.gen[58].Value + " 70%";
			int num13 = 0;
			int num14 = 1000;
			int num15 = 0;
			int num16 = Main.maxTilesX / 100;
			if (getGoodWorldGen)
			{
				num16 *= 3;
			}
			while (num15 < num16)
			{
				num13++;
				int num17 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num18 = genRand.Next((int)Main.worldSurface + 25, GenVars.dMaxY);
				if (drunkWorldGen)
				{
					num18 = genRand.Next(GenVars.dungeonY + 25, GenVars.dMaxY);
				}
				int num19 = num17;
				if (Main.tile[num17, num18].wall == num3 && !Main.tile[num17, num18].active())
				{
					int num20 = 1;
					if (genRand.Next(2) == 0)
					{
						num20 = -1;
					}
					for (; !Main.tile[num17, num18].active(); num18 += num20)
					{
					}
					if (Main.tile[num17 - 1, num18].active() && Main.tile[num17 + 1, num18].active() && Main.tile[num17 - 1, num18].type != GenVars.crackedType && !Main.tile[num17 - 1, num18 - num20].active() && !Main.tile[num17 + 1, num18 - num20].active())
					{
						num15++;
						int num21 = genRand.Next(5, 13);
						while (Main.tile[num17 - 1, num18].active() && Main.tile[num17 - 1, num18].type != GenVars.crackedType && Main.tile[num17, num18 + num20].active() && Main.tile[num17, num18].active() && !Main.tile[num17, num18 - num20].active() && num21 > 0)
						{
							Main.tile[num17, num18].type = 48;
							if (!Main.tile[num17 - 1, num18 - num20].active() && !Main.tile[num17 + 1, num18 - num20].active())
							{
								Main.tile[num17, num18 - num20].Clear(TileDataType.Slope);
								Main.tile[num17, num18 - num20].type = 48;
								Main.tile[num17, num18 - num20].active(active: true);
								Main.tile[num17, num18 - num20 * 2].Clear(TileDataType.Slope);
								Main.tile[num17, num18 - num20 * 2].type = 48;
								Main.tile[num17, num18 - num20 * 2].active(active: true);
							}
							num17--;
							num21--;
						}
						num21 = genRand.Next(5, 13);
						num17 = num19 + 1;
						while (Main.tile[num17 + 1, num18].active() && Main.tile[num17 + 1, num18].type != GenVars.crackedType && Main.tile[num17, num18 + num20].active() && Main.tile[num17, num18].active() && !Main.tile[num17, num18 - num20].active() && num21 > 0)
						{
							Main.tile[num17, num18].type = 48;
							if (!Main.tile[num17 - 1, num18 - num20].active() && !Main.tile[num17 + 1, num18 - num20].active())
							{
								Main.tile[num17, num18 - num20].Clear(TileDataType.Slope);
								Main.tile[num17, num18 - num20].type = 48;
								Main.tile[num17, num18 - num20].active(active: true);
								Main.tile[num17, num18 - num20 * 2].Clear(TileDataType.Slope);
								Main.tile[num17, num18 - num20 * 2].type = 48;
								Main.tile[num17, num18 - num20 * 2].active(active: true);
							}
							num17++;
							num21--;
						}
					}
				}
				if (num13 > num14)
				{
					num13 = 0;
					num15++;
				}
			}
			num13 = 0;
			num14 = 1000;
			num15 = 0;
			Main.statusText = Lang.gen[58].Value + " 75%";
			while (num15 < num16)
			{
				num13++;
				int num22 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num23 = genRand.Next((int)Main.worldSurface + 25, GenVars.dMaxY);
				int num24 = num23;
				if (Main.tile[num22, num23].wall == num3 && !Main.tile[num22, num23].active())
				{
					int num25 = 1;
					if (genRand.Next(2) == 0)
					{
						num25 = -1;
					}
					for (; num22 > 5 && num22 < Main.maxTilesX - 5 && !Main.tile[num22, num23].active(); num22 += num25)
					{
					}
					if (Main.tile[num22, num23 - 1].active() && Main.tile[num22, num23 + 1].active() && Main.tile[num22, num23 - 1].type != GenVars.crackedType && !Main.tile[num22 - num25, num23 - 1].active() && !Main.tile[num22 - num25, num23 + 1].active())
					{
						num15++;
						int num26 = genRand.Next(5, 13);
						while (Main.tile[num22, num23 - 1].active() && Main.tile[num22, num23 - 1].type != GenVars.crackedType && Main.tile[num22 + num25, num23].active() && Main.tile[num22, num23].active() && !Main.tile[num22 - num25, num23].active() && num26 > 0)
						{
							Main.tile[num22, num23].type = 48;
							if (!Main.tile[num22 - num25, num23 - 1].active() && !Main.tile[num22 - num25, num23 + 1].active())
							{
								Main.tile[num22 - num25, num23].type = 48;
								Main.tile[num22 - num25, num23].active(active: true);
								Main.tile[num22 - num25, num23].Clear(TileDataType.Slope);
								Main.tile[num22 - num25 * 2, num23].type = 48;
								Main.tile[num22 - num25 * 2, num23].active(active: true);
								Main.tile[num22 - num25 * 2, num23].Clear(TileDataType.Slope);
							}
							num23--;
							num26--;
						}
						num26 = genRand.Next(5, 13);
						num23 = num24 + 1;
						while (Main.tile[num22, num23 + 1].active() && Main.tile[num22, num23 + 1].type != GenVars.crackedType && Main.tile[num22 + num25, num23].active() && Main.tile[num22, num23].active() && !Main.tile[num22 - num25, num23].active() && num26 > 0)
						{
							Main.tile[num22, num23].type = 48;
							if (!Main.tile[num22 - num25, num23 - 1].active() && !Main.tile[num22 - num25, num23 + 1].active())
							{
								Main.tile[num22 - num25, num23].type = 48;
								Main.tile[num22 - num25, num23].active(active: true);
								Main.tile[num22 - num25, num23].Clear(TileDataType.Slope);
								Main.tile[num22 - num25 * 2, num23].type = 48;
								Main.tile[num22 - num25 * 2, num23].active(active: true);
								Main.tile[num22 - num25 * 2, num23].Clear(TileDataType.Slope);
							}
							num23++;
							num26--;
						}
					}
				}
				if (num13 > num14)
				{
					num13 = 0;
					num15++;
				}
			}
			Main.statusText = Lang.gen[58].Value + " 80%";
			for (int num27 = 0; num27 < GenVars.numDDoors; num27++)
			{
				int num28 = GenVars.DDoorX[num27] - 10;
				int num29 = GenVars.DDoorX[num27] + 10;
				int num30 = 100;
				int num31 = 0;
				int num32 = 0;
				int num33 = 0;
				for (int num34 = num28; num34 < num29; num34++)
				{
					bool flag = true;
					int num35 = GenVars.DDoorY[num27];
					while (num35 > 10 && !Main.tile[num34, num35].active())
					{
						num35--;
					}
					if (!Main.tileDungeon[Main.tile[num34, num35].type])
					{
						flag = false;
					}
					num32 = num35;
					for (num35 = GenVars.DDoorY[num27]; !Main.tile[num34, num35].active(); num35++)
					{
					}
					if (!Main.tileDungeon[Main.tile[num34, num35].type])
					{
						flag = false;
					}
					num33 = num35;
					if (num33 - num32 < 3)
					{
						continue;
					}
					int num36 = num34 - 20;
					int num37 = num34 + 20;
					int num38 = num33 - 10;
					int num39 = num33 + 10;
					for (int num40 = num36; num40 < num37; num40++)
					{
						for (int num41 = num38; num41 < num39; num41++)
						{
							if (Main.tile[num40, num41].active() && Main.tile[num40, num41].type == 10)
							{
								flag = false;
								break;
							}
						}
					}
					if (flag)
					{
						for (int num42 = num33 - 3; num42 < num33; num42++)
						{
							for (int num43 = num34 - 3; num43 <= num34 + 3; num43++)
							{
								if (Main.tile[num43, num42].active())
								{
									flag = false;
									break;
								}
							}
						}
					}
					if (flag && num33 - num32 < 20)
					{
						bool flag2 = false;
						if (GenVars.DDoorPos[num27] == 0 && num33 - num32 < num30)
						{
							flag2 = true;
						}
						if (GenVars.DDoorPos[num27] == -1 && num34 > num31)
						{
							flag2 = true;
						}
						if (GenVars.DDoorPos[num27] == 1 && (num34 < num31 || num31 == 0))
						{
							flag2 = true;
						}
						if (flag2)
						{
							num31 = num34;
							num30 = num33 - num32;
						}
					}
				}
				if (num30 >= 20)
				{
					continue;
				}
				int num44 = num31;
				int num45 = GenVars.DDoorY[num27];
				int num46 = num45;
				for (; !Main.tile[num44, num45].active(); num45++)
				{
					Main.tile[num44, num45].active(active: false);
				}
				while (!Main.tile[num44, num46].active())
				{
					num46--;
				}
				num45--;
				num46++;
				for (int num47 = num46; num47 < num45 - 2; num47++)
				{
					Main.tile[num44, num47].Clear(TileDataType.Slope);
					Main.tile[num44, num47].active(active: true);
					Main.tile[num44, num47].type = num2;
				}
				int style = 13;
				if (genRand.Next(3) == 0)
				{
					switch (num3)
					{
					case 7:
						style = 16;
						break;
					case 8:
						style = 17;
						break;
					case 9:
						style = 18;
						break;
					}
				}
				PlaceTile(num44, num45, 10, mute: true, forced: false, -1, style);
				num44--;
				int num48 = num45 - 3;
				while (!Main.tile[num44, num48].active())
				{
					num48--;
				}
				if (num45 - num48 < num45 - num46 + 5 && Main.tileDungeon[Main.tile[num44, num48].type])
				{
					for (int num49 = num45 - 4 - genRand.Next(3); num49 > num48; num49--)
					{
						Main.tile[num44, num49].Clear(TileDataType.Slope);
						Main.tile[num44, num49].active(active: true);
						Main.tile[num44, num49].type = num2;
					}
				}
				num44 += 2;
				num48 = num45 - 3;
				while (!Main.tile[num44, num48].active())
				{
					num48--;
				}
				if (num45 - num48 < num45 - num46 + 5 && Main.tileDungeon[Main.tile[num44, num48].type])
				{
					for (int num50 = num45 - 4 - genRand.Next(3); num50 > num48; num50--)
					{
						Main.tile[num44, num50].active(active: true);
						Main.tile[num44, num50].Clear(TileDataType.Slope);
						Main.tile[num44, num50].type = num2;
					}
				}
				num45++;
				num44--;
				Main.tile[num44 - 1, num45].active(active: true);
				Main.tile[num44 - 1, num45].type = num2;
				Main.tile[num44 - 1, num45].Clear(TileDataType.Slope);
				Main.tile[num44 + 1, num45].active(active: true);
				Main.tile[num44 + 1, num45].type = num2;
				Main.tile[num44 + 1, num45].Clear(TileDataType.Slope);
			}
			int[] array = new int[3];
			switch (num3)
			{
			case 7:
				array[0] = 7;
				array[1] = 94;
				array[2] = 95;
				break;
			case 9:
				array[0] = 9;
				array[1] = 96;
				array[2] = 97;
				break;
			default:
				array[0] = 8;
				array[1] = 98;
				array[2] = 99;
				break;
			}
			for (int num51 = 0; num51 < 5; num51++)
			{
				for (int num52 = 0; num52 < 3; num52++)
				{
					int num53 = genRand.Next(40, 240);
					int num54 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
					int num55 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
					for (int num56 = num54 - num53; num56 < num54 + num53; num56++)
					{
						for (int num57 = num55 - num53; num57 < num55 + num53; num57++)
						{
							if ((double)num57 > Main.worldSurface)
							{
								double num58 = Math.Abs(num54 - num56);
								double num59 = Math.Abs(num55 - num57);
								if (Math.Sqrt(num58 * num58 + num59 * num59) < (double)num53 * 0.4 && Main.wallDungeon[Main.tile[num56, num57].wall])
								{
									Spread.WallDungeon(num56, num57, array[num52]);
								}
							}
						}
					}
				}
			}
			Main.statusText = Lang.gen[58].Value + " 85%";
			for (int num60 = 0; num60 < GenVars.numDungeonPlatforms; num60++)
			{
				int num61 = GenVars.dungeonPlatformX[num60];
				int num62 = GenVars.dungeonPlatformY[num60];
				int num63 = Main.maxTilesX;
				int num64 = 10;
				if ((double)num62 < Main.worldSurface + 50.0)
				{
					num64 = 20;
				}
				for (int num65 = num62 - 5; num65 <= num62 + 5; num65++)
				{
					int num66 = num61;
					int num67 = num61;
					bool flag3 = false;
					if (Main.tile[num66, num65].active())
					{
						flag3 = true;
					}
					else
					{
						while (!Main.tile[num66, num65].active())
						{
							num66--;
							if (!Main.tileDungeon[Main.tile[num66, num65].type] || num66 == 0)
							{
								flag3 = true;
								break;
							}
						}
						while (!Main.tile[num67, num65].active())
						{
							num67++;
							if (!Main.tileDungeon[Main.tile[num67, num65].type] || num67 == Main.maxTilesX - 1)
							{
								flag3 = true;
								break;
							}
						}
					}
					if (flag3 || num67 - num66 > num64)
					{
						continue;
					}
					bool flag4 = true;
					int num68 = num61 - num64 / 2 - 2;
					int num69 = num61 + num64 / 2 + 2;
					int num70 = num65 - 5;
					int num71 = num65 + 5;
					for (int num72 = num68; num72 <= num69; num72++)
					{
						for (int num73 = num70; num73 <= num71; num73++)
						{
							if (Main.tile[num72, num73].active() && Main.tile[num72, num73].type == 19)
							{
								flag4 = false;
								break;
							}
						}
					}
					for (int num74 = num65 + 3; num74 >= num65 - 5; num74--)
					{
						if (Main.tile[num61, num74].active())
						{
							flag4 = false;
							break;
						}
					}
					if (flag4)
					{
						num63 = num65;
						break;
					}
				}
				if (num63 <= num62 - 10 || num63 >= num62 + 10)
				{
					continue;
				}
				int num75 = num61;
				int num76 = num63;
				int num77 = num61 + 1;
				while (!Main.tile[num75, num76].active())
				{
					Main.tile[num75, num76].active(active: true);
					Main.tile[num75, num76].type = 19;
					Main.tile[num75, num76].Clear(TileDataType.Slope);
					switch (num3)
					{
					case 7:
						Main.tile[num75, num76].frameY = 108;
						break;
					case 8:
						Main.tile[num75, num76].frameY = 144;
						break;
					default:
						Main.tile[num75, num76].frameY = 126;
						break;
					}
					TileFrame(num75, num76);
					num75--;
				}
				for (; !Main.tile[num77, num76].active(); num77++)
				{
					Main.tile[num77, num76].active(active: true);
					Main.tile[num77, num76].type = 19;
					Main.tile[num77, num76].Clear(TileDataType.Slope);
					switch (num3)
					{
					case 7:
						Main.tile[num77, num76].frameY = 108;
						break;
					case 8:
						Main.tile[num77, num76].frameY = 144;
						break;
					default:
						Main.tile[num77, num76].frameY = 126;
						break;
					}
					TileFrame(num77, num76);
				}
			}
			int num78 = 5;
			if (drunkWorldGen)
			{
				num78 = 6;
			}
			for (int num79 = 0; num79 < num78; num79++)
			{
				bool flag5 = false;
				while (!flag5)
				{
					int num80 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
					int num81 = genRand.Next((int)Main.worldSurface, GenVars.dMaxY);
					if (!Main.wallDungeon[Main.tile[num80, num81].wall] || Main.tile[num80, num81].active())
					{
						continue;
					}
					ushort chestTileType = 21;
					int contain = 0;
					int style2 = 0;
					switch (num79)
					{
					case 0:
						style2 = 23;
						contain = 1156;
						break;
					case 1:
						if (!crimson)
						{
							style2 = 24;
							contain = 1571;
						}
						else
						{
							style2 = 25;
							contain = 1569;
						}
						break;
					case 5:
						if (crimson)
						{
							style2 = 24;
							contain = 1571;
						}
						else
						{
							style2 = 25;
							contain = 1569;
						}
						break;
					case 2:
						style2 = 26;
						contain = 1260;
						break;
					case 3:
						style2 = 27;
						contain = 1572;
						break;
					case 4:
						chestTileType = 467;
						style2 = 13;
						contain = 4607;
						break;
					}
					flag5 = AddBuriedChest(num80, num81, contain, notNearOtherChests: false, style2, trySlope: false, chestTileType);
				}
			}
			int[] array2 = new int[3]
			{
				genRand.Next(9, 13),
				genRand.Next(9, 13),
				0
			};
			while (array2[1] == array2[0])
			{
				array2[1] = genRand.Next(9, 13);
			}
			array2[2] = genRand.Next(9, 13);
			while (array2[2] == array2[0] || array2[2] == array2[1])
			{
				array2[2] = genRand.Next(9, 13);
			}
			Main.statusText = Lang.gen[58].Value + " 90%";
			num13 = 0;
			num14 = 1000;
			num15 = 0;
			while (num15 < Main.maxTilesX / 20)
			{
				num13++;
				int num82 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num83 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				bool flag6 = true;
				if (Main.wallDungeon[Main.tile[num82, num83].wall] && !Main.tile[num82, num83].active())
				{
					int num84 = 1;
					if (genRand.Next(2) == 0)
					{
						num84 = -1;
					}
					while (flag6 && !Main.tile[num82, num83].active())
					{
						num82 -= num84;
						if (num82 < 5 || num82 > Main.maxTilesX - 5)
						{
							flag6 = false;
						}
						else if (Main.tile[num82, num83].active() && !Main.tileDungeon[Main.tile[num82, num83].type])
						{
							flag6 = false;
						}
					}
					if (flag6 && Main.tile[num82, num83].active() && Main.tileDungeon[Main.tile[num82, num83].type] && Main.tile[num82, num83 - 1].active() && Main.tileDungeon[Main.tile[num82, num83 - 1].type] && Main.tile[num82, num83 + 1].active() && Main.tileDungeon[Main.tile[num82, num83 + 1].type])
					{
						num82 += num84;
						for (int num85 = num82 - 3; num85 <= num82 + 3; num85++)
						{
							for (int num86 = num83 - 3; num86 <= num83 + 3; num86++)
							{
								if (Main.tile[num85, num86].active() && Main.tile[num85, num86].type == 19)
								{
									flag6 = false;
									break;
								}
							}
						}
						if (flag6 && (!Main.tile[num82, num83 - 1].active() & !Main.tile[num82, num83 - 2].active() & !Main.tile[num82, num83 - 3].active()))
						{
							int num87 = num82;
							int num88 = num82;
							for (; num87 > GenVars.dMinX && num87 < GenVars.dMaxX && !Main.tile[num87, num83].active() && !Main.tile[num87, num83 - 1].active() && !Main.tile[num87, num83 + 1].active(); num87 += num84)
							{
							}
							num87 = Math.Abs(num82 - num87);
							bool flag7 = false;
							if (genRand.Next(2) == 0)
							{
								flag7 = true;
							}
							if (num87 > 5)
							{
								for (int num89 = genRand.Next(1, 4); num89 > 0; num89--)
								{
									Main.tile[num82, num83].active(active: true);
									Main.tile[num82, num83].Clear(TileDataType.Slope);
									Main.tile[num82, num83].type = 19;
									if (Main.tile[num82, num83].wall == array[0])
									{
										Main.tile[num82, num83].frameY = (short)(18 * array2[0]);
									}
									else if (Main.tile[num82, num83].wall == array[1])
									{
										Main.tile[num82, num83].frameY = (short)(18 * array2[1]);
									}
									else
									{
										Main.tile[num82, num83].frameY = (short)(18 * array2[2]);
									}
									TileFrame(num82, num83);
									if (flag7)
									{
										PlaceTile(num82, num83 - 1, 50, mute: true);
										if (genRand.Next(50) == 0 && (double)num83 > (Main.worldSurface + Main.rockLayer) / 2.0 && Main.tile[num82, num83 - 1].type == 50)
										{
											Main.tile[num82, num83 - 1].frameX = 90;
										}
									}
									num82 += num84;
								}
								num13 = 0;
								num15++;
								if (!flag7 && genRand.Next(2) == 0)
								{
									num82 = num88;
									num83--;
									int num90 = 0;
									if (genRand.Next(4) == 0)
									{
										num90 = 1;
									}
									switch (num90)
									{
									case 0:
										num90 = 13;
										break;
									case 1:
										num90 = 49;
										break;
									}
									PlaceTile(num82, num83, num90, mute: true);
									if (Main.tile[num82, num83].type == 13)
									{
										if (genRand.Next(2) == 0)
										{
											Main.tile[num82, num83].frameX = 18;
										}
										else
										{
											Main.tile[num82, num83].frameX = 36;
										}
									}
								}
							}
						}
					}
				}
				if (num13 > num14)
				{
					num13 = 0;
					num15++;
				}
			}
			Main.statusText = Lang.gen[58].Value + " 95%";
			int num91 = 1;
			for (int num92 = 0; num92 < GenVars.numDRooms; num92++)
			{
				int num93 = 0;
				while (num93 < 1000)
				{
					int num94 = (int)((double)GenVars.dRoomSize[num92] * 0.4);
					int i3 = GenVars.dRoomX[num92] + genRand.Next(-num94, num94 + 1);
					int num95 = GenVars.dRoomY[num92] + genRand.Next(-num94, num94 + 1);
					int num96 = 0;
					int style3 = 2;
					if (num91 == 1)
					{
						num91++;
					}
					switch (num91)
					{
					case 2:
						num96 = 155;
						break;
					case 3:
						num96 = 156;
						break;
					case 4:
						num96 = ((!remixWorldGen) ? 157 : 2623);
						break;
					case 5:
						num96 = 163;
						break;
					case 6:
						num96 = 113;
						break;
					case 7:
						num96 = 3317;
						break;
					case 8:
						num96 = 327;
						style3 = 0;
						break;
					default:
						num96 = 164;
						num91 = 0;
						break;
					}
					if ((double)num95 < Main.worldSurface + 50.0)
					{
						num96 = 327;
						style3 = 0;
					}
					if (num96 == 0 && genRand.Next(2) == 0)
					{
						num93 = 1000;
						continue;
					}
					if (AddBuriedChest(i3, num95, num96, notNearOtherChests: false, style3, trySlope: false, 0))
					{
						num93 += 1000;
						num91++;
					}
					num93++;
				}
			}
			GenVars.dMinX -= 25;
			GenVars.dMaxX += 25;
			GenVars.dMinY -= 25;
			GenVars.dMaxY += 25;
			if (GenVars.dMinX < 0)
			{
				GenVars.dMinX = 0;
			}
			if (GenVars.dMaxX > Main.maxTilesX)
			{
				GenVars.dMaxX = Main.maxTilesX;
			}
			if (GenVars.dMinY < 0)
			{
				GenVars.dMinY = 0;
			}
			if (GenVars.dMaxY > Main.maxTilesY)
			{
				GenVars.dMaxY = Main.maxTilesY;
			}
			num13 = 0;
			num14 = 1000;
			num15 = 0;
			MakeDungeon_Lights(num2, ref num13, num14, ref num15, array);
			num13 = 0;
			num14 = 1000;
			num15 = 0;
			MakeDungeon_Traps(ref num13, num14, ref num15);
			double count = MakeDungeon_GroundFurniture(num3);
			count = MakeDungeon_Pictures(array, count);
			count = MakeDungeon_Banners(array, count);
		}

		private static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd)
		{
			while (numAdd < Main.maxTilesX / 500)
			{
				failCount++;
				int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				while ((double)num2 < Main.worldSurface)
				{
					num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				}
				if (Main.wallDungeon[Main.tile[num, num2].wall] && placeTrap(num, num2, 0))
				{
					failCount = failMax;
				}
				if (failCount > failMax)
				{
					numAdd++;
					failCount = 0;
				}
			}
		}

		private static void MakeDungeon_Lights(ushort tileType, ref int failCount, int failMax, ref int numAdd, int[] roomWall)
		{
			int[] array = new int[3]
			{
				genRand.Next(7),
				genRand.Next(7),
				0
			};
			while (array[1] == array[0])
			{
				array[1] = genRand.Next(7);
			}
			array[2] = genRand.Next(7);
			while (array[2] == array[0] || array[2] == array[1])
			{
				array[2] = genRand.Next(7);
			}
			while (numAdd < Main.maxTilesX / 150)
			{
				failCount++;
				int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				if (Main.wallDungeon[Main.tile[num, num2].wall])
				{
					for (int num3 = num2; num3 > GenVars.dMinY; num3--)
					{
						if (Main.tile[num, num3 - 1].active() && Main.tile[num, num3 - 1].type == tileType)
						{
							bool flag = false;
							for (int i = num - 15; i < num + 15; i++)
							{
								for (int j = num3 - 15; j < num3 + 15; j++)
								{
									if (i > 0 && i < Main.maxTilesX && j > 0 && j < Main.maxTilesY && (Main.tile[i, j].type == 42 || Main.tile[i, j].type == 34))
									{
										flag = true;
										break;
									}
								}
							}
							if (Main.tile[num - 1, num3].active() || Main.tile[num + 1, num3].active() || Main.tile[num - 1, num3 + 1].active() || Main.tile[num + 1, num3 + 1].active() || Main.tile[num, num3 + 2].active())
							{
								flag = true;
							}
							if (flag)
							{
								break;
							}
							bool flag2 = false;
							if (!flag2 && genRand.Next(7) == 0)
							{
								int style = 27;
								switch (roomWall[0])
								{
								case 7:
									style = 27;
									break;
								case 8:
									style = 28;
									break;
								case 9:
									style = 29;
									break;
								}
								bool flag3 = false;
								for (int k = 0; k < 15; k++)
								{
									if (SolidTile(num, num3 + k))
									{
										flag3 = true;
										break;
									}
								}
								if (!flag3)
								{
									PlaceChand(num, num3, 34, style);
								}
								if (Main.tile[num, num3].type == 34)
								{
									flag2 = true;
									failCount = 0;
									numAdd++;
									for (int l = 0; l < 1000; l++)
									{
										int num4 = num + genRand.Next(-12, 13);
										int num5 = num3 + genRand.Next(3, 21);
										if (Main.tile[num4, num5].active() || Main.tile[num4, num5 + 1].active() || !Main.tileDungeon[Main.tile[num4 - 1, num5].type] || !Main.tileDungeon[Main.tile[num4 + 1, num5].type] || !Collision.CanHit(new Point(num4 * 16, num5 * 16), 16, 16, new Point(num * 16, num3 * 16 + 1), 16, 16))
										{
											continue;
										}
										if (((SolidTile(num4 - 1, num5) && Main.tile[num4 - 1, num5].type != 10) || (SolidTile(num4 + 1, num5) && Main.tile[num4 + 1, num5].type != 10) || SolidTile(num4, num5 + 1)) && Main.wallDungeon[Main.tile[num4, num5].wall] && (Main.tileDungeon[Main.tile[num4 - 1, num5].type] || Main.tileDungeon[Main.tile[num4 + 1, num5].type]))
										{
											PlaceTile(num4, num5, 136, mute: true);
										}
										if (!Main.tile[num4, num5].active())
										{
											continue;
										}
										while (num4 != num || num5 != num3)
										{
											Main.tile[num4, num5].wire(wire: true);
											if (num4 > num)
											{
												num4--;
											}
											if (num4 < num)
											{
												num4++;
											}
											Main.tile[num4, num5].wire(wire: true);
											if (num5 > num3)
											{
												num5--;
											}
											if (num5 < num3)
											{
												num5++;
											}
											Main.tile[num4, num5].wire(wire: true);
										}
										if (genRand.Next(3) > 0)
										{
											Main.tile[num, num3].frameX = 18;
											Main.tile[num, num3 + 1].frameX = 18;
										}
										break;
									}
								}
							}
							if (flag2)
							{
								break;
							}
							int style2 = array[0];
							if (Main.tile[num, num3].wall == roomWall[1])
							{
								style2 = array[1];
							}
							if (Main.tile[num, num3].wall == roomWall[2])
							{
								style2 = array[2];
							}
							Place1x2Top(num, num3, 42, style2);
							if (Main.tile[num, num3].type != 42)
							{
								break;
							}
							flag2 = true;
							failCount = 0;
							numAdd++;
							for (int m = 0; m < 1000; m++)
							{
								int num6 = num + genRand.Next(-12, 13);
								int num7 = num3 + genRand.Next(3, 21);
								if (Main.tile[num6, num7].active() || Main.tile[num6, num7 + 1].active() || Main.tile[num6 - 1, num7].type == 48 || Main.tile[num6 + 1, num7].type == 48 || !Collision.CanHit(new Point(num6 * 16, num7 * 16), 16, 16, new Point(num * 16, num3 * 16 + 1), 16, 16))
								{
									continue;
								}
								if ((SolidTile(num6 - 1, num7) && Main.tile[num6 - 1, num7].type != 10) || (SolidTile(num6 + 1, num7) && Main.tile[num6 + 1, num7].type != 10) || SolidTile(num6, num7 + 1))
								{
									PlaceTile(num6, num7, 136, mute: true);
								}
								if (!Main.tile[num6, num7].active())
								{
									continue;
								}
								while (num6 != num || num7 != num3)
								{
									Main.tile[num6, num7].wire(wire: true);
									if (num6 > num)
									{
										num6--;
									}
									if (num6 < num)
									{
										num6++;
									}
									Main.tile[num6, num7].wire(wire: true);
									if (num7 > num3)
									{
										num7--;
									}
									if (num7 < num3)
									{
										num7++;
									}
									Main.tile[num6, num7].wire(wire: true);
								}
								if (genRand.Next(3) > 0)
								{
									Main.tile[num, num3].frameX = 18;
									Main.tile[num, num3 + 1].frameX = 18;
								}
								break;
							}
							break;
						}
					}
				}
				if (failCount > failMax)
				{
					numAdd++;
					failCount = 0;
				}
			}
		}

		private static double MakeDungeon_Banners(int[] roomWall, double count)
		{
			count = 840000.0 / (double)Main.maxTilesX;
			for (int i = 0; (double)i < count; i++)
			{
				int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active())
				{
					num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
					num2 = genRand.Next(GenVars.dMinY, GenVars.dMaxY);
				}
				while (!SolidTile(num, num2) && num2 > 10)
				{
					num2--;
				}
				num2++;
				if (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2 - 1].type == 48 || Main.tile[num, num2].active() || Main.tile[num, num2 + 1].active() || Main.tile[num, num2 + 2].active() || Main.tile[num, num2 + 3].active())
				{
					continue;
				}
				bool flag = true;
				for (int j = num - 1; j <= num + 1; j++)
				{
					for (int k = num2; k <= num2 + 3; k++)
					{
						if (Main.tile[j, k].active() && (Main.tile[j, k].type == 10 || Main.tile[j, k].type == 11 || Main.tile[j, k].type == 91))
						{
							flag = false;
						}
					}
				}
				if (flag)
				{
					int num3 = 10;
					if (Main.tile[num, num2].wall == roomWall[1])
					{
						num3 = 12;
					}
					if (Main.tile[num, num2].wall == roomWall[2])
					{
						num3 = 14;
					}
					num3 += genRand.Next(2);
					PlaceTile(num, num2, 91, mute: true, forced: false, -1, num3);
				}
			}
			return count;
		}

		private static double MakeDungeon_Pictures(int[] roomWall, double count)
		{
			count = 420000.0 / (double)Main.maxTilesX;
			for (int i = 0; (double)i < count; i++)
			{
				int num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int num2 = genRand.Next((int)Main.worldSurface, GenVars.dMaxY);
				while (!Main.wallDungeon[Main.tile[num, num2].wall] || Main.tile[num, num2].active())
				{
					num = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
					num2 = genRand.Next((int)Main.worldSurface, GenVars.dMaxY);
				}
				int num3 = num;
				int num4 = num;
				int num5 = num2;
				int num6 = num2;
				int num7 = 0;
				int num8 = 0;
				for (int j = 0; j < 2; j++)
				{
					num3 = num;
					num4 = num;
					while (!Main.tile[num3, num2].active() && Main.wallDungeon[Main.tile[num3, num2].wall])
					{
						num3--;
					}
					num3++;
					for (; !Main.tile[num4, num2].active() && Main.wallDungeon[Main.tile[num4, num2].wall]; num4++)
					{
					}
					num4--;
					num = (num3 + num4) / 2;
					num5 = num2;
					num6 = num2;
					while (!Main.tile[num, num5].active() && Main.wallDungeon[Main.tile[num, num5].wall])
					{
						num5--;
					}
					num5++;
					for (; !Main.tile[num, num6].active() && Main.wallDungeon[Main.tile[num, num6].wall]; num6++)
					{
					}
					num6--;
					num2 = (num5 + num6) / 2;
				}
				num3 = num;
				num4 = num;
				while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active())
				{
					num3--;
				}
				num3++;
				for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++)
				{
				}
				num4--;
				num5 = num2;
				num6 = num2;
				while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active())
				{
					num5--;
				}
				num5++;
				for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++)
				{
				}
				num6--;
				num = (num3 + num4) / 2;
				num2 = (num5 + num6) / 2;
				num7 = num4 - num3;
				num8 = num6 - num5;
				if (num7 <= 7 || num8 <= 5)
				{
					continue;
				}
				bool[] array = new bool[3] { true, false, false };
				if (num7 > num8 * 3 && num7 > 21)
				{
					array[1] = true;
				}
				if (num8 > num7 * 3 && num8 > 21)
				{
					array[2] = true;
				}
				int num9 = genRand.Next(3);
				if (Main.tile[num, num2].wall == roomWall[0])
				{
					num9 = 0;
				}
				while (!array[num9])
				{
					num9 = genRand.Next(3);
				}
				if (nearPicture2(num, num2))
				{
					num9 = -1;
				}
				switch (num9)
				{
				case 0:
				{
					PaintingEntry paintingEntry2 = RandPictureTile();
					if (Main.tile[num, num2].wall != roomWall[0])
					{
						paintingEntry2 = RandBonePicture();
					}
					if (!nearPicture(num, num2))
					{
						PlaceTile(num, num2, paintingEntry2.tileType, mute: true, forced: false, -1, paintingEntry2.style);
					}
					break;
				}
				case 1:
				{
					PaintingEntry paintingEntry3 = RandPictureTile();
					if (Main.tile[num, num2].wall != roomWall[0])
					{
						paintingEntry3 = RandBonePicture();
					}
					if (!Main.tile[num, num2].active())
					{
						PlaceTile(num, num2, paintingEntry3.tileType, mute: true, forced: false, -1, paintingEntry3.style);
					}
					int num13 = num;
					int num14 = num2;
					int num15 = num2;
					for (int m = 0; m < 2; m++)
					{
						num += 7;
						num5 = num15;
						num6 = num15;
						while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active())
						{
							num5--;
						}
						num5++;
						for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++)
						{
						}
						num6--;
						num15 = (num5 + num6) / 2;
						paintingEntry3 = RandPictureTile();
						if (Main.tile[num, num15].wall != roomWall[0])
						{
							paintingEntry3 = RandBonePicture();
						}
						if (Math.Abs(num14 - num15) >= 4 || nearPicture(num, num15))
						{
							break;
						}
						PlaceTile(num, num15, paintingEntry3.tileType, mute: true, forced: false, -1, paintingEntry3.style);
					}
					num15 = num2;
					num = num13;
					for (int n = 0; n < 2; n++)
					{
						num -= 7;
						num5 = num15;
						num6 = num15;
						while (!Main.tile[num, num5].active() && !Main.tile[num - 1, num5].active() && !Main.tile[num + 1, num5].active())
						{
							num5--;
						}
						num5++;
						for (; !Main.tile[num, num6].active() && !Main.tile[num - 1, num6].active() && !Main.tile[num + 1, num6].active(); num6++)
						{
						}
						num6--;
						num15 = (num5 + num6) / 2;
						paintingEntry3 = RandPictureTile();
						if (Main.tile[num, num15].wall != roomWall[0])
						{
							paintingEntry3 = RandBonePicture();
						}
						if (Math.Abs(num14 - num15) >= 4 || nearPicture(num, num15))
						{
							break;
						}
						PlaceTile(num, num15, paintingEntry3.tileType, mute: true, forced: false, -1, paintingEntry3.style);
					}
					break;
				}
				case 2:
				{
					PaintingEntry paintingEntry = RandPictureTile();
					if (Main.tile[num, num2].wall != roomWall[0])
					{
						paintingEntry = RandBonePicture();
					}
					if (!Main.tile[num, num2].active())
					{
						PlaceTile(num, num2, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
					}
					int num10 = num2;
					int num11 = num;
					int num12 = num;
					for (int k = 0; k < 3; k++)
					{
						num2 += 7;
						num3 = num12;
						num4 = num12;
						while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active())
						{
							num3--;
						}
						num3++;
						for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++)
						{
						}
						num4--;
						num12 = (num3 + num4) / 2;
						paintingEntry = RandPictureTile();
						if (Main.tile[num12, num2].wall != roomWall[0])
						{
							paintingEntry = RandBonePicture();
						}
						if (Math.Abs(num11 - num12) >= 4 || nearPicture(num12, num2))
						{
							break;
						}
						PlaceTile(num12, num2, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
					}
					num12 = num;
					num2 = num10;
					for (int l = 0; l < 3; l++)
					{
						num2 -= 7;
						num3 = num12;
						num4 = num12;
						while (!Main.tile[num3, num2].active() && !Main.tile[num3, num2 - 1].active() && !Main.tile[num3, num2 + 1].active())
						{
							num3--;
						}
						num3++;
						for (; !Main.tile[num4, num2].active() && !Main.tile[num4, num2 - 1].active() && !Main.tile[num4, num2 + 1].active(); num4++)
						{
						}
						num4--;
						num12 = (num3 + num4) / 2;
						paintingEntry = RandPictureTile();
						if (Main.tile[num12, num2].wall != roomWall[0])
						{
							paintingEntry = RandBonePicture();
						}
						if (Math.Abs(num11 - num12) >= 4 || nearPicture(num12, num2))
						{
							break;
						}
						PlaceTile(num12, num2, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
					}
					break;
				}
				}
			}
			return count;
		}

		private static double MakeDungeon_GroundFurniture(int wallType)
		{
			double num = (double)(2000 * Main.maxTilesX) / 4200.0;
			int num2 = 1 + (int)((double)Main.maxTilesX / 4200.0);
			int num3 = 1 + (int)((double)Main.maxTilesX / 4200.0);
			for (int i = 0; (double)i < num; i++)
			{
				if (num2 > 0 || num3 > 0)
				{
					i--;
				}
				int num4 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
				int j = genRand.Next((int)Main.worldSurface + 10, GenVars.dMaxY);
				while (!Main.wallDungeon[Main.tile[num4, j].wall] || Main.tile[num4, j].active())
				{
					num4 = genRand.Next(GenVars.dMinX, GenVars.dMaxX);
					j = genRand.Next((int)Main.worldSurface + 10, GenVars.dMaxY);
				}
				if (!Main.wallDungeon[Main.tile[num4, j].wall] || Main.tile[num4, j].active())
				{
					continue;
				}
				for (; !SolidTile(num4, j) && j < Main.UnderworldLayer; j++)
				{
				}
				j--;
				int num5 = num4;
				int k = num4;
				while (!Main.tile[num5, j].active() && SolidTile(num5, j + 1))
				{
					num5--;
				}
				num5++;
				for (; !Main.tile[k, j].active() && SolidTile(k, j + 1); k++)
				{
				}
				k--;
				int num6 = k - num5;
				int num7 = (k + num5) / 2;
				if (Main.tile[num7, j].active() || !Main.wallDungeon[Main.tile[num7, j].wall] || !SolidTile(num7, j + 1) || Main.tile[num7, j + 1].type == 48)
				{
					continue;
				}
				int style = 13;
				int style2 = 10;
				int style3 = 11;
				int num8 = 1;
				int num9 = 46;
				int style4 = 1;
				int num10 = 5;
				int num11 = 11;
				int num12 = 5;
				int num13 = 6;
				int num14 = 21;
				int num15 = 22;
				int num16 = 24;
				int num17 = 30;
				switch (wallType)
				{
				case 8:
					style = 14;
					style2 = 11;
					style3 = 12;
					num8 = 2;
					num9 = 47;
					style4 = 2;
					num10 = 6;
					num11 = 12;
					num12 = 6;
					num13 = 7;
					num14 = 22;
					num15 = 23;
					num16 = 25;
					num17 = 31;
					break;
				case 9:
					style = 15;
					style2 = 12;
					style3 = 13;
					num8 = 3;
					num9 = 48;
					style4 = 3;
					num10 = 7;
					num11 = 13;
					num12 = 7;
					num13 = 8;
					num14 = 23;
					num15 = 24;
					num16 = 26;
					num17 = 32;
					break;
				}
				if (Main.tile[num7, j].wall >= 94 && Main.tile[num7, j].wall <= 105)
				{
					style = 17;
					style2 = 14;
					style3 = 15;
					num8 = -1;
					num9 = -1;
					style4 = 5;
					num10 = -1;
					num11 = -1;
					num12 = -1;
					num13 = -1;
					num14 = -1;
					num15 = -1;
					num16 = -1;
					num17 = -1;
				}
				int num18 = genRand.Next(13);
				if ((num18 == 10 || num18 == 11 || num18 == 12) && genRand.Next(4) != 0)
				{
					num18 = genRand.Next(13);
				}
				while ((num18 == 2 && num9 == -1) || (num18 == 5 && num10 == -1) || (num18 == 6 && num11 == -1) || (num18 == 7 && num12 == -1) || (num18 == 8 && num13 == -1) || (num18 == 9 && num14 == -1) || (num18 == 10 && num15 == -1) || (num18 == 11 && num16 == -1) || (num18 == 12 && num17 == -1))
				{
					num18 = genRand.Next(13);
				}
				int num19 = 0;
				int num20 = 0;
				if (num18 == 0)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 1)
				{
					num19 = 4;
					num20 = 3;
				}
				if (num18 == 2)
				{
					num19 = 3;
					num20 = 5;
				}
				if (num18 == 3)
				{
					num19 = 4;
					num20 = 6;
				}
				if (num18 == 4)
				{
					num19 = 3;
					num20 = 3;
				}
				if (num18 == 5)
				{
					num19 = 5;
					num20 = 3;
				}
				if (num18 == 6)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 7)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 8)
				{
					num19 = 5;
					num20 = 4;
				}
				if (num18 == 9)
				{
					num19 = 5;
					num20 = 3;
				}
				if (num18 == 10)
				{
					num19 = 2;
					num20 = 4;
				}
				if (num18 == 11)
				{
					num19 = 3;
					num20 = 3;
				}
				if (num18 == 12)
				{
					num19 = 2;
					num20 = 5;
				}
				for (int l = num7 - num19; l <= num7 + num19; l++)
				{
					for (int m = j - num20; m <= j; m++)
					{
						if (Main.tile[l, m].active())
						{
							num18 = -1;
							break;
						}
					}
				}
				if ((double)num6 < (double)num19 * 1.75)
				{
					num18 = -1;
				}
				if (num2 > 0 || num3 > 0)
				{
					if (num2 > 0)
					{
						PlaceTile(num7, j, 355, mute: true);
						if (Main.tile[num7, j].type == 355)
						{
							num2--;
						}
					}
					else if (num3 > 0)
					{
						PlaceTile(num7, j, 354, mute: true);
						if (Main.tile[num7, j].type == 354)
						{
							num3--;
						}
					}
					continue;
				}
				switch (num18)
				{
				case 0:
				{
					PlaceTile(num7, j, 14, mute: true, forced: false, -1, style2);
					if (Main.tile[num7, j].active())
					{
						if (!Main.tile[num7 - 2, j].active())
						{
							PlaceTile(num7 - 2, j, 15, mute: true, forced: false, -1, style);
							if (Main.tile[num7 - 2, j].active())
							{
								Main.tile[num7 - 2, j].frameX += 18;
								Main.tile[num7 - 2, j - 1].frameX += 18;
							}
						}
						if (!Main.tile[num7 + 2, j].active())
						{
							PlaceTile(num7 + 2, j, 15, mute: true, forced: false, -1, style);
						}
					}
					for (int num22 = num7 - 1; num22 <= num7 + 1; num22++)
					{
						if (genRand.Next(2) == 0 && !Main.tile[num22, j - 2].active())
						{
							int num23 = genRand.Next(5);
							if (num8 != -1 && num23 <= 1 && !Main.tileLighted[Main.tile[num22 - 1, j - 2].type])
							{
								PlaceTile(num22, j - 2, 33, mute: true, forced: false, -1, num8);
							}
							if (num23 == 2 && !Main.tileLighted[Main.tile[num22 - 1, j - 2].type])
							{
								PlaceTile(num22, j - 2, 49, mute: true);
							}
							if (num23 == 3)
							{
								PlaceTile(num22, j - 2, 50, mute: true);
							}
							if (num23 == 4)
							{
								PlaceTile(num22, j - 2, 103, mute: true);
							}
						}
					}
					break;
				}
				case 1:
				{
					PlaceTile(num7, j, 18, mute: true, forced: false, -1, style3);
					if (!Main.tile[num7, j].active())
					{
						break;
					}
					if (genRand.Next(2) == 0)
					{
						if (!Main.tile[num7 - 1, j].active())
						{
							PlaceTile(num7 - 1, j, 15, mute: true, forced: false, -1, style);
							if (Main.tile[num7 - 1, j].active())
							{
								Main.tile[num7 - 1, j].frameX += 18;
								Main.tile[num7 - 1, j - 1].frameX += 18;
							}
						}
					}
					else if (!Main.tile[num7 + 2, j].active())
					{
						PlaceTile(num7 + 2, j, 15, mute: true, forced: false, -1, style);
					}
					for (int n = num7; n <= num7 + 1; n++)
					{
						if (genRand.Next(2) == 0 && !Main.tile[n, j - 1].active())
						{
							int num21 = genRand.Next(5);
							if (num8 != -1 && num21 <= 1 && !Main.tileLighted[Main.tile[n - 1, j - 1].type])
							{
								PlaceTile(n, j - 1, 33, mute: true, forced: false, -1, num8);
							}
							if (num21 == 2 && !Main.tileLighted[Main.tile[n - 1, j - 1].type])
							{
								PlaceTile(n, j - 1, 49, mute: true);
							}
							if (num21 == 3)
							{
								PlaceTile(n, j - 1, 50, mute: true);
							}
							if (num21 == 4)
							{
								PlaceTile(n, j - 1, 103, mute: true);
							}
						}
					}
					break;
				}
				case 2:
					PlaceTile(num7, j, 105, mute: true, forced: false, -1, num9);
					break;
				case 3:
					PlaceTile(num7, j, 101, mute: true, forced: false, -1, style4);
					break;
				case 4:
					if (genRand.Next(2) == 0)
					{
						PlaceTile(num7, j, 15, mute: true, forced: false, -1, style);
						Main.tile[num7, j].frameX += 18;
						Main.tile[num7, j - 1].frameX += 18;
					}
					else
					{
						PlaceTile(num7, j, 15, mute: true, forced: false, -1, style);
					}
					break;
				case 5:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num7, j, 79, 1, num10);
					}
					else
					{
						Place4x2(num7, j, 79, -1, num10);
					}
					break;
				case 6:
					PlaceTile(num7, j, 87, mute: true, forced: false, -1, num11);
					break;
				case 7:
					PlaceTile(num7, j, 88, mute: true, forced: false, -1, num12);
					break;
				case 8:
					PlaceTile(num7, j, 89, mute: true, forced: false, -1, num13);
					break;
				case 9:
					if (genRand.Next(2) == 0)
					{
						Place4x2(num7, j, 90, 1, num14);
					}
					else
					{
						Place4x2(num7, j, 90, -1, num14);
					}
					break;
				case 10:
					PlaceTile(num7, j, 93, mute: true, forced: false, -1, num16);
					break;
				case 11:
					PlaceTile(num7, j, 100, mute: true, forced: false, -1, num15);
					break;
				case 12:
					PlaceTile(num7, j, 104, mute: true, forced: false, -1, num17);
					break;
				}
			}
			return num;
		}

		public static PaintingEntry RandBonePicture()
		{
			int num = genRand.Next(2);
			int num2 = 0;
			switch (num)
			{
			case 0:
				num = 240;
				num2 = genRand.Next(2);
				switch (num2)
				{
				case 0:
					num2 = 16;
					break;
				case 1:
					num2 = 17;
					break;
				}
				break;
			case 1:
				num = 241;
				num2 = genRand.Next(9);
				break;
			}
			PaintingEntry result = default(PaintingEntry);
			result.tileType = num;
			result.style = num2;
			return result;
		}

		public static PaintingEntry RandHellPicture()
		{
			int num = genRand.Next(4);
			int num2 = 0;
			if (num == 1)
			{
				num = genRand.Next(4);
			}
			switch (num)
			{
			case 0:
				num = 240;
				num2 = genRand.Next(5);
				switch (num2)
				{
				case 0:
					num2 = 27;
					break;
				case 1:
					num2 = 29;
					break;
				case 2:
					num2 = 30;
					break;
				case 3:
					num2 = 31;
					break;
				case 4:
					num2 = 32;
					break;
				}
				break;
			case 1:
				num = 242;
				num2 = 14;
				break;
			case 2:
				num = 245;
				num2 = genRand.Next(3);
				switch (num2)
				{
				case 0:
					num2 = 1;
					break;
				case 1:
					num2 = 2;
					break;
				case 2:
					num2 = 4;
					break;
				}
				break;
			default:
				num = 246;
				num2 = genRand.Next(3);
				switch (num2)
				{
				case 0:
					num2 = 0;
					break;
				case 1:
					num2 = 16;
					break;
				case 2:
					num2 = 17;
					break;
				}
				break;
			}
			PaintingEntry result = default(PaintingEntry);
			result.tileType = num;
			result.style = num2;
			return result;
		}

		public static PaintingEntry RandHousePictureDesert()
		{
			int num = genRand.Next(4);
			int num2 = 0;
			if (num <= 1)
			{
				num = 240;
				int maxValue = 6;
				num2 = 63 + genRand.Next(maxValue);
			}
			else if (num == 2)
			{
				num = 245;
				int maxValue2 = 2;
				num2 = 7 + genRand.Next(maxValue2);
			}
			else
			{
				num = 242;
				int maxValue3 = 6;
				num2 = 37 + genRand.Next(maxValue3);
			}
			PaintingEntry result = default(PaintingEntry);
			result.tileType = num;
			result.style = num2;
			return result;
		}

		public static PaintingEntry RandHousePicture()
		{
			int num = genRand.Next(4);
			int num2 = 0;
			if (num >= 3 && genRand.Next(2) != 0)
			{
				num = genRand.Next(3);
			}
			if (num <= 1)
			{
				num = 240;
				int maxValue = 15;
				num2 = genRand.Next(maxValue);
				switch (num2)
				{
				case 0:
					num2 = 26;
					break;
				case 1:
					num2 = 28;
					break;
				case 2:
					num2 = 20;
					break;
				case 3:
					num2 = 21;
					break;
				case 4:
					num2 = 22;
					break;
				case 5:
					num2 = 24;
					break;
				case 6:
					num2 = 25;
					break;
				case 7:
					num2 = 33;
					break;
				case 8:
					num2 = 34;
					break;
				case 9:
					num2 = 35;
					break;
				case 10:
					num2 = 76;
					break;
				case 11:
					num2 = 77;
					break;
				case 12:
					num2 = 78;
					break;
				case 13:
					num2 = 79;
					break;
				case 14:
					num2 = 82;
					break;
				}
			}
			else if (num == 2)
			{
				int maxValue2 = 9;
				num = 245;
				num2 = genRand.Next(maxValue2);
				if (num2 == 0 && genRand.Next(3) != 0)
				{
					num2 = genRand.Next(maxValue2);
				}
				switch (num2)
				{
				case 0:
					num2 = 0;
					break;
				case 1:
					num2 = 3;
					break;
				case 2:
					num2 = 5;
					break;
				case 3:
					num2 = 6;
					break;
				case 4:
					num2 = 14;
					break;
				case 5:
				{
					int num3 = genRand.Next(4);
					if (num3 == 0)
					{
						num2 = 15;
					}
					if (num3 == 1)
					{
						num2 = 16;
					}
					if (num3 == 2)
					{
						num2 = 17;
					}
					if (num3 == 3)
					{
						num2 = 18;
					}
					break;
				}
				case 6:
					num2 = 19;
					break;
				case 7:
					num2 = 20;
					break;
				case 8:
					num2 = 21;
					break;
				}
			}
			else
			{
				num = 246;
				int maxValue3 = 8;
				num2 = genRand.Next(maxValue3);
				switch (num2)
				{
				case 0:
					num2 = 1;
					break;
				case 1:
					num2 = 30;
					break;
				case 2:
					num2 = 31;
					break;
				case 3:
					num2 = 32;
					break;
				case 4:
					num2 = 33;
					break;
				case 5:
					num2 = 34;
					break;
				case 6:
					num2 = 35;
					break;
				case 7:
					num2 = 36;
					break;
				}
			}
			PaintingEntry result = default(PaintingEntry);
			result.tileType = num;
			result.style = num2;
			return result;
		}

		public static PaintingEntry RandPictureTile()
		{
			int num = genRand.Next(3);
			int num2 = 0;
			if (num <= 1)
			{
				int maxValue = 7;
				num = 240;
				num2 = genRand.Next(maxValue);
				if (num2 == 6)
				{
					num2 = genRand.Next(maxValue);
				}
				switch (num2)
				{
				case 0:
					num2 = 12;
					break;
				case 1:
					num2 = 13;
					break;
				case 2:
					num2 = 14;
					break;
				case 3:
					num2 = 15;
					break;
				case 4:
					num2 = 18;
					break;
				case 5:
					num2 = 19;
					break;
				case 6:
					num2 = 23;
					break;
				}
			}
			else if (num == 2)
			{
				num = 242;
				int maxValue2 = 17;
				num2 = genRand.Next(maxValue2);
				switch (num2)
				{
				case 14:
					num2 = 15;
					break;
				case 15:
					num2 = 16;
					break;
				case 16:
					num2 = 30;
					break;
				}
			}
			PaintingEntry result = default(PaintingEntry);
			result.tileType = num;
			result.style = num2;
			return result;
		}

		public static void DungeonStairs(int i, int j, ushort tileType, int wallType)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0124: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			//IL_0175: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_020a: Unknown result type (might be due to invalid IL or missing references)
			//IL_021f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_030e: Unknown result type (might be due to invalid IL or missing references)
			//IL_033c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0368: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_04c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_04de: Unknown result type (might be due to invalid IL or missing references)
			//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0588: Unknown result type (might be due to invalid IL or missing references)
			//IL_0589: Unknown result type (might be due to invalid IL or missing references)
			//IL_058a: Unknown result type (might be due to invalid IL or missing references)
			//IL_058f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0590: Unknown result type (might be due to invalid IL or missing references)
			//IL_05b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
			Vector2D zero = Vector2D.get_Zero();
			double num = genRand.Next(5, 9);
			int num2 = 1;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			int num3 = genRand.Next(10, 30);
			num2 = ((i <= GenVars.dEnteranceX) ? 1 : (-1));
			if (i > Main.maxTilesX - 400)
			{
				num2 = -1;
			}
			else if (i < 400)
			{
				num2 = 1;
			}
			zero.Y = -1.0;
			zero.X = num2;
			if (genRand.Next(3) != 0)
			{
				zero.X *= 1.0 + (double)genRand.Next(0, 200) * 0.01;
			}
			else if (genRand.Next(3) == 0)
			{
				zero.X *= (double)genRand.Next(50, 76) * 0.01;
			}
			else if (genRand.Next(6) == 0)
			{
				zero.Y *= 2.0;
			}
			if (GenVars.dungeonX < Main.maxTilesX / 2 && zero.X < 0.0 && zero.X < 0.5)
			{
				zero.X = -0.5;
			}
			if (GenVars.dungeonX > Main.maxTilesX / 2 && zero.X > 0.0 && zero.X > 0.5)
			{
				zero.X = -0.5;
			}
			if (drunkWorldGen)
			{
				num2 *= -1;
				zero.X *= -1.0;
			}
			while (num3 > 0)
			{
				num3--;
				int num4 = (int)(val.X - num - 4.0 - (double)genRand.Next(6));
				int num5 = (int)(val.X + num + 4.0 + (double)genRand.Next(6));
				int num6 = (int)(val.Y - num - 4.0);
				int num7 = (int)(val.Y + num + 4.0 + (double)genRand.Next(6));
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				int num8 = 1;
				if (val.X > (double)(Main.maxTilesX / 2))
				{
					num8 = -1;
				}
				int num9 = (int)(val.X + GenVars.dxStrength1 * 0.6 * (double)num8 + GenVars.dxStrength2 * (double)num8);
				int num10 = (int)(GenVars.dyStrength2 * 0.5);
				if (val.Y < Main.worldSurface - 5.0 && Main.tile[num9, (int)(val.Y - num - 6.0 + (double)num10)].wall == 0 && Main.tile[num9, (int)(val.Y - num - 7.0 + (double)num10)].wall == 0 && Main.tile[num9, (int)(val.Y - num - 8.0 + (double)num10)].wall == 0)
				{
					GenVars.dSurface = true;
					TileRunner(num9, (int)(val.Y - num - 6.0 + (double)num10), genRand.Next(25, 35), genRand.Next(10, 20), -1, addTile: false, 0.0, -1.0);
				}
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						Main.tile[k, l].liquid = 0;
						if (!Main.wallDungeon[Main.tile[k, l].wall])
						{
							Main.tile[k, l].wall = 0;
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = tileType;
						}
					}
				}
				for (int m = num4 + 1; m < num5 - 1; m++)
				{
					for (int n = num6 + 1; n < num7 - 1; n++)
					{
						Main.tile[m, n].wall = (ushort)wallType;
					}
				}
				int num11 = 0;
				if (genRand.Next((int)num) == 0)
				{
					num11 = genRand.Next(1, 3);
				}
				num4 = (int)(val.X - num * 0.5 - (double)num11);
				num5 = (int)(val.X + num * 0.5 + (double)num11);
				num6 = (int)(val.Y - num * 0.5 - (double)num11);
				num7 = (int)(val.Y + num * 0.5 + (double)num11);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				for (int num12 = num4; num12 < num5; num12++)
				{
					for (int num13 = num6; num13 < num7; num13++)
					{
						Main.tile[num12, num13].active(active: false);
						PlaceWall(num12, num13, wallType, mute: true);
					}
				}
				if (GenVars.dSurface)
				{
					num3 = 0;
				}
				val += zero;
				if (val.Y < Main.worldSurface)
				{
					zero.Y *= 0.98;
				}
			}
			GenVars.dungeonX = (int)val.X;
			GenVars.dungeonY = (int)val.Y;
		}

		public static bool PlaceSandTrap(int i, int j)
		{
			int num = 6;
			int num2 = 4;
			int num3 = 25;
			int k;
			for (k = j; !Main.tile[i, k].active() && k < Main.UnderworldLayer; k++)
			{
			}
			if (!Main.tileSolid[Main.tile[i, k].type] || Main.tile[i, k].halfBrick() || Main.tile[i, k].topSlope())
			{
				return false;
			}
			if ((Main.tile[i, k].type != 53 && Main.tile[i, k].type != 397 && Main.tile[i, k].type != 396) || (Main.tile[i, k].wall != 216 && Main.tile[i, k].wall != 187))
			{
				return false;
			}
			k--;
			int num4 = -1;
			int num5 = genRand.Next(6, 12);
			int num6 = genRand.Next(6, 14);
			for (int l = i - num3; l <= i + num3; l++)
			{
				for (int m = k - num3; m < k + num3; m++)
				{
					if (Main.tile[l, m].wire())
					{
						return false;
					}
					if (TileID.Sets.BasicChest[Main.tile[l, m].type])
					{
						return false;
					}
					if (TileID.Sets.Paintings[Main.tile[l, m].type])
					{
						return false;
					}
					if (Main.tile[l, m].type == 10)
					{
						return false;
					}
					if (Main.tile[l, m].type == 19)
					{
						return false;
					}
					if (Main.tile[l, m].type == 15)
					{
						return false;
					}
					if (Main.tile[l, m].type == 219)
					{
						return false;
					}
				}
			}
			for (int n = i - 2; n <= i + 2; n++)
			{
				for (int num7 = k + 1; num7 <= k + 3; num7++)
				{
					if (!Main.tile[n, num7].active() || !Main.tileSolid[Main.tile[n, num7].type])
					{
						return false;
					}
				}
			}
			if (Main.tile[i, k + 1].type == 162)
			{
				return false;
			}
			for (int num8 = k; num8 > k - 30; num8--)
			{
				if (Main.tile[i, num8].active())
				{
					if (Main.tile[i, num8].type == 396)
					{
						num4 = num8;
						break;
					}
					return false;
				}
			}
			if (num4 <= -1)
			{
				return false;
			}
			if (k - num4 < num6 + num2)
			{
				return false;
			}
			int num9 = 0;
			int num10 = (k + num4) / 2;
			for (int num11 = i - num5; num11 <= i + num5; num11++)
			{
				if (Main.tile[num11, num10].active() && Main.tileSolid[Main.tile[num11, num10].type])
				{
					return false;
				}
				for (int num12 = num4 - num6; num12 <= num4; num12++)
				{
					if (Main.tile[num11, num12].active())
					{
						if (TileID.Sets.Ore[Main.tile[num11, num12].type] || Main.tile[num11, num12].type == 404)
						{
							return false;
						}
						if (Main.tileSolid[Main.tile[num11, num12].type])
						{
							num9++;
						}
					}
				}
			}
			double num13 = (double)((num5 * 2 + 1) * (num6 + 1)) * 0.75;
			if ((double)num9 < num13)
			{
				return false;
			}
			for (int num14 = i - num5 - 1; num14 <= i + num5 + 1; num14++)
			{
				for (int num15 = num4 - num6; num15 <= num4; num15++)
				{
					bool flag = false;
					if (Main.tile[num14, num15].active() && Main.tileSolid[Main.tile[num14, num15].type])
					{
						flag = true;
					}
					if (num15 == num4)
					{
						Main.tile[num14, num15].slope(0);
						Main.tile[num14, num15].halfBrick(halfBrick: false);
						if (!flag)
						{
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].type = 396;
						}
					}
					else if (num15 == num4 - num6)
					{
						Main.tile[num14, num15].ClearTile();
						Main.tile[num14, num15].active(active: true);
						if (flag && Main.tile[num14, num15 - 1].active() && Main.tileSolid[Main.tile[num14, num15 - 1].type])
						{
							Main.tile[num14, num15].type = 397;
						}
						else
						{
							Main.tile[num14, num15].type = 396;
						}
					}
					else if (num14 == i - num5 - 1 || num14 == i + num5 + 1)
					{
						if (!flag)
						{
							Main.tile[num14, num15].ClearTile();
							Main.tile[num14, num15].active(active: true);
							Main.tile[num14, num15].type = 396;
						}
						else
						{
							Main.tile[num14, num15].slope(0);
							Main.tile[num14, num15].halfBrick(halfBrick: false);
						}
					}
					else
					{
						Main.tile[num14, num15].ClearTile();
						Main.tile[num14, num15].active(active: true);
						Main.tile[num14, num15].type = 53;
					}
				}
			}
			for (int num16 = (int)((double)num4 - (double)num6 * 0.666); (double)num16 <= (double)num4 - (double)num6 * 0.333; num16++)
			{
				if ((double)num16 < (double)num4 - (double)num6 * 0.4)
				{
					if (Main.tile[i - num5 - 2, num16].bottomSlope())
					{
						Main.tile[i - num5 - 2, num16].slope(0);
					}
				}
				else if ((double)num16 > (double)num4 - (double)num6 * 0.6)
				{
					if (Main.tile[i - num5 - 2, num16].topSlope())
					{
						Main.tile[i - num5 - 2, num16].slope(0);
					}
					Main.tile[i - num5 - 2, num16].halfBrick(halfBrick: false);
				}
				else
				{
					Main.tile[i - num5 - 2, num16].halfBrick(halfBrick: false);
					Main.tile[i - num5 - 2, num16].slope(0);
				}
				if (!Main.tile[i - num5 - 2, num16].active() || !Main.tileSolid[Main.tile[i - num5 - 2, num16].type])
				{
					Main.tile[i - num5 - 2, num16].active(active: true);
					Main.tile[i - num5 - 2, num16].type = 396;
				}
				if (!Main.tile[i + num5 + 2, num16].active() || !Main.tileSolid[Main.tile[i + num5 + 2, num16].type])
				{
					Main.tile[i + num5 + 2, num16].active(active: true);
					Main.tile[i + num5 + 2, num16].type = 396;
				}
			}
			for (int num17 = num4 - num6; num17 <= num4; num17++)
			{
				Main.tile[i - num5 - 2, num17].slope(0);
				Main.tile[i - num5 - 2, num17].halfBrick(halfBrick: false);
				Main.tile[i - num5 - 1, num17].slope(0);
				Main.tile[i - num5 - 1, num17].halfBrick(halfBrick: false);
				Main.tile[i - num5 + 1, num17].slope(0);
				Main.tile[i - num5 + 1, num17].halfBrick(halfBrick: false);
				Main.tile[i - num5 + 2, num17].slope(0);
				Main.tile[i - num5 + 2, num17].halfBrick(halfBrick: false);
			}
			for (int num18 = i - num5 - 1; num18 < i + num5 + 1; num18++)
			{
				int num19 = k - num6 - 1;
				if (Main.tile[num18, num19].bottomSlope())
				{
					Main.tile[num18, num19].slope(0);
				}
				Main.tile[num18, num19].halfBrick(halfBrick: false);
			}
			KillTile(i - 2, k);
			KillTile(i - 1, k);
			KillTile(i + 1, k);
			KillTile(i + 2, k);
			PlaceTile(i, k, 135, mute: true, forced: false, -1, 7);
			for (int num20 = i - num5; num20 <= i + num5; num20++)
			{
				int num21 = k;
				if ((double)num20 < (double)i - (double)num5 * 0.8 || (double)num20 > (double)i + (double)num5 * 0.8)
				{
					num21 = k - 3;
				}
				else if ((double)num20 < (double)i - (double)num5 * 0.6 || (double)num20 > (double)i + (double)num5 * 0.6)
				{
					num21 = k - 2;
				}
				else if ((double)num20 < (double)i - (double)num5 * 0.4 || (double)num20 > (double)i + (double)num5 * 0.4)
				{
					num21 = k - 1;
				}
				for (int num22 = num4; num22 <= k; num22++)
				{
					if (num20 == i && num22 <= k)
					{
						Main.tile[i, num22].wire(wire: true);
					}
					if (Main.tile[num20, num22].active() && Main.tileSolid[Main.tile[num20, num22].type])
					{
						if (num22 < num4 + num - 4)
						{
							Main.tile[num20, num22].actuator(actuator: true);
							Main.tile[num20, num22].wire(wire: true);
						}
						else if (num22 < num21)
						{
							KillTile(num20, num22);
						}
					}
				}
			}
			return true;
		}

		public static bool DungeonPitTrap(int i, int j, ushort tileType, int wallType)
		{
			int num = 30;
			int num2 = j;
			int num3 = num2;
			int num4 = genRand.Next(8, 19);
			int num5 = genRand.Next(19, 46);
			int num6 = num4 + genRand.Next(6, 10);
			int num7 = num5 + genRand.Next(6, 10);
			if (!Main.wallDungeon[Main.tile[i, num2].wall])
			{
				return false;
			}
			if (Main.tile[i, num2].active())
			{
				return false;
			}
			for (int k = num2; k < Main.maxTilesY; k++)
			{
				if (k > Main.maxTilesY - 300)
				{
					return false;
				}
				if (Main.tile[i, k].active() && SolidTile(i, k))
				{
					if (Main.tile[i, k].type == 48)
					{
						return false;
					}
					num2 = k;
					break;
				}
			}
			if (!Main.wallDungeon[Main.tile[i - num4, num2].wall] || !Main.wallDungeon[Main.tile[i + num4, num2].wall])
			{
				return false;
			}
			bool flag = true;
			for (int l = num2; l < num2 + num; l++)
			{
				flag = true;
				for (int m = i - num4; m <= i + num4; m++)
				{
					Tile tile = Main.tile[m, l];
					if (tile.active() && Main.tileDungeon[tile.type])
					{
						flag = false;
					}
				}
				if (flag)
				{
					num2 = l;
					break;
				}
			}
			for (int n = i - num4; n <= i + num4; n++)
			{
				for (int num8 = num2; num8 <= num2 + num5; num8++)
				{
					Tile tile2 = Main.tile[n, num8];
					if (tile2.active() && (Main.tileDungeon[tile2.type] || tile2.type == GenVars.crackedType))
					{
						return false;
					}
				}
			}
			bool flag2 = false;
			if (GenVars.dungeonLake)
			{
				flag2 = true;
				GenVars.dungeonLake = false;
			}
			else if (genRand.Next(8) == 0)
			{
				flag2 = true;
			}
			for (int num9 = i - num4; num9 <= i + num4; num9++)
			{
				for (int num10 = num3; num10 <= num2 + num5; num10++)
				{
					if (Main.tileDungeon[Main.tile[num9, num10].type])
					{
						Main.tile[num9, num10].type = GenVars.crackedType;
						Main.tile[num9, num10].wall = (ushort)wallType;
					}
				}
			}
			for (int num11 = i - num6; num11 <= i + num6; num11++)
			{
				for (int num12 = num3; num12 <= num2 + num7; num12++)
				{
					Main.tile[num11, num12].lava(lava: false);
					Main.tile[num11, num12].liquid = 0;
					if (!Main.wallDungeon[Main.tile[num11, num12].wall] && Main.tile[num11, num12].type != GenVars.crackedType)
					{
						Main.tile[num11, num12].Clear(TileDataType.Slope);
						Main.tile[num11, num12].type = tileType;
						Main.tile[num11, num12].active(active: true);
						if (num11 > i - num6 && num11 < i + num6 && num12 < num2 + num7)
						{
							Main.tile[num11, num12].wall = (ushort)wallType;
						}
					}
				}
			}
			for (int num13 = i - num4; num13 <= i + num4; num13++)
			{
				for (int num14 = num3; num14 <= num2 + num5; num14++)
				{
					if (Main.tile[num13, num14].type != GenVars.crackedType)
					{
						if (flag2)
						{
							Main.tile[num13, num14].liquid = byte.MaxValue;
						}
						if (num13 == i - num4 || num13 == i + num4 || num14 == num2 + num5)
						{
							Main.tile[num13, num14].type = 48;
						}
						else if ((num13 == i - num4 + 1 && num14 % 2 == 0) || (num13 == i + num4 - 1 && num14 % 2 == 0) || (num14 == num2 + num5 - 1 && num13 % 2 == 0))
						{
							Main.tile[num13, num14].type = 48;
						}
						else
						{
							Main.tile[num13, num14].active(active: false);
						}
					}
				}
			}
			return true;
		}

		public static void DungeonHalls(int i, int j, ushort tileType, int wallType, bool forceX = false)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_044c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0451: Unknown result type (might be due to invalid IL or missing references)
			//IL_0467: Unknown result type (might be due to invalid IL or missing references)
			//IL_0487: Unknown result type (might be due to invalid IL or missing references)
			//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0539: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_07ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_0850: Unknown result type (might be due to invalid IL or missing references)
			//IL_0863: Unknown result type (might be due to invalid IL or missing references)
			//IL_08ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_090a: Unknown result type (might be due to invalid IL or missing references)
			//IL_091c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0948: Unknown result type (might be due to invalid IL or missing references)
			//IL_095a: Unknown result type (might be due to invalid IL or missing references)
			//IL_096e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0970: Unknown result type (might be due to invalid IL or missing references)
			//IL_0975: Unknown result type (might be due to invalid IL or missing references)
			//IL_0980: Unknown result type (might be due to invalid IL or missing references)
			//IL_09ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_09e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a0b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a24: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a36: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a53: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a65: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a8e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0aa0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ac0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ae2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b05: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b27: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c85: Unknown result type (might be due to invalid IL or missing references)
			//IL_0cb7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d08: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d21: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d3b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d54: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e7e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e7f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e80: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e85: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ebb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ec7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ed3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0eef: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f01: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f2c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f3e: Unknown result type (might be due to invalid IL or missing references)
			Vector2D zero = Vector2D.get_Zero();
			double num = genRand.Next(4, 6);
			double num2 = num;
			Vector2D zero2 = Vector2D.get_Zero();
			Vector2D zero3 = Vector2D.get_Zero();
			int num3 = 1;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			int num4 = genRand.Next(35, 80);
			bool flag = false;
			if (genRand.Next(6) == 0)
			{
				flag = true;
			}
			if (forceX)
			{
				num4 += 20;
				GenVars.lastDungeonHall = Vector2D.get_Zero();
			}
			else if (genRand.Next(5) == 0)
			{
				num *= 2.0;
				num4 /= 2;
			}
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = true;
			bool flag5 = false;
			while (!flag2)
			{
				flag5 = false;
				if (flag4 && !forceX)
				{
					bool flag6 = true;
					bool flag7 = true;
					bool flag8 = true;
					bool flag9 = true;
					int num5 = num4;
					bool flag10 = false;
					for (int num6 = j; num6 > j - num5; num6--)
					{
						if (Main.tile[i, num6].wall == wallType)
						{
							if (flag10)
							{
								flag6 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					flag10 = false;
					for (int k = j; k < j + num5; k++)
					{
						if (Main.tile[i, k].wall == wallType)
						{
							if (flag10)
							{
								flag7 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					flag10 = false;
					for (int num7 = i; num7 > i - num5; num7--)
					{
						if (Main.tile[num7, j].wall == wallType)
						{
							if (flag10)
							{
								flag8 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					flag10 = false;
					for (int l = i; l < i + num5; l++)
					{
						if (Main.tile[l, j].wall == wallType)
						{
							if (flag10)
							{
								flag9 = false;
								break;
							}
						}
						else
						{
							flag10 = true;
						}
					}
					if (!flag8 && !flag9 && !flag6 && !flag7)
					{
						num3 = ((genRand.Next(2) != 0) ? 1 : (-1));
						if (genRand.Next(2) == 0)
						{
							flag5 = true;
						}
					}
					else
					{
						int num8 = genRand.Next(4);
						do
						{
							num8 = genRand.Next(4);
						}
						while (!(num8 == 0 && flag6) && !(num8 == 1 && flag7) && !(num8 == 2 && flag8) && !(num8 == 3 && flag9));
						switch (num8)
						{
						case 0:
							num3 = -1;
							break;
						case 1:
							num3 = 1;
							break;
						default:
							flag5 = true;
							num3 = ((num8 != 2) ? 1 : (-1));
							break;
						}
					}
				}
				else
				{
					num3 = ((genRand.Next(2) != 0) ? 1 : (-1));
					if (genRand.Next(2) == 0)
					{
						flag5 = true;
					}
				}
				flag4 = false;
				if (forceX)
				{
					flag5 = true;
				}
				if (flag5)
				{
					zero2.Y = 0.0;
					zero2.X = num3;
					zero3.Y = 0.0;
					zero3.X = -num3;
					zero.Y = 0.0;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2;
						}
						else
						{
							zero.Y = 0.2;
						}
					}
				}
				else
				{
					num += 1.0;
					zero.Y = num3;
					zero.X = 0.0;
					zero2.X = 0.0;
					zero2.Y = num3;
					zero3.X = 0.0;
					zero3.Y = -num3;
					if (genRand.Next(3) != 0)
					{
						flag3 = true;
						if (genRand.Next(2) == 0)
						{
							zero.X = (double)genRand.Next(10, 20) * 0.1;
						}
						else
						{
							zero.X = (double)(-genRand.Next(10, 20)) * 0.1;
						}
					}
					else if (genRand.Next(2) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.X = (double)genRand.Next(20, 40) * 0.01;
						}
						else
						{
							zero.X = (double)(-genRand.Next(20, 40)) * 0.01;
						}
					}
					else
					{
						num4 /= 2;
					}
				}
				if (GenVars.lastDungeonHall != zero3)
				{
					flag2 = true;
				}
			}
			int num9 = 0;
			bool flag11 = val.Y < Main.rockLayer + 100.0;
			if (remixWorldGen)
			{
				flag11 = val.Y < Main.worldSurface + 100.0;
			}
			if (!forceX)
			{
				if (val.X > (double)(lastMaxTilesX - 200))
				{
					num3 = -1;
					zero2.Y = 0.0;
					zero2.X = num3;
					zero.Y = 0.0;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2;
						}
						else
						{
							zero.Y = 0.2;
						}
					}
				}
				else if (val.X < 200.0)
				{
					num3 = 1;
					zero2.Y = 0.0;
					zero2.X = num3;
					zero.Y = 0.0;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2;
						}
						else
						{
							zero.Y = 0.2;
						}
					}
				}
				else if (val.Y > (double)(lastMaxTilesY - 300))
				{
					num3 = -1;
					num += 1.0;
					zero.Y = num3;
					zero.X = 0.0;
					zero2.X = 0.0;
					zero2.Y = num3;
					if (genRand.Next(2) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.X = (double)genRand.Next(20, 50) * 0.01;
						}
						else
						{
							zero.X = (double)(-genRand.Next(20, 50)) * 0.01;
						}
					}
				}
				else if (flag11)
				{
					num3 = 1;
					num += 1.0;
					zero.Y = num3;
					zero.X = 0.0;
					zero2.X = 0.0;
					zero2.Y = num3;
					if (genRand.Next(3) != 0)
					{
						flag3 = true;
						if (genRand.Next(2) == 0)
						{
							zero.X = (double)genRand.Next(10, 20) * 0.1;
						}
						else
						{
							zero.X = (double)(-genRand.Next(10, 20)) * 0.1;
						}
					}
					else if (genRand.Next(2) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.X = (double)genRand.Next(20, 50) * 0.01;
						}
						else
						{
							zero.X = (double)genRand.Next(20, 50) * 0.01;
						}
					}
				}
				else if (val.X < (double)(Main.maxTilesX / 2) && val.X > (double)Main.maxTilesX * 0.25)
				{
					num3 = -1;
					zero2.Y = 0.0;
					zero2.X = num3;
					zero.Y = 0.0;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2;
						}
						else
						{
							zero.Y = 0.2;
						}
					}
				}
				else if (val.X > (double)(Main.maxTilesX / 2) && val.X < (double)Main.maxTilesX * 0.75)
				{
					num3 = 1;
					zero2.Y = 0.0;
					zero2.X = num3;
					zero.Y = 0.0;
					zero.X = num3;
					if (genRand.Next(3) == 0)
					{
						if (genRand.Next(2) == 0)
						{
							zero.Y = -0.2;
						}
						else
						{
							zero.Y = 0.2;
						}
					}
				}
			}
			if (zero2.Y == 0.0)
			{
				GenVars.DDoorX[GenVars.numDDoors] = (int)val.X;
				GenVars.DDoorY[GenVars.numDDoors] = (int)val.Y;
				GenVars.DDoorPos[GenVars.numDDoors] = 0;
				GenVars.numDDoors++;
			}
			else
			{
				GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = (int)val.X;
				GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = (int)val.Y;
				GenVars.numDungeonPlatforms++;
			}
			GenVars.lastDungeonHall = zero2;
			if (Math.Abs(zero.X) > Math.Abs(zero.Y) && genRand.Next(3) != 0)
			{
				num = (int)(num2 * ((double)genRand.Next(110, 150) * 0.01));
			}
			while (num4 > 0)
			{
				num9++;
				if (zero2.X > 0.0 && val.X > (double)(Main.maxTilesX - 100))
				{
					num4 = 0;
				}
				else if (zero2.X < 0.0 && val.X < 100.0)
				{
					num4 = 0;
				}
				else if (zero2.Y > 0.0 && val.Y > (double)(Main.maxTilesY - 100))
				{
					num4 = 0;
				}
				else if (remixWorldGen && zero2.Y < 0.0 && val.Y < (Main.rockLayer + Main.worldSurface) / 2.0)
				{
					num4 = 0;
				}
				else if (!remixWorldGen && zero2.Y < 0.0 && val.Y < Main.rockLayer + 50.0)
				{
					num4 = 0;
				}
				num4--;
				int num10 = (int)(val.X - num - 4.0 - (double)genRand.Next(6));
				int num11 = (int)(val.X + num + 4.0 + (double)genRand.Next(6));
				int num12 = (int)(val.Y - num - 4.0 - (double)genRand.Next(6));
				int num13 = (int)(val.Y + num + 4.0 + (double)genRand.Next(6));
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesX)
				{
					num11 = Main.maxTilesX;
				}
				if (num12 < 0)
				{
					num12 = 0;
				}
				if (num13 > Main.maxTilesY)
				{
					num13 = Main.maxTilesY;
				}
				for (int m = num10; m < num11; m++)
				{
					for (int n = num12; n < num13; n++)
					{
						if (m < GenVars.dMinX)
						{
							GenVars.dMinX = m;
						}
						if (m > GenVars.dMaxX)
						{
							GenVars.dMaxX = m;
						}
						if (n > GenVars.dMaxY)
						{
							GenVars.dMaxY = n;
						}
						Main.tile[m, n].liquid = 0;
						if (!Main.wallDungeon[Main.tile[m, n].wall])
						{
							Main.tile[m, n].active(active: true);
							Main.tile[m, n].type = tileType;
							Main.tile[m, n].Clear(TileDataType.Slope);
						}
					}
				}
				for (int num14 = num10 + 1; num14 < num11 - 1; num14++)
				{
					for (int num15 = num12 + 1; num15 < num13 - 1; num15++)
					{
						Main.tile[num14, num15].wall = (ushort)wallType;
					}
				}
				int num16 = 0;
				if (zero.Y == 0.0 && genRand.Next((int)num + 1) == 0)
				{
					num16 = genRand.Next(1, 3);
				}
				else if (zero.X == 0.0 && genRand.Next((int)num - 1) == 0)
				{
					num16 = genRand.Next(1, 3);
				}
				else if (genRand.Next((int)num * 3) == 0)
				{
					num16 = genRand.Next(1, 3);
				}
				num10 = (int)(val.X - num * 0.5 - (double)num16);
				num11 = (int)(val.X + num * 0.5 + (double)num16);
				num12 = (int)(val.Y - num * 0.5 - (double)num16);
				num13 = (int)(val.Y + num * 0.5 + (double)num16);
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesX)
				{
					num11 = Main.maxTilesX;
				}
				if (num12 < 0)
				{
					num12 = 0;
				}
				if (num13 > Main.maxTilesY)
				{
					num13 = Main.maxTilesY;
				}
				for (int num17 = num10; num17 < num11; num17++)
				{
					for (int num18 = num12; num18 < num13; num18++)
					{
						Main.tile[num17, num18].Clear(TileDataType.Slope);
						if (flag)
						{
							if (Main.tile[num17, num18].active() || Main.tile[num17, num18].wall != wallType)
							{
								Main.tile[num17, num18].active(active: true);
								Main.tile[num17, num18].type = GenVars.crackedType;
							}
						}
						else
						{
							Main.tile[num17, num18].active(active: false);
						}
						Main.tile[num17, num18].Clear(TileDataType.Slope);
						Main.tile[num17, num18].wall = (ushort)wallType;
					}
				}
				val += zero;
				if (flag3 && num9 > genRand.Next(10, 20))
				{
					num9 = 0;
					zero.X *= -1.0;
				}
			}
			GenVars.dungeonX = (int)val.X;
			GenVars.dungeonY = (int)val.Y;
			if (zero2.Y == 0.0)
			{
				GenVars.DDoorX[GenVars.numDDoors] = (int)val.X;
				GenVars.DDoorY[GenVars.numDDoors] = (int)val.Y;
				GenVars.DDoorPos[GenVars.numDDoors] = 0;
				GenVars.numDDoors++;
			}
			else
			{
				GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = (int)val.X;
				GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = (int)val.Y;
				GenVars.numDungeonPlatforms++;
			}
		}

		public static void DungeonRoom(int i, int j, ushort tileType, int wallType)
		{
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0262: Unknown result type (might be due to invalid IL or missing references)
			//IL_0277: Unknown result type (might be due to invalid IL or missing references)
			//IL_028d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_035b: Unknown result type (might be due to invalid IL or missing references)
			//IL_035c: Unknown result type (might be due to invalid IL or missing references)
			//IL_035d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0362: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_040e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0441: Unknown result type (might be due to invalid IL or missing references)
			//IL_0453: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(15, 30);
			Vector2D val = default(Vector2D);
			val.X = (double)genRand.Next(-10, 11) * 0.1;
			val.Y = (double)genRand.Next(-10, 11) * 0.1;
			Vector2D val2 = default(Vector2D);
			val2.X = i;
			val2.Y = (double)j - num / 2.0;
			int num2 = genRand.Next(10, 20);
			double num3 = val2.X;
			double num4 = val2.X;
			double num5 = val2.Y;
			double num6 = val2.Y;
			while (num2 > 0)
			{
				num2--;
				int num7 = (int)(val2.X - num * 0.8 - 5.0);
				int num8 = (int)(val2.X + num * 0.8 + 5.0);
				int num9 = (int)(val2.Y - num * 0.8 - 5.0);
				int num10 = (int)(val2.Y + num * 0.8 + 5.0);
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesX)
				{
					num8 = Main.maxTilesX;
				}
				if (num9 < 0)
				{
					num9 = 0;
				}
				if (num10 > Main.maxTilesY)
				{
					num10 = Main.maxTilesY;
				}
				for (int k = num7; k < num8; k++)
				{
					for (int l = num9; l < num10; l++)
					{
						if (k < GenVars.dMinX)
						{
							GenVars.dMinX = k;
						}
						if (k > GenVars.dMaxX)
						{
							GenVars.dMaxX = k;
						}
						if (l > GenVars.dMaxY)
						{
							GenVars.dMaxY = l;
						}
						Main.tile[k, l].liquid = 0;
						if (!Main.wallDungeon[Main.tile[k, l].wall])
						{
							Main.tile[k, l].Clear(TileDataType.Slope);
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = tileType;
						}
					}
				}
				for (int m = num7 + 1; m < num8 - 1; m++)
				{
					for (int n = num9 + 1; n < num10 - 1; n++)
					{
						Main.tile[m, n].wall = (ushort)wallType;
					}
				}
				num7 = (int)(val2.X - num * 0.5);
				num8 = (int)(val2.X + num * 0.5);
				num9 = (int)(val2.Y - num * 0.5);
				num10 = (int)(val2.Y + num * 0.5);
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesX)
				{
					num8 = Main.maxTilesX;
				}
				if (num9 < 0)
				{
					num9 = 0;
				}
				if (num10 > Main.maxTilesY)
				{
					num10 = Main.maxTilesY;
				}
				if ((double)num7 < num3)
				{
					num3 = num7;
				}
				if ((double)num8 > num4)
				{
					num4 = num8;
				}
				if ((double)num9 < num5)
				{
					num5 = num9;
				}
				if ((double)num10 > num6)
				{
					num6 = num10;
				}
				for (int num11 = num7; num11 < num8; num11++)
				{
					for (int num12 = num9; num12 < num10; num12++)
					{
						Main.tile[num11, num12].active(active: false);
						Main.tile[num11, num12].wall = (ushort)wallType;
					}
				}
				val2 += val;
				val.X += (double)genRand.Next(-10, 11) * 0.05;
				val.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val.X > 1.0)
				{
					val.X = 1.0;
				}
				if (val.X < -1.0)
				{
					val.X = -1.0;
				}
				if (val.Y > 1.0)
				{
					val.Y = 1.0;
				}
				if (val.Y < -1.0)
				{
					val.Y = -1.0;
				}
			}
			GenVars.dRoomX[GenVars.numDRooms] = (int)val2.X;
			GenVars.dRoomY[GenVars.numDRooms] = (int)val2.Y;
			GenVars.dRoomSize[GenVars.numDRooms] = (int)num;
			GenVars.dRoomL[GenVars.numDRooms] = (int)num3;
			GenVars.dRoomR[GenVars.numDRooms] = (int)num4;
			GenVars.dRoomT[GenVars.numDRooms] = (int)num5;
			GenVars.dRoomB[GenVars.numDRooms] = (int)num6;
			GenVars.dRoomTreasure[GenVars.numDRooms] = false;
			GenVars.numDRooms++;
		}

		public static void DungeonEnt(int i, int j, ushort tileType, int wallType)
		{
			//IL_0099: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_0110: Unknown result type (might be due to invalid IL or missing references)
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_056f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0584: Unknown result type (might be due to invalid IL or missing references)
			//IL_059a: Unknown result type (might be due to invalid IL or missing references)
			//IL_05af: Unknown result type (might be due to invalid IL or missing references)
			//IL_0654: Unknown result type (might be due to invalid IL or missing references)
			//IL_0673: Unknown result type (might be due to invalid IL or missing references)
			//IL_0693: Unknown result type (might be due to invalid IL or missing references)
			//IL_06b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_076c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0781: Unknown result type (might be due to invalid IL or missing references)
			//IL_0797: Unknown result type (might be due to invalid IL or missing references)
			//IL_07ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_084d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0862: Unknown result type (might be due to invalid IL or missing references)
			//IL_08c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_09af: Unknown result type (might be due to invalid IL or missing references)
			//IL_09d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a19: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ab2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0acf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c1e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c33: Unknown result type (might be due to invalid IL or missing references)
			//IL_0eb3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ec8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ede: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ef3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f7f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f94: Unknown result type (might be due to invalid IL or missing references)
			//IL_0faa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0fbf: Unknown result type (might be due to invalid IL or missing references)
			//IL_105f: Unknown result type (might be due to invalid IL or missing references)
			//IL_14a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_14bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_1557: Unknown result type (might be due to invalid IL or missing references)
			//IL_156c: Unknown result type (might be due to invalid IL or missing references)
			//IL_1659: Unknown result type (might be due to invalid IL or missing references)
			//IL_166e: Unknown result type (might be due to invalid IL or missing references)
			//IL_1684: Unknown result type (might be due to invalid IL or missing references)
			//IL_1699: Unknown result type (might be due to invalid IL or missing references)
			//IL_172a: Unknown result type (might be due to invalid IL or missing references)
			//IL_1731: Unknown result type (might be due to invalid IL or missing references)
			int num = 60;
			for (int k = i - num; k < i + num; k++)
			{
				for (int l = j - num; l < j + num; l++)
				{
					Main.tile[k, l].liquid = 0;
					Main.tile[k, l].lava(lava: false);
					Main.tile[k, l].Clear(TileDataType.Slope);
				}
			}
			double dxStrength = GenVars.dxStrength1;
			double dyStrength = GenVars.dyStrength1;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = (double)j - dyStrength / 2.0;
			GenVars.dMinY = (int)val.Y;
			int num2 = 1;
			if (i > Main.maxTilesX / 2)
			{
				num2 = -1;
			}
			if (drunkWorldGen || getGoodWorldGen)
			{
				num2 *= -1;
			}
			int num3 = (int)(val.X - dxStrength * 0.6 - (double)genRand.Next(2, 5));
			int num4 = (int)(val.X + dxStrength * 0.6 + (double)genRand.Next(2, 5));
			int num5 = (int)(val.Y - dyStrength * 0.6 - (double)genRand.Next(2, 5));
			int num6 = (int)(val.Y + dyStrength * 0.6 + (double)genRand.Next(8, 16));
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int m = num3; m < num4; m++)
			{
				for (int n = num5; n < num6; n++)
				{
					Main.tile[m, n].liquid = 0;
					if (Main.tile[m, n].wall != wallType)
					{
						Main.tile[m, n].wall = 0;
						if (m > num3 + 1 && m < num4 - 2 && n > num5 + 1 && n < num6 - 2)
						{
							Main.tile[m, n].wall = (ushort)wallType;
						}
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = tileType;
						Main.tile[m, n].Clear(TileDataType.Slope);
					}
				}
			}
			int num7 = num3;
			int num8 = num3 + 5 + genRand.Next(4);
			int num9 = num5 - 3 - genRand.Next(3);
			int num10 = num5;
			for (int num11 = num7; num11 < num8; num11++)
			{
				for (int num12 = num9; num12 < num10; num12++)
				{
					Main.tile[num11, num12].liquid = 0;
					if (Main.tile[num11, num12].wall != wallType)
					{
						Main.tile[num11, num12].active(active: true);
						Main.tile[num11, num12].type = tileType;
						Main.tile[num11, num12].Clear(TileDataType.Slope);
					}
				}
			}
			num7 = num4 - 5 - genRand.Next(4);
			num8 = num4;
			num9 = num5 - 3 - genRand.Next(3);
			num10 = num5;
			for (int num13 = num7; num13 < num8; num13++)
			{
				for (int num14 = num9; num14 < num10; num14++)
				{
					Main.tile[num13, num14].liquid = 0;
					if (Main.tile[num13, num14].wall != wallType)
					{
						Main.tile[num13, num14].active(active: true);
						Main.tile[num13, num14].type = tileType;
						Main.tile[num13, num14].Clear(TileDataType.Slope);
					}
				}
			}
			int num15 = 1 + genRand.Next(2);
			int num16 = 2 + genRand.Next(4);
			int num17 = 0;
			for (int num18 = num3; num18 < num4; num18++)
			{
				for (int num19 = num5 - num15; num19 < num5; num19++)
				{
					Main.tile[num18, num19].liquid = 0;
					if (Main.tile[num18, num19].wall != wallType)
					{
						Main.tile[num18, num19].active(active: true);
						Main.tile[num18, num19].type = tileType;
						Main.tile[num18, num19].Clear(TileDataType.Slope);
					}
				}
				num17++;
				if (num17 >= num16)
				{
					num18 += num16;
					num17 = 0;
				}
			}
			for (int num20 = num3; num20 < num4; num20++)
			{
				for (int num21 = num6; (double)num21 < Main.worldSurface; num21++)
				{
					Main.tile[num20, num21].liquid = 0;
					if (!Main.wallDungeon[Main.tile[num20, num21].wall])
					{
						Main.tile[num20, num21].active(active: true);
						Main.tile[num20, num21].type = tileType;
					}
					if (num20 > num3 && num20 < num4 - 1)
					{
						Main.tile[num20, num21].wall = (ushort)wallType;
					}
					Main.tile[num20, num21].Clear(TileDataType.Slope);
				}
			}
			num3 = (int)(val.X - dxStrength * 0.6);
			num4 = (int)(val.X + dxStrength * 0.6);
			num5 = (int)(val.Y - dyStrength * 0.6);
			num6 = (int)(val.Y + dyStrength * 0.6);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int num22 = num3; num22 < num4; num22++)
			{
				for (int num23 = num5; num23 < num6; num23++)
				{
					Main.tile[num22, num23].liquid = 0;
					Main.tile[num22, num23].wall = (ushort)wallType;
					Main.tile[num22, num23].Clear(TileDataType.Slope);
				}
			}
			num3 = (int)(val.X - dxStrength * 0.6 - 1.0);
			num4 = (int)(val.X + dxStrength * 0.6 + 1.0);
			num5 = (int)(val.Y - dyStrength * 0.6 - 1.0);
			num6 = (int)(val.Y + dyStrength * 0.6 + 1.0);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			if (drunkWorldGen)
			{
				num3 -= 4;
			}
			for (int num24 = num3; num24 < num4; num24++)
			{
				for (int num25 = num5; num25 < num6; num25++)
				{
					Main.tile[num24, num25].liquid = 0;
					Main.tile[num24, num25].wall = (ushort)wallType;
					Main.tile[num24, num25].Clear(TileDataType.Slope);
				}
			}
			num3 = (int)(val.X - dxStrength * 0.5);
			num4 = (int)(val.X + dxStrength * 0.5);
			num5 = (int)(val.Y - dyStrength * 0.5);
			num6 = (int)(val.Y + dyStrength * 0.5);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int num26 = num3; num26 < num4; num26++)
			{
				for (int num27 = num5; num27 < num6; num27++)
				{
					Main.tile[num26, num27].liquid = 0;
					Main.tile[num26, num27].active(active: false);
					Main.tile[num26, num27].wall = (ushort)wallType;
				}
			}
			int num28 = (int)val.X;
			int num29 = num6;
			for (int num30 = 0; num30 < 20; num30++)
			{
				num28 = (int)val.X - num30;
				if (!Main.tile[num28, num29].active() && Main.wallDungeon[Main.tile[num28, num29].wall])
				{
					GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = num28;
					GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = num29;
					GenVars.numDungeonPlatforms++;
					break;
				}
				num28 = (int)val.X + num30;
				if (!Main.tile[num28, num29].active() && Main.wallDungeon[Main.tile[num28, num29].wall])
				{
					GenVars.dungeonPlatformX[GenVars.numDungeonPlatforms] = num28;
					GenVars.dungeonPlatformY[GenVars.numDungeonPlatforms] = num29;
					GenVars.numDungeonPlatforms++;
					break;
				}
			}
			val.X += dxStrength * 0.6 * (double)num2;
			val.Y += dyStrength * 0.5;
			dxStrength = GenVars.dxStrength2;
			dyStrength = GenVars.dyStrength2;
			val.X += dxStrength * 0.55 * (double)num2;
			val.Y -= dyStrength * 0.5;
			num3 = (int)(val.X - dxStrength * 0.6 - (double)genRand.Next(1, 3));
			num4 = (int)(val.X + dxStrength * 0.6 + (double)genRand.Next(1, 3));
			num5 = (int)(val.Y - dyStrength * 0.6 - (double)genRand.Next(1, 3));
			num6 = (int)(val.Y + dyStrength * 0.6 + (double)genRand.Next(6, 16));
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int num31 = num3; num31 < num4; num31++)
			{
				for (int num32 = num5; num32 < num6; num32++)
				{
					Main.tile[num31, num32].liquid = 0;
					if (Main.tile[num31, num32].wall == wallType)
					{
						continue;
					}
					bool flag = true;
					if (num2 < 0)
					{
						if ((double)num31 < val.X - dxStrength * 0.5)
						{
							flag = false;
						}
					}
					else if ((double)num31 > val.X + dxStrength * 0.5 - 1.0)
					{
						flag = false;
					}
					if (flag)
					{
						Main.tile[num31, num32].wall = 0;
						Main.tile[num31, num32].active(active: true);
						Main.tile[num31, num32].type = tileType;
						Main.tile[num31, num32].Clear(TileDataType.Slope);
					}
				}
			}
			for (int num33 = num3; num33 < num4; num33++)
			{
				for (int num34 = num6; (double)num34 < Main.worldSurface; num34++)
				{
					Main.tile[num33, num34].liquid = 0;
					if (!Main.wallDungeon[Main.tile[num33, num34].wall])
					{
						Main.tile[num33, num34].active(active: true);
						Main.tile[num33, num34].type = tileType;
					}
					Main.tile[num33, num34].wall = (ushort)wallType;
					Main.tile[num33, num34].Clear(TileDataType.Slope);
				}
			}
			num3 = (int)(val.X - dxStrength * 0.5);
			num4 = (int)(val.X + dxStrength * 0.5);
			num7 = num3;
			if (num2 < 0)
			{
				num7++;
			}
			num8 = num7 + 5 + genRand.Next(4);
			num9 = num5 - 3 - genRand.Next(3);
			num10 = num5;
			for (int num35 = num7; num35 < num8; num35++)
			{
				for (int num36 = num9; num36 < num10; num36++)
				{
					Main.tile[num35, num36].liquid = 0;
					if (Main.tile[num35, num36].wall != wallType)
					{
						Main.tile[num35, num36].active(active: true);
						Main.tile[num35, num36].type = tileType;
						Main.tile[num35, num36].Clear(TileDataType.Slope);
					}
				}
			}
			num7 = num4 - 5 - genRand.Next(4);
			num8 = num4;
			num9 = num5 - 3 - genRand.Next(3);
			num10 = num5;
			for (int num37 = num7; num37 < num8; num37++)
			{
				for (int num38 = num9; num38 < num10; num38++)
				{
					Main.tile[num37, num38].liquid = 0;
					if (Main.tile[num37, num38].wall != wallType)
					{
						Main.tile[num37, num38].active(active: true);
						Main.tile[num37, num38].type = tileType;
						Main.tile[num37, num38].Clear(TileDataType.Slope);
					}
				}
			}
			num15 = 1 + genRand.Next(2);
			num16 = 2 + genRand.Next(4);
			num17 = 0;
			if (num2 < 0)
			{
				num4++;
			}
			for (int num39 = num3 + 1; num39 < num4 - 1; num39++)
			{
				for (int num40 = num5 - num15; num40 < num5; num40++)
				{
					Main.tile[num39, num40].liquid = 0;
					if (Main.tile[num39, num40].wall != wallType)
					{
						Main.tile[num39, num40].active(active: true);
						Main.tile[num39, num40].type = tileType;
						Main.tile[num39, num40].Clear(TileDataType.Slope);
					}
				}
				num17++;
				if (num17 >= num16)
				{
					num39 += num16;
					num17 = 0;
				}
			}
			if (!drunkWorldGen)
			{
				num3 = (int)(val.X - dxStrength * 0.6);
				num4 = (int)(val.X + dxStrength * 0.6);
				num5 = (int)(val.Y - dyStrength * 0.6);
				num6 = (int)(val.Y + dyStrength * 0.6);
				if (num3 < 0)
				{
					num3 = 0;
				}
				if (num4 > Main.maxTilesX)
				{
					num4 = Main.maxTilesX;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int num41 = num3; num41 < num4; num41++)
				{
					for (int num42 = num5; num42 < num6; num42++)
					{
						Main.tile[num41, num42].liquid = 0;
						Main.tile[num41, num42].wall = 0;
					}
				}
			}
			num3 = (int)(val.X - dxStrength * 0.5);
			num4 = (int)(val.X + dxStrength * 0.5);
			num5 = (int)(val.Y - dyStrength * 0.5);
			num6 = (int)(val.Y + dyStrength * 0.5);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int num43 = num3; num43 < num4; num43++)
			{
				for (int num44 = num5; num44 < num6; num44++)
				{
					Main.tile[num43, num44].liquid = 0;
					Main.tile[num43, num44].active(active: false);
					Main.tile[num43, num44].wall = 0;
				}
			}
			Main.dungeonX = (int)val.X;
			Main.dungeonY = num6;
			int num45 = NPC.NewNPC(new EntitySource_WorldGen(), Main.dungeonX * 16 + 8, Main.dungeonY * 16, 37);
			Main.npc[num45].homeless = false;
			Main.npc[num45].homeTileX = Main.dungeonX;
			Main.npc[num45].homeTileY = Main.dungeonY;
			if (drunkWorldGen)
			{
				int num46 = (int)Main.worldSurface;
				while (Main.tile[GenVars.dungeonX, num46].active() || Main.tile[GenVars.dungeonX, num46].wall > 0 || Main.tile[GenVars.dungeonX, num46 - 1].active() || Main.tile[GenVars.dungeonX, num46 - 1].wall > 0 || Main.tile[GenVars.dungeonX, num46 - 2].active() || Main.tile[GenVars.dungeonX, num46 - 2].wall > 0 || Main.tile[GenVars.dungeonX, num46 - 3].active() || Main.tile[GenVars.dungeonX, num46 - 3].wall > 0 || Main.tile[GenVars.dungeonX, num46 - 4].active() || Main.tile[GenVars.dungeonX, num46 - 4].wall > 0)
				{
					num46--;
					if (num46 < 50)
					{
						break;
					}
				}
				if (num46 > 50)
				{
					GrowDungeonTree(GenVars.dungeonX, num46);
				}
			}
			if (!drunkWorldGen)
			{
				int num47 = 100;
				if (num2 == 1)
				{
					int num48 = 0;
					for (int num49 = num4; num49 < num4 + num47; num49++)
					{
						num48++;
						for (int num50 = num6 + num48; num50 < num6 + num47; num50++)
						{
							Main.tile[num49, num50].liquid = 0;
							Main.tile[num49, num50 - 1].liquid = 0;
							Main.tile[num49, num50 - 2].liquid = 0;
							Main.tile[num49, num50 - 3].liquid = 0;
							if (!Main.wallDungeon[Main.tile[num49, num50].wall] && Main.tile[num49, num50].wall != 3 && Main.tile[num49, num50].wall != 83)
							{
								Main.tile[num49, num50].active(active: true);
								Main.tile[num49, num50].type = tileType;
								Main.tile[num49, num50].Clear(TileDataType.Slope);
							}
						}
					}
				}
				else
				{
					int num51 = 0;
					for (int num52 = num3; num52 > num3 - num47; num52--)
					{
						num51++;
						for (int num53 = num6 + num51; num53 < num6 + num47; num53++)
						{
							Main.tile[num52, num53].liquid = 0;
							Main.tile[num52, num53 - 1].liquid = 0;
							Main.tile[num52, num53 - 2].liquid = 0;
							Main.tile[num52, num53 - 3].liquid = 0;
							if (!Main.wallDungeon[Main.tile[num52, num53].wall] && Main.tile[num52, num53].wall != 3 && Main.tile[num52, num53].wall != 83)
							{
								Main.tile[num52, num53].active(active: true);
								Main.tile[num52, num53].type = tileType;
								Main.tile[num52, num53].Clear(TileDataType.Slope);
							}
						}
					}
				}
			}
			num15 = 1 + genRand.Next(2);
			num16 = 2 + genRand.Next(4);
			num17 = 0;
			num3 = (int)(val.X - dxStrength * 0.5);
			num4 = (int)(val.X + dxStrength * 0.5);
			if (drunkWorldGen)
			{
				if (num2 == 1)
				{
					num4--;
					num3--;
				}
				else
				{
					num3++;
					num4++;
				}
			}
			else
			{
				num3 += 2;
				num4 -= 2;
			}
			for (int num54 = num3; num54 < num4; num54++)
			{
				for (int num55 = num5; num55 < num6 + 1; num55++)
				{
					PlaceWall(num54, num55, wallType, mute: true);
				}
				if (!drunkWorldGen)
				{
					num17++;
					if (num17 >= num16)
					{
						num54 += num16 * 2;
						num17 = 0;
					}
				}
			}
			if (drunkWorldGen)
			{
				num3 = (int)(val.X - dxStrength * 0.5);
				num4 = (int)(val.X + dxStrength * 0.5);
				if (num2 == 1)
				{
					num3 = num4 - 3;
				}
				else
				{
					num4 = num3 + 3;
				}
				for (int num56 = num3; num56 < num4; num56++)
				{
					for (int num57 = num5; num57 < num6 + 1; num57++)
					{
						Main.tile[num56, num57].active(active: true);
						Main.tile[num56, num57].type = tileType;
						Main.tile[num56, num57].Clear(TileDataType.Slope);
					}
				}
			}
			val.X -= dxStrength * 0.6 * (double)num2;
			val.Y += dyStrength * 0.5;
			dxStrength = 15.0;
			dyStrength = 3.0;
			val.Y -= dyStrength * 0.5;
			num3 = (int)(val.X - dxStrength * 0.5);
			num4 = (int)(val.X + dxStrength * 0.5);
			num5 = (int)(val.Y - dyStrength * 0.5);
			num6 = (int)(val.Y + dyStrength * 0.5);
			if (num3 < 0)
			{
				num3 = 0;
			}
			if (num4 > Main.maxTilesX)
			{
				num4 = Main.maxTilesX;
			}
			if (num5 < 0)
			{
				num5 = 0;
			}
			if (num6 > Main.maxTilesY)
			{
				num6 = Main.maxTilesY;
			}
			for (int num58 = num3; num58 < num4; num58++)
			{
				for (int num59 = num5; num59 < num6; num59++)
				{
					Main.tile[num58, num59].active(active: false);
				}
			}
			if (num2 < 0)
			{
				val.X -= 1.0;
			}
			PlaceTile((int)val.X, (int)val.Y + 1, 10, mute: true, forced: false, -1, 13);
		}

		public static bool AddBuriedChest(Point point, int contain = 0, bool notNearOtherChests = false, int Style = -1)
		{
			return AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style, trySlope: false, 0);
		}

		public static bool IsChestRigged(int x, int y)
		{
			if (Main.tile[x, y].type == 467)
			{
				return Main.tile[x, y].frameX / 36 == 4;
			}
			return false;
		}

		private static bool IsUndergroundDesert(int x, int y)
		{
			if ((double)y < Main.worldSurface)
			{
				return false;
			}
			if ((double)x < (double)Main.maxTilesX * 0.15 || (double)x > (double)Main.maxTilesX * 0.85)
			{
				return false;
			}
			if (remixWorldGen && (double)y > Main.rockLayer)
			{
				return false;
			}
			int num = 15;
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num; j <= y + num; j++)
				{
					if (Main.tile[i, j].wall == 187 || Main.tile[i, j].wall == 216)
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool IsDungeon(int x, int y)
		{
			if ((double)y < Main.worldSurface)
			{
				return false;
			}
			if (x < 0 || x > Main.maxTilesX)
			{
				return false;
			}
			if (Main.wallDungeon[Main.tile[x, y].wall])
			{
				return true;
			}
			return false;
		}

		public static bool AddBuriedChest(int i, int j, int contain = 0, bool notNearOtherChests = false, int Style = -1, bool trySlope = false, ushort chestTileType = 0)
		{
			if (chestTileType == 0)
			{
				chestTileType = 21;
			}
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			bool flag6 = false;
			bool flag7 = false;
			bool flag8 = false;
			bool flag9 = false;
			bool flag10 = false;
			int num = 15;
			if (tenthAnniversaryWorldGen)
			{
				num *= 3;
			}
			for (int k = j; k < Main.maxTilesY - 10; k++)
			{
				int num2 = -1;
				int num3 = -1;
				if (Main.tile[i, k].shimmer())
				{
					return false;
				}
				if (trySlope && Main.tile[i, k].active() && Main.tileSolid[Main.tile[i, k].type] && !Main.tileSolidTop[Main.tile[i, k].type])
				{
					if (Style == 17)
					{
						int num4 = 30;
						for (int l = i - num4; l <= i + num4; l++)
						{
							for (int m = k - num4; m <= k + num4; m++)
							{
								if (!InWorld(l, m, 5))
								{
									return false;
								}
								if (Main.tile[l, m].active() && (Main.tile[l, m].type == 21 || Main.tile[l, m].type == 467))
								{
									return false;
								}
							}
						}
					}
					if (Main.tile[i - 1, k].topSlope())
					{
						num2 = Main.tile[i - 1, k].slope();
						Main.tile[i - 1, k].slope(0);
					}
					if (Main.tile[i, k].topSlope())
					{
						num3 = Main.tile[i, k].slope();
						Main.tile[i, k].slope(0);
					}
				}
				if (remixWorldGen && (double)i > (double)Main.maxTilesX * 0.37 && (double)i < (double)Main.maxTilesX * 0.63 && k > Main.maxTilesY - 250)
				{
					return false;
				}
				int num5 = 2;
				for (int n = i - num5; n <= i + num5; n++)
				{
					for (int num6 = k - num5; num6 <= k + num5; num6++)
					{
						if (Main.tile[n, num6].active() && (TileID.Sets.Boulders[Main.tile[n, num6].type] || Main.tile[n, num6].type == 26 || Main.tile[n, num6].type == 237))
						{
							return false;
						}
					}
				}
				if (!SolidTile(i, k))
				{
					continue;
				}
				bool flag11 = false;
				int num7 = k;
				int num8 = -1;
				int num9 = 0;
				bool flag12 = (double)num7 >= Main.worldSurface + 25.0;
				if (remixWorldGen)
				{
					flag12 = num7 < Main.maxTilesY - 400;
				}
				if (flag12 || contain > 0)
				{
					num9 = 1;
				}
				if (Style >= 0)
				{
					num9 = Style;
				}
				if (contain == 0 && num7 <= Main.maxTilesY - 205 && IsUndergroundDesert(i, k))
				{
					flag2 = true;
					num9 = 10;
					chestTileType = 467;
					contain = ((num7 <= (GenVars.desertHiveHigh * 3 + GenVars.desertHiveLow * 4) / 7) ? Utils.SelectRandom(genRand, new short[4] { 4056, 4055, 4262, 4263 }) : Utils.SelectRandom(genRand, new short[3] { 4061, 4062, 4276 }));
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && (num9 == 11 || (contain == 0 && (double)num7 >= Main.worldSurface + 25.0 && num7 <= Main.maxTilesY - 205 && (Main.tile[i, k].type == 147 || Main.tile[i, k].type == 161 || Main.tile[i, k].type == 162))))
				{
					flag = true;
					num9 = 11;
					contain = genRand.Next(6) switch
					{
						0 => 670, 
						1 => 724, 
						2 => 950, 
						3 => (!remixWorldGen) ? 1319 : 725, 
						4 => 987, 
						_ => 1579, 
					};
					if (genRand.Next(20) == 0)
					{
						contain = 997;
					}
					if (genRand.Next(50) == 0)
					{
						contain = 669;
					}
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && (Style == 10 || contain == 211 || contain == 212 || contain == 213 || contain == 753))
				{
					flag3 = true;
					num9 = 10;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num7 > Main.maxTilesY - 205 && contain == 0)
				{
					flag7 = true;
					contain = GenVars.hellChestItem[GenVars.hellChest];
					num9 = 4;
					flag11 = true;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num9 == 17)
				{
					flag4 = true;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num9 == 12)
				{
					flag5 = true;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num9 == 32)
				{
					flag6 = true;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num9 != 0 && IsDungeon(i, k))
				{
					flag8 = true;
					if (getGoodWorldGen && genRand.Next(num) == 0)
					{
						contain = 52;
					}
				}
				if (chestTileType == 21 && num9 != 0 && (contain == 848 || contain == 857 || contain == 934))
				{
					flag9 = true;
				}
				if (chestTileType == 21 && (num9 == 13 || contain == 159 || contain == 65 || contain == 158 || contain == 2219))
				{
					flag10 = true;
					if (remixWorldGen && !getGoodWorldGen)
					{
						if (crimson)
						{
							num9 = 43;
						}
						else
						{
							chestTileType = 467;
							num9 = 3;
						}
					}
				}
				if (noTrapsWorldGen && num9 == 1 && chestTileType == 21 && (!remixWorldGen || genRand.Next(3) == 0))
				{
					num9 = 4;
					chestTileType = 467;
				}
				num8 = ((chestTileType != 467) ? PlaceChest(i - 1, num7 - 1, chestTileType, notNearOtherChests, num9) : PlaceChest(i - 1, num7 - 1, chestTileType, notNearOtherChests, num9));
				if (num8 >= 0)
				{
					if (flag11)
					{
						GenVars.hellChest++;
						if (GenVars.hellChest >= GenVars.hellChestItem.Length)
						{
							GenVars.hellChest = 0;
						}
					}
					Chest chest = Main.chest[num8];
					int num10 = 0;
					while (num10 == 0)
					{
						bool flag13 = (double)num7 < Main.worldSurface + 25.0;
						if (remixWorldGen)
						{
							flag13 = (double)num7 >= (Main.rockLayer + (double)((Main.maxTilesY - 350) * 2)) / 3.0;
						}
						if ((num9 == 0 && flag13) || flag9)
						{
							if (contain > 0)
							{
								chest.item[num10].SetDefaults(contain);
								chest.item[num10].Prefix(-1);
								num10++;
								switch (contain)
								{
								case 848:
									chest.item[num10].SetDefaults(866);
									num10++;
									break;
								case 832:
									chest.item[num10].SetDefaults(933);
									num10++;
									if (genRand.Next(6) == 0)
									{
										int num11 = genRand.Next(2);
										switch (num11)
										{
										case 0:
											num11 = 4429;
											break;
										case 1:
											num11 = 4427;
											break;
										}
										chest.item[num10].SetDefaults(num11);
										num10++;
									}
									break;
								}
								if (Main.tenthAnniversaryWorld && flag9)
								{
									chest.item[num10++].SetDefaults(848);
									chest.item[num10++].SetDefaults(866);
								}
							}
							else
							{
								int num12 = genRand.Next(10);
								if (num12 == 0)
								{
									chest.item[num10].SetDefaults(280);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 1)
								{
									chest.item[num10].SetDefaults(281);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 2)
								{
									chest.item[num10].SetDefaults(284);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 3)
								{
									chest.item[num10].SetDefaults(285);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 4)
								{
									chest.item[num10].SetDefaults(953);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 5)
								{
									chest.item[num10].SetDefaults(946);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 6)
								{
									chest.item[num10].SetDefaults(3068);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 7)
								{
									if (remixWorldGen)
									{
										chest.item[num10].SetDefaults(517);
										chest.item[num10].Prefix(-1);
									}
									else
									{
										chest.item[num10].SetDefaults(3069);
										chest.item[num10].Prefix(-1);
									}
								}
								if (num12 == 8)
								{
									chest.item[num10].SetDefaults(3084);
									chest.item[num10].Prefix(-1);
								}
								if (num12 == 9)
								{
									chest.item[num10].SetDefaults(4341);
									chest.item[num10].Prefix(-1);
								}
								num10++;
							}
							if (genRand.Next(6) == 0)
							{
								int stack = genRand.Next(40, 76);
								chest.item[num10].SetDefaults(282);
								chest.item[num10].stack = stack;
								num10++;
							}
							if (genRand.Next(6) == 0)
							{
								int stack2 = genRand.Next(150, 301);
								chest.item[num10].SetDefaults(279);
								chest.item[num10].stack = stack2;
								num10++;
							}
							if (genRand.Next(6) == 0)
							{
								chest.item[num10].SetDefaults(3093);
								chest.item[num10].stack = 1;
								if (genRand.Next(5) == 0)
								{
									chest.item[num10].stack += genRand.Next(2);
								}
								if (genRand.Next(10) == 0)
								{
									chest.item[num10].stack += genRand.Next(3);
								}
								num10++;
							}
							if (genRand.Next(6) == 0)
							{
								chest.item[num10].SetDefaults(4345);
								chest.item[num10].stack = 1;
								if (genRand.Next(5) == 0)
								{
									chest.item[num10].stack += genRand.Next(2);
								}
								if (genRand.Next(10) == 0)
								{
									chest.item[num10].stack += genRand.Next(3);
								}
								num10++;
							}
							if (genRand.Next(3) == 0)
							{
								chest.item[num10].SetDefaults(168);
								chest.item[num10].stack = genRand.Next(3, 6);
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num13 = genRand.Next(2);
								int stack3 = genRand.Next(8) + 3;
								if (num13 == 0)
								{
									chest.item[num10].SetDefaults(GenVars.copperBar);
								}
								if (num13 == 1)
								{
									chest.item[num10].SetDefaults(GenVars.ironBar);
								}
								chest.item[num10].stack = stack3;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack4 = genRand.Next(50, 101);
								chest.item[num10].SetDefaults(965);
								chest.item[num10].stack = stack4;
								num10++;
							}
							if (genRand.Next(3) != 0)
							{
								int num14 = genRand.Next(2);
								int stack5 = genRand.Next(26) + 25;
								if (num14 == 0)
								{
									chest.item[num10].SetDefaults(40);
								}
								if (num14 == 1)
								{
									chest.item[num10].SetDefaults(42);
								}
								chest.item[num10].stack = stack5;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack6 = genRand.Next(3) + 3;
								chest.item[num10].SetDefaults(28);
								chest.item[num10].stack = stack6;
								num10++;
							}
							if (genRand.Next(3) != 0)
							{
								chest.item[num10].SetDefaults(2350);
								chest.item[num10].stack = genRand.Next(3, 6);
								num10++;
							}
							if (genRand.Next(3) > 0)
							{
								int num15 = genRand.Next(6);
								int stack7 = genRand.Next(1, 3);
								if (num15 == 0)
								{
									chest.item[num10].SetDefaults(292);
								}
								if (num15 == 1)
								{
									chest.item[num10].SetDefaults(298);
								}
								if (num15 == 2)
								{
									chest.item[num10].SetDefaults(299);
								}
								if (num15 == 3)
								{
									chest.item[num10].SetDefaults(290);
								}
								if (num15 == 4)
								{
									chest.item[num10].SetDefaults(2322);
								}
								if (num15 == 5)
								{
									chest.item[num10].SetDefaults(2325);
								}
								chest.item[num10].stack = stack7;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num16 = genRand.Next(2);
								int stack8 = genRand.Next(11) + 10;
								if (num16 == 0)
								{
									chest.item[num10].SetDefaults(8);
								}
								if (num16 == 1)
								{
									chest.item[num10].SetDefaults(31);
								}
								chest.item[num10].stack = stack8;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num10].SetDefaults(72);
								chest.item[num10].stack = genRand.Next(10, 30);
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num10].SetDefaults(9);
								chest.item[num10].stack = genRand.Next(50, 100);
								num10++;
							}
						}
						else if ((!remixWorldGen && (double)num7 < Main.rockLayer) || (remixWorldGen && (double)num7 > Main.rockLayer && num7 < Main.maxTilesY - 250))
						{
							if (contain > 0)
							{
								if (contain == 832)
								{
									chest.item[num10].SetDefaults(933);
									num10++;
								}
								chest.item[num10].SetDefaults(contain);
								chest.item[num10].Prefix(-1);
								num10++;
								if (flag4)
								{
									if (genRand.Next(2) == 0)
									{
										chest.item[num10++].SetDefaults(4425);
									}
									if (genRand.Next(2) == 0)
									{
										chest.item[num10++].SetDefaults(4460);
									}
								}
								if (flag10 && genRand.Next(40) == 0)
								{
									chest.item[num10++].SetDefaults(4978);
								}
								if (flag5 && genRand.Next(10) == 0)
								{
									int num17 = genRand.Next(2);
									switch (num17)
									{
									case 0:
										num17 = 4429;
										break;
									case 1:
										num17 = 4427;
										break;
									}
									chest.item[num10].SetDefaults(num17);
									num10++;
								}
								if (flag8 && (!GenVars.generatedShadowKey || genRand.Next(3) == 0))
								{
									GenVars.generatedShadowKey = true;
									chest.item[num10].SetDefaults(329);
									num10++;
								}
							}
							else
							{
								switch (genRand.Next(6))
								{
								case 0:
									chest.item[num10].SetDefaults(49);
									chest.item[num10].Prefix(-1);
									break;
								case 1:
									chest.item[num10].SetDefaults(50);
									chest.item[num10].Prefix(-1);
									break;
								case 2:
									chest.item[num10].SetDefaults(53);
									chest.item[num10].Prefix(-1);
									break;
								case 3:
									chest.item[num10].SetDefaults(54);
									chest.item[num10].Prefix(-1);
									break;
								case 4:
									chest.item[num10].SetDefaults(5011);
									chest.item[num10].Prefix(-1);
									break;
								default:
									chest.item[num10].SetDefaults(975);
									chest.item[num10].Prefix(-1);
									break;
								}
								num10++;
								if (genRand.Next(20) == 0)
								{
									chest.item[num10].SetDefaults(997);
									chest.item[num10].Prefix(-1);
									num10++;
								}
								else if (genRand.Next(20) == 0)
								{
									chest.item[num10].SetDefaults(930);
									chest.item[num10].Prefix(-1);
									num10++;
									chest.item[num10].SetDefaults(931);
									chest.item[num10].stack = genRand.Next(26) + 25;
									num10++;
								}
								if (flag6 && genRand.Next(2) == 0)
								{
									chest.item[num10].SetDefaults(4450);
									num10++;
								}
								if (flag6 && genRand.Next(3) == 0)
								{
									chest.item[num10].SetDefaults(4779);
									num10++;
									chest.item[num10].SetDefaults(4780);
									num10++;
									chest.item[num10].SetDefaults(4781);
									num10++;
								}
							}
							if (flag2)
							{
								if (genRand.Next(3) == 0)
								{
									chest.item[num10].SetDefaults(4423);
									chest.item[num10].stack = genRand.Next(10, 20);
									num10++;
								}
							}
							else if (genRand.Next(3) == 0)
							{
								chest.item[num10].SetDefaults(166);
								chest.item[num10].stack = genRand.Next(10, 20);
								num10++;
							}
							if (genRand.Next(5) == 0)
							{
								chest.item[num10].SetDefaults(52);
								num10++;
							}
							if (genRand.Next(3) == 0)
							{
								int stack9 = genRand.Next(50, 101);
								chest.item[num10].SetDefaults(965);
								chest.item[num10].stack = stack9;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num18 = genRand.Next(2);
								int stack10 = genRand.Next(10) + 5;
								if (num18 == 0)
								{
									chest.item[num10].SetDefaults(GenVars.ironBar);
								}
								if (num18 == 1)
								{
									chest.item[num10].SetDefaults(GenVars.silverBar);
								}
								chest.item[num10].stack = stack10;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num19 = genRand.Next(2);
								int stack11 = genRand.Next(25) + 25;
								if (num19 == 0)
								{
									chest.item[num10].SetDefaults(40);
								}
								if (num19 == 1)
								{
									chest.item[num10].SetDefaults(42);
								}
								chest.item[num10].stack = stack11;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack12 = genRand.Next(3) + 3;
								chest.item[num10].SetDefaults(28);
								chest.item[num10].stack = stack12;
								num10++;
							}
							if (genRand.Next(3) > 0)
							{
								int num20 = genRand.Next(9);
								int stack13 = genRand.Next(1, 3);
								if (num20 == 0)
								{
									chest.item[num10].SetDefaults(289);
								}
								if (num20 == 1)
								{
									chest.item[num10].SetDefaults(298);
								}
								if (num20 == 2)
								{
									chest.item[num10].SetDefaults(299);
								}
								if (num20 == 3)
								{
									chest.item[num10].SetDefaults(290);
								}
								if (num20 == 4)
								{
									chest.item[num10].SetDefaults(303);
								}
								if (num20 == 5)
								{
									chest.item[num10].SetDefaults(291);
								}
								if (num20 == 6)
								{
									chest.item[num10].SetDefaults(304);
								}
								if (num20 == 7)
								{
									chest.item[num10].SetDefaults(2322);
								}
								if (num20 == 8)
								{
									chest.item[num10].SetDefaults(2329);
								}
								chest.item[num10].stack = stack13;
								num10++;
							}
							if (genRand.Next(3) != 0)
							{
								int stack14 = genRand.Next(2, 5);
								chest.item[num10].SetDefaults(2350);
								chest.item[num10].stack = stack14;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack15 = genRand.Next(11) + 10;
								if (num9 == 11)
								{
									chest.item[num10].SetDefaults(974);
								}
								else
								{
									chest.item[num10].SetDefaults(8);
								}
								chest.item[num10].stack = stack15;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num10].SetDefaults(72);
								chest.item[num10].stack = genRand.Next(50, 90);
								num10++;
							}
						}
						else if (num7 < Main.maxTilesY - 250 || (remixWorldGen && (Style == 7 || Style == 14)))
						{
							if (contain > 0)
							{
								chest.item[num10].SetDefaults(contain);
								chest.item[num10].Prefix(-1);
								num10++;
								if (flag && genRand.Next(5) == 0)
								{
									chest.item[num10].SetDefaults(3199);
									num10++;
								}
								if (flag2)
								{
									if (genRand.Next(7) == 0)
									{
										chest.item[num10].SetDefaults(4346);
										num10++;
									}
									if (genRand.Next(15) == 0)
									{
										chest.item[num10].SetDefaults(4066);
										num10++;
									}
								}
								if (flag3 && genRand.Next(6) == 0)
								{
									chest.item[num10++].SetDefaults(3360);
									chest.item[num10++].SetDefaults(3361);
								}
								if (flag3 && genRand.Next(10) == 0)
								{
									chest.item[num10++].SetDefaults(4426);
								}
								if (flag4)
								{
									if (genRand.Next(2) == 0)
									{
										chest.item[num10++].SetDefaults(4425);
									}
									if (genRand.Next(2) == 0)
									{
										chest.item[num10++].SetDefaults(4460);
									}
								}
								if (flag8 && (!GenVars.generatedShadowKey || genRand.Next(3) == 0))
								{
									GenVars.generatedShadowKey = true;
									chest.item[num10].SetDefaults(329);
									num10++;
								}
							}
							else
							{
								int num21 = genRand.Next(7);
								bool flag14 = num7 > GenVars.lavaLine;
								if (remixWorldGen)
								{
									flag14 = (double)num7 > Main.worldSurface && (double)num7 < Main.rockLayer;
								}
								int maxValue = 20;
								if (tenthAnniversaryWorldGen)
								{
									maxValue = 15;
								}
								if (genRand.Next(maxValue) == 0 && flag14)
								{
									chest.item[num10].SetDefaults(906);
									chest.item[num10].Prefix(-1);
								}
								else if (genRand.Next(15) == 0)
								{
									chest.item[num10].SetDefaults(997);
									chest.item[num10].Prefix(-1);
								}
								else
								{
									if (num21 == 0)
									{
										chest.item[num10].SetDefaults(49);
										chest.item[num10].Prefix(-1);
									}
									if (num21 == 1)
									{
										chest.item[num10].SetDefaults(50);
										chest.item[num10].Prefix(-1);
									}
									if (num21 == 2)
									{
										chest.item[num10].SetDefaults(53);
										chest.item[num10].Prefix(-1);
									}
									if (num21 == 3)
									{
										chest.item[num10].SetDefaults(54);
										chest.item[num10].Prefix(-1);
									}
									if (num21 == 4)
									{
										chest.item[num10].SetDefaults(5011);
										chest.item[num10].Prefix(-1);
									}
									if (num21 == 5)
									{
										chest.item[num10].SetDefaults(975);
										chest.item[num10].Prefix(-1);
									}
									if (num21 == 6)
									{
										chest.item[num10].SetDefaults(930);
										chest.item[num10].Prefix(-1);
										num10++;
										chest.item[num10].SetDefaults(931);
										chest.item[num10].stack = genRand.Next(26) + 25;
									}
								}
								num10++;
								if (flag6)
								{
									if (genRand.Next(2) == 0)
									{
										chest.item[num10].SetDefaults(4450);
										num10++;
									}
									else
									{
										chest.item[num10].SetDefaults(4779);
										num10++;
										chest.item[num10].SetDefaults(4780);
										num10++;
										chest.item[num10].SetDefaults(4781);
										num10++;
									}
								}
							}
							if (genRand.Next(5) == 0)
							{
								chest.item[num10].SetDefaults(43);
								num10++;
							}
							if (genRand.Next(3) == 0)
							{
								chest.item[num10].SetDefaults(167);
								num10++;
							}
							if (genRand.Next(4) == 0)
							{
								chest.item[num10].SetDefaults(51);
								chest.item[num10].stack = genRand.Next(26) + 25;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num22 = genRand.Next(2);
								int stack16 = genRand.Next(8) + 3;
								if (num22 == 0)
								{
									chest.item[num10].SetDefaults(GenVars.goldBar);
								}
								if (num22 == 1)
								{
									chest.item[num10].SetDefaults(GenVars.silverBar);
								}
								chest.item[num10].stack = stack16;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num23 = genRand.Next(2);
								int stack17 = genRand.Next(26) + 25;
								if (num23 == 0)
								{
									chest.item[num10].SetDefaults(41);
								}
								if (num23 == 1)
								{
									chest.item[num10].SetDefaults(279);
								}
								chest.item[num10].stack = stack17;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack18 = genRand.Next(3) + 3;
								chest.item[num10].SetDefaults(188);
								chest.item[num10].stack = stack18;
								num10++;
							}
							if (genRand.Next(3) > 0)
							{
								int num24 = genRand.Next(6);
								int stack19 = genRand.Next(1, 3);
								if (num24 == 0)
								{
									chest.item[num10].SetDefaults(296);
								}
								if (num24 == 1)
								{
									chest.item[num10].SetDefaults(295);
								}
								if (num24 == 2)
								{
									chest.item[num10].SetDefaults(299);
								}
								if (num24 == 3)
								{
									chest.item[num10].SetDefaults(302);
								}
								if (num24 == 4)
								{
									chest.item[num10].SetDefaults(303);
								}
								if (num24 == 5)
								{
									chest.item[num10].SetDefaults(305);
								}
								chest.item[num10].stack = stack19;
								num10++;
							}
							if (genRand.Next(3) > 1)
							{
								int num25 = genRand.Next(6);
								int stack20 = genRand.Next(1, 3);
								if (num25 == 0)
								{
									chest.item[num10].SetDefaults(301);
								}
								if (num25 == 1)
								{
									chest.item[num10].SetDefaults(297);
								}
								if (num25 == 2)
								{
									chest.item[num10].SetDefaults(304);
								}
								if (num25 == 3)
								{
									chest.item[num10].SetDefaults(2329);
								}
								if (num25 == 4)
								{
									chest.item[num10].SetDefaults(2351);
								}
								if (num25 == 5)
								{
									chest.item[num10].SetDefaults(2326);
								}
								chest.item[num10].stack = stack20;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack21 = genRand.Next(2, 5);
								chest.item[num10].SetDefaults(2350);
								chest.item[num10].stack = stack21;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num26 = genRand.Next(2);
								int stack22 = genRand.Next(15) + 15;
								if (num26 == 0)
								{
									if (num9 == 11)
									{
										chest.item[num10].SetDefaults(974);
									}
									else
									{
										chest.item[num10].SetDefaults(8);
									}
								}
								if (num26 == 1)
								{
									chest.item[num10].SetDefaults(282);
								}
								chest.item[num10].stack = stack22;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num10].SetDefaults(73);
								chest.item[num10].stack = genRand.Next(1, 3);
								num10++;
							}
						}
						else
						{
							if (contain > 0)
							{
								chest.item[num10].SetDefaults(contain);
								chest.item[num10].Prefix(-1);
								num10++;
								if (flag7 && genRand.Next(5) == 0)
								{
									chest.item[num10].SetDefaults(5010);
									num10++;
								}
								if (flag7 && genRand.Next(10) == 0)
								{
									chest.item[num10].SetDefaults(4443);
									num10++;
								}
								if (flag7 && genRand.Next(10) == 0)
								{
									chest.item[num10].SetDefaults(4737);
									num10++;
								}
								if (flag7 && genRand.Next(10) == 0)
								{
									chest.item[num10].SetDefaults(4551);
									num10++;
								}
							}
							else
							{
								int num27 = genRand.Next(4);
								if (num27 == 0)
								{
									chest.item[num10].SetDefaults(49);
									chest.item[num10].Prefix(-1);
								}
								if (num27 == 1)
								{
									chest.item[num10].SetDefaults(50);
									chest.item[num10].Prefix(-1);
								}
								if (num27 == 2)
								{
									chest.item[num10].SetDefaults(53);
									chest.item[num10].Prefix(-1);
								}
								if (num27 == 3)
								{
									chest.item[num10].SetDefaults(54);
									chest.item[num10].Prefix(-1);
								}
								num10++;
							}
							if (genRand.Next(3) == 0)
							{
								chest.item[num10].SetDefaults(167);
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num28 = genRand.Next(2);
								int stack23 = genRand.Next(15) + 15;
								if (num28 == 0)
								{
									chest.item[num10].SetDefaults(117);
								}
								if (num28 == 1)
								{
									chest.item[num10].SetDefaults(GenVars.goldBar);
								}
								chest.item[num10].stack = stack23;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num29 = genRand.Next(2);
								int stack24 = genRand.Next(25) + 50;
								if (num29 == 0)
								{
									chest.item[num10].SetDefaults(265);
								}
								if (num29 == 1)
								{
									if (SavedOreTiers.Silver == 168)
									{
										chest.item[num10].SetDefaults(4915);
									}
									else
									{
										chest.item[num10].SetDefaults(278);
									}
								}
								chest.item[num10].stack = stack24;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int stack25 = genRand.Next(6) + 15;
								chest.item[num10].SetDefaults(227);
								chest.item[num10].stack = stack25;
								num10++;
							}
							if (genRand.Next(4) > 0)
							{
								int num30 = genRand.Next(8);
								int stack26 = genRand.Next(1, 3);
								if (num30 == 0)
								{
									chest.item[num10].SetDefaults(296);
								}
								if (num30 == 1)
								{
									chest.item[num10].SetDefaults(295);
								}
								if (num30 == 2)
								{
									chest.item[num10].SetDefaults(293);
								}
								if (num30 == 3)
								{
									chest.item[num10].SetDefaults(288);
								}
								if (num30 == 4)
								{
									chest.item[num10].SetDefaults(294);
								}
								if (num30 == 5)
								{
									chest.item[num10].SetDefaults(297);
								}
								if (num30 == 6)
								{
									chest.item[num10].SetDefaults(304);
								}
								if (num30 == 7)
								{
									chest.item[num10].SetDefaults(2323);
								}
								chest.item[num10].stack = stack26;
								num10++;
							}
							if (genRand.Next(3) > 0)
							{
								int num31 = genRand.Next(8);
								int stack27 = genRand.Next(1, 3);
								if (num31 == 0)
								{
									chest.item[num10].SetDefaults(305);
								}
								if (num31 == 1)
								{
									chest.item[num10].SetDefaults(301);
								}
								if (num31 == 2)
								{
									chest.item[num10].SetDefaults(302);
								}
								if (num31 == 3)
								{
									chest.item[num10].SetDefaults(288);
								}
								if (num31 == 4)
								{
									chest.item[num10].SetDefaults(300);
								}
								if (num31 == 5)
								{
									chest.item[num10].SetDefaults(2351);
								}
								if (num31 == 6)
								{
									chest.item[num10].SetDefaults(2348);
								}
								if (num31 == 7)
								{
									chest.item[num10].SetDefaults(2345);
								}
								chest.item[num10].stack = stack27;
								num10++;
							}
							if (genRand.Next(3) == 0)
							{
								int stack28 = genRand.Next(1, 3);
								if (genRand.Next(2) == 0)
								{
									chest.item[num10].SetDefaults(2350);
								}
								else
								{
									chest.item[num10].SetDefaults(4870);
								}
								chest.item[num10].stack = stack28;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								int num32 = genRand.Next(2);
								int stack29 = genRand.Next(15) + 15;
								if (num32 == 0)
								{
									chest.item[num10].SetDefaults(8);
								}
								if (num32 == 1)
								{
									chest.item[num10].SetDefaults(282);
								}
								chest.item[num10].stack = stack29;
								num10++;
							}
							if (genRand.Next(2) == 0)
							{
								chest.item[num10].SetDefaults(73);
								chest.item[num10].stack = genRand.Next(2, 5);
								num10++;
							}
						}
						if (num10 > 0 && chestTileType == 21)
						{
							if (num9 == 10 && genRand.Next(4) == 0)
							{
								chest.item[num10].SetDefaults(2204);
								num10++;
							}
							if (num9 == 11 && genRand.Next(7) == 0)
							{
								chest.item[num10].SetDefaults(2198);
								num10++;
							}
							if (flag10 && genRand.Next(3) == 0)
							{
								chest.item[num10].SetDefaults(2197);
								num10++;
							}
							if (flag10)
							{
								int num33 = genRand.Next(6);
								if (num33 == 0)
								{
									chest.item[num10].SetDefaults(5258);
								}
								if (num33 == 1)
								{
									chest.item[num10].SetDefaults(5226);
								}
								if (num33 == 2)
								{
									chest.item[num10].SetDefaults(5254);
								}
								if (num33 == 3)
								{
									chest.item[num10].SetDefaults(5238);
								}
								if (num33 == 4)
								{
									chest.item[num10].SetDefaults(5255);
								}
								if (num33 == 5)
								{
									chest.item[num10].SetDefaults(5388);
								}
								num10++;
							}
							if (flag10)
							{
								chest.item[num10].SetDefaults(751);
								chest.item[num10].stack = genRand.Next(50, 101);
								num10++;
							}
							if (num9 == 16)
							{
								chest.item[num10].SetDefaults(2195);
								num10++;
							}
							if (Main.wallDungeon[Main.tile[i, k].wall] && genRand.Next(8) == 0)
							{
								chest.item[num10].SetDefaults(2192);
								num10++;
							}
							if ((num9 == 23 || num9 == 24 || num9 == 25 || num9 == 26 || num9 == 27) && genRand.Next(2) == 0)
							{
								chest.item[num10].SetDefaults(5234);
								num10++;
							}
							if (num9 == 16)
							{
								if (genRand.Next(5) == 0)
								{
									chest.item[num10].SetDefaults(2767);
									num10++;
								}
								else
								{
									chest.item[num10].SetDefaults(2766);
									chest.item[num10].stack = genRand.Next(3, 8);
									num10++;
								}
							}
						}
						if (num10 <= 0 || chestTileType != 467)
						{
							continue;
						}
						if (flag10 && genRand.Next(3) == 0)
						{
							chest.item[num10].SetDefaults(2197);
							num10++;
						}
						if (flag10)
						{
							int num34 = genRand.Next(5);
							if (num34 == 0)
							{
								chest.item[num10].SetDefaults(5258);
							}
							if (num34 == 1)
							{
								chest.item[num10].SetDefaults(5226);
							}
							if (num34 == 2)
							{
								chest.item[num10].SetDefaults(5254);
							}
							if (num34 == 3)
							{
								chest.item[num10].SetDefaults(5238);
							}
							if (num34 == 4)
							{
								chest.item[num10].SetDefaults(5255);
							}
							num10++;
						}
						if (flag10)
						{
							chest.item[num10].SetDefaults(751);
							chest.item[num10].stack = genRand.Next(50, 101);
							num10++;
						}
						if (num9 == 13 && genRand.Next(2) == 0)
						{
							chest.item[num10].SetDefaults(5234);
							num10++;
						}
					}
					return true;
				}
				if (trySlope)
				{
					if (num2 > -1)
					{
						Main.tile[i - 1, k].slope((byte)num2);
					}
					if (num3 > -1)
					{
						Main.tile[i, k].slope((byte)num3);
					}
				}
				return false;
			}
			return false;
		}

		public static void UnlockDoor(int i, int j)
		{
			int num = j;
			if (Main.tile[i, num] == null)
			{
				return;
			}
			while (Main.tile[i, num].frameY != 594)
			{
				num--;
				if (Main.tile[i, num].frameY < 594 || num <= 0)
				{
					return;
				}
			}
			SoundEngine.PlaySound(22, i * 16, num * 16 + 16);
			for (int k = num; k <= num + 2; k++)
			{
				if (Main.tile[i, k] == null)
				{
					Main.tile[i, k] = new Tile();
				}
				Main.tile[i, k].frameY += 54;
				for (int l = 0; l < 4; l++)
				{
					Dust.NewDust(new Vector2(i * 16, k * 16), 16, 16, 11);
				}
			}
			AchievementsHelper.NotifyProgressionEvent(22);
		}

		public static bool OpenDoor(int i, int j, int direction)
		{
			int num = 0;
			if (Main.tile[i, j - 1] == null)
			{
				Main.tile[i, j - 1] = new Tile();
			}
			if (Main.tile[i, j - 2] == null)
			{
				Main.tile[i, j - 2] = new Tile();
			}
			if (Main.tile[i, j + 1] == null)
			{
				Main.tile[i, j + 1] = new Tile();
			}
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			Tile tile = Main.tile[i, j];
			if (tile.type != 10)
			{
				return false;
			}
			if (IsLockedDoor(tile))
			{
				return false;
			}
			short num2 = 0;
			int num3 = tile.frameY;
			int num4 = 0;
			while (num3 >= 54)
			{
				num3 -= 54;
				num4++;
			}
			if (tile.frameX >= 54)
			{
				int num5 = tile.frameX / 54;
				num4 += 36 * num5;
				num2 = (short)(num2 + (short)(72 * num5));
			}
			num = j - num3 / 18;
			int num6 = i;
			TileColorCache cache = Main.tile[num6, num].BlockColorAndCoating();
			if (Main.tile[num6, num + 1] == null)
			{
				Main.tile[num6, num + 1] = new Tile();
			}
			TileColorCache cache2 = Main.tile[num6, num + 1].BlockColorAndCoating();
			if (Main.tile[num6, num + 2] == null)
			{
				Main.tile[num6, num + 2] = new Tile();
			}
			TileColorCache cache3 = Main.tile[num6, num + 2].BlockColorAndCoating();
			int num7;
			if (direction == -1)
			{
				num6 = i - 1;
				num2 = (short)(num2 + 36);
				num7 = i - 1;
			}
			else
			{
				num6 = i;
				num7 = i + 1;
			}
			for (int k = num; k < num + 3; k++)
			{
				if (Main.tile[num7, k] == null)
				{
					Main.tile[num7, k] = new Tile();
				}
				if (Main.tile[num7, k].active())
				{
					if (!Main.tileCut[Main.tile[num7, k].type] && Main.tile[num7, k].type != 3 && Main.tile[num7, k].type != 24 && Main.tile[num7, k].type != 52 && Main.tile[num7, k].type != 61 && Main.tile[num7, k].type != 62 && Main.tile[num7, k].type != 69 && Main.tile[num7, k].type != 655 && Main.tile[num7, k].type != 71 && Main.tile[num7, k].type != 73 && Main.tile[num7, k].type != 74 && Main.tile[num7, k].type != 110 && Main.tile[num7, k].type != 113 && Main.tile[num7, k].type != 115 && Main.tile[num7, k].type != 165)
					{
						return false;
					}
					KillTile(num7, k);
				}
			}
			if (Main.netMode != 1 && Wiring.running)
			{
				Wiring.SkipWire(num6, num);
				Wiring.SkipWire(num6, num + 1);
				Wiring.SkipWire(num6, num + 2);
				Wiring.SkipWire(num6 + 1, num);
				Wiring.SkipWire(num6 + 1, num + 1);
				Wiring.SkipWire(num6 + 1, num + 2);
			}
			int num8 = num4 % 36 * 54;
			SoundEngine.PlaySound(8, i * 16, j * 16);
			Main.tile[num6, num].active(active: true);
			Main.tile[num6, num].type = 11;
			Main.tile[num6, num].frameY = (short)num8;
			Main.tile[num6, num].frameX = num2;
			Main.tile[num6, num].UseBlockColors(cache);
			if (Main.tile[num6 + 1, num] == null)
			{
				Main.tile[num6 + 1, num] = new Tile();
			}
			Main.tile[num6 + 1, num].active(active: true);
			Main.tile[num6 + 1, num].type = 11;
			Main.tile[num6 + 1, num].frameY = (short)num8;
			Main.tile[num6 + 1, num].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num].UseBlockColors(cache);
			if (Main.tile[num6, num + 1] == null)
			{
				Main.tile[num6, num + 1] = new Tile();
			}
			Main.tile[num6, num + 1].active(active: true);
			Main.tile[num6, num + 1].type = 11;
			Main.tile[num6, num + 1].frameY = (short)(num8 + 18);
			Main.tile[num6, num + 1].frameX = num2;
			Main.tile[num6, num + 1].UseBlockColors(cache2);
			if (Main.tile[num6 + 1, num + 1] == null)
			{
				Main.tile[num6 + 1, num + 1] = new Tile();
			}
			Main.tile[num6 + 1, num + 1].active(active: true);
			Main.tile[num6 + 1, num + 1].type = 11;
			Main.tile[num6 + 1, num + 1].frameY = (short)(num8 + 18);
			Main.tile[num6 + 1, num + 1].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num + 1].UseBlockColors(cache2);
			if (Main.tile[num6, num + 2] == null)
			{
				Main.tile[num6, num + 2] = new Tile();
			}
			Main.tile[num6, num + 2].active(active: true);
			Main.tile[num6, num + 2].type = 11;
			Main.tile[num6, num + 2].frameY = (short)(num8 + 36);
			Main.tile[num6, num + 2].frameX = num2;
			Main.tile[num6, num + 2].UseBlockColors(cache3);
			if (Main.tile[num6 + 1, num + 2] == null)
			{
				Main.tile[num6 + 1, num + 2] = new Tile();
			}
			Main.tile[num6 + 1, num + 2].active(active: true);
			Main.tile[num6 + 1, num + 2].type = 11;
			Main.tile[num6 + 1, num + 2].frameY = (short)(num8 + 36);
			Main.tile[num6 + 1, num + 2].frameX = (short)(num2 + 18);
			Main.tile[num6 + 1, num + 2].UseBlockColors(cache3);
			for (int l = num6 - 1; l <= num6 + 2; l++)
			{
				for (int m = num - 1; m <= num + 2; m++)
				{
					TileFrame(l, m);
				}
			}
			return true;
		}

		public static void Check1xX(int x, int j, short type)
		{
			if (destroyObject)
			{
				return;
			}
			int frameX = Main.tile[x, j].frameX;
			int num = 3;
			if (type == 92)
			{
				num = 6;
			}
			int num2 = Main.tile[x, j].frameY;
			int num3 = 0;
			while (num2 >= 18 * num)
			{
				num2 -= 18 * num;
				num3++;
			}
			int num4 = Main.tile[x, j].frameX / 18;
			int num5 = j - num2 / 18;
			bool flag = false;
			for (int i = 0; i < num; i++)
			{
				if (Main.tile[x, num5 + i] == null)
				{
					Main.tile[x, num5 + i] = new Tile();
				}
				if (!Main.tile[x, num5 + i].active())
				{
					flag = true;
				}
				else if (Main.tile[x, num5 + i].type != type)
				{
					flag = true;
				}
				else if (Main.tile[x, num5 + i].frameY != i * 18 + num3 * num * 18)
				{
					flag = true;
				}
				else if (Main.tile[x, num5 + i].frameX != frameX)
				{
					flag = true;
				}
			}
			if (Main.tile[x, num5 + num] == null)
			{
				Main.tile[x, num5 + num] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(x, num5 + num))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = 0; k < num; k++)
			{
				if (Main.tile[x, num5 + k].type == type)
				{
					KillTile(x, num5 + k);
				}
			}
			if (type == 92)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, 341);
			}
			if (type == 453)
			{
				int num6 = 0;
				num6 = ((num4 < 2) ? 3744 : ((num4 >= 4) ? 3743 : 3745));
				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 16, 32, num6);
			}
			if (type == 93)
			{
				int type2 = 0;
				switch (num3)
				{
				case 0:
					type2 = 342;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					type2 = 2082 + num3 - 1;
					break;
				default:
					if (num3 >= 11 && num3 <= 16)
					{
						type2 = 2129 + num3 - 11;
						break;
					}
					switch (num3)
					{
					case 17:
						type2 = 2225;
						break;
					case 18:
						type2 = 2533;
						break;
					case 19:
						type2 = 2547;
						break;
					case 20:
						type2 = 2563;
						break;
					case 21:
						type2 = 2578;
						break;
					case 22:
						type2 = 2643;
						break;
					case 23:
						type2 = 2644;
						break;
					case 24:
						type2 = 2645;
						break;
					case 25:
						type2 = 2646;
						break;
					case 26:
						type2 = 2647;
						break;
					case 27:
						type2 = 2819;
						break;
					case 28:
						type2 = 3135;
						break;
					case 29:
						type2 = 3137;
						break;
					case 30:
						type2 = 3136;
						break;
					case 31:
						type2 = 3892;
						break;
					case 32:
						type2 = 3942;
						break;
					case 33:
						type2 = 3969;
						break;
					case 34:
						type2 = 4156;
						break;
					case 35:
						type2 = 4177;
						break;
					case 36:
						type2 = 4198;
						break;
					case 37:
						type2 = 4219;
						break;
					case 38:
						type2 = 4308;
						break;
					case 39:
						type2 = 4577;
						break;
					case 40:
						type2 = 5159;
						break;
					case 41:
						type2 = 5180;
						break;
					case 42:
						type2 = 5201;
						break;
					}
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(x, j), x * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
		}

		public static void Check2xX(int i, int j, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2;
			for (num2 = Main.tile[i, j].frameX; num2 >= 36; num2 -= 36)
			{
			}
			if (num2 == 18)
			{
				num--;
			}
			if (Main.tile[num, j] == null)
			{
				Main.tile[num, j] = new Tile();
			}
			int num3 = Main.tile[num, j].frameY / 18;
			int num4 = 3;
			if (type == 104)
			{
				num4 = 5;
			}
			if (type == 207)
			{
				num4 = 4;
			}
			int num5 = 0;
			while (num3 >= num4)
			{
				num3 -= num4;
				num5 += num4 * 18;
			}
			int num6 = j - num3;
			if (type == 410 && num5 != 0)
			{
				num5 += 2;
			}
			if (Main.tile[num, num6] == null)
			{
				Main.tile[num, num6] = new Tile();
			}
			int frameX = Main.tile[num, j].frameX;
			int frameY = Main.tile[num, j].frameY;
			bool flag = false;
			for (int k = 0; k < num4; k++)
			{
				if (Main.tile[num, num6 + k] == null)
				{
					Main.tile[num, num6 + k] = new Tile();
				}
				if (!Main.tile[num, num6 + k].active())
				{
					flag = true;
				}
				else if (Main.tile[num, num6 + k].type != type)
				{
					flag = true;
				}
				else if (Main.tile[num, num6 + k].frameY != k * 18 + num5)
				{
					flag = true;
				}
				else if (Main.tile[num, num6 + k].frameX != frameX)
				{
					flag = true;
				}
				if (Main.tile[num + 1, num6 + k] == null)
				{
					Main.tile[num + 1, num6 + k] = new Tile();
				}
				if (!Main.tile[num + 1, num6 + k].active())
				{
					flag = true;
				}
				else if (Main.tile[num + 1, num6 + k].type != type)
				{
					flag = true;
				}
				else if (Main.tile[num + 1, num6 + k].frameY != k * 18 + num5)
				{
					flag = true;
				}
				else if (Main.tile[num + 1, num6 + k].frameX != frameX + 18)
				{
					flag = true;
				}
			}
			if (type == 465 || type == 531 || type == 591 || type == 592)
			{
				for (int l = 0; l < 2; l++)
				{
					if (!SolidTileAllowTopSlope(num + l, num6 - 1))
					{
						flag = true;
						break;
					}
				}
			}
			else
			{
				if (!SolidTileAllowBottomSlope(num, num6 + num4))
				{
					flag = true;
				}
				if (!SolidTileAllowBottomSlope(num + 1, num6 + num4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = 0; m < num4; m++)
			{
				if (Main.tile[num, num6 + m].type == type)
				{
					KillTile(num, num6 + m);
				}
				if (Main.tile[num + 1, num6 + m].type == type)
				{
					KillTile(num + 1, num6 + m);
				}
			}
			if (type == 104)
			{
				int num7 = frameX / 36;
				int num8 = 0;
				if (num7 >= 1 && num7 <= 5)
				{
					num8 = 2237 + num7 - 1;
				}
				else
				{
					switch (num7)
					{
					case 6:
						num8 = 2560;
						break;
					case 7:
						num8 = 2575;
						break;
					case 8:
					case 9:
					case 10:
					case 11:
					case 12:
					case 13:
					case 14:
					case 15:
					case 16:
					case 17:
					case 18:
					case 19:
					case 20:
					case 21:
					case 22:
					case 23:
						num8 = 2591 + num7 - 8;
						break;
					default:
						num8 = num7 switch
						{
							24 => 2809, 
							25 => 3126, 
							26 => 3128, 
							27 => 3127, 
							28 => 3898, 
							29 => 3899, 
							30 => 3900, 
							31 => 3901, 
							32 => 3902, 
							33 => 3940, 
							34 => 3966, 
							35 => 4154, 
							36 => 4175, 
							37 => 4196, 
							38 => 4217, 
							39 => 4306, 
							40 => 4575, 
							41 => 5157, 
							42 => 5178, 
							43 => 5199, 
							_ => 359, 
						};
						break;
					}
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num8);
			}
			if (type == 105)
			{
				int num9 = frameX / 36;
				int num10 = frameY / 54;
				num10 %= 3;
				num9 += num10 * 55;
				switch (num9)
				{
				case 0:
					num9 = 360;
					break;
				case 1:
					num9 = 52;
					break;
				case 43:
					num9 = 1152;
					break;
				case 44:
					num9 = 1153;
					break;
				case 45:
					num9 = 1154;
					break;
				case 46:
					num9 = 1408;
					break;
				case 47:
					num9 = 1409;
					break;
				case 48:
					num9 = 1410;
					break;
				case 49:
					num9 = 1462;
					break;
				case 50:
					num9 = 2672;
					break;
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
				case 58:
				case 59:
				case 60:
				case 61:
				case 62:
					num9 = 3651 + num9 - 51;
					break;
				default:
					num9 = ((num9 >= 63 && num9 <= 75) ? (3708 + num9 - 63) : (num9 switch
					{
						76 => 4397, 
						77 => 4360, 
						78 => 4342, 
						79 => 4466, 
						80 => 5317, 
						81 => 5318, 
						82 => 5319, 
						_ => 438 + num9 - 2, 
					}));
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num9);
			}
			if (type == 356)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3064);
			}
			if (type == 663)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5381);
			}
			if (type == 456)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3748);
			}
			if (type == 337)
			{
				int num11 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 2702 + num11);
			}
			if (type == 207)
			{
				int num12 = frameX / 36;
				switch (num12)
				{
				case 0:
					num12 = 909;
					break;
				case 1:
					num12 = 910;
					break;
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
					num12 = 938 + num12;
					break;
				default:
					switch (num12)
					{
					case 8:
						num12 = 4922;
						break;
					case 9:
						num12 = 4417;
						break;
					}
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num12);
			}
			if (type == 410)
			{
				int num13 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num13 + 3536);
			}
			if (type == 480)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4054);
			}
			if (type == 509)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4318);
			}
			if (type == 657)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5345);
			}
			if (type == 658)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 5347);
			}
			if (type == 489)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4074);
			}
			if (type == 320)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 2496);
			}
			if (type == 349)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 470);
			}
			if (type == 506)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4276);
			}
			if (type == 545)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4420);
			}
			if (type == 465)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 3815);
			}
			if (type == 531)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4355);
			}
			if (type == 378)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 48, 3202);
				TETrainingDummy.Kill(num, num6);
			}
			if (type == 560)
			{
				int num14 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num14 + 4599);
			}
			if (type == 591)
			{
				int num15 = frameX / 36;
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, num15 + 4858);
			}
			if (type == 592)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, j), num * 16, j * 16, 32, 32, 4867);
			}
			destroyObject = false;
		}

		public static void PlaceTight(int x, int y, bool spiders = false)
		{
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (!Main.tile[x, y].shimmer())
			{
				PlaceUncheckedStalactite(x, y, genRand.Next(2) == 0, genRand.Next(3), spiders);
				if (Main.tile[x, y].type == 165)
				{
					CheckTight(x, y);
				}
			}
		}

		public static void PlaceUncheckedStalactite(int x, int y, bool preferSmall, int variation, bool spiders)
		{
			ushort type = 165;
			variation = Utils.Clamp(variation, 0, 2);
			if (SolidTile(x, y - 1) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active())
			{
				if (spiders)
				{
					int num = 108 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num;
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y + 1].type = type;
					Main.tile[x, y + 1].active(active: true);
					Main.tile[x, y + 1].frameX = (short)num;
					Main.tile[x, y + 1].frameY = 18;
					return;
				}
				if (Main.tile[x, y - 1].type == 147 || Main.tile[x, y - 1].type == 161 || Main.tile[x, y - 1].type == 163 || Main.tile[x, y - 1].type == 164 || Main.tile[x, y - 1].type == 200)
				{
					if (preferSmall)
					{
						int num2 = variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num2;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num3 = variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num3;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num3;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 1 || Main.tileMoss[Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
				{
					if (preferSmall)
					{
						int num4 = 54 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num4;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num5 = 54 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num5;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num5;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 225)
				{
					int num6 = 162 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num6;
					Main.tile[x, y].frameY = 72;
				}
				if (Main.tile[x, y - 1].type == 396 || Main.tile[x, y - 1].type == 397)
				{
					if (preferSmall)
					{
						int num7 = 378 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num7;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num8 = 378 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num8;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num8;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 368)
				{
					if (preferSmall)
					{
						int num9 = 432 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num9;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num10 = 432 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num10;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num10;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
				if (Main.tile[x, y - 1].type == 367)
				{
					if (preferSmall)
					{
						int num11 = 486 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num11;
						Main.tile[x, y].frameY = 72;
					}
					else
					{
						int num12 = 486 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num12;
						Main.tile[x, y].frameY = 0;
						Main.tile[x, y + 1].type = type;
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].frameX = (short)num12;
						Main.tile[x, y + 1].frameY = 18;
					}
				}
			}
			else
			{
				if (spiders || !SolidTile(x, y + 1) || Main.tile[x, y].active() || Main.tile[x, y - 1].active())
				{
					return;
				}
				if (Main.tile[x, y + 1].type == 1 || Main.tileMoss[Main.tile[x, y + 1].type] || Main.tile[x, y - 1].type == 117 || Main.tile[x, y - 1].type == 25 || Main.tile[x, y - 1].type == 203)
				{
					if (preferSmall)
					{
						int num13 = 54 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num13;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num14 = 54 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num14;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num14;
						Main.tile[x, y].frameY = 54;
					}
				}
				if (Main.tile[x, y + 1].type == 225)
				{
					int num15 = 162 + variation * 18;
					Main.tile[x, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameX = (short)num15;
					Main.tile[x, y].frameY = 90;
				}
				if (Main.tile[x, y + 1].type == 396 || Main.tile[x, y + 1].type == 397)
				{
					if (preferSmall)
					{
						int num16 = 378 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num16;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num17 = 378 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num17;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num17;
						Main.tile[x, y].frameY = 54;
					}
				}
				if (Main.tile[x, y + 1].type == 368)
				{
					if (preferSmall)
					{
						int num18 = 432 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num18;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num19 = 432 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num19;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num19;
						Main.tile[x, y].frameY = 54;
					}
				}
				if (Main.tile[x, y + 1].type == 367)
				{
					if (preferSmall)
					{
						int num20 = 486 + variation * 18;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num20;
						Main.tile[x, y].frameY = 90;
					}
					else
					{
						int num21 = 486 + variation * 18;
						Main.tile[x, y - 1].type = type;
						Main.tile[x, y - 1].active(active: true);
						Main.tile[x, y - 1].frameX = (short)num21;
						Main.tile[x, y - 1].frameY = 36;
						Main.tile[x, y].type = type;
						Main.tile[x, y].active(active: true);
						Main.tile[x, y].frameX = (short)num21;
						Main.tile[x, y].frameY = 54;
					}
				}
			}
		}

		public static bool UpdateStalagtiteStyle(int x, int j)
		{
			if (Main.netMode == 1)
			{
				return true;
			}
			if (Main.tile[x, j] == null)
			{
				return true;
			}
			GetStalagtiteStyle(x, j, out var style, out var fail);
			if (fail)
			{
				return false;
			}
			GetDesiredStalagtiteStyle(x, j, out var fail2, out var desiredStyle, out var height, out var y);
			if (fail2)
			{
				return false;
			}
			if (style != desiredStyle)
			{
				int num = genRand.Next(3) * 18;
				switch (desiredStyle)
				{
				case 0:
					num += 54;
					break;
				case 1:
					num += 216;
					break;
				case 2:
					num += 270;
					break;
				case 3:
					num += 324;
					break;
				case 4:
					num += 378;
					break;
				case 5:
					num += 432;
					break;
				case 6:
					num += 486;
					break;
				case 7:
					num = num;
					break;
				case 8:
					num += 540;
					break;
				case 9:
					num += 594;
					break;
				case 10:
					num += 648;
					break;
				}
				for (int i = y; i < y + height; i++)
				{
					Main.tile[x, i].frameX = (short)num;
				}
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y, 1, 2);
				}
			}
			return true;
		}

		private static void GetDesiredStalagtiteStyle(int x, int j, out bool fail, out int desiredStyle, out int height, out int y)
		{
			fail = false;
			desiredStyle = 0;
			height = 1;
			y = j;
			if (Main.tile[x, y].frameY == 72)
			{
				desiredStyle = Main.tile[x, y - 1].type;
			}
			else if (Main.tile[x, y].frameY == 90)
			{
				desiredStyle = Main.tile[x, y + 1].type;
			}
			else if (Main.tile[x, y].frameY >= 36)
			{
				if (Main.tile[x, y].frameY == 54)
				{
					y--;
				}
				height = 2;
				desiredStyle = Main.tile[x, y + 2].type;
			}
			else
			{
				if (Main.tile[x, y].frameY == 18)
				{
					y--;
				}
				height = 2;
				desiredStyle = Main.tile[x, y - 1].type;
			}
			if (desiredStyle == 1 || Main.tileMoss[desiredStyle])
			{
				desiredStyle = 0;
			}
			else if (desiredStyle == 200)
			{
				desiredStyle = 10;
			}
			else if (desiredStyle == 164)
			{
				desiredStyle = 8;
			}
			else if (desiredStyle == 163)
			{
				desiredStyle = 9;
			}
			else if (desiredStyle == 117 || desiredStyle == 402 || desiredStyle == 403)
			{
				desiredStyle = 1;
			}
			else if (desiredStyle == 25 || desiredStyle == 398 || desiredStyle == 400)
			{
				desiredStyle = 2;
			}
			else if (desiredStyle == 203 || desiredStyle == 399 || desiredStyle == 401)
			{
				desiredStyle = 3;
			}
			else if (desiredStyle == 396 || desiredStyle == 397)
			{
				desiredStyle = 4;
			}
			else if (desiredStyle == 367)
			{
				desiredStyle = 6;
			}
			else if (desiredStyle == 368)
			{
				desiredStyle = 5;
			}
			else if (desiredStyle == 161 || desiredStyle == 147)
			{
				desiredStyle = 7;
			}
			else
			{
				fail = true;
			}
		}

		private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail)
		{
			style = 0;
			fail = false;
			switch (Main.tile[x, y].frameX / 54)
			{
			default:
				fail = true;
				break;
			case 0:
				style = 7;
				break;
			case 1:
				style = 0;
				break;
			case 4:
				style = 1;
				break;
			case 5:
				style = 2;
				break;
			case 6:
				style = 3;
				break;
			case 7:
				style = 4;
				break;
			case 8:
				style = 5;
				break;
			case 9:
				style = 6;
				break;
			case 10:
				style = 8;
				break;
			case 11:
				style = 9;
				break;
			case 12:
				style = 10;
				break;
			}
		}

		public static void CheckTight(int x, int j)
		{
			if (Main.tile[x, j] == null)
			{
				return;
			}
			int num = j;
			if (Main.tile[x, num].frameY == 72)
			{
				if (Main.tile[x, num - 1] == null)
				{
					Main.tile[x, num - 1] = new Tile();
				}
				if (Main.tile[x, num] == null)
				{
					Main.tile[x, num] = new Tile();
				}
				if (Main.tile[x, num + 1] == null)
				{
					Main.tile[x, num + 1] = new Tile();
				}
				bool flag = false;
				if (!SolidTile(x, num - 1))
				{
					flag = true;
				}
				if (!flag && !UpdateStalagtiteStyle(x, num))
				{
					flag = true;
				}
				if (flag)
				{
					destroyObject = true;
					if (Main.tile[x, num].type == Main.tile[x, j].type)
					{
						KillTile(x, num);
					}
					destroyObject = false;
				}
				return;
			}
			if (Main.tile[x, num].frameY == 90)
			{
				if (Main.tile[x, num - 1] == null)
				{
					Main.tile[x, num - 1] = new Tile();
				}
				if (Main.tile[x, num] == null)
				{
					Main.tile[x, num] = new Tile();
				}
				if (Main.tile[x, num + 1] == null)
				{
					Main.tile[x, num + 1] = new Tile();
				}
				bool flag2 = false;
				if (!SolidTile(x, num + 1))
				{
					flag2 = true;
				}
				if (!flag2 && !UpdateStalagtiteStyle(x, num))
				{
					flag2 = true;
				}
				if (flag2)
				{
					destroyObject = true;
					if (Main.tile[x, num].type == Main.tile[x, j].type)
					{
						KillTile(x, num);
					}
					destroyObject = false;
				}
				return;
			}
			if (Main.tile[x, num].frameY >= 36)
			{
				if (Main.tile[x, num].frameY == 54)
				{
					num--;
				}
				if (Main.tile[x, num] == null)
				{
					Main.tile[x, num] = new Tile();
				}
				if (Main.tile[x, num + 1] == null)
				{
					Main.tile[x, num + 1] = new Tile();
				}
				if (Main.tile[x, num + 2] == null)
				{
					Main.tile[x, num + 2] = new Tile();
				}
				bool flag3 = false;
				if (!SolidTile(x, num + 2))
				{
					flag3 = true;
				}
				if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
				{
					flag3 = true;
				}
				if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
				{
					flag3 = true;
				}
				if (!flag3 && !UpdateStalagtiteStyle(x, num))
				{
					flag3 = true;
				}
				if (flag3)
				{
					destroyObject = true;
					if (Main.tile[x, num].type == Main.tile[x, j].type)
					{
						KillTile(x, num);
					}
					if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
					{
						KillTile(x, num + 1);
					}
					destroyObject = false;
				}
				return;
			}
			if (Main.tile[x, num].frameY == 18)
			{
				num--;
			}
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			bool flag4 = false;
			if (!SolidTile(x, num - 1))
			{
				flag4 = true;
			}
			if (Main.tile[x, num + 1].type != Main.tile[x, num].type)
			{
				flag4 = true;
			}
			if (Main.tile[x, num + 1].frameX != Main.tile[x, num].frameX)
			{
				flag4 = true;
			}
			if (!flag4 && !UpdateStalagtiteStyle(x, num))
			{
				flag4 = true;
			}
			if (flag4)
			{
				destroyObject = true;
				if (Main.tile[x, num].type == Main.tile[x, j].type)
				{
					KillTile(x, num);
				}
				if (Main.tile[x, num + 1].type == Main.tile[x, j].type)
				{
					KillTile(x, num + 1);
				}
				destroyObject = false;
			}
		}

		public static void Place1xX(int x, int y, ushort type, int style = 0)
		{
			int num = style * 18;
			int num2 = 3;
			if (type == 92)
			{
				num2 = 6;
			}
			bool flag = true;
			for (int i = y - num2 + 1; i < y + 1; i++)
			{
				if (Main.tile[x, i] == null)
				{
					Main.tile[x, i] = new Tile();
				}
				if (Main.tile[x, i].active())
				{
					flag = false;
				}
				if (type == 93 && Main.tile[x, i].liquid > 0)
				{
					flag = false;
				}
			}
			if (flag && SolidTile2(x, y + 1))
			{
				for (int j = 0; j < num2; j++)
				{
					Main.tile[x, y - num2 + 1 + j].active(active: true);
					Main.tile[x, y - num2 + 1 + j].frameY = (short)(j * 18 + num2 * num);
					Main.tile[x, y - num2 + 1 + j].frameX = 0;
					Main.tile[x, y - num2 + 1 + j].type = type;
				}
			}
		}

		public static int checkXmasTreeDrop(int x, int y, int obj)
		{
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			int num3 = 0;
			if ((Main.tile[num, num2].frameY & 1) == 1)
			{
				num3++;
			}
			if ((Main.tile[num, num2].frameY & 2) == 2)
			{
				num3 += 2;
			}
			if ((Main.tile[num, num2].frameY & 4) == 4)
			{
				num3 += 4;
			}
			int num4 = 0;
			if ((Main.tile[num, num2].frameY & 8) == 8)
			{
				num4++;
			}
			if ((Main.tile[num, num2].frameY & 0x10) == 16)
			{
				num4 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x20) == 32)
			{
				num4 += 4;
			}
			int num5 = 0;
			if ((Main.tile[num, num2].frameY & 0x40) == 64)
			{
				num5++;
			}
			if ((Main.tile[num, num2].frameY & 0x80) == 128)
			{
				num5 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x100) == 256)
			{
				num5 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x200) == 512)
			{
				num5 += 8;
			}
			int num6 = 0;
			if ((Main.tile[num, num2].frameY & 0x400) == 1024)
			{
				num6++;
			}
			if ((Main.tile[num, num2].frameY & 0x800) == 2048)
			{
				num6 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
			{
				num6 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
			{
				num6 += 8;
			}
			if (obj == 0 && num3 > 0)
			{
				return num3;
			}
			if (obj == 1 && num4 > 0)
			{
				return num4;
			}
			if (obj == 2 && num5 > 0)
			{
				return num5;
			}
			if (obj == 3 && num6 > 0)
			{
				return num6;
			}
			return -1;
		}

		public static void dropXmasTree(int x, int y, int obj)
		{
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			int num3 = 0;
			if ((Main.tile[num, num2].frameY & 1) == 1)
			{
				num3++;
			}
			if ((Main.tile[num, num2].frameY & 2) == 2)
			{
				num3 += 2;
			}
			if ((Main.tile[num, num2].frameY & 4) == 4)
			{
				num3 += 4;
			}
			int num4 = 0;
			if ((Main.tile[num, num2].frameY & 8) == 8)
			{
				num4++;
			}
			if ((Main.tile[num, num2].frameY & 0x10) == 16)
			{
				num4 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x20) == 32)
			{
				num4 += 4;
			}
			int num5 = 0;
			if ((Main.tile[num, num2].frameY & 0x40) == 64)
			{
				num5++;
			}
			if ((Main.tile[num, num2].frameY & 0x80) == 128)
			{
				num5 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x100) == 256)
			{
				num5 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x200) == 512)
			{
				num5 += 8;
			}
			int num6 = 0;
			if ((Main.tile[num, num2].frameY & 0x400) == 1024)
			{
				num6++;
			}
			if ((Main.tile[num, num2].frameY & 0x800) == 2048)
			{
				num6 += 2;
			}
			if ((Main.tile[num, num2].frameY & 0x1000) == 4096)
			{
				num6 += 4;
			}
			if ((Main.tile[num, num2].frameY & 0x2000) == 8192)
			{
				num6 += 8;
			}
			if (obj == 0 && num3 > 0)
			{
				int number = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1874 + num3 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number, 1f);
				}
			}
			else if (obj == 1 && num4 > 0)
			{
				int number2 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1878 + num4 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number2, 1f);
				}
			}
			else if (obj == 2 && num5 > 0)
			{
				int number3 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1884 + num5 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number3, 1f);
				}
			}
			else if (obj == 3 && num6 > 0)
			{
				int number4 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, 1895 + num6 - 1);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(21, -1, -1, null, number4, 1f);
				}
			}
		}

		public static void setXmasTree(int x, int y, int obj, int style)
		{
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			if (obj == 0)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 1;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 2;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -3);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 4;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -5);
				}
			}
			if (obj == 1)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 8;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -9);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 16;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -17);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 32;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -33);
				}
			}
			if (obj == 2)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 64;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -65);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 128;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -129);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 256;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -257);
				}
				if ((style & 8) == 8)
				{
					Main.tile[num, num2].frameY |= 512;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -513);
				}
			}
			if (obj == 3)
			{
				if ((style & 1) == 1)
				{
					Main.tile[num, num2].frameY |= 1024;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -1025);
				}
				if ((style & 2) == 2)
				{
					Main.tile[num, num2].frameY |= 2048;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -2049);
				}
				if ((style & 4) == 4)
				{
					Main.tile[num, num2].frameY |= 4096;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -4097);
				}
				if ((style & 8) == 8)
				{
					Main.tile[num, num2].frameY |= 8192;
				}
				else
				{
					Main.tile[num, num2].frameY = (short)(Main.tile[num, num2].frameY & -8193);
				}
			}
		}

		public static int PlaceXmasTree_Direct(int x, int y, int type, int style, int dir, int alternate)
		{
			for (short num = 0; num < 4; num = (short)(num + 1))
			{
				for (short num2 = 0; num2 < 8; num2 = (short)(num2 + 1))
				{
					Tile tile = Main.tile[x + num, y + num2];
					tile.active(active: true);
					tile.type = (ushort)type;
					if (num == 0 && num2 == 0)
					{
						tile.frameX = 10;
						tile.frameY = 0;
					}
					else
					{
						tile.frameX = num;
						tile.frameY = num2;
					}
				}
			}
			return 0;
		}

		public static void PlaceXmasTree(int x, int y, ushort type = 171)
		{
			bool flag = true;
			int num = x - 1;
			int num2 = y - 7;
			for (int i = num; i < num + 4; i++)
			{
				for (int j = num2; j < num2 + 8; j++)
				{
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (i > num && i < num + 3 && !SolidTile(i, num2 + 8))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 0;
			for (int k = num; k < num + 4; k++)
			{
				int num4 = 0;
				for (int l = num2; l < num2 + 8; l++)
				{
					Main.tile[k, l].active(active: true);
					if (num3 == 0 && num4 == 0)
					{
						Main.tile[k, l].frameX = 10;
						Main.tile[k, l].frameY = 0;
					}
					else
					{
						Main.tile[k, l].frameX = (short)num3;
						Main.tile[k, l].frameY = (short)num4;
					}
					Main.tile[k, l].type = type;
					Main.tile[k, l].active(active: true);
					num4++;
				}
				num3++;
			}
		}

		public static void CheckXmasTree(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			int num = x;
			int num2 = y;
			if (Main.tile[x, y].frameX < 10)
			{
				num -= Main.tile[x, y].frameX;
				num2 -= Main.tile[x, y].frameY;
			}
			bool flag = false;
			int num3 = 0;
			for (int i = num; i < num + 4; i++)
			{
				int num4 = 0;
				for (int j = num2; j < num2 + 8; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 171)
					{
						if (num3 != 0 && num4 != 0 && Main.tile[i, j].frameX != num3 && Main.tile[i, j].frameY != num4)
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					num4++;
				}
				num3++;
				if (i > num && i < num + 3 && !SolidTile2(i, num2 + 8))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 8; l++)
				{
					if (Main.tile[k, l].type == 171)
					{
						KillTile(k, l);
					}
				}
			}
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1873);
			destroyObject = false;
		}

		public static void Place2xX(int x, int y, ushort type, int style = 0)
		{
			int num = style * 36;
			int num2 = 0;
			int num3 = 3;
			if (type == 105 && style == 34)
			{
				type = 349;
				style = 0;
				num = 0;
			}
			if (type == 105)
			{
				int num4 = style / 55;
				num -= 1980 * num4;
				num2 += 54 * num4;
			}
			if (type == 104)
			{
				num3 = 5;
			}
			if (type == 207)
			{
				num3 = 4;
			}
			bool flag = true;
			for (int i = y - num3 + 1; i < y + 1; i++)
			{
				if (Main.tile[x, i] == null)
				{
					Main.tile[x, i] = new Tile();
				}
				if (Main.tile[x, i].active())
				{
					flag = false;
				}
				if (Main.tile[x + 1, i] == null)
				{
					Main.tile[x + 1, i] = new Tile();
				}
				if (Main.tile[x + 1, i].active())
				{
					flag = false;
				}
			}
			if (flag && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
			{
				for (int j = 0; j < num3; j++)
				{
					Main.tile[x, y - num3 + 1 + j].active(active: true);
					Main.tile[x, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
					Main.tile[x, y - num3 + 1 + j].frameX = (short)num;
					Main.tile[x, y - num3 + 1 + j].type = type;
					Main.tile[x + 1, y - num3 + 1 + j].active(active: true);
					Main.tile[x + 1, y - num3 + 1 + j].frameY = (short)(num2 + j * 18);
					Main.tile[x + 1, y - num3 + 1 + j].frameX = (short)(num + 18);
					Main.tile[x + 1, y - num3 + 1 + j].type = type;
				}
			}
		}

		public static int GetItemDrop_Benches(int style)
		{
			return style switch
			{
				1 => 2397, 
				2 => 2398, 
				3 => 2399, 
				4 => 2400, 
				5 => 2401, 
				6 => 2402, 
				7 => 2403, 
				8 => 2404, 
				9 => 2405, 
				10 => 2406, 
				11 => 2407, 
				12 => 2408, 
				13 => 2409, 
				14 => 2410, 
				15 => 2411, 
				16 => 2412, 
				17 => 2413, 
				18 => 2414, 
				19 => 2415, 
				20 => 2416, 
				21 => 2521, 
				22 => 2527, 
				23 => 2539, 
				24 => 858, 
				25 => 2582, 
				26 => 2634, 
				27 => 2635, 
				28 => 2636, 
				29 => 2823, 
				30 => 3150, 
				31 => 3152, 
				32 => 3151, 
				33 => 3918, 
				34 => 3919, 
				35 => 3947, 
				36 => 3973, 
				37 => 4161, 
				38 => 4182, 
				39 => 4203, 
				40 => 4224, 
				41 => 4313, 
				42 => 4582, 
				43 => 4993, 
				44 => 5164, 
				45 => 5185, 
				46 => 5206, 
				_ => 335, 
			};
		}

		public static int GetItemDrop_PicnicTables(int style)
		{
			if (style == 0 || style != 1)
			{
				return 4064;
			}
			return 4065;
		}

		public static int GetItemDrop_Chair(int style)
		{
			switch (style)
			{
			default:
				return 34;
			case 1:
				return 358;
			case 2:
				return 628;
			case 3:
				return 629;
			case 4:
				return 630;
			case 5:
				return 806;
			case 6:
				return 807;
			case 7:
				return 808;
			case 8:
				return 809;
			case 9:
				return 810;
			case 10:
				return 826;
			case 11:
				return 915;
			case 12:
				return 1143;
			case 13:
				return 1396;
			case 14:
				return 1399;
			case 15:
				return 1402;
			case 16:
				return 1459;
			case 17:
				return 1509;
			case 18:
			case 19:
			case 20:
			case 21:
			case 22:
			case 23:
				return 1703 + style - 18;
			case 24:
				return 1792;
			case 25:
				return 1814;
			case 26:
				return 1925;
			case 27:
				return 2228;
			case 28:
				return 2288;
			case 29:
				return 2524;
			case 30:
				return 2557;
			case 31:
				return 2572;
			case 32:
				return 2812;
			case 33:
				return 3174;
			case 34:
				return 3176;
			case 35:
				return 3175;
			case 36:
				return 3889;
			case 37:
				return 3937;
			case 38:
				return 3963;
			case 39:
				return 4151;
			case 40:
				return 4172;
			case 41:
				return 4193;
			case 42:
				return 4214;
			case 43:
				return 4304;
			case 44:
				return 4572;
			case 45:
				return 5154;
			case 46:
				return 5175;
			case 47:
				return 5196;
			}
		}

		public static int GetItemDrop_Toilet(int style)
		{
			int num = 4096 + style;
			switch (style)
			{
			case 32:
				num = 4141;
				break;
			case 33:
				num = 4165;
				break;
			case 34:
				num = 4186;
				break;
			case 35:
				num = 4207;
				break;
			case 36:
				num = 4228;
				break;
			case 37:
				num = 4316;
				break;
			case 38:
				num = 4586;
				break;
			case 39:
				num = 4731;
				break;
			case 40:
				num = 5168;
				break;
			case 41:
				num = 5189;
				break;
			case 42:
				num = 5210;
				break;
			}
			if (num > 5210)
			{
				num = 5210;
			}
			return num;
		}

		public static void Check1x2(int x, int j, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = j;
			bool flag = true;
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			int num2 = Main.tile[x, num].frameY;
			int num3 = 0;
			while (num2 >= 40)
			{
				num2 -= 40;
				num3++;
			}
			if (num2 == 18)
			{
				num--;
			}
			int num4 = Main.tile[x, num].frameX / 18;
			if (Main.tile[x, num].frameX == -1)
			{
				num4 = Main.tile[x, num + 1].frameX / 18;
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num].frameY == 40 * num3 && Main.tile[x, num + 1].frameY == 40 * num3 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
			{
				flag = false;
			}
			if (Main.tile[x, num + 2] == null)
			{
				Main.tile[x, num + 2] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(x, num + 2) && !TileID.Sets.Platforms[Main.tile[x, num + 2].type])
			{
				flag = true;
			}
			if (Main.tile[x, num].type == 20)
			{
				int num5 = Main.tile[x, num].frameX / 54;
				int type2 = Main.tile[x, num + 2].type;
				int num6 = -1;
				switch (type2)
				{
				case 2:
				case 477:
					num6 = 0;
					break;
				case 147:
					num6 = 1;
					break;
				case 60:
					num6 = 2;
					break;
				case 23:
				case 661:
					num6 = 3;
					break;
				case 199:
				case 662:
					num6 = 4;
					break;
				case 109:
				case 492:
					num6 = 5;
					break;
				case 53:
					num6 = 6;
					break;
				case 116:
					num6 = 7;
					break;
				case 234:
					num6 = 8;
					break;
				case 112:
					num6 = 9;
					break;
				case 633:
					num6 = 10;
					break;
				default:
					flag = true;
					break;
				}
				if (!flag && num5 != num6)
				{
					int num7 = 54 * num6;
					num7 += genRand.Next(3) * 18;
					Main.tile[x, num].frameX = (short)num7;
					Main.tile[x, num + 1].frameX = (short)num7;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			if (Main.tile[x, num].type == type)
			{
				KillTile(x, num);
			}
			if (Main.tile[x, num + 1].type == type)
			{
				KillTile(x, num + 1);
			}
			if (type == 216)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 970 + num3);
			}
			if (type == 338)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 2738);
			}
			if (type == 390)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 16, 32, 3253);
			}
			if (type == 493)
			{
				int num8 = 0;
				switch (num4)
				{
				case 0:
					num8 = 4083;
					break;
				case 1:
					num8 = 4084;
					break;
				case 2:
					num8 = 4085;
					break;
				case 3:
					num8 = 4086;
					break;
				case 4:
					num8 = 4087;
					break;
				case 5:
					num8 = 4088;
					break;
				}
				if (num8 > 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, num8);
				}
			}
			if (type == 15)
			{
				int itemDrop_Chair = GetItemDrop_Chair(num3);
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Chair);
			}
			switch (type)
			{
			case 497:
			{
				int itemDrop_Toilet = GetItemDrop_Toilet(num3);
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, itemDrop_Toilet);
				break;
			}
			case 134:
				if (num3 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 1220);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 525);
				}
				break;
			}
			destroyObject = false;
		}

		public static void CheckOnTable1x1(int x, int y, int type)
		{
			if (Main.tile[x, y + 1] == null)
			{
				return;
			}
			if (Main.tile[x, y + 1].topSlope())
			{
				if (TileID.Sets.Platforms[Main.tile[x, y + 1].type])
				{
					if ((Main.tile[x, y + 1].blockType() != 3 || !Main.tile[x - 1, y + 1].active() || Main.tile[x - 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type]) && (Main.tile[x, y + 1].blockType() != 2 || !Main.tile[x + 1, y + 1].active() || Main.tile[x + 1, y + 1].blockType() != 0 || !TileID.Sets.Platforms[Main.tile[x + 1, y + 1].type]))
					{
						KillTile(x, y);
					}
				}
				else
				{
					KillTile(x, y);
				}
			}
			else
			{
				if (Main.tile[x, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick())
				{
					return;
				}
				if (type == 78)
				{
					if (!SolidTileAllowBottomSlope(x, y + 1))
					{
						KillTile(x, y);
					}
				}
				else
				{
					KillTile(x, y);
				}
			}
		}

		public static void CheckSign(int x, int y, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0 || num2 > Main.maxTilesX || num3 < 0 || num4 > Main.maxTilesY)
			{
				return;
			}
			bool flag = false;
			for (int i = num; i < num2; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
				}
			}
			int num5 = Main.tile[x, y].frameX / 18;
			int num6 = Main.tile[x, y].frameY / 18;
			num5 %= 2;
			num6 %= 2;
			int num7 = x - num5;
			int num8 = y - num6;
			int num9 = Main.tile[num7, num8].frameX / 18 / 2;
			int num10 = Main.tile[num7, num8].frameY / 18 / 2;
			int num11 = Main.tile[x, y].frameX / 18;
			int num12 = 0;
			while (num11 > 1)
			{
				num11 -= 2;
				num12++;
			}
			num = num7;
			num2 = num7 + 2;
			num3 = num8;
			num4 = num8 + 2;
			num5 = 0;
			for (int k = num; k < num2; k++)
			{
				num6 = 0;
				for (int l = num3; l < num4; l++)
				{
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type)
					{
						flag = true;
						break;
					}
					if (Main.tile[k, l].frameX / 18 != num5 + num9 * 2 || Main.tile[k, l].frameY / 18 != num6 + num10 * 2)
					{
						flag = true;
						break;
					}
					num6++;
				}
				num5++;
			}
			if (!flag)
			{
				if (type == 85)
				{
					if (SolidTileAllowBottomSlope(num7, num8 + 2) && SolidTileAllowBottomSlope(num7 + 1, num8 + 2))
					{
						num9 = num12;
					}
					else
					{
						flag = true;
					}
				}
				else if (TopEdgeCanBeAttachedTo(num7, num8 + 2) && TopEdgeCanBeAttachedTo(num7 + 1, num8 + 2))
				{
					num9 = 0;
				}
				else if (BottomEdgeCanBeAttachedTo(num7, num8 - 1) && BottomEdgeCanBeAttachedTo(num7 + 1, num8 - 1))
				{
					num9 = 1;
				}
				else if (RightEdgeCanBeAttachedTo(num7 - 1, num8) && RightEdgeCanBeAttachedTo(num7 - 1, num8 + 1))
				{
					num9 = 2;
				}
				else if (LeftEdgeCanBeAttachedTo(num7 + 2, num8) && LeftEdgeCanBeAttachedTo(num7 + 2, num8 + 1))
				{
					num9 = 3;
				}
				else if (Main.tile[num7, num8].wall > 0 && Main.tile[num7 + 1, num8].wall > 0 && Main.tile[num7, num8 + 1].wall > 0 && Main.tile[num7 + 1, num8 + 1].wall > 0)
				{
					num9 = 4;
				}
				else
				{
					flag = true;
				}
			}
			if (flag)
			{
				if (type == 395)
				{
					int num13 = TEItemFrame.Find(num7, num8);
					if (num13 != -1 && ((TEItemFrame)TileEntity.ByID[num13]).item.stack > 0)
					{
						((TEItemFrame)TileEntity.ByID[num13]).DropItem();
						if (Main.netMode != 2)
						{
							Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
						}
					}
				}
				destroyObject = true;
				for (int m = num; m < num2; m++)
				{
					for (int n = num3; n < num4; n++)
					{
						if (Main.tile[m, n].type == type)
						{
							KillTile(m, n);
						}
					}
				}
				if (type != 395)
				{
					Sign.KillSign(num7, num8);
				}
				switch (type)
				{
				case 85:
				{
					int type2 = 321;
					if (num12 >= 6 && num12 <= 10)
					{
						type2 = 3229 + num12 - 6;
					}
					else if (num12 >= 1 && num12 <= 5)
					{
						type2 = 1173 + num12 - 1;
					}
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, type2);
					if (Main.netMode != 1 && genRand.Next(2) == 0 && NPC.CountNPCS(316) < 2)
					{
						int num14 = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
						if (Main.player[num14].ZoneGraveyard || !Main.dayTime || (double)y > Main.worldSurface)
						{
							NPC.SpawnOnPlayer(num14, 316);
						}
					}
					break;
				}
				case 395:
					Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 3270);
					TEItemFrame.Kill(num7, num8);
					break;
				case 425:
					Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 3617);
					break;
				case 573:
					Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 4710);
					break;
				case 511:
					Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 4320);
					break;
				case 510:
					Item.NewItem(GetItemSource_FromTileBreak(num7, num8), num7 * 16, num8 * 16, 32, 32, 4319);
					break;
				default:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 171);
					break;
				}
				destroyObject = false;
				return;
			}
			int num15 = 36 * num9;
			for (int num16 = 0; num16 < 2; num16++)
			{
				for (int num17 = 0; num17 < 2; num17++)
				{
					Main.tile[num7 + num16, num8 + num17].active(active: true);
					Main.tile[num7 + num16, num8 + num17].type = type;
					Main.tile[num7 + num16, num8 + num17].frameX = (short)(num15 + 18 * num16);
					Main.tile[num7 + num16, num8 + num17].frameY = (short)(18 * num17 + num10 * 36);
				}
			}
		}

		public static bool PlaceSign(int x, int y, ushort type, int Style = 0)
		{
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0)
			{
				return false;
			}
			if (num2 > Main.maxTilesX)
			{
				return false;
			}
			if (num3 < 0)
			{
				return false;
			}
			if (num4 > Main.maxTilesY)
			{
				return false;
			}
			for (int i = num; i < num2; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
				}
			}
			int num5 = x;
			int num6 = y;
			int num7 = 0;
			if (type == 55 || type == 425 || type == 510 || type == 511)
			{
				if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
				{
					num6--;
					num7 = 0;
				}
				else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive() && Main.tileSolid[Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y - 1].type])
				{
					num7 = 1;
				}
				else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type] && !Main.tileNoAttach[Main.tile[x - 1, y].type] && Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[Main.tile[x - 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x - 1, y + 1].type])
				{
					num7 = 2;
				}
				else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type] && !Main.tileNoAttach[Main.tile[x + 1, y].type] && Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[Main.tile[x + 1, y + 1].type] && !Main.tileSolidTop[Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[Main.tile[x + 1, y + 1].type])
				{
					num5--;
					num7 = 3;
				}
				else
				{
					if (Main.tile[num5, num6].wall <= 0 || Main.tile[num5 + 1, num6].wall <= 0 || Main.tile[num5, num6 + 1].wall <= 0 || Main.tile[num5 + 1, num6 + 1].wall <= 0)
					{
						return false;
					}
					num7 = 4;
				}
			}
			if (Main.tile[num5, num6].active() || Main.tile[num5 + 1, num6].active() || Main.tile[num5, num6 + 1].active() || Main.tile[num5 + 1, num6 + 1].active())
			{
				return false;
			}
			int num8 = 36 * num7;
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Main.tile[num5 + k, num6 + l].active(active: true);
					Main.tile[num5 + k, num6 + l].type = type;
					Main.tile[num5 + k, num6 + l].frameX = (short)(num8 + 18 * k);
					Main.tile[num5 + k, num6 + l].frameY = (short)(18 * l);
				}
			}
			return true;
		}

		public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0)
		{
			int num = x - 2;
			int num2 = x + 3;
			int num3 = y - 2;
			int num4 = y + 3;
			if (num < 0)
			{
				return false;
			}
			if (num2 > Main.maxTilesX)
			{
				return false;
			}
			if (num3 < 0)
			{
				return false;
			}
			if (num4 > Main.maxTilesY)
			{
				return false;
			}
			for (int i = num; i < num2; i++)
			{
				for (int j = num3; j < num4; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
				}
			}
			int num5 = y;
			int num6 = 0;
			if (SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1))
			{
				num5--;
				num6 = Style;
				if (Main.tile[x, num5].active() || Main.tile[x + 1, num5].active() || Main.tile[x, num5 + 1].active() || Main.tile[x + 1, num5 + 1].active())
				{
					return false;
				}
				int num7 = 36 * num6;
				for (int k = 0; k < 2; k++)
				{
					for (int l = 0; l < 2; l++)
					{
						Main.tile[x + k, num5 + l].active(active: true);
						Main.tile[x + k, num5 + l].type = type;
						Main.tile[x + k, num5 + l].frameX = (short)(num7 + 18 * k);
						Main.tile[x + k, num5 + l].frameY = (short)(18 * l);
					}
				}
				return true;
			}
			return false;
		}

		public static Color paintColor(int color)
		{
			Color white = Color.White;
			if (color == 1 || color == 13)
			{
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = 0;
			}
			if (color == 2 || color == 14)
			{
				white.R = byte.MaxValue;
				white.G = 127;
				white.B = 0;
			}
			if (color == 3 || color == 15)
			{
				white.R = byte.MaxValue;
				white.G = byte.MaxValue;
				white.B = 0;
			}
			if (color == 4 || color == 16)
			{
				white.R = 127;
				white.G = byte.MaxValue;
				white.B = 0;
			}
			if (color == 5 || color == 17)
			{
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = 0;
			}
			if (color == 6 || color == 18)
			{
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = 127;
			}
			if (color == 7 || color == 19)
			{
				white.R = 0;
				white.G = byte.MaxValue;
				white.B = byte.MaxValue;
			}
			if (color == 8 || color == 20)
			{
				white.R = 0;
				white.G = 127;
				white.B = byte.MaxValue;
			}
			if (color == 9 || color == 21)
			{
				white.R = 0;
				white.G = 0;
				white.B = byte.MaxValue;
			}
			if (color == 10 || color == 22)
			{
				white.R = 127;
				white.G = 0;
				white.B = byte.MaxValue;
			}
			if (color == 11 || color == 23)
			{
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = byte.MaxValue;
			}
			if (color == 12 || color == 24)
			{
				white.R = byte.MaxValue;
				white.G = 0;
				white.B = 127;
			}
			if (color == 25)
			{
				white.R = 75;
				white.G = 75;
				white.B = 75;
			}
			if (color == 26)
			{
				white.R = byte.MaxValue;
				white.G = byte.MaxValue;
				white.B = byte.MaxValue;
			}
			if (color == 27)
			{
				white.R = 175;
				white.G = 175;
				white.B = 175;
			}
			if (color == 28)
			{
				white.R = byte.MaxValue;
				white.G = 178;
				white.B = 125;
			}
			if (color == 29)
			{
				white.R = 25;
				white.G = 25;
				white.B = 25;
			}
			if (color == 30)
			{
				white.R = 200;
				white.G = 200;
				white.B = 200;
				white.A = 150;
			}
			return white;
		}

		public static Color coatingColor(int coating)
		{
			return coating switch
			{
				1 => new Color(235, 170, 255, 255), 
				2 => new Color(180, 245, 255, 255), 
				_ => Color.Transparent, 
			};
		}

		public static List<Color> coatingColors(Tile tile, bool block)
		{
			_coatingColors.Clear();
			if (tile == null)
			{
				return _coatingColors;
			}
			if ((block && tile.fullbrightBlock()) || (!block && tile.fullbrightWall()))
			{
				_coatingColors.Add(coatingColor(1));
			}
			if ((block && tile.invisibleBlock()) || (!block && tile.invisibleWall()))
			{
				_coatingColors.Add(coatingColor(2));
			}
			return _coatingColors;
		}

		public static void paintEffect(int x, int y, byte color, byte oldColor)
		{
			int color2 = color;
			if (color == 0)
			{
				color2 = oldColor;
			}
			Color newColor = paintColor(color2);
			for (int i = 0; i < 10; i++)
			{
				int num = Dust.NewDust(new Vector2(x * 16, y * 16), 16, 16, 143, 0f, 0f, 50, newColor);
				if (genRand.Next(2) == 0)
				{
					Main.dust[num].noGravity = true;
					Main.dust[num].scale *= 1.2f;
				}
				else
				{
					Main.dust[num].scale *= 0.5f;
				}
			}
		}

		public static void paintCoatEffect(int x, int y, byte paintCoatId, List<Color> oldColors)
		{
			Color color = coatingColor(paintCoatId);
			for (int i = 0; i < 10; i++)
			{
				Color newColor = color;
				if (paintCoatId == 0 && oldColors.Count > 0)
				{
					newColor = oldColors[Main.rand.Next(oldColors.Count)];
				}
				int num = Dust.NewDust(new Vector2(x * 16, y * 16), 16, 16, 143, 0f, 0f, 50, newColor);
				if (genRand.Next(2) == 0)
				{
					Main.dust[num].noGravity = true;
					Main.dust[num].scale *= 1.2f;
				}
				else
				{
					Main.dust[num].scale *= 0.5f;
				}
			}
		}

		public static bool paintTile(int x, int y, byte color, bool broadCast = false)
		{
			Tile tile = Main.tile[x, y];
			if (tile == null || !tile.active())
			{
				return false;
			}
			byte b = tile.color();
			if (b == color)
			{
				return false;
			}
			paintEffect(x, y, color, b);
			tile.color(color);
			if (broadCast)
			{
				NetMessage.SendData(63, -1, -1, null, x, y, (int)color);
			}
			return true;
		}

		public static bool paintCoatTile(int x, int y, byte paintCoatId, bool broadcast = false)
		{
			Tile tile = Main.tile[x, y];
			if (tile == null || !tile.active())
			{
				return false;
			}
			List<Color> oldColors = coatingColors(tile, block: true);
			switch (paintCoatId)
			{
			default:
				return false;
			case 0:
				if (!tile.fullbrightBlock() && !tile.invisibleBlock())
				{
					return false;
				}
				tile.fullbrightBlock(fullbrightBlock: false);
				tile.invisibleBlock(invisibleBlock: false);
				SquareTileFrame(x, y, resetFrame: false);
				break;
			case 1:
				if (tile.fullbrightBlock())
				{
					return false;
				}
				tile.fullbrightBlock(fullbrightBlock: true);
				break;
			case 2:
				if (tile.invisibleBlock())
				{
					return false;
				}
				tile.invisibleBlock(invisibleBlock: true);
				SquareTileFrame(x, y, resetFrame: false);
				break;
			}
			if (broadcast)
			{
				NetMessage.SendData(63, -1, -1, null, x, y, (int)paintCoatId, 1f);
			}
			paintCoatEffect(x, y, paintCoatId, oldColors);
			return true;
		}

		public static bool paintCoatWall(int x, int y, byte paintCoatId, bool broadcast = false)
		{
			Tile tile = Main.tile[x, y];
			if (tile == null || tile.wall == 0)
			{
				return false;
			}
			List<Color> oldColors = coatingColors(tile, block: false);
			switch (paintCoatId)
			{
			default:
				return false;
			case 0:
				if (!tile.fullbrightWall() && !tile.invisibleWall())
				{
					return false;
				}
				tile.fullbrightWall(fullbrightWall: false);
				tile.invisibleWall(invisibleWall: false);
				SquareWallFrame(x, y, resetFrame: false);
				break;
			case 1:
				if (tile.fullbrightWall())
				{
					return false;
				}
				tile.fullbrightWall(fullbrightWall: true);
				break;
			case 2:
				if (tile.invisibleWall())
				{
					return false;
				}
				tile.invisibleWall(invisibleWall: true);
				SquareWallFrame(x, y, resetFrame: false);
				break;
			}
			if (broadcast)
			{
				NetMessage.SendData(64, -1, -1, null, x, y, (int)paintCoatId, 1f);
			}
			paintCoatEffect(x, y, paintCoatId, oldColors);
			return true;
		}

		public static bool paintWall(int x, int y, byte color, bool broadCast = false)
		{
			Tile tile = Main.tile[x, y];
			if (tile == null || tile.wall == 0)
			{
				return false;
			}
			byte b = tile.wallColor();
			if (b == color)
			{
				return false;
			}
			tile.wallColor(color);
			if (broadCast)
			{
				NetMessage.SendData(64, -1, -1, null, x, y, (int)color);
			}
			paintEffect(x, y, color, b);
			return true;
		}

		public static void Place3x3Wall(int x, int y, ushort type, int style)
		{
			int num = x - 1;
			int num2 = y - 1;
			bool flag = true;
			for (int i = num; i < num + 3; i++)
			{
				for (int j = num2; j < num2 + 3; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 0;
			while (style > 35)
			{
				num3++;
				style -= 36;
			}
			int num4 = style * 54;
			int num5 = num3 * 54;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
				}
			}
		}

		public static void Check3x3Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			Tile tile = Main.tile[x, y];
			if (tile == null)
			{
				return;
			}
			int type = tile.type;
			int num = 0;
			int num2 = 0;
			int num3 = tile.frameX / 18;
			while (num3 >= 3)
			{
				num3 -= 3;
				num++;
			}
			int num4 = x - num3;
			int num5 = tile.frameY / 18;
			while (num5 >= 3)
			{
				num5 -= 3;
				num2++;
			}
			int num6 = y - num5;
			num5 = num2 * 54;
			num3 = num * 54;
			for (int i = num4; i < num4 + 3; i++)
			{
				for (int j = num6; j < num6 + 3; j++)
				{
					Tile tile2 = Main.tile[i, j];
					if (tile2 != null && (tile2.type != type || !tile2.active() || tile2.wall <= 0 || tile2.frameX != num3 + (i - num4) * 18 || tile2.frameY != num5 + (j - num6) * 18))
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num4; k < num4 + 3; k++)
			{
				for (int l = num6; l < num6 + 3; l++)
				{
					if (Main.tile[k, l] != null && Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			switch (type)
			{
			case 240:
				num += num2 * 36;
				switch (num)
				{
				case 37:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1856);
					break;
				case 36:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1855);
					break;
				case 38:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1960);
					break;
				case 39:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1961);
					break;
				case 40:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1962);
					break;
				case 33:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1574);
					break;
				case 34:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1575);
					break;
				case 35:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1576);
					break;
				case 18:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1419);
					break;
				case 19:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1420);
					break;
				case 20:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1427);
					break;
				case 21:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1428);
					break;
				case 54:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2489);
					break;
				case 55:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2589);
					break;
				case 56:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3357);
					break;
				case 57:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3358);
					break;
				case 58:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3359);
					break;
				case 59:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3595);
					break;
				case 60:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3867);
					break;
				case 61:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3866);
					break;
				case 62:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3868);
					break;
				case 69:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4660);
					break;
				case 70:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4723);
					break;
				case 71:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4724);
					break;
				case 72:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4783);
					break;
				case 73:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4958);
					break;
				case 74:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5087);
					break;
				case 75:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5108);
					break;
				case 92:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5388);
					break;
				case 76:
				case 77:
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
				case 84:
				case 85:
				case 86:
				case 87:
				case 88:
				case 89:
				case 90:
				case 91:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5218 + num - 76);
					break;
				default:
					if (num >= 63 && num <= 68)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4626 + num - 63);
					}
					else if (num >= 41 && num <= 45)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2114 + num - 41);
					}
					else if (num >= 46 && num <= 53)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2442 + num - 46);
					}
					else if (num >= 22 && num <= 25)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1440 + num - 22);
					}
					else if (num >= 26 && num <= 29)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1496 + num - 26);
					}
					else if (num >= 30 && num <= 32)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1538 + num - 30);
					}
					else
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1360 + num);
					}
					break;
				}
				break;
			case 440:
			{
				int num7 = -1;
				int num8 = -1;
				switch (num)
				{
				case 0:
					num7 = 3644;
					num8 = 1526;
					break;
				case 1:
					num7 = 3645;
					num8 = 1524;
					break;
				case 2:
					num7 = 3646;
					num8 = 1525;
					break;
				case 3:
					num7 = 3647;
					num8 = 1523;
					break;
				case 4:
					num7 = 3648;
					num8 = 1522;
					break;
				case 5:
					num7 = 3649;
					num8 = 1527;
					break;
				case 6:
					num7 = 3650;
					num8 = 3643;
					break;
				}
				if (num7 != -1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, num7);
				}
				if (num8 != -1 && num2 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, num8);
				}
				break;
			}
			}
			destroyObject = false;
		}

		public static void Place2x3Wall(int x, int y, ushort type, int style)
		{
			int num = y - 1;
			bool flag = true;
			for (int i = x; i < x + 2; i++)
			{
				for (int j = num; j < num + 3; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num2 = style * 36;
			int num3 = 0;
			for (int k = x; k < x + 2; k++)
			{
				for (int l = num; l < num + 3; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num2 + 18 * (k - x));
					Main.tile[k, l].frameY = (short)(num3 + 18 * (l - num));
				}
			}
		}

		public static void Check2x3Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameX / 18;
			while (num2 >= 2)
			{
				num2 -= 2;
				num++;
			}
			int num3 = x - num2;
			int num4 = y - Main.tile[x, y].frameY / 18;
			num2 = num * 36;
			for (int i = num3; i < num3 + 2; i++)
			{
				for (int j = num4; j < num4 + 3; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameX != num2 + (i - num3) * 18 || Main.tile[i, j].frameY != (j - num4) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num3; k < num3 + 2; k++)
			{
				for (int l = num4; l < num4 + 3; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 245)
			{
				if (num >= 19 && num <= 28)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5248 + num - 19);
				}
				else if (num >= 15 && num <= 18)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5247);
				}
				else
				{
					switch (num)
					{
					case 14:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5246);
						break;
					case 13:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5086);
						break;
					case 12:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4728);
						break;
					case 11:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4727);
						break;
					case 10:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4726);
						break;
					case 9:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4659);
						break;
					case 8:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4639);
						break;
					case 7:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4638);
						break;
					case 6:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1577);
						break;
					case 5:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1495);
						break;
					default:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1474 + num);
						break;
					}
				}
			}
			destroyObject = false;
		}

		public static void Place3x2Wall(int x, int y, ushort type, int style)
		{
			int num = x - 1;
			bool flag = true;
			for (int i = num; i < num + 3; i++)
			{
				for (int j = y; j < y + 2; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num2 = 0;
			int num3 = style * 36;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = y; l < y + 2; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num2 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num3 + 18 * (l - y));
				}
			}
		}

		public static void Check3x2Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			while (num2 >= 2)
			{
				num2 -= 2;
				num++;
			}
			int num3 = y - num2;
			int num4 = x - Main.tile[x, y].frameX / 18;
			num2 = num * 36;
			for (int i = num4; i < num4 + 3; i++)
			{
				for (int j = num3; j < num3 + 2; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num4; k < num4 + 3; k++)
			{
				for (int l = num3; l < num3 + 2; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 246)
			{
				switch (num)
				{
				case 16:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1541);
					break;
				case 17:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1542);
					break;
				case 18:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1908);
					break;
				case 19:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4661);
					break;
				case 20:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4729);
					break;
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5258 + num - 21);
					break;
				default:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1479 + num);
					break;
				}
			}
			destroyObject = false;
		}

		public static void Place4x3Wall(int x, int y, ushort type, int style)
		{
			int num = x - 1;
			int num2 = y - 1;
			bool flag = true;
			for (int i = num; i < num + 4; i++)
			{
				for (int j = num2; j < num2 + 3; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 0;
			int num4 = style * 54;
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num3 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num4 + 18 * (l - num2));
				}
			}
		}

		public static void Check4x3Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			while (num2 >= 3)
			{
				num2 -= 3;
				num++;
			}
			int num3 = y - num2;
			int num4 = x - Main.tile[x, y].frameX / 18;
			num2 = num * 54;
			for (int i = num4; i < num4 + 4; i++)
			{
				for (int j = num3; j < num3 + 3; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num3) * 18 || Main.tile[i, j].frameX != (i - num4) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num4; k < num4 + 4; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 241)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1417);
			}
			destroyObject = false;
		}

		public static void Place6x4Wall(int x, int y, ushort type, int style)
		{
			int num = x - 2;
			int num2 = y - 2;
			bool flag = true;
			for (int i = num; i < num + 6; i++)
			{
				for (int j = num2; j < num2 + 4; j++)
				{
					if (Main.tile[i, j].active() || Main.tile[i, j].wall == 0)
					{
						flag = false;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num3 = 27;
			int num4 = style / num3 * 108;
			int num5 = style % num3 * 72;
			for (int k = num; k < num + 6; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].type = type;
					Main.tile[k, l].frameX = (short)(num4 + 18 * (k - num));
					Main.tile[k, l].frameY = (short)(num5 + 18 * (l - num2));
				}
			}
		}

		public static void Check6x4Wall(int x, int y)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int type = Main.tile[x, y].type;
			int num = 0;
			int num2 = Main.tile[x, y].frameY / 18;
			int num3 = Main.tile[x, y].frameX / 18;
			num = 27 * (num3 / 6) + (num2 >> 2);
			num2 %= 4;
			num3 %= 6;
			int num4 = y - num2;
			int num5 = x - Main.tile[x, y].frameX / 18 % 6;
			num2 = num % 27 * 72;
			num3 = num / 27 * 108;
			for (int i = num5; i < num5 + 6; i++)
			{
				for (int j = num4; j < num4 + 4; j++)
				{
					if (Main.tile[i, j].type != type || !Main.tile[i, j].active() || Main.tile[i, j].wall <= 0 || Main.tile[i, j].frameY != num2 + (j - num4) * 18 || Main.tile[i, j].frameX != num3 + (i - num5) * 18)
					{
						flag = true;
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = num5; k < num5 + 6; k++)
			{
				for (int l = num4; l < num4 + 4; l++)
				{
					if (Main.tile[k, l].type == type && Main.tile[k, l].active())
					{
						KillTile(k, l);
					}
				}
			}
			if (type == 242)
			{
				switch (num)
				{
				case 30:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2995);
					break;
				case 65:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5389);
					break;
				case 64:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5310);
					break;
				case 63:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5308);
					break;
				case 62:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5274);
					break;
				case 50:
				case 51:
				case 52:
				case 53:
				case 54:
				case 55:
				case 56:
				case 57:
				case 58:
				case 59:
				case 60:
				case 61:
					Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5234 + num - 50);
					break;
				default:
					if (num >= 46 && num <= 49)
					{
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5121 + num - 46);
						break;
					}
					switch (num)
					{
					case 45:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 5085);
						break;
					case 44:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4725);
						break;
					case 43:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4658);
						break;
					case 37:
					case 38:
					case 39:
					case 40:
					case 41:
					case 42:
						Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 4632 + num - 37);
						break;
					default:
						if (num >= 31 && num <= 35)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3055 + num - 31);
						}
						else if (num >= 27 && num <= 29)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2865 + num - 27);
						}
						else if (num == 36)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 3596);
						}
						else if (num == 26)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2497);
						}
						else if (num == 25)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2495);
						}
						else if (num >= 22)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 2281 + num - 22);
						}
						else if (num >= 17)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1846 + num - 17);
						}
						else if (num == 16)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1573);
						}
						else if (num >= 13)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1500 + num - 13);
						}
						else if (num >= 6)
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1433 + num - 6);
						}
						else
						{
							Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 32, 32, 1421 + num);
						}
						break;
					}
					break;
				}
			}
			destroyObject = false;
		}

		private static int RollRandomSeaShellStyle()
		{
			int result = genRand.Next(2);
			if (genRand.Next(10) == 0)
			{
				result = 2;
			}
			if (genRand.Next(10) == 0)
			{
				result = 3;
			}
			if (genRand.Next(50) == 0)
			{
				result = 4;
			}
			return result;
		}

		public static void Place1x1(int x, int y, int type, int style = 0)
		{
			Tile tile = Main.tile[x, y];
			if (Main.tile[x, y] == null)
			{
				tile = new Tile();
				Main.tile[x, y] = tile;
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (type == 324)
			{
				if (SolidTile2(x, y + 1) || (Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type]))
				{
					tile.active(active: true);
					tile.type = (ushort)type;
					tile.frameX = (short)(22 * genRand.Next(3));
					tile.frameY = (short)(22 * style);
				}
			}
			else if (SolidTile2(x, y + 1) && !tile.active())
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				switch (type)
				{
				case 324:
					tile.frameX = (short)(22 * RollRandomSeaShellStyle());
					tile.frameY = (short)(22 * style);
					break;
				case 36:
				case 144:
				case 239:
					tile.frameX = (short)(style * 18);
					tile.frameY = 0;
					break;
				default:
					tile.frameY = (short)(style * 18);
					break;
				}
			}
		}

		public static void Check1x1(int x, int y, int type)
		{
			if (Main.tile[x, y + 1] != null)
			{
				if (!SolidTileAllowBottomSlope(x, y + 1))
				{
					KillTile(x, y);
				}
				if (type == 624 && !TileID.Sets.Conversion.Grass[Main.tile[x, y + 1].type])
				{
					KillTile(x, y);
				}
			}
		}

		public static void CheckGolf1x1(int x, int y, int type)
		{
			Tile tile = Main.tile[x, y];
			bool flag = false;
			if (tile.frameX % 18 != 0)
			{
				flag = true;
			}
			if (tile.frameY % 18 != 0)
			{
				flag = true;
			}
			if (!SolidTileAllowBottomSlope(x, y + 1))
			{
				flag = true;
			}
			if (flag)
			{
				KillTile(x, y);
			}
		}

		public static void CheckLogicTiles(int x, int y, int type)
		{
			if (type == 419)
			{
				Tile tile = Main.tile[x, y + 1];
				if (tile != null && (!tile.active() || (tile.type != 420 && tile.type != 419)))
				{
					KillTile(x, y);
					return;
				}
			}
			Tile tile2 = Main.tile[x, y];
			bool flag = false;
			if (tile2.frameX % 18 != 0)
			{
				flag = true;
			}
			if (tile2.frameY % 18 != 0)
			{
				flag = true;
			}
			if (flag)
			{
				KillTile(x, y);
			}
		}

		public static void PlaceLogicTiles(int x, int y, int type, int style = 0)
		{
			Tile tile = Main.tile[x, y];
			if (Main.tile[x, y] == null)
			{
				tile = new Tile();
				Main.tile[x, y] = tile;
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (type == 419)
			{
				if (Main.tile[x, y + 1].active() && (Main.tile[x, y + 1].type == 419 || Main.tile[x, y + 1].type == 420))
				{
					tile.active(active: true);
					tile.type = (ushort)type;
					tile.frameX = (short)(style * 18);
					tile.frameY = 0;
				}
			}
			else if (!tile.active())
			{
				tile.active(active: true);
				tile.type = (ushort)type;
				tile.frameX = 0;
				tile.frameY = (short)(18 * style);
			}
		}

		public static void PlaceOnTable1x1(int x, int y, int type, int style = 0)
		{
			bool flag = false;
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[Main.tile[x, y + 1].type])
			{
				flag = true;
			}
			if (type == 78 && !Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
			{
				flag = true;
			}
			if (flag)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].type = (ushort)type;
				if (type == 33)
				{
					Main.tile[x, y].frameX = 0;
					Main.tile[x, y].frameY = (short)(style * 22);
				}
				else
				{
					Main.tile[x, y].frameX = (short)(style * 18);
					Main.tile[x, y].frameY = 0;
				}
				if (type == 50)
				{
					Main.tile[x, y].frameX = (short)(18 * genRand.Next(5));
				}
			}
		}

		public static bool PlaceAlch(int x, int y, int style)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
			{
				bool flag = false;
				switch (style)
				{
				case 0:
					if (Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 109)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 1:
					if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 2:
					if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 3:
					if (Main.tile[x, y + 1].type != 661 && Main.tile[x, y + 1].type != 662 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0)
					{
						flag = true;
					}
					break;
				case 4:
					if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 5:
					if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 633 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && !Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 6:
					if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				}
				if (!flag)
				{
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].type = 82;
					Main.tile[x, y].frameX = (short)(18 * style);
					Main.tile[x, y].frameY = 0;
					return true;
				}
			}
			return false;
		}

		public static void GrowSpike(int i, int j, ushort spikeType, ushort landType)
		{
			int num = -1;
			switch (landType)
			{
			case 23:
				num = 661;
				break;
			case 199:
				num = 662;
				break;
			}
			int num2 = i;
			int num3 = j;
			int num4 = 0;
			if (Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == spikeType)
			{
				num4++;
			}
			if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == spikeType)
			{
				num4++;
			}
			if (Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == spikeType)
			{
				num4++;
			}
			if (Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == spikeType)
			{
				num4++;
			}
			if (num4 >= 3 && Main.tile[i, j].type != landType && Main.tile[i, j].type != num)
			{
				return;
			}
			switch (genRand.Next(4))
			{
			case 0:
				num3--;
				break;
			case 1:
				num3++;
				break;
			case 2:
				num2--;
				break;
			case 3:
				num2++;
				break;
			}
			if (Main.tile[num2, num3].active())
			{
				return;
			}
			num4 = 0;
			if (Main.tile[num2 + 1, num3].active() && Main.tile[num2 + 1, num3].type == spikeType)
			{
				num4++;
			}
			if (Main.tile[num2 - 1, num3].active() && Main.tile[num2 - 1, num3].type == spikeType)
			{
				num4++;
			}
			if (Main.tile[num2, num3 + 1].active() && Main.tile[num2, num3 + 1].type == spikeType)
			{
				num4++;
			}
			if (Main.tile[num2, num3 - 1].active() && Main.tile[num2, num3 - 1].type == spikeType)
			{
				num4++;
			}
			if (num4 >= 2)
			{
				return;
			}
			int num5 = 7;
			int num6 = num2 - num5;
			int num7 = num2 + num5;
			int num8 = num3 - num5;
			int num9 = num3 + num5;
			bool flag = false;
			for (int k = num6; k < num7; k++)
			{
				for (int l = num8; l < num9; l++)
				{
					if (Math.Abs(k - num2) * 2 + Math.Abs(l - num3) < 9 && Main.tile[k, l].active() && (Main.tile[k, l].type == landType || Main.tile[k, l].type == num) && Main.tile[k, l - 1].active() && Main.tile[k, l - 1].type == spikeType && Main.tile[k, l - 1].liquid == 0)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				Main.tile[num2, num3].type = spikeType;
				Main.tile[num2, num3].active(active: true);
				Main.tile[num2, num3].CopyPaintAndCoating(Main.tile[i, j]);
				SquareTileFrame(num2, num3);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num2, num3, 1);
				}
			}
		}

		private static bool GrowMoreVines(int x, int y)
		{
			if (!InWorld(x, y, 30))
			{
				return false;
			}
			int num = 4;
			int num2 = 6;
			int num3 = 10;
			int num4 = 60;
			int num5 = 0;
			if (Main.tile[x, y].type == 528)
			{
				num4 /= 5;
			}
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num2; j <= y + num3; j++)
				{
					if (TileID.Sets.IsVine[Main.tile[i, j].type])
					{
						num5++;
						if (j > y && Collision.CanHitLine(new Vector2(x * 16, y * 16), 1, 1, new Vector2(i * 16, j * 16), 1, 1))
						{
							num5 = ((Main.tile[i, j].type != 528) ? (num5 + (j - y) * 2) : (num5 + (j - y) * 20));
						}
						if (num5 > num4)
						{
							return false;
						}
					}
				}
			}
			return true;
		}

		private static void GrowGlowTulips()
		{
			int num = ((Main.maxTilesX > 4200) ? ((Main.maxTilesX <= 6400) ? 1 : 2) : 0);
			int num2 = 100;
			int num3 = 300;
			int num4 = 2;
			num4 = num switch
			{
				1 => 4, 
				2 => 6, 
				_ => 2, 
			};
			int num5 = 0;
			int num6 = 10000;
			int num7 = (int)((double)num6 * 0.75);
			while (num5 < num4)
			{
				num6--;
				if (num6 <= 0)
				{
					break;
				}
				int i = ((num5 >= num4 / 2 && (num6 <= num7 || genRand.Next(2) != 0)) ? genRand.Next(Main.maxTilesX - num3, Main.maxTilesX - num2) : genRand.Next(num2, num3));
				int j = ((!remixWorldGen) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 200) : genRand.Next((int)Main.worldSurface, Main.maxTilesY - 350));
				if (TryGrowingGlowTulip(i, j))
				{
					num5++;
				}
			}
		}

		private static void MatureTheHerbPlants()
		{
			for (int i = 10; i < Main.maxTilesX - 10; i++)
			{
				for (int j = 10; j < Main.maxTilesY - 10; j++)
				{
					if ((double)j > Main.rockLayer && (Main.tile[i, j + 1].type == 59 || Main.tile[i, j + 1].type == 0) && SolidTile(i, j + 1) && !Main.tile[i, j].active() && Main.tile[i, j].liquid == 0 && genRand.Next(25) == 0)
					{
						Main.tile[i, j].active(active: true);
						Main.tile[i, j].type = 82;
						Main.tile[i, j].frameX = 36;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].type == 82 && genRand.Next(3) == 0)
					{
						Main.tile[i, j].type = 83;
						if (Main.tile[i, j].frameX == 36 && genRand.Next(2) == 0)
						{
							Main.tile[i, j].type = 84;
						}
						if (Main.tile[i, j].frameX == 108 && genRand.Next(3) == 0)
						{
							Main.tile[i, j].type = 84;
						}
					}
				}
			}
		}

		public static void GrowAlch(int x, int y)
		{
			if (!Main.tile[x, y].active())
			{
				return;
			}
			if (Main.tile[x, y].liquid > 0)
			{
				int num = Main.tile[x, y].frameX / 18;
				if ((!Main.tile[x, y].lava() || num != 5) && (Main.tile[x, y].liquidType() != 0 || (num != 1 && num != 4)))
				{
					KillTile(x, y);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
			}
			if (Main.tile[x, y].type == 82)
			{
				if (genRand.Next(50) == 0)
				{
					bool flag = false;
					if (Main.tile[x, y].frameX == 108)
					{
						if (genRand.Next(2) == 0)
						{
							flag = true;
						}
					}
					else
					{
						flag = true;
					}
					if (flag)
					{
						Main.tile[x, y].type = 83;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
						SquareTileFrame(x, y);
					}
				}
				else if (Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 0 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
				else if (!Main.dayTime && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 18 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
				else if (Main.raining && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 72 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
				else if ((double)y > Main.worldSurface && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 36 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
				else if (y > Main.maxTilesY - 200 && Main.tile[x, y].type == 82 && Main.tile[x, y].frameX == 90 && genRand.Next(50) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
					SquareTileFrame(x, y);
				}
			}
			else if (Main.tile[x, y].frameX == 36 && genRand.Next(3) != 0)
			{
				if (Main.tile[x, y].type == 83)
				{
					if (genRand.Next(2) == 0)
					{
						Main.tile[x, y].type = 84;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
				}
				else if (Main.tile[x, y].type == 84 || genRand.Next(5) == 0)
				{
					Main.tile[x, y].type = 83;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (Main.tile[x, y].frameX == 108 && Main.tile[x, y].type == 83 && genRand.Next(30) == 0)
			{
				Main.tile[x, y].type = 84;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
				SquareTileFrame(x, y);
			}
		}

		public static void PlantAlch()
		{
			int num = genRand.Next(20, Main.maxTilesX - 20);
			int num2 = 0;
			for (num2 = (Main.remixWorld ? genRand.Next(20, Main.maxTilesY - 20) : ((genRand.Next(40) == 0) ? genRand.Next((int)(Main.rockLayer + (double)Main.maxTilesY) / 2, Main.maxTilesY - 20) : ((genRand.Next(10) != 0) ? genRand.Next((int)Main.worldSurface, Main.maxTilesY - 20) : genRand.Next(20, Main.maxTilesY - 20)))); num2 < Main.maxTilesY - 20 && !Main.tile[num, num2].active(); num2++)
			{
			}
			if (!Main.tile[num, num2].nactive() || Main.tile[num, num2 - 1].active() || Main.tile[num, num2 - 1].liquid != 0)
			{
				return;
			}
			int num3 = 15;
			int num4 = 5;
			int num5 = 0;
			num3 = (int)((double)num3 * ((double)Main.maxTilesX / 4200.0));
			int num6 = Utils.Clamp(num - num3, 4, Main.maxTilesX - 4);
			int num7 = Utils.Clamp(num + num3, 4, Main.maxTilesX - 4);
			int num8 = Utils.Clamp(num2 - num3, 4, Main.maxTilesY - 4);
			int num9 = Utils.Clamp(num2 + num3, 4, Main.maxTilesY - 4);
			for (int i = num6; i <= num7; i++)
			{
				for (int j = num8; j <= num9; j++)
				{
					if (Main.tileAlch[Main.tile[i, j].type])
					{
						num5++;
					}
				}
			}
			if (num5 < num4)
			{
				if (Main.tile[num, num2].type == 2 || Main.tile[num, num2].type == 109)
				{
					PlaceAlch(num, num2 - 1, 0);
				}
				if (Main.tile[num, num2].type == 60)
				{
					PlaceAlch(num, num2 - 1, 1);
				}
				if (Main.tile[num, num2].type == 0 || Main.tile[num, num2].type == 59)
				{
					PlaceAlch(num, num2 - 1, 2);
				}
				if (Main.tile[num, num2].type == 23 || Main.tile[num, num2].type == 661 || Main.tile[num, num2].type == 25 || Main.tile[num, num2].type == 203 || Main.tile[num, num2].type == 199 || Main.tile[num, num2].type == 662)
				{
					PlaceAlch(num, num2 - 1, 3);
				}
				if ((Main.tile[num, num2].type == 53 || Main.tile[num, num2].type == 116) && num >= beachDistance && num <= Main.maxTilesX - beachDistance)
				{
					PlaceAlch(num, num2 - 1, 4);
				}
				if (Main.tile[num, num2].type == 57 || Main.tile[num, num2].type == 633)
				{
					PlaceAlch(num, num2 - 1, 5);
				}
				if (Main.tile[num, num2].type == 147 || Main.tile[num, num2].type == 163 || Main.tile[num, num2].type == 164 || Main.tile[num, num2].type == 161 || Main.tile[num, num2].type == 200)
				{
					PlaceAlch(num, num2 - 1, 6);
				}
				if (Main.tile[num, num2 - 1].active() && Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num, num2 - 1);
				}
			}
		}

		public static void CheckAlch(int x, int y)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			bool flag = false;
			if (!Main.tile[x, y + 1].nactive())
			{
				flag = true;
			}
			if (Main.tile[x, y + 1].halfBrick())
			{
				flag = true;
			}
			int num = Main.tile[x, y].frameX / 18;
			Main.tile[x, y].frameY = 0;
			if (!flag)
			{
				switch (num)
				{
				case 0:
					if (Main.tile[x, y + 1].type != 109 && Main.tile[x, y + 1].type != 2 && Main.tile[x, y + 1].type != 477 && Main.tile[x, y + 1].type != 492 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 1:
					if (Main.tile[x, y + 1].type != 60 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 2:
					if (Main.tile[x, y + 1].type != 0 && Main.tile[x, y + 1].type != 59 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 3:
					if (Main.tile[x, y + 1].type != 661 && Main.tile[x, y + 1].type != 662 && Main.tile[x, y + 1].type != 199 && Main.tile[x, y + 1].type != 203 && Main.tile[x, y + 1].type != 23 && Main.tile[x, y + 1].type != 25 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 4:
					if (Main.tile[x, y + 1].type != 53 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 116)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				case 5:
					if (Main.tile[x, y + 1].type != 57 && Main.tile[x, y + 1].type != 633 && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380)
					{
						flag = true;
					}
					if (Main.tile[x, y].type == 82 || !Main.tile[x, y].lava() || Main.netMode == 1)
					{
						break;
					}
					if (Main.tile[x, y].liquid > 16)
					{
						if (Main.tile[x, y].type == 83)
						{
							Main.tile[x, y].type = 84;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, x, y);
							}
						}
					}
					else if (Main.tile[x, y].type == 84)
					{
						Main.tile[x, y].type = 83;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
					break;
				case 6:
					if (Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 147 && Main.tile[x, y + 1].type != 161 && Main.tile[x, y + 1].type != 163 && Main.tile[x, y + 1].type != 164 && Main.tile[x, y + 1].type != 200)
					{
						flag = true;
					}
					if (Main.tile[x, y].liquid > 0 && Main.tile[x, y].lava())
					{
						flag = true;
					}
					break;
				}
			}
			if (flag)
			{
				KillTile(x, y);
			}
		}

		public static void CheckBanner(int x, int j, byte type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = Main.tile[x, j].frameY / 18;
			int num2 = 0;
			while (num >= 3)
			{
				num -= 3;
				num2++;
			}
			num = j - num;
			int frameX = Main.tile[x, j].frameX;
			bool flag = false;
			for (int i = 0; i < 3; i++)
			{
				if (Main.tile[x, num + i] == null)
				{
					Main.tile[x, num + i] = new Tile();
				}
				if (!Main.tile[x, num + i].active())
				{
					flag = true;
				}
				else if (Main.tile[x, num + i].type != type)
				{
					flag = true;
				}
				else if (Main.tile[x, num + i].frameY != i * 18 + num2 * 18 * 3)
				{
					flag = true;
				}
				else if (Main.tile[x, num + i].frameX != frameX)
				{
					flag = true;
				}
			}
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			Tile tile = Main.tile[x, num - 1];
			if (!tile.nactive())
			{
				flag = true;
			}
			bool num3 = tile.topSlope() || tile.halfBrick() || Main.tileSolid[tile.type];
			bool flag2 = !Main.tileSolidTop[tile.type] || (TileID.Sets.Platforms[tile.type] && (tile.halfBrick() || tile.topSlope()));
			bool flag3 = num3 && flag2 && !TileID.Sets.NotReallySolid[tile.type] && !tile.bottomSlope();
			if (TileID.Sets.Platforms[tile.type] || tile.type == 380)
			{
				flag3 = true;
			}
			if (!flag3)
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int k = 0; k < 3; k++)
			{
				if (Main.tile[x, num + k].type == type)
				{
					KillTile(x, num + k);
				}
			}
			if (type == 91)
			{
				int num4 = frameX / 18;
				num4 += num2 * 111;
				if (num4 >= 298)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 5352);
				}
				else if (num4 >= 297)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4668 + num4);
				}
				else if (num4 >= 295)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4392 + num4);
				}
				else if (num4 >= 294)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4602);
				}
				else if (num4 >= 288)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 4253 + num4);
				}
				else if (num4 >= 278)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3559 + num4);
				}
				else if (num4 >= 273)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3516 + num4);
				}
				else if (num4 >= 272)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3780);
				}
				else if (num4 >= 270)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3323 + num4);
				}
				else if (num4 >= 207)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 3183 + num4);
				}
				else if (num4 >= 109)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 2788 + num4);
				}
				else if (num4 >= 22)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1593 + num4);
				}
				else if (num4 >= 10 && num4 <= 15)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1441 + num4);
				}
				else if (num4 >= 16 && num4 <= 21)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 1448 + num4);
				}
				else if (num4 >= 7 && num4 <= 9)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 838 + num4);
				}
				else if (num4 >= 4 && num4 <= 6)
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 785 + num4);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(x, num + 1), x * 16, (num + 1) * 16, 32, 32, 337 + num4);
				}
			}
			destroyObject = false;
		}

		public static void PlaceBanner(int x, int y, ushort type, int style = 0)
		{
			int num = style * 18;
			int num2 = 0;
			if (style >= 90)
			{
				num -= 1620;
				num2 += 54;
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (Main.tile[x, y + 2] == null)
			{
				Main.tile[x, y + 2] = new Tile();
			}
			if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active() && !Main.tile[x, y + 2].active())
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)num2;
				Main.tile[x, y].frameX = (short)num;
				Main.tile[x, y].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameY = (short)(num2 + 18);
				Main.tile[x, y + 1].frameX = (short)num;
				Main.tile[x, y + 1].type = type;
				Main.tile[x, y + 2].active(active: true);
				Main.tile[x, y + 2].frameY = (short)(num2 + 36);
				Main.tile[x, y + 2].frameX = (short)num;
				Main.tile[x, y + 2].type = type;
			}
		}

		public static void PlaceMan(int i, int j, int dir)
		{
			for (int k = i; k <= i + 1; k++)
			{
				for (int l = j - 2; l <= j; l++)
				{
					if (Main.tile[k, l].active())
					{
						return;
					}
				}
			}
			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
			{
				byte b = 0;
				if (dir == 1)
				{
					b = 36;
				}
				Main.tile[i, j - 2].active(active: true);
				Main.tile[i, j - 2].frameY = 0;
				Main.tile[i, j - 2].frameX = b;
				Main.tile[i, j - 2].type = 128;
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].frameY = 18;
				Main.tile[i, j - 1].frameX = b;
				Main.tile[i, j - 1].type = 128;
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = 36;
				Main.tile[i, j].frameX = b;
				Main.tile[i, j].type = 128;
				Main.tile[i + 1, j - 2].active(active: true);
				Main.tile[i + 1, j - 2].frameY = 0;
				Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 2].type = 128;
				Main.tile[i + 1, j - 1].active(active: true);
				Main.tile[i + 1, j - 1].frameY = 18;
				Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 1].type = 128;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = 36;
				Main.tile[i + 1, j].frameX = (byte)(18 + b);
				Main.tile[i + 1, j].type = 128;
			}
		}

		public static void PlaceWoman(int i, int j, int dir)
		{
			for (int k = i; k <= i + 1; k++)
			{
				for (int l = j - 2; l <= j; l++)
				{
					if (Main.tile[k, l].active())
					{
						return;
					}
				}
			}
			if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1))
			{
				byte b = 0;
				if (dir == 1)
				{
					b = 36;
				}
				Main.tile[i, j - 2].active(active: true);
				Main.tile[i, j - 2].frameY = 0;
				Main.tile[i, j - 2].frameX = b;
				Main.tile[i, j - 2].type = 269;
				Main.tile[i, j - 1].active(active: true);
				Main.tile[i, j - 1].frameY = 18;
				Main.tile[i, j - 1].frameX = b;
				Main.tile[i, j - 1].type = 269;
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = 36;
				Main.tile[i, j].frameX = b;
				Main.tile[i, j].type = 269;
				Main.tile[i + 1, j - 2].active(active: true);
				Main.tile[i + 1, j - 2].frameY = 0;
				Main.tile[i + 1, j - 2].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 2].type = 269;
				Main.tile[i + 1, j - 1].active(active: true);
				Main.tile[i + 1, j - 1].frameY = 18;
				Main.tile[i + 1, j - 1].frameX = (byte)(18 + b);
				Main.tile[i + 1, j - 1].type = 269;
				Main.tile[i + 1, j].active(active: true);
				Main.tile[i + 1, j].frameY = 36;
				Main.tile[i + 1, j].frameX = (byte)(18 + b);
				Main.tile[i + 1, j].type = 269;
			}
		}

		public static void CheckWeaponsRack(int i, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3 = Main.tile[i, j].frameX;
			int num4 = 0;
			while (num3 >= 5000)
			{
				num3 -= 5000;
				num4++;
			}
			if (num4 != 0)
			{
				num3 = (num4 - 1) * 18;
			}
			num3 %= 54;
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k < 3; k++)
			{
				for (int l = 0; l < 3; l++)
				{
					int num5 = num + k;
					int num6 = num2 + l;
					int num7 = Main.tile[num5, num6].frameX;
					int num8 = 0;
					while (num7 >= 5000)
					{
						num7 -= 5000;
						num8++;
					}
					if (num8 != 0)
					{
						num7 = (num8 - 1) * 18;
					}
					num7 %= 54;
					if (!Main.tile[num5, num6].active() || Main.tile[num5, num6].type != 334 || Main.tile[num5, num6].wall <= 0 || Main.tile[num5, num6].frameY != l * 18 || num7 != k * 18)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int num9 = TEWeaponsRack.Find(num, num2);
			if (num9 != -1 && ((TEWeaponsRack)TileEntity.ByID[num9]).item.stack > 0)
			{
				((TEWeaponsRack)TileEntity.ByID[num9]).DropItem();
				if (Main.netMode != 2)
				{
					Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
				}
			}
			destroyObject = true;
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 48, 2699);
			TEWeaponsRack.Kill(num, num2);
			for (int m = 0; m < 3; m++)
			{
				for (int n = 0; n < 3; n++)
				{
					int num10 = num + m;
					int num11 = num2 + n;
					if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 334)
					{
						KillTile(num10, num11);
					}
				}
			}
			destroyObject = false;
		}

		public static void ToggleGemLock(int i, int j, bool on)
		{
			Tile tileSafely = Framing.GetTileSafely(i, j);
			if (!tileSafely.active() || tileSafely.type != 440 || (tileSafely.frameY < 54 && !on))
			{
				return;
			}
			bool flag = false;
			int num = -1;
			if (tileSafely.frameY >= 54)
			{
				flag = true;
			}
			int num2 = Main.tile[i, j].frameX / 54;
			int num3 = Main.tile[i, j].frameX % 54 / 18;
			int num4 = Main.tile[i, j].frameY % 54 / 18;
			switch (num2)
			{
			case 0:
				num = 1526;
				break;
			case 1:
				num = 1524;
				break;
			case 2:
				num = 1525;
				break;
			case 3:
				num = 1523;
				break;
			case 4:
				num = 1522;
				break;
			case 5:
				num = 1527;
				break;
			case 6:
				num = 3643;
				break;
			}
			for (int k = i - num3; k < i - num3 + 3; k++)
			{
				for (int l = j - num4; l < j - num4 + 3; l++)
				{
					Main.tile[k, l].frameY = (short)((on ? 54 : 0) + (l - j + num4) * 18);
				}
			}
			if (num != -1 && flag)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num);
			}
			SquareTileFrame(i, j);
			NetMessage.SendTileSquare(-1, i - num3, j - num4, 3, 3);
			Wiring.HitSwitch(i - num3, j - num4);
			NetMessage.SendData(59, -1, -1, null, i - num3, j - num4);
		}

		public static void CheckMan(int i, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3;
			for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
			{
			}
			while (num3 >= 36)
			{
				num3 -= 36;
			}
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k <= 1; k++)
			{
				for (int l = 0; l <= 2; l++)
				{
					int num4 = num + k;
					int num5 = num2 + l;
					int num6;
					for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
					{
					}
					if (num6 >= 36)
					{
						num6 -= 36;
					}
					if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 128 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
					{
						flag = true;
					}
				}
			}
			if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 498);
			for (int m = 0; m <= 1; m++)
			{
				for (int n = 0; n <= 2; n++)
				{
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 128)
					{
						KillTile(num7, num8);
					}
				}
			}
			destroyObject = false;
		}

		public static void CheckWoman(int i, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j - Main.tile[i, j].frameY / 18;
			int num3;
			for (num3 = Main.tile[i, j].frameX; num3 >= 100; num3 -= 100)
			{
			}
			while (num3 >= 36)
			{
				num3 -= 36;
			}
			num -= num3 / 18;
			bool flag = false;
			for (int k = 0; k <= 1; k++)
			{
				for (int l = 0; l <= 2; l++)
				{
					int num4 = num + k;
					int num5 = num2 + l;
					int num6;
					for (num6 = Main.tile[num4, num5].frameX; num6 >= 100; num6 -= 100)
					{
					}
					if (num6 >= 36)
					{
						num6 -= 36;
					}
					if (!Main.tile[num4, num5].active() || Main.tile[num4, num5].type != 269 || Main.tile[num4, num5].frameY != l * 18 || num6 != k * 18)
					{
						flag = true;
					}
				}
			}
			if (!SolidTileAllowBottomSlope(num, num2 + 3) || !SolidTileAllowBottomSlope(num + 1, num2 + 3))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1989);
			for (int m = 0; m <= 1; m++)
			{
				for (int n = 0; n <= 2; n++)
				{
					int num7 = num + m;
					int num8 = num2 + n;
					if (Main.tile[num7, num8].active() && Main.tile[num7, num8].type == 269)
					{
						KillTile(num7, num8);
					}
				}
			}
			destroyObject = false;
		}

		public static void Place1x2(int x, int y, ushort type, int style)
		{
			short frameX = 0;
			if (type == 20)
			{
				frameX = (short)(genRand.Next(3) * 18);
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active())
			{
				short num = (short)(style * 40);
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = num;
				Main.tile[x, y - 1].frameX = frameX;
				Main.tile[x, y - 1].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num + 18);
				Main.tile[x, y].frameX = frameX;
				Main.tile[x, y].type = type;
			}
		}

		public static void Place1x2Top(int x, int y, ushort type, int style)
		{
			short frameX = 0;
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (Main.tile[x, y - 1].nactive() && Main.tileSolid[Main.tile[x, y - 1].type] && !Main.tileSolidTop[Main.tile[x, y - 1].type] && !Main.tile[x, y + 1].active())
			{
				short num = (short)(style * 36);
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = num;
				Main.tile[x, y].frameX = frameX;
				Main.tile[x, y].type = type;
				Main.tile[x, y + 1].active(active: true);
				Main.tile[x, y + 1].frameY = (short)(num + 18);
				Main.tile[x, y + 1].frameX = frameX;
				Main.tile[x, y + 1].type = type;
			}
		}

		public static void Check1x2Top(int x, int j, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = j;
			bool flag = true;
			int num2 = Main.tile[x, num].frameY / 18;
			int num3 = 0;
			while (num2 >= 2)
			{
				num2 -= 2;
				num3++;
			}
			num -= num2;
			num2 = num3 * 36;
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num + 1] == null)
			{
				Main.tile[x, num + 1] = new Tile();
			}
			if (Main.tile[x, num] == null)
			{
				Main.tile[x, num] = new Tile();
			}
			if (Main.tile[x, num].frameY == num2 && Main.tile[x, num + 1].frameY == num2 + 18 && Main.tile[x, num].type == type && Main.tile[x, num + 1].type == type)
			{
				flag = false;
			}
			if (Main.tile[x, num - 1] == null)
			{
				Main.tile[x, num - 1] = new Tile();
			}
			bool flag2 = false;
			switch (type)
			{
			case 42:
			case 270:
			case 271:
			case 572:
			case 581:
			case 660:
				flag2 = true;
				break;
			}
			bool flag3 = Main.tile[x, num - 1].active() && (TileID.Sets.Platforms[Main.tile[x, num - 1].type] || Main.tile[x, num - 1].type == 380);
			if ((!flag2 || !flag3) && (!Main.tile[x, num - 1].nactive() || !Main.tileSolid[Main.tile[x, num - 1].type] || Main.tileSolidTop[Main.tile[x, num - 1].type]))
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			if (Main.tile[x, num].type == type)
			{
				KillTile(x, num);
			}
			if (Main.tile[x, num + 1].type == type)
			{
				KillTile(x, num + 1);
			}
			switch (type)
			{
			case 42:
			{
				int type2 = 0;
				if (num3 == 0)
				{
					type2 = 136;
				}
				else if (num3 == 7)
				{
					type2 = 1431;
				}
				else if (num3 == 8)
				{
					type2 = 1808;
				}
				else if (num3 == 9)
				{
					type2 = 1859;
				}
				else if (num3 < 10)
				{
					type2 = 1389 + num3;
				}
				else
				{
					switch (num3)
					{
					case 10:
						type2 = 2032;
						break;
					case 11:
						type2 = 2033;
						break;
					case 12:
						type2 = 2034;
						break;
					case 13:
						type2 = 2035;
						break;
					case 14:
						type2 = 2036;
						break;
					case 15:
						type2 = 2037;
						break;
					case 16:
						type2 = 2038;
						break;
					case 17:
						type2 = 2039;
						break;
					case 18:
						type2 = 2040;
						break;
					case 19:
						type2 = 2041;
						break;
					case 20:
						type2 = 2042;
						break;
					case 21:
						type2 = 2043;
						break;
					case 22:
					case 23:
					case 24:
					case 25:
						type2 = 2145 + num3 - 22;
						break;
					default:
						switch (num3)
						{
						case 26:
							type2 = 2226;
							break;
						case 27:
							type2 = 2530;
							break;
						case 28:
							type2 = 2546;
							break;
						case 29:
							type2 = 2564;
							break;
						case 30:
							type2 = 2579;
							break;
						case 31:
							type2 = 2641;
							break;
						case 32:
							type2 = 2642;
							break;
						case 33:
							type2 = 2820;
							break;
						case 34:
							type2 = 3138;
							break;
						case 35:
							type2 = 3140;
							break;
						case 36:
							type2 = 3139;
							break;
						case 37:
							type2 = 3891;
							break;
						case 38:
							type2 = 3943;
							break;
						case 39:
							type2 = 3970;
							break;
						case 40:
							type2 = 4157;
							break;
						case 41:
							type2 = 4178;
							break;
						case 42:
							type2 = 4199;
							break;
						case 43:
							type2 = 4220;
							break;
						case 44:
							type2 = 4309;
							break;
						case 45:
							type2 = 4578;
							break;
						case 46:
							type2 = 5160;
							break;
						case 47:
							type2 = 5181;
							break;
						case 48:
							type2 = 5202;
							break;
						}
						break;
					}
				}
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, type2);
				break;
			}
			case 270:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 1993);
				break;
			case 271:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 2005);
				break;
			case 581:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 4848);
				break;
			case 660:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 5351);
				break;
			case 572:
				Item.NewItem(GetItemSource_FromTileBreak(x, num), x * 16, num * 16, 32, 32, 4695 + num3);
				break;
			}
			destroyObject = false;
		}

		public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185)
		{
			short frameY = (short)(Y * 18);
			short frameX = (short)(X * 18);
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			if (Main.tile[i + 1, j] == null)
			{
				Main.tile[i + 1, j] = new Tile();
			}
			if (Main.tile[i, j + 1] == null)
			{
				Main.tile[i, j + 1] = new Tile();
			}
			if (Main.tile[i + 1, j + 1] == null)
			{
				Main.tile[i + 1, j + 1] = new Tile();
			}
			if (Main.tile[i, j].lava())
			{
				return false;
			}
			if (Y == 1)
			{
				frameX = (short)(X * 36);
				bool flag = false;
				if (SolidTile2(i, j + 1) && SolidTile2(i + 1, j + 1) && !Main.tile[i, j].active() && !Main.tile[i + 1, j].active())
				{
					flag = true;
				}
				if (flag)
				{
					Main.tile[i, j].active(active: true);
					Main.tile[i, j].frameY = frameY;
					Main.tile[i, j].frameX = frameX;
					Main.tile[i, j].type = type;
					Main.tile[i + 1, j].active(active: true);
					Main.tile[i + 1, j].frameY = frameY;
					Main.tile[i + 1, j].frameX = (short)(frameX + 18);
					Main.tile[i + 1, j].type = type;
					return true;
				}
			}
			else if (SolidTile2(i, j + 1) && !Main.tile[i, j].active())
			{
				Main.tile[i, j].active(active: true);
				Main.tile[i, j].frameY = frameY;
				Main.tile[i, j].frameX = frameX;
				Main.tile[i, j].type = type;
				return true;
			}
			return false;
		}

		public static void CheckPile(int i, int y)
		{
			if (Main.tile[i, y] == null)
			{
				Main.tile[i, y] = new Tile();
			}
			if (Main.tile[i + 1, y] == null)
			{
				Main.tile[i + 1, y] = new Tile();
			}
			if (Main.tile[i, y + 1] == null)
			{
				Main.tile[i, y + 1] = new Tile();
			}
			if (Main.tile[i + 1, y + 1] == null)
			{
				Main.tile[i + 1, y + 1] = new Tile();
			}
			Tile tile = Main.tile[i, y];
			if (tile.frameY == 18 || tile.type == 649)
			{
				Check2x1(i, y, tile.type);
			}
			else if (!SolidTileAllowBottomSlope(i, y + 1))
			{
				KillTile(i, y);
			}
			else
			{
				if (tile.type != 185)
				{
					return;
				}
				int num = tile.frameX / 18;
				Tile tile2 = Main.tile[i, y + 1];
				if (tile2 == null || !tile2.active() || tile2.type < 0 || tile2.type >= 693)
				{
					return;
				}
				ushort type = tile2.type;
				switch (num)
				{
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 47:
					if (!TileID.Sets.Snow[type] && !TileID.Sets.Conversion.Ice[type] && type != 162 && type != 224)
					{
						KillTile(i, y);
					}
					break;
				case 54:
				case 55:
				case 56:
				case 57:
				case 58:
				case 59:
				case 73:
				case 74:
				case 75:
				case 76:
					if (!TileID.Sets.Conversion.Sand[type] && !TileID.Sets.Conversion.HardenedSand[type] && !TileID.Sets.Conversion.Sandstone[type])
					{
						KillTile(i, y);
					}
					break;
				case 48:
				case 49:
				case 50:
				case 51:
				case 52:
				case 53:
				case 60:
				case 61:
				case 62:
				case 63:
				case 64:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
					break;
				}
			}
		}

		public static void Check2x1(int i, int y, ushort type)
		{
			if (destroyObject)
			{
				return;
			}
			int num = i;
			bool flag = true;
			if (Main.tile[num, y] == null)
			{
				Main.tile[num, y] = new Tile();
			}
			int num2 = Main.tile[num, y].frameX / 18;
			int num3 = num2 >> 1;
			int num4 = Main.tile[num, y].frameY / 18;
			num2 %= 2;
			num -= num2;
			if (Main.tile[num, y] == null)
			{
				Main.tile[num, y] = new Tile();
			}
			if (Main.tile[num + 1, y] == null)
			{
				Main.tile[num + 1, y] = new Tile();
			}
			if (Main.tile[num, y + 1] == null)
			{
				Main.tile[num, y + 1] = new Tile();
			}
			if (Main.tile[num + 1, y + 1] == null)
			{
				Main.tile[num + 1, y + 1] = new Tile();
			}
			if (Main.tile[num + 1, y].frameX == Main.tile[num, y].frameX + 18 && Main.tile[num, y].type == type && Main.tile[num + 1, y].type == type)
			{
				flag = false;
			}
			if (type == 29 || type == 103 || type == 462)
			{
				if (!Main.tile[num, y + 1].active() || !Main.tileTable[Main.tile[num, y + 1].type] || Main.tile[num, y + 1].halfBrick() || Main.tile[num, y + 1].topSlope())
				{
					flag = true;
				}
				if (!Main.tile[num + 1, y + 1].active() || !Main.tileTable[Main.tile[num + 1, y + 1].type] || Main.tile[num + 1, y + 1].halfBrick() || Main.tile[num + 1, y + 1].topSlope())
				{
					flag = true;
				}
			}
			else
			{
				if (!SolidTileAllowBottomSlope(num, y + 1))
				{
					flag = true;
				}
				if (!SolidTileAllowBottomSlope(num + 1, y + 1))
				{
					flag = true;
				}
			}
			if (type == 185)
			{
				if (Main.tile[num, y].frameX >= 1368 && Main.tile[num, y].frameX <= 1458 && Main.tile[num, y + 1].type != 2 && Main.tile[num + 1, y + 1].type != 2 && Main.tile[num, y + 1].type != 477 && Main.tile[num + 1, y + 1].type != 477 && Main.tile[num, y + 1].type != 492 && Main.tile[num + 1, y + 1].type != 492)
				{
					Main.tile[num, y].frameX -= 1368;
					Main.tile[num + 1, y].frameX -= 1368;
				}
				Tile tile = Main.tile[num, y];
				int num5 = tile.frameX / 36;
				num5 += (tile.frameY / 18 - 1) * 52;
				for (int j = num; j < num + 2; j++)
				{
					Tile tile2 = Main.tile[j, y + 1];
					if (tile2 == null || !tile2.active() || tile2.type < 0 || tile2.type >= 693)
					{
						continue;
					}
					ushort type2 = tile2.type;
					switch (num5)
					{
					case 25:
					case 26:
					case 27:
					case 28:
					case 29:
					case 30:
						if (!TileID.Sets.Snow[type2] && !TileID.Sets.Conversion.Ice[type2] && type2 != 162 && type2 != 224)
						{
							flag = true;
						}
						break;
					case 41:
					case 42:
					case 43:
					case 44:
					case 45:
					case 46:
					case 62:
					case 63:
					case 64:
						if (!TileID.Sets.Conversion.Sand[type2] && !TileID.Sets.Conversion.HardenedSand[type2] && !TileID.Sets.Conversion.Sandstone[type2])
						{
							flag = true;
						}
						break;
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int frameX = Main.tile[num, y].frameX;
			if (!Main.tile[num, y].active())
			{
				frameX = Main.tile[num + 1, y].frameX;
			}
			destroyObject = true;
			if (Main.tile[num, y].type == type)
			{
				KillTile(num, y);
			}
			if (Main.tile[num + 1, y].type == type)
			{
				KillTile(num + 1, y);
			}
			if (type == 16)
			{
				if (num3 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 716);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 35);
				}
			}
			if (type == 18)
			{
				int type3 = 36;
				if (num3 >= 1 && num3 <= 3)
				{
					type3 = 634 + num3;
				}
				else if (num3 >= 4 && num3 <= 8)
				{
					type3 = 807 + num3;
				}
				else
				{
					switch (num3)
					{
					case 9:
						type3 = 916;
						break;
					case 10:
						type3 = 1145;
						break;
					case 11:
						type3 = 1398;
						break;
					case 12:
						type3 = 1401;
						break;
					case 13:
						type3 = 1404;
						break;
					case 14:
						type3 = 1461;
						break;
					case 15:
						type3 = 1511;
						break;
					case 16:
						type3 = 1795;
						break;
					case 17:
						type3 = 1817;
						break;
					case 18:
						type3 = 2229;
						break;
					case 19:
						type3 = 2251;
						break;
					case 20:
						type3 = 2252;
						break;
					case 21:
						type3 = 2253;
						break;
					case 22:
						type3 = 2534;
						break;
					case 23:
						type3 = 673;
						break;
					case 24:
						type3 = 2631;
						break;
					case 25:
						type3 = 2632;
						break;
					case 26:
						type3 = 2633;
						break;
					case 27:
						type3 = 2826;
						break;
					case 28:
						type3 = 3156;
						break;
					case 29:
						type3 = 3158;
						break;
					case 30:
						type3 = 3157;
						break;
					case 31:
						type3 = 3909;
						break;
					case 32:
						type3 = 3910;
						break;
					case 33:
						type3 = 3949;
						break;
					case 34:
						type3 = 3975;
						break;
					case 35:
						type3 = 4163;
						break;
					case 36:
						type3 = 4184;
						break;
					case 37:
						type3 = 4205;
						break;
					case 38:
						type3 = 4226;
						break;
					case 39:
						type3 = 4315;
						break;
					case 40:
						type3 = 4584;
						break;
					case 41:
						type3 = 5166;
						break;
					case 42:
						type3 = 5187;
						break;
					case 43:
						type3 = 5208;
						break;
					}
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, type3);
			}
			if (type == 185)
			{
				if (frameX >= 576 && frameX <= 610)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					if (genRand.Next(3) != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(3) != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(4) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(4) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(10, 100));
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 71, genRand.Next(20, 100));
					}
				}
				if (frameX >= 612 && frameX <= 646)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(10, 100));
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(20, 100));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 72, genRand.Next(30, 100));
					}
				}
				if (frameX >= 648 && frameX <= 682)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(1, 6));
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(2, 6));
					}
					if (genRand.Next(3) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 73, genRand.Next(3, 6));
					}
				}
				if (frameX >= 684 && frameX <= 718)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 181, genRand.Next(1, 4));
				}
				if (frameX >= 720 && frameX <= 754)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 180, genRand.Next(1, 4));
				}
				if (frameX >= 756 && frameX <= 790)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 177, genRand.Next(1, 4));
				}
				if (frameX >= 792 && frameX <= 826)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 179, genRand.Next(1, 4));
				}
				if (frameX >= 828 && frameX <= 862)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 178, genRand.Next(1, 4));
				}
				if (frameX >= 864 && frameX <= 898)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 182, genRand.Next(1, 4));
				}
			}
			if (type == 462)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 3795);
			}
			if (type == 29)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 87);
				SoundEngine.PlaySound(13, i * 16, y * 16);
			}
			switch (type)
			{
			case 103:
			{
				int type4 = 356;
				if (num3 == 1)
				{
					type4 = 2235;
				}
				if (num3 == 2)
				{
					type4 = 2242;
				}
				if (num3 == 3)
				{
					type4 = 2243;
				}
				Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, type4);
				SoundEngine.PlaySound(13, i * 16, y * 16);
				break;
			}
			case 134:
				if (num3 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 1220);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, 525);
				}
				break;
			case 649:
			{
				num3 += num4 * 53;
				int num6 = 0;
				if (num3 < 6)
				{
					num6 = 3;
				}
				else if (num3 < 16)
				{
					num6 = 154;
				}
				else if (num3 < 17)
				{
					num6 = 71;
				}
				else if (num3 < 18)
				{
					num6 = 72;
				}
				else if (num3 < 19)
				{
					num6 = 73;
				}
				else if (num3 < 20)
				{
					num6 = 181;
				}
				else if (num3 < 21)
				{
					num6 = 180;
				}
				else if (num3 < 22)
				{
					num6 = 177;
				}
				else if (num3 < 23)
				{
					num6 = 179;
				}
				else if (num3 < 24)
				{
					num6 = 178;
				}
				else if (num3 < 25)
				{
					num6 = 182;
				}
				else if (num3 < 31)
				{
					num6 = 593;
				}
				else if (num3 < 34)
				{
					num6 = 9;
				}
				else if (num3 < 38)
				{
					num6 = 150;
				}
				else if (num3 < 41)
				{
					num6 = 3;
				}
				else if (num3 < 47)
				{
					num6 = 3271;
				}
				else if (num3 < 53)
				{
					num6 = 3086;
				}
				else if (num3 < 59)
				{
					num6 = 3081;
				}
				else if (num3 < 62)
				{
					num6 = 62;
				}
				else if (num3 < 65)
				{
					num6 = 169;
				}
				if (num6 != 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(num, y), num * 16, y * 16, 32, 32, num6);
				}
				break;
			}
			}
			destroyObject = false;
			SquareTileFrame(num, y);
			SquareTileFrame(num + 1, y);
		}

		public static void Place2x1(int x, int y, ushort type, int style = 0)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x + 1, y] == null)
			{
				Main.tile[x + 1, y] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			if (Main.tile[x + 1, y + 1] == null)
			{
				Main.tile[x + 1, y + 1] = new Tile();
			}
			bool flag = false;
			if (type != 29 && type != 103 && SolidTile2(x, y + 1) && SolidTile2(x + 1, y + 1) && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
			{
				flag = true;
			}
			else if ((type == 29 || type == 103) && Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active() && Main.tileTable[Main.tile[x, y + 1].type] && Main.tileTable[Main.tile[x + 1, y + 1].type] && !Main.tile[x, y].active() && !Main.tile[x + 1, y].active())
			{
				flag = true;
			}
			if (flag)
			{
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(36 * style);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(36 * style + 18);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Check4x2(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			num = ((type != 487) ? (num + Main.tile[i, j].frameX / 18 * -1) : (num + Main.tile[i, j].frameX / 18 % 4 * -1));
			if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
			{
				num += 4;
			}
			int num2 = Main.tile[i, j].frameY / 18;
			int num3 = 0;
			while (num2 > 1)
			{
				num2 -= 2;
				num3++;
			}
			num2 = j - num2;
			if (type == 487)
			{
				num3 = Main.tile[i, j].frameX / 72;
			}
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					int num4 = (k - num) * 18;
					int num5 = (l - num2) * 18;
					if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= 72)
					{
						num4 = (k - num + 4) * 18;
					}
					if (type == 487)
					{
						num4 += num3 * 72;
					}
					else
					{
						num5 += num3 * 36;
					}
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num4 || Main.tile[k, l].frameY != num5)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 2] == null)
				{
					Main.tile[k, num2 + 2] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 2) && (!Main.tile[k, num2 + 2].active() || !TileID.Sets.Platforms[Main.tile[k, num2 + 2].type]))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 4; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 79)
			{
				int num6 = 0;
				switch (num3)
				{
				case 0:
					num6 = 224;
					break;
				case 4:
					num6 = 920;
					break;
				case 9:
				case 10:
				case 11:
				case 12:
					num6 = 1710 + num3;
					break;
				default:
					num6 = ((num3 >= 5 && num3 <= 8) ? (1465 + num3) : ((num3 >= 13 && num3 <= 18) ? (2066 + num3 - 13) : (num3 switch
					{
						19 => 2139, 
						20 => 2140, 
						21 => 2231, 
						22 => 2520, 
						23 => 2538, 
						24 => 2553, 
						25 => 2568, 
						26 => 2669, 
						27 => 2811, 
						28 => 3162, 
						29 => 3164, 
						30 => 3163, 
						31 => 3897, 
						32 => 3932, 
						33 => 3959, 
						34 => 4146, 
						35 => 4167, 
						36 => 4188, 
						37 => 4209, 
						38 => 4299, 
						39 => 4567, 
						40 => 5149, 
						41 => 5170, 
						42 => 5191, 
						_ => num3 + 643, 
					})));
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num6);
			}
			if (type == 487)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetItemDrop_PicnicTables(num3));
			}
			if (type == 90)
			{
				int type2 = 0;
				switch (num3)
				{
				case 0:
					type2 = 336;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					type2 = 2072 + num3 - 1;
					break;
				default:
					if (num3 >= 11 && num3 <= 15)
					{
						type2 = 2124 + num3 - 11;
						break;
					}
					switch (num3)
					{
					case 16:
						type2 = 2232;
						break;
					case 17:
						type2 = 2519;
						break;
					case 18:
						type2 = 2537;
						break;
					case 19:
						type2 = 2552;
						break;
					case 20:
						type2 = 2567;
						break;
					case 21:
						type2 = 2658;
						break;
					case 22:
						type2 = 2659;
						break;
					case 23:
						type2 = 2660;
						break;
					case 24:
						type2 = 2661;
						break;
					case 25:
						type2 = 2662;
						break;
					case 26:
						type2 = 2663;
						break;
					case 27:
						type2 = 2810;
						break;
					case 28:
						type2 = 3159;
						break;
					case 29:
						type2 = 3161;
						break;
					case 30:
						type2 = 3160;
						break;
					case 31:
						type2 = 3895;
						break;
					case 32:
						type2 = 3931;
						break;
					case 33:
						type2 = 3958;
						break;
					case 34:
						type2 = 4145;
						break;
					case 35:
						type2 = 4166;
						break;
					case 36:
						type2 = 4187;
						break;
					case 37:
						type2 = 4208;
						break;
					case 38:
						type2 = 4298;
						break;
					case 39:
						type2 = 4566;
						break;
					case 40:
						type2 = 5148;
						break;
					case 41:
						type2 = 5169;
						break;
					case 42:
						type2 = 5190;
						break;
					}
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
			for (int num7 = num - 1; num7 < num + 4; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}

		private static bool OasisPlantWaterCheck(int x, int y, bool boost = false)
		{
			int num = 45;
			int num2 = 20;
			if (boost)
			{
				num += 4;
				num2 += 3;
			}
			int num3 = 20;
			int num4 = 0;
			for (int i = x - num; i <= x + num; i++)
			{
				if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
				{
					continue;
				}
				for (int j = y - num2; j <= y + num2; j++)
				{
					if (InWorld(i, j) && !SolidTile(i, j))
					{
						num4 += Main.tile[i, j].liquid;
					}
				}
			}
			if (num4 / 255 >= num3)
			{
				return true;
			}
			return false;
		}

		public static void PlaceOasisPlant(int X, int Y, ushort type = 530)
		{
			int num = genRand.Next(9);
			int num2 = 0;
			if (X < beachDistance || X > Main.maxTilesX - beachDistance || Y < 5 || Y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = X - 1; i < X + 2; i++)
			{
				for (int j = Y - 1; j < Y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type != 529)
					{
						flag = false;
					}
					if (Main.tile[i, j].liquid > 0)
					{
						flag = false;
					}
				}
				if (Main.tile[i, Y + 1] == null)
				{
					Main.tile[i, Y + 1] = new Tile();
				}
				if (!SolidTile(i, Y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[i, Y + 1].type])
				{
					flag = false;
				}
			}
			if (flag && OasisPlantWaterCheck(X, Y))
			{
				short num3 = (short)(54 * num);
				short num4 = (short)(36 * num2);
				Main.tile[X - 1, Y - 1].active(active: true);
				Main.tile[X - 1, Y - 1].frameY = num4;
				Main.tile[X - 1, Y - 1].frameX = num3;
				Main.tile[X - 1, Y - 1].type = type;
				Main.tile[X, Y - 1].active(active: true);
				Main.tile[X, Y - 1].frameY = num4;
				Main.tile[X, Y - 1].frameX = (short)(num3 + 18);
				Main.tile[X, Y - 1].type = type;
				Main.tile[X + 1, Y - 1].active(active: true);
				Main.tile[X + 1, Y - 1].frameY = num4;
				Main.tile[X + 1, Y - 1].frameX = (short)(num3 + 36);
				Main.tile[X + 1, Y - 1].type = type;
				Main.tile[X - 1, Y].active(active: true);
				Main.tile[X - 1, Y].frameY = (short)(num4 + 18);
				Main.tile[X - 1, Y].frameX = num3;
				Main.tile[X - 1, Y].type = type;
				Main.tile[X, Y].active(active: true);
				Main.tile[X, Y].frameY = (short)(num4 + 18);
				Main.tile[X, Y].frameX = (short)(num3 + 18);
				Main.tile[X, Y].type = type;
				Main.tile[X + 1, Y].active(active: true);
				Main.tile[X + 1, Y].frameY = (short)(num4 + 18);
				Main.tile[X + 1, Y].frameX = (short)(num3 + 36);
				Main.tile[X + 1, Y].type = type;
			}
		}

		public static void CheckOasisPlant(int i, int j, int type = 530)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = j;
			Tile tileSafely = Framing.GetTileSafely(i, j);
			int num2 = tileSafely.frameY % 36;
			num += num2 / 18 * -1;
			int num3 = tileSafely.frameX / 18;
			int num4 = 0;
			_ = Framing.GetTileSafely(num3, num).frameY / 36;
			while (num3 > 2)
			{
				num3 -= 3;
				num4++;
			}
			num3 = i - num3;
			int num5 = num4 * 54;
			for (int k = num3; k < num3 + 3; k++)
			{
				for (int l = num; l < num + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5 || Main.tile[k, l].frameY != (l - num) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num + 2] == null)
				{
					Main.tile[k, num + 2] = new Tile();
				}
				if (!SolidTile(k, num + 2) || !TileID.Sets.Conversion.Sand[Main.tile[k, num + 2].type])
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int m = num3; m < num3 + 3; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = new Tile();
					}
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			destroyObject = false;
			for (int num6 = num3 - 1; num6 < num3 + 4; num6++)
			{
				for (int num7 = num - 1; num7 < num + 3; num7++)
				{
					TileFrame(num6, num7);
				}
			}
		}

		public static void GetCactusType(int tileX, int tileY, int frameX, int frameY, out bool evil, out bool good, out bool crimson)
		{
			evil = false;
			good = false;
			crimson = false;
			int num = tileX;
			if (frameX == 36)
			{
				num--;
			}
			if (frameX == 54)
			{
				num++;
			}
			if (frameX == 108)
			{
				num = ((frameY != 18) ? (num + 1) : (num - 1));
			}
			int num2 = tileY;
			bool flag = false;
			Tile tile = Main.tile[num, num2];
			if (tile == null)
			{
				return;
			}
			if (tile.type == 80 && tile.active())
			{
				flag = true;
			}
			while (tile != null && (!tile.active() || !Main.tileSolid[tile.type] || !flag))
			{
				if (tile.type == 80 && tile.active())
				{
					flag = true;
				}
				num2++;
				if (num2 > tileY + 20)
				{
					break;
				}
				tile = Main.tile[num, num2];
			}
			if (tile.type == 112)
			{
				evil = true;
			}
			if (tile.type == 116)
			{
				good = true;
			}
			if (tile.type == 234)
			{
				crimson = true;
			}
		}

		public static void GetBiomeInfluence(int startX, int endX, int startY, int endY, out int corruptCount, out int crimsonCount, out int hallowedCount)
		{
			corruptCount = 0;
			crimsonCount = 0;
			hallowedCount = 0;
			for (int i = startX; i <= endX; i++)
			{
				for (int j = startY; j <= endY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile != null)
					{
						if (TileID.Sets.Corrupt[tile.type])
						{
							corruptCount++;
						}
						if (TileID.Sets.Crimson[tile.type])
						{
							crimsonCount++;
						}
						if (TileID.Sets.Hallow[tile.type])
						{
							hallowedCount++;
						}
					}
				}
			}
		}

		public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY)
		{
			if (styleY > 0 || type == 236 || type == 238)
			{
				int num = Y2;
				if (type == 95 || type == 126)
				{
					num++;
				}
				if (X2 < 5 || X2 > Main.maxTilesX - 5 || num < 5 || num > Main.maxTilesY - 5)
				{
					return;
				}
				bool flag = true;
				for (int i = X2 - 1; i < X2 + 1; i++)
				{
					for (int j = num - 1; j < num + 1; j++)
					{
						if (Main.tile[i, j] == null)
						{
							Main.tile[i, j] = new Tile();
						}
						Tile tile = Main.tile[i, j];
						if (tile.active() && tile.type != 61 && tile.type != 62 && tile.type != 655 && tile.type != 69 && tile.type != 74 && (type != 236 || tile.type != 233) && (type != 238 || tile.type != 233) && (tile.type != 185 || tile.frameY != 0))
						{
							flag = false;
						}
						if (type == 98 && tile.liquid > 0)
						{
							flag = false;
						}
					}
					if (Main.tile[i, num + 1] == null)
					{
						Main.tile[i, num + 1] = new Tile();
					}
					if (!SolidTile(i, num + 1) || Main.tile[i, num + 1].type != 60)
					{
						flag = false;
					}
				}
				if (!flag)
				{
					return;
				}
				for (int k = X2 - 1; k < X2 + 1; k++)
				{
					for (int l = num - 1; l < num + 1; l++)
					{
						if (Main.tile[k, l] != null && Main.tile[k, l].active())
						{
							KillTile(k, l, fail: false, effectOnly: false, noItem: true);
						}
					}
				}
				short num2 = 36;
				if (type == 236 || type == 238)
				{
					num2 = 0;
				}
				short num3 = (short)(36 * styleX);
				Main.tile[X2 - 1, num - 1].active(active: true);
				Main.tile[X2 - 1, num - 1].frameY = num2;
				Main.tile[X2 - 1, num - 1].frameX = num3;
				Main.tile[X2 - 1, num - 1].type = type;
				Main.tile[X2, num - 1].active(active: true);
				Main.tile[X2, num - 1].frameY = num2;
				Main.tile[X2, num - 1].frameX = (short)(18 + num3);
				Main.tile[X2, num - 1].type = type;
				Main.tile[X2 - 1, num].active(active: true);
				Main.tile[X2 - 1, num].frameY = (short)(num2 + 18);
				Main.tile[X2 - 1, num].frameX = num3;
				Main.tile[X2 - 1, num].type = type;
				Main.tile[X2, num].active(active: true);
				Main.tile[X2, num].frameY = (short)(num2 + 18);
				Main.tile[X2, num].frameX = (short)(18 + num3);
				Main.tile[X2, num].type = type;
			}
			else
			{
				if (X2 < 5 || X2 > Main.maxTilesX - 5 || Y2 < 5 || Y2 > Main.maxTilesY - 5)
				{
					return;
				}
				bool flag2 = true;
				for (int m = X2 - 1; m < X2 + 2; m++)
				{
					for (int n = Y2 - 1; n < Y2 + 1; n++)
					{
						if (Main.tile[m, n] == null)
						{
							Main.tile[m, n] = new Tile();
						}
						if (Main.tile[m, n].active() && Main.tile[m, n].type != 61 && Main.tile[m, n].type != 62 && Main.tile[m, n].type != 69 && Main.tile[m, n].type != 655 && Main.tile[m, n].type != 74 && (Main.tile[m, n].type != 185 || Main.tile[m, n].frameY != 0))
						{
							flag2 = false;
						}
					}
					if (Main.tile[m, Y2 + 1] == null)
					{
						Main.tile[m, Y2 + 1] = new Tile();
					}
					if (!SolidTile(m, Y2 + 1) || Main.tile[m, Y2 + 1].type != 60)
					{
						flag2 = false;
					}
				}
				if (!flag2)
				{
					return;
				}
				for (int num4 = X2 - 1; num4 < X2 + 2; num4++)
				{
					for (int num5 = Y2 - 1; num5 < Y2 + 1; num5++)
					{
						if (Main.tile[num4, num5] != null && Main.tile[num4, num5].active())
						{
							KillTile(num4, num5, fail: false, effectOnly: false, noItem: true);
						}
					}
				}
				short num6 = (short)(54 * styleX);
				Main.tile[X2 - 1, Y2 - 1].active(active: true);
				Main.tile[X2 - 1, Y2 - 1].frameY = 0;
				Main.tile[X2 - 1, Y2 - 1].frameX = num6;
				Main.tile[X2 - 1, Y2 - 1].type = type;
				Main.tile[X2, Y2 - 1].active(active: true);
				Main.tile[X2, Y2 - 1].frameY = 0;
				Main.tile[X2, Y2 - 1].frameX = (short)(num6 + 18);
				Main.tile[X2, Y2 - 1].type = type;
				Main.tile[X2 + 1, Y2 - 1].active(active: true);
				Main.tile[X2 + 1, Y2 - 1].frameY = 0;
				Main.tile[X2 + 1, Y2 - 1].frameX = (short)(num6 + 36);
				Main.tile[X2 + 1, Y2 - 1].type = type;
				Main.tile[X2 - 1, Y2].active(active: true);
				Main.tile[X2 - 1, Y2].frameY = 18;
				Main.tile[X2 - 1, Y2].frameX = num6;
				Main.tile[X2 - 1, Y2].type = type;
				Main.tile[X2, Y2].active(active: true);
				Main.tile[X2, Y2].frameY = 18;
				Main.tile[X2, Y2].frameX = (short)(num6 + 18);
				Main.tile[X2, Y2].type = type;
				Main.tile[X2 + 1, Y2].active(active: true);
				Main.tile[X2 + 1, Y2].frameY = 18;
				Main.tile[X2 + 1, Y2].frameX = (short)(num6 + 36);
				Main.tile[X2 + 1, Y2].type = type;
			}
		}

		public static void CheckJunglePlant(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			if (Main.tile[i, j].frameY >= 36 || Main.tile[i, j].type == 236 || Main.tile[i, j].type == 238)
			{
				bool flag = false;
				int num = Main.tile[i, j].frameX / 18;
				int num2 = 0;
				while (num > 1)
				{
					num -= 2;
					num2++;
				}
				num = i - num;
				int num3 = 36;
				if (type == 236 || type == 238)
				{
					num3 = 0;
				}
				int num4;
				for (num4 = Main.tile[i, j].frameY / 18; num4 > 1; num4 -= 2)
				{
				}
				num4 = j - num4;
				int num5 = num2 * 36;
				for (int k = num; k < num + 2; k++)
				{
					for (int l = num4; l < num4 + 2; l++)
					{
						if (Main.tile[k, l] == null)
						{
							Main.tile[k, l] = new Tile();
						}
						if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num5 || Main.tile[k, l].frameY != (l - num4) * 18 + num3)
						{
							flag = true;
						}
					}
					if (Main.tile[k, num4 + 2] == null)
					{
						Main.tile[k, num4 + 2] = new Tile();
					}
					if (!SolidTile(k, num4 + 2) || Main.tile[k, num4 + 2].type != 60)
					{
						flag = true;
					}
				}
				if (!flag)
				{
					return;
				}
				if (type == 238)
				{
					float num6 = i * 16;
					float num7 = j * 16;
					float num8 = -1f;
					int plr = 0;
					for (int m = 0; m < 255; m++)
					{
						float num9 = Math.Abs(Main.player[m].position.X - num6) + Math.Abs(Main.player[m].position.Y - num7);
						if (num9 < num8 || num8 == -1f)
						{
							plr = m;
							num8 = num9;
						}
					}
					if (num8 / 16f < 50f)
					{
						NPC.SpawnOnPlayer(plr, 262);
					}
				}
				if (type == 236)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1291);
				}
				_ = Main.tile[i, j].frameX;
				destroyObject = true;
				for (int n = num; n < num + 2; n++)
				{
					for (int num10 = num4; num10 < num4 + 2; num10++)
					{
						if (Main.tile[n, num10] == null)
						{
							Main.tile[n, num10] = new Tile();
						}
						if (Main.tile[n, num10].type == type && Main.tile[n, num10].active())
						{
							KillTile(n, num10);
						}
					}
				}
				destroyObject = false;
				return;
			}
			bool flag2 = false;
			int num11 = j;
			num11 += Main.tile[i, j].frameY / 18 * -1;
			int num12 = Main.tile[i, j].frameX / 18;
			int num13 = 0;
			while (num12 > 2)
			{
				num12 -= 3;
				num13++;
			}
			num12 = i - num12;
			int num14 = num13 * 54;
			for (int num15 = num12; num15 < num12 + 3; num15++)
			{
				for (int num16 = num11; num16 < num11 + 2; num16++)
				{
					if (Main.tile[num15, num16] == null)
					{
						Main.tile[num15, num16] = new Tile();
					}
					if (!Main.tile[num15, num16].active() || Main.tile[num15, num16].type != type || Main.tile[num15, num16].frameX != (num15 - num12) * 18 + num14 || Main.tile[num15, num16].frameY != (num16 - num11) * 18)
					{
						flag2 = true;
					}
				}
				if (Main.tile[num15, num11 + 2] == null)
				{
					Main.tile[num15, num11 + 2] = new Tile();
				}
				if (!SolidTile(num15, num11 + 2) || Main.tile[num15, num11 + 2].type != 60)
				{
					flag2 = true;
				}
			}
			if (!flag2)
			{
				return;
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int num17 = num12; num17 < num12 + 3; num17++)
			{
				for (int num18 = num11; num18 < num11 + 3; num18++)
				{
					if (Main.tile[num17, num18] == null)
					{
						Main.tile[num17, num18] = new Tile();
					}
					if (Main.tile[num17, num18].type == type && Main.tile[num17, num18].active())
					{
						KillTile(num17, num18);
					}
				}
			}
			destroyObject = false;
		}

		public static void CheckSuper(int x, int y, int type)
		{
			if (destroyObject)
			{
				return;
			}
			Tile tile = Main.tile[x, y];
			int num = 0;
			if (type == 376)
			{
				num = tile.frameX / 36;
			}
			if (type == 443)
			{
				num = tile.frameX / 36;
			}
			if (type == 485)
			{
				num = tile.frameX / 36;
			}
			bool flag = type == 376;
			bool flag2 = type == 443;
			bool flag3 = type == 444;
			bool flag4 = type == 485;
			TileObjectData tileData = TileObjectData.GetTileData(type, num);
			bool styleHorizontal = tileData.StyleHorizontal;
			int width = tileData.Width;
			int height = tileData.Height;
			int num2 = x;
			int num3 = y;
			num2 -= tile.frameX / 18 % width;
			num3 -= tile.frameY / 18 % height;
			int num4 = 0;
			int num5 = 0;
			if (styleHorizontal)
			{
				num4 = tile.frameX / tileData.CoordinateFullWidth;
			}
			else
			{
				num5 = tile.frameY / tileData.CoordinateFullHeight;
			}
			bool flag5 = false;
			bool flag6 = false;
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					Tile tileSafely = Framing.GetTileSafely(num2 + i, num3 + j);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != num4 * tileData.CoordinateFullWidth + i * (tileData.CoordinateWidth + 2) || tileSafely.frameY != num5 * tileData.CoordinateFullHeight + j * (tileData.CoordinateHeights[0] + 2))
					{
						flag5 = true;
					}
				}
			}
			if (flag)
			{
				for (int k = 0; k < width; k++)
				{
					Tile tileSafely = Framing.GetTileSafely(num2 + k, num3 + height);
					if (!tileSafely.active() || (!Main.tileSolid[tileSafely.type] && !Main.tileTable[tileSafely.type]))
					{
						flag5 = true;
					}
					if (tileSafely.halfBrick())
					{
						flag5 = true;
					}
				}
			}
			if (flag2)
			{
				bool flag7 = true;
				bool flag8 = true;
				for (int l = 0; l < width; l++)
				{
					if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
					{
						flag8 = false;
					}
					if (!AnchorValid(Framing.GetTileSafely(num2 + l, num3 - 1), AnchorType.SolidBottom))
					{
						flag7 = false;
					}
				}
				if (!flag7 && !flag8)
				{
					flag5 = true;
				}
				if (!flag5)
				{
					int num6 = 0;
					if (flag8)
					{
						for (int m = 0; m < width; m++)
						{
							Framing.GetTileSafely(num2 + m, num3).frameX = (short)(m * 18 + num / 2 * 36 + num6 * 36);
						}
					}
					else
					{
						for (int n = 0; n < width; n++)
						{
							Framing.GetTileSafely(num2 + n, num3).frameX = (short)(n * 18 + (num - 2) / 2 * 36 + 72 + num6 * 36);
						}
					}
				}
			}
			if (flag3)
			{
				bool flag9 = true;
				for (int num7 = 0; num7 < width; num7++)
				{
					if (!AnchorValid(Framing.GetTileSafely(num2 + num7, num3 - 1), AnchorType.SolidTile))
					{
						flag9 = false;
					}
				}
				if (!flag9)
				{
					flag5 = true;
				}
				for (int num8 = 0; num8 < width; num8++)
				{
					for (int num9 = 0; num9 < height; num9++)
					{
						Tile tileSafely = Framing.GetTileSafely(num2 + num8, num3 + num9);
						if (tileSafely.liquid > 0)
						{
							flag5 = true;
							flag6 = true;
						}
					}
				}
			}
			if (flag4)
			{
				bool flag10 = true;
				for (int num10 = 0; num10 < width; num10++)
				{
					if (!AnchorValid(Framing.GetTileSafely(num2 + num10, num3 + height), AnchorType.SolidTile))
					{
						flag10 = false;
					}
				}
				if (!flag10)
				{
					flag5 = true;
				}
			}
			if (!flag5)
			{
				return;
			}
			destroyObject = true;
			for (int num11 = 0; num11 < width; num11++)
			{
				for (int num12 = 0; num12 < height; num12++)
				{
					if (Main.tile[num2 + num11, num3 + num12].type == type && Main.tile[num2 + num11, num3 + num12].active())
					{
						KillTile(num2 + num11, num3 + num12);
					}
				}
			}
			int num13 = 0;
			if (type == 376)
			{
				switch (num)
				{
				case 0:
					num13 = 2334;
					break;
				case 1:
					num13 = 2335;
					break;
				case 2:
					num13 = 2336;
					break;
				case 3:
					num13 = 3203;
					break;
				case 4:
					num13 = 3204;
					break;
				case 5:
					num13 = 3205;
					break;
				case 6:
					num13 = 3206;
					break;
				case 7:
					num13 = 3207;
					break;
				case 8:
					num13 = 3208;
					break;
				case 9:
					num13 = 3979;
					break;
				case 10:
					num13 = 3980;
					break;
				case 11:
					num13 = 3981;
					break;
				case 12:
					num13 = 3982;
					break;
				case 13:
					num13 = 3983;
					break;
				case 14:
					num13 = 3984;
					break;
				case 15:
					num13 = 3985;
					break;
				case 16:
					num13 = 3986;
					break;
				case 17:
					num13 = 3987;
					break;
				case 18:
					num13 = 4405;
					break;
				case 19:
					num13 = 4406;
					break;
				case 20:
					num13 = 4407;
					break;
				case 21:
					num13 = 4408;
					break;
				case 22:
					num13 = 4877;
					break;
				case 23:
					num13 = 4878;
					break;
				case 24:
					num13 = 5002;
					break;
				case 25:
					num13 = 5003;
					break;
				}
			}
			if (type == 443)
			{
				num13 = 3722;
			}
			if (type == 485 && !gen && Main.netMode != 1)
			{
				int availableAmountOfNPCsToSpawnUpToSlot = NPC.GetAvailableAmountOfNPCsToSpawnUpToSlot(1);
				for (int num14 = 0; num14 < availableAmountOfNPCsToSpawnUpToSlot; num14++)
				{
					int num15 = NPC.NewNPC(GetNPCSource_TileBreak(num2, num3), num2 * 16, num3 * 16 + 32, 582);
					Main.npc[num15].TargetClosest();
					Main.npc[num15].velocity = new Vector2((float)Main.npc[num15].direction * 1.5f, -5f);
					NetMessage.SendData(23, -1, -1, null, num15);
					int num16 = 20;
					int num17 = -1;
					Main.npc[num15].GetImmuneTime(num17, num16);
					NetMessage.SendData(131, -1, -1, null, num15, 1f, num17, num16);
				}
			}
			if (type == 444 && Main.netMode != 1 && !flag6)
			{
				Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num3), num2 * 16 + 16, num3 * 16 + 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
			}
			if (num13 != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(num2, num3), num2 * 16, num3 * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, num13);
			}
			destroyObject = false;
			for (int num18 = -1; num18 < width + 1; num18++)
			{
				for (int num19 = -1; num19 < height + 1; num19++)
				{
					TileFrame(num2 + num18, num3 + num19);
				}
			}
		}

		public static void Check2x2(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = Main.tile[i, j].frameX / 18 * -1;
			if (num2 < -1)
			{
				num2 += 2;
				num = 36;
			}
			num2 += i;
			int num3 = ((type == 172) ? 38 : 36);
			int num4 = Main.tile[i, j].frameY;
			int num5 = 0;
			while (num4 >= num3)
			{
				num4 -= num3;
				num5++;
			}
			int num6 = j - num4 / 18;
			int num7 = 0;
			if (type == 652)
			{
				num7 = Main.tile[i, j].frameX / 36;
				num2 = Main.tile[i, j].frameX % 36 / 18 * -1 + i;
				num = num7 * 36;
			}
			for (int k = num2; k < num2 + 2; k++)
			{
				for (int l = num6; l < num6 + 2; l++)
				{
					Tile tileSafely = Framing.GetTileSafely(k, l);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != (k - num2) * 18 + num || tileSafely.frameY != (l - num6) * 18 + num5 * num3)
					{
						flag = true;
						break;
					}
				}
				if (type == 95 || type == 126)
				{
					Framing.GetTileSafely(k, num6 - 1);
					if (!Main.tile[k, num6 - 1].active() || !Main.tileSolid[Main.tile[k, num6 - 1].type] || Main.tileSolidTop[Main.tile[k, num6 - 1].type])
					{
						flag = true;
					}
				}
				else if (!TileID.Sets.Boulders[type] && type != 132)
				{
					Tile tileSafely2 = Framing.GetTileSafely(k, num6 + 2);
					if (!tileSafely2.active() || (!Main.tileSolid[tileSafely2.type] && !Main.tileTable[tileSafely2.type]))
					{
						flag = true;
					}
					if (tileSafely2.halfBrick())
					{
						flag = true;
					}
				}
			}
			if (TileID.Sets.Boulders[type])
			{
				if (Main.tile[num2, num6 - 1] == null)
				{
					Main.tile[num2, num6 - 1] = new Tile();
				}
				if (Main.tile[num2 + 1, num6 - 1] == null)
				{
					Main.tile[num2 + 1, num6 - 1] = new Tile();
				}
				ushort type2 = Main.tile[num2, num6 - 1].type;
				ushort type3 = Main.tile[num2 + 1, num6 - 1].type;
				if (!TileID.Sets.BasicChest[type2] && !TileID.Sets.BasicChest[type3] && type2 != 88 && type3 != 88 && !TileID.Sets.BasicChestFake[type2] && !TileID.Sets.BasicChestFake[type3] && type2 != 470 && type3 != 470 && type2 != 475 && type3 != 475 && !SolidTileAllowBottomSlope(num2, num6 + 2) && !SolidTileAllowBottomSlope(num2 + 1, num6 + 2))
				{
					flag = true;
				}
			}
			else if (type == 132)
			{
				flag = false;
				num6 = Main.tile[i, j].frameY / 18 * -1;
				num6 += j;
				num = 0;
				num2 = Main.tile[i, j].frameX / 18 * -1;
				while (num2 < -1)
				{
					num2 += 2;
					num += 36;
				}
				num2 += i;
				for (int m = num2; m < num2 + 2; m++)
				{
					for (int n = num6; n < num6 + 2; n++)
					{
						if (Main.tile[m, n] == null)
						{
							Main.tile[m, n] = new Tile();
						}
						if (!Main.tile[m, n].active() || Main.tile[m, n].type != type || Main.tile[m, n].frameX != (m - num2) * 18 + num || Main.tile[m, n].frameY != (n - num6) * 18)
						{
							flag = true;
						}
					}
				}
				if (Main.tile[num2, num6 + 2] == null)
				{
					Main.tile[num2, num6 + 2] = new Tile();
				}
				if (Main.tile[num2 + 1, num6 + 2] == null)
				{
					Main.tile[num2 + 1, num6 + 2] = new Tile();
				}
				bool flag2 = false;
				ushort type4 = Main.tile[num2, num6 + 2].type;
				ushort type5 = Main.tile[num2 + 1, num6 + 2].type;
				if (!Main.tile[num2, num6 + 2].active() || (!Main.tileSolid[type4] && !Main.tileSolidTop[type4]) || Main.tile[num2, num6 + 2].halfBrick() || (Main.tile[num2, num6 + 2].slope() != 0 && !Main.tile[num2, num6 + 2].bottomSlope()))
				{
					flag2 = true;
				}
				if (!Main.tile[num2 + 1, num6 + 2].active() || (!Main.tileSolid[type5] && !Main.tileSolidTop[type5]) || Main.tile[num2 + 1, num6 + 2].halfBrick() || (Main.tile[num2 + 1, num6 + 2].slope() != 0 && !Main.tile[num2 + 1, num6 + 2].bottomSlope()))
				{
					flag2 = true;
				}
				if (flag2)
				{
					if (Main.tile[num2, num6].wall < 1 || Main.tile[num2 + 1, num6].wall < 1 || Main.tile[num2, num6 + 1].wall < 1 || Main.tile[num2 + 1, num6 + 1].wall < 1)
					{
						flag = true;
					}
					else if (num < 72)
					{
						for (int num8 = num2; num8 < num2 + 2; num8++)
						{
							for (int num9 = num6; num9 < num6 + 2; num9++)
							{
								Main.tile[num8, num9].frameX += 72;
							}
						}
					}
				}
				else if (num >= 72)
				{
					for (int num10 = num2; num10 < num2 + 2; num10++)
					{
						for (int num11 = num6; num11 < num6 + 2; num11++)
						{
							Main.tile[num10, num11].frameX -= 72;
						}
					}
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int num12 = num2; num12 < num2 + 2; num12++)
			{
				for (int num13 = num6; num13 < num6 + 2; num13++)
				{
					if (Main.tile[num12, num13].type == type && Main.tile[num12, num13].active())
					{
						KillTile(num12, num13);
					}
				}
			}
			int num14 = 0;
			switch (type)
			{
			case 521:
				num14 = 4327;
				break;
			case 522:
				num14 = 4328;
				break;
			case 523:
				num14 = 4329;
				break;
			case 524:
				num14 = 4330;
				break;
			case 525:
				num14 = 4331;
				break;
			case 526:
				num14 = 4332;
				break;
			case 527:
				num14 = 4333;
				break;
			case 564:
				num14 = 4553;
				break;
			case 565:
				num14 = 4552;
				break;
			case 594:
				num14 = 4869;
				break;
			case 621:
				num14 = 3750;
				break;
			case 622:
				num14 = 5008;
				break;
			}
			if (type == 598)
			{
				num14 = 4880;
			}
			if (type == 360)
			{
				num14 = 3072;
			}
			if (type == 580)
			{
				num14 = 4846;
			}
			if (type == 620)
			{
				num14 = 4964;
			}
			if (type == 505)
			{
				num14 = 4275;
			}
			if (type == 543)
			{
				num14 = 4398;
			}
			if (type == 568)
			{
				num14 = 4655;
			}
			if (type == 569)
			{
				num14 = 4656;
			}
			if (type == 570)
			{
				num14 = 4657;
			}
			if (type >= 288 && type <= 295)
			{
				num14 = 2178 + type - 288;
			}
			if (type >= 316 && type <= 318)
			{
				num14 = 2439 + type - 316;
			}
			if (type == 85)
			{
				num14 = 321;
			}
			if (type == 94)
			{
				num14 = 352;
			}
			if (type == 95)
			{
				num14 = 344;
			}
			if (type == 96)
			{
				num14 = 345;
			}
			if (type == 97)
			{
				num14 = 346;
			}
			if (type == 98)
			{
				num14 = 347;
			}
			if (type == 99)
			{
				num14 = 348;
			}
			if (type == 335)
			{
				num14 = 2700;
			}
			if (type == 411)
			{
				num14 = 3545;
			}
			if (type == 652)
			{
				num14 = ((num7 < 3) ? 195 : ((num7 >= 6) ? 331 : 62));
			}
			if (type == 100)
			{
				switch (num5)
				{
				case 0:
					num14 = 349;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
					num14 = 2092 + num5 - 1;
					break;
				default:
					if (num5 >= 13 && num5 <= 16)
					{
						num14 = 2149 + num5 - 13;
						break;
					}
					switch (num5)
					{
					case 17:
						num14 = 2227;
						break;
					case 18:
						num14 = 2522;
						break;
					case 19:
						num14 = 2541;
						break;
					case 20:
						num14 = 2555;
						break;
					case 21:
						num14 = 2570;
						break;
					case 22:
						num14 = 2664;
						break;
					case 23:
						num14 = 2665;
						break;
					case 24:
						num14 = 2666;
						break;
					case 25:
						num14 = 2667;
						break;
					case 26:
						num14 = 2668;
						break;
					case 27:
						num14 = 2825;
						break;
					case 28:
						num14 = 3168;
						break;
					case 29:
						num14 = 3170;
						break;
					case 30:
						num14 = 3169;
						break;
					case 31:
						num14 = 3893;
						break;
					case 32:
						num14 = 3935;
						break;
					case 33:
						num14 = 3961;
						break;
					case 34:
						num14 = 4149;
						break;
					case 35:
						num14 = 4170;
						break;
					case 36:
						num14 = 4191;
						break;
					case 37:
						num14 = 4212;
						break;
					case 38:
						num14 = 4302;
						break;
					case 39:
						num14 = 4570;
						break;
					case 40:
						num14 = 5152;
						break;
					case 41:
						num14 = 5173;
						break;
					case 42:
						num14 = 5194;
						break;
					}
					break;
				}
			}
			if (type == 173)
			{
				num14 = 714;
			}
			if (type == 125)
			{
				num14 = 487;
			}
			if (type == 287)
			{
				num14 = 2177;
			}
			if (type == 126)
			{
				num14 = 488;
			}
			if (type == 132)
			{
				num14 = 513;
			}
			if (type == 142)
			{
				num14 = 581;
			}
			if (type == 143)
			{
				num14 = 582;
			}
			if (type == 282)
			{
				num14 = 250;
			}
			if (type == 319)
			{
				num14 = 2490;
			}
			if (type == 490)
			{
				num14 = 4075;
			}
			if (type == 172)
			{
				num14 = 2827 + num5;
				switch (num5)
				{
				case 29:
					num14 = 3147;
					break;
				case 30:
					num14 = 3149;
					break;
				case 31:
					num14 = 3148;
					break;
				case 32:
					num14 = 3896;
					break;
				case 33:
					num14 = 3946;
					break;
				case 34:
					num14 = 3972;
					break;
				case 35:
					num14 = 4160;
					break;
				case 36:
					num14 = 4181;
					break;
				case 37:
					num14 = 4202;
					break;
				case 38:
					num14 = 4223;
					break;
				case 39:
					num14 = 4312;
					break;
				case 40:
					num14 = 4581;
					break;
				case 41:
					num14 = 5163;
					break;
				case 42:
					num14 = 5184;
					break;
				case 43:
					num14 = 5205;
					break;
				}
			}
			if (num14 != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num14);
			}
			if (!gen && Main.netMode != 1)
			{
				switch (type)
				{
				case 138:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 99, 70, 10f, Main.myPlayer);
					break;
				case 484:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 727, 35, 10f, Main.myPlayer);
					break;
				case 654:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), num2 * 16 + 8, num6 * 16 + 8, 0f, 0f, 1002, 400, 10f, Main.myPlayer);
					break;
				case 664:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1013, 70, 10f, Main.myPlayer);
					break;
				case 665:
					Projectile.NewProjectile(GetProjectileSource_TileBreak(num2, num6), (float)(num2 * 16) + 15.5f, num6 * 16 + 16, 0f, 0f, 1014, 70, 10f, Main.myPlayer);
					break;
				}
			}
			destroyObject = false;
			for (int num15 = num2 - 1; num15 < num2 + 3; num15++)
			{
				for (int num16 = num6 - 1; num16 < num6 + 3; num16++)
				{
					TileFrame(num15, num16);
				}
			}
		}

		public static bool CheckBoulderChest(int i, int j)
		{
			int num = Main.tile[i, j].frameX / 18 * -1;
			if (num < -1)
			{
				num += 2;
			}
			num += i;
			int num2;
			for (num2 = Main.tile[i, j].frameY; num2 >= 36; num2 -= 36)
			{
			}
			num2 = j - num2 / 18;
			if (IsAContainer(Main.tile[num, num2 - 1]) || IsAContainer(Main.tile[num + 1, num2 - 1]))
			{
				return true;
			}
			return false;
		}

		public static bool IsAContainer(Tile t)
		{
			if (!TileID.Sets.BasicDresser[t.type] && t.type != 470 && t.type != 475 && !TileID.Sets.BasicChest[t.type])
			{
				return TileID.Sets.BasicChestFake[t.type];
			}
			return true;
		}

		public static void OreRunner(int i, int j, double strength, int steps, ushort type)
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_0148: Unknown result type (might be due to invalid IL or missing references)
			//IL_05a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_05a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_05d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_05f4: Unknown result type (might be due to invalid IL or missing references)
			double num = strength;
			double num2 = steps;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-10, 11) * 0.1;
			while (num > 0.0 && num2 > 0.0)
			{
				if (val.Y < 0.0 && num2 > 0.0 && type == 59)
				{
					num2 = 0.0;
				}
				num = strength * (num2 / (double)steps);
				num2 -= 1.0;
				int num3 = (int)(val.X - num * 0.5);
				int num4 = (int)(val.X + num * 0.5);
				int num5 = (int)(val.Y - num * 0.5);
				int num6 = (int)(val.Y + num * 0.5);
				if (num3 < 0)
				{
					num3 = 0;
				}
				if (num4 > Main.maxTilesX)
				{
					num4 = Main.maxTilesX;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int k = num3; k < num4; k++)
				{
					for (int l = num5; l < num6; l++)
					{
						if (Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].active() && (Main.tile[k, l].type == 0 || Main.tile[k, l].type == 1 || Main.tile[k, l].type == 23 || Main.tile[k, l].type == 25 || Main.tile[k, l].type == 40 || Main.tile[k, l].type == 53 || Main.tile[k, l].type == 57 || Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60 || Main.tile[k, l].type == 70 || Main.tile[k, l].type == 109 || Main.tile[k, l].type == 112 || Main.tile[k, l].type == 116 || Main.tile[k, l].type == 117 || Main.tile[k, l].type == 147 || Main.tile[k, l].type == 161 || Main.tile[k, l].type == 163 || Main.tile[k, l].type == 164 || Main.tileMoss[Main.tile[k, l].type] || Main.tile[k, l].type == 199 || Main.tile[k, l].type == 200 || Main.tile[k, l].type == 203 || Main.tile[k, l].type == 234 || Main.tile[k, l].type == 396 || Main.tile[k, l].type == 397 || Main.tile[k, l].type == 401 || Main.tile[k, l].type == 403 || Main.tile[k, l].type == 400 || Main.tile[k, l].type == 398 || Main.tile[k, l].type == 399 || Main.tile[k, l].type == 402 || (Main.remixWorld && Main.tile[k, l].type == 230) || (Main.tile[k, l].type == 225 && Main.tile[k, l].wall != 108)))
						{
							Main.tile[k, l].type = type;
							Main.tile[k, l].ClearBlockPaintAndCoating();
							SquareTileFrame(k, l);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, k, l);
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
			}
		}

		public static void SmashAltar(int i, int j)
		{
			if (Main.netMode == 1 || !Main.hardMode || noTileActions || gen)
			{
				return;
			}
			int num = altarCount % 3;
			int num2 = altarCount / 3 + 1;
			double num3 = (double)Main.maxTilesX / 4200.0;
			int num4 = 1 - num;
			num3 = num3 * 310.0 - (double)(85 * num);
			num3 *= 0.85;
			num3 /= (double)num2;
			bool flag = false;
			if (Main.drunkWorld)
			{
				if (SavedOreTiers.Adamantite == 111)
				{
					SavedOreTiers.Adamantite = 223;
				}
				else if (SavedOreTiers.Adamantite == 223)
				{
					SavedOreTiers.Adamantite = 111;
				}
			}
			switch (num)
			{
			case 0:
			{
				if (SavedOreTiers.Cobalt == -1)
				{
					flag = true;
					SavedOreTiers.Cobalt = 107;
					if (genRand.Next(2) == 0)
					{
						SavedOreTiers.Cobalt = 221;
					}
				}
				int num6 = 12;
				if (SavedOreTiers.Cobalt == 221)
				{
					num6 += 9;
					num3 *= 0.8999999761581421;
				}
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[num6].Value, 50, byte.MaxValue, 130);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num6].Key), new Color(50, 255, 130));
				}
				num = SavedOreTiers.Cobalt;
				num3 *= 1.0499999523162842;
				break;
			}
			case 1:
			{
				if (Main.drunkWorld)
				{
					if (SavedOreTiers.Mythril == 108)
					{
						SavedOreTiers.Mythril = 222;
					}
					else if (SavedOreTiers.Mythril == 222)
					{
						SavedOreTiers.Mythril = 108;
					}
				}
				if (SavedOreTiers.Mythril == -1)
				{
					flag = true;
					SavedOreTiers.Mythril = 108;
					if (genRand.Next(2) == 0)
					{
						SavedOreTiers.Mythril = 222;
					}
				}
				int num7 = 13;
				if (SavedOreTiers.Mythril == 222)
				{
					num7 += 9;
					num3 *= 0.8999999761581421;
				}
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[num7].Value, 50, byte.MaxValue, 130);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num7].Key), new Color(50, 255, 130));
				}
				num = SavedOreTiers.Mythril;
				break;
			}
			default:
			{
				if (Main.drunkWorld)
				{
					if (SavedOreTiers.Cobalt == 107)
					{
						SavedOreTiers.Cobalt = 221;
					}
					else if (SavedOreTiers.Cobalt == 221)
					{
						SavedOreTiers.Cobalt = 107;
					}
				}
				if (SavedOreTiers.Adamantite == -1)
				{
					flag = true;
					SavedOreTiers.Adamantite = 111;
					if (genRand.Next(2) == 0)
					{
						SavedOreTiers.Adamantite = 223;
					}
				}
				int num5 = 14;
				if (SavedOreTiers.Adamantite == 223)
				{
					num5 += 9;
					num3 *= 0.8999999761581421;
				}
				if (Main.netMode == 0)
				{
					Main.NewText(Lang.misc[num5].Value, 50, byte.MaxValue, 130);
				}
				else if (Main.netMode == 2)
				{
					ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[num5].Key), new Color(50, 255, 130));
				}
				num = SavedOreTiers.Adamantite;
				break;
			}
			}
			if (flag)
			{
				NetMessage.SendData(7);
			}
			for (int k = 0; (double)k < num3; k++)
			{
				int i2 = genRand.Next(100, Main.maxTilesX - 100);
				double num8 = Main.worldSurface;
				if (num == 108 || num == 222)
				{
					num8 = Main.rockLayer;
				}
				if (num == 111 || num == 223)
				{
					num8 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY) / 3.0;
				}
				int j2 = genRand.Next((int)num8, Main.maxTilesY - 150);
				if (Main.remixWorld)
				{
					double num9 = Main.maxTilesX - 350;
					if (num == 108 || num == 222)
					{
						num9 = (Main.rockLayer + Main.rockLayer + (double)Main.maxTilesY - 350.0) / 3.0;
					}
					if (num == 111 || num == 223)
					{
						num9 = Main.rockLayer - 25.0;
					}
					j2 = genRand.Next((int)Main.worldSurface + 15, (int)num9);
				}
				if (Main.tenthAnniversaryWorld)
				{
					OreRunner(i2, j2, genRand.Next(5, 11 + num4), genRand.Next(5, 11 + num4), (ushort)num);
				}
				else
				{
					OreRunner(i2, j2, genRand.Next(5, 9 + num4), genRand.Next(5, 9 + num4), (ushort)num);
				}
			}
			if (Main.netMode != 1)
			{
				int num10 = Main.rand.Next(2) + 1;
				for (int l = 0; l < num10; l++)
				{
					NPC.SpawnOnPlayer(Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16), 82);
				}
			}
			altarCount++;
			AchievementsHelper.NotifyProgressionEvent(6);
		}

		public static void Check3x1(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num > 2)
			{
				num -= 3;
				num2++;
			}
			num = i - num;
			int num3 = num2 * 54;
			for (int k = num; k < num + 3; k++)
			{
				if (Main.tile[k, j] == null)
				{
					Main.tile[k, j] = new Tile();
				}
				if (!Main.tile[k, j].active() || Main.tile[k, j].type != type || Main.tile[k, j].frameX != (k - num) * 18 + num3 || Main.tile[k, j].frameY != 0)
				{
					flag = true;
				}
				if (Main.tile[k, j - 1] == null)
				{
					Main.tile[k, j - 1] = new Tile();
				}
				if (Main.tile[k, j - 1].active() && (TileID.Sets.BasicChest[Main.tile[k, j - 1].type] || TileID.Sets.BasicChestFake[Main.tile[k, j - 1].type] || Main.tile[k, j - 1].type == 88 || Main.tile[k, j - 1].type == 470 || Main.tile[k, j - 1].type == 475 || Main.tile[k, j - 1].type == 597))
				{
					return;
				}
				if (!SolidTileAllowBottomSlope(k, j + 1))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			_ = Main.tile[i, j].frameX;
			destroyObject = true;
			if (type == 235)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1263);
			}
			for (int l = num; l < num + 3; l++)
			{
				if (Main.tile[l, j] == null)
				{
					Main.tile[l, j] = new Tile();
				}
				if (Main.tile[l, j].type == type && Main.tile[l, j].active())
				{
					KillTile(l, j);
				}
			}
			destroyObject = false;
			for (int m = num - 1; m < num + 4; m++)
			{
				TileFrame(m, j);
			}
		}

		public static void Check3x2(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			int num = j;
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			int num2 = 36;
			int num3 = Main.tile[i, j].frameY / num2;
			int num4 = Main.tile[i, j].frameY % num2;
			num -= num4 / 18;
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = 0;
			while (num5 > 2)
			{
				num5 -= 3;
				num6++;
			}
			num5 = i - num5;
			int num7 = num6 * 54;
			if (type == 14 && num6 == 25)
			{
				flag2 = true;
			}
			int num8 = num + 2;
			if (flag2)
			{
				num8--;
			}
			for (int k = num5; k < num5 + 3; k++)
			{
				for (int l = num; l < num8; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num7 || Main.tile[k, l].frameY != (l - num) * 18 + num3 * 36)
					{
						flag = true;
					}
				}
				if (type == 285 || type == 286 || type == 298 || type == 299 || type == 310 || type == 339 || type == 538 || (type >= 361 && type <= 364) || type == 532 || type == 544 || type == 533 || type == 555 || type == 556 || type == 582 || type == 619 || type == 629)
				{
					if (!SolidTileAllowBottomSlope(k, num8) && (Main.tile[k, num8] == null || !Main.tile[k, num8].nactive() || !Main.tileSolidTop[Main.tile[k, num8].type] || Main.tile[k, num8].frameY != 0) && (Main.tile[k, num8] == null || !Main.tile[k, num8].active() || !TileID.Sets.Platforms[Main.tile[k, num8].type]))
					{
						flag = true;
					}
				}
				else
				{
					switch (type)
					{
					case 488:
					{
						int num9 = 0;
						if (Main.tile[k, num8] != null && Main.tile[k, num8].active())
						{
							num9 = Main.tile[k, num8].type;
						}
						if (num9 != 2 && num9 != 477 && num9 != 109 && num9 != 492)
						{
							flag = true;
						}
						break;
					}
					case 26:
					{
						Tile tile2 = Main.tile[k, num8];
						if (!SolidTileAllowBottomSlope(k, num8) || (tile2 != null && tile2.active() && TileID.Sets.Boulders[tile2.type]))
						{
							flag = true;
						}
						break;
					}
					case 186:
					{
						if (!SolidTileAllowBottomSlope(k, num8))
						{
							flag = true;
							break;
						}
						Tile tile = Main.tile[k, num8];
						if (tile == null || !tile.active())
						{
							break;
						}
						switch (num6)
						{
						case 26:
						case 27:
						case 28:
						case 29:
						case 30:
						case 31:
							if (!TileID.Sets.Snow[tile.type] && !TileID.Sets.Conversion.Ice[tile.type] && tile.type != 162 && tile.type != 224)
							{
								flag = true;
							}
							break;
						case 32:
						case 33:
						case 34:
							if (!TileID.Sets.Mud[tile.type] && tile.type != 70)
							{
								flag = true;
							}
							break;
						}
						break;
					}
					}
				}
				if (type == 187)
				{
					if (!SolidTileAllowBottomSlope(k, num8))
					{
						flag = true;
						continue;
					}
					Tile tile3 = Main.tile[k, num8];
					if (tile3 == null || !tile3.active())
					{
						continue;
					}
					switch (num6)
					{
					case 0:
					case 1:
					case 2:
					case 3:
					case 4:
					case 5:
						if (!TileID.Sets.Mud[tile3.type] && tile3.type != 60 && tile3.type != 226)
						{
							flag = true;
						}
						break;
					case 6:
					case 7:
					case 8:
						if (tile3.type != 57 && tile3.type != 58 && tile3.type != 75 && tile3.type != 76)
						{
							flag = true;
						}
						break;
					case 29:
					case 30:
					case 31:
					case 32:
					case 33:
					case 34:
						if (!TileID.Sets.Conversion.Sand[tile3.type] && !TileID.Sets.Conversion.HardenedSand[tile3.type] && !TileID.Sets.Conversion.Sandstone[tile3.type])
						{
							flag = true;
						}
						break;
					}
				}
				else if (!SolidTileAllowBottomSlope(k, num8))
				{
					flag = true;
				}
			}
			if (type == 187 && Main.tile[num5, num] != null && Main.tile[num5, num].frameX >= 756 && Main.tile[num5, num].frameX <= 900 && Main.tile[num5, num + 2].type != 2 && Main.tile[num5 + 1, num + 2].type != 2 && Main.tile[num5 + 2, num + 2].type != 2 && Main.tile[num5, num + 2].type != 477 && Main.tile[num5 + 1, num + 2].type != 477 && Main.tile[num5 + 2, num + 2].type != 477 && Main.tile[num5, num + 2].type != 492 && Main.tile[num5 + 1, num + 2].type != 492 && Main.tile[num5 + 2, num + 2].type != 492)
			{
				Main.tile[num5, num].frameX -= 378;
				Main.tile[num5 + 1, num].frameX -= 378;
				Main.tile[num5 + 2, num].frameX -= 378;
				Main.tile[num5, num + 1].frameX -= 378;
				Main.tile[num5 + 1, num + 1].frameX -= 378;
				Main.tile[num5 + 2, num + 1].frameX -= 378;
				Main.tile[num5, num].type = 186;
				Main.tile[num5 + 1, num].type = 186;
				Main.tile[num5 + 2, num].type = 186;
				Main.tile[num5, num + 1].type = 186;
				Main.tile[num5 + 1, num + 1].type = 186;
				Main.tile[num5 + 2, num + 1].type = 186;
			}
			if (flag && type == 488 && gen)
			{
				for (int m = num5; m < num5 + 3; m++)
				{
					for (int n = num; n < num + 2; n++)
					{
						Main.tile[m, n].active(active: true);
						Main.tile[m, n].type = 488;
						Main.tile[m, n].frameX = (short)((m - num5) * 18);
						Main.tile[m, n].frameY = (short)((n - num) * 18);
					}
					Main.tile[m, num + 2].active(active: true);
					Main.tile[m, num + 2].type = 2;
					Main.tile[m, num + 2].slope(0);
					Main.tile[m, num + 2].halfBrick(halfBrick: false);
				}
				flag = false;
			}
			if (!flag)
			{
				return;
			}
			int frameX = Main.tile[i, j].frameX;
			destroyObject = true;
			num8 = num + 3;
			if (flag2)
			{
				num8--;
			}
			for (int num10 = num5; num10 < num5 + 3; num10++)
			{
				for (int num11 = num; num11 < num + 3; num11++)
				{
					if (Main.tile[num10, num11] == null)
					{
						Main.tile[num10, num11] = new Tile();
					}
					if (Main.tile[num10, num11].type == type && Main.tile[num10, num11].active())
					{
						KillTile(num10, num11);
					}
				}
			}
			if (type == 14)
			{
				int type2 = ((num6 >= 1 && num6 <= 3) ? (637 + num6) : ((num6 >= 15 && num6 <= 20) ? (1698 + num6) : ((num6 >= 4 && num6 <= 7) ? (823 + num6) : (num6 switch
				{
					8 => 917, 
					9 => 1144, 
					10 => 1397, 
					11 => 1400, 
					12 => 1403, 
					13 => 1460, 
					14 => 1510, 
					23 => 1926, 
					21 => 1794, 
					22 => 1816, 
					24 => 2248, 
					25 => 2259, 
					26 => 2532, 
					27 => 2550, 
					28 => 677, 
					29 => 2583, 
					30 => 2743, 
					31 => 2824, 
					32 => 3153, 
					33 => 3155, 
					34 => 3154, 
					_ => 32, 
				}))));
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			switch (type)
			{
			case 469:
			{
				int type4 = 3920;
				if (num6 == 1)
				{
					type4 = 3948;
				}
				if (num6 == 2)
				{
					type4 = 3974;
				}
				if (num6 == 3)
				{
					type4 = 4162;
				}
				if (num6 == 4)
				{
					type4 = 4183;
				}
				if (num6 == 5)
				{
					type4 = 4204;
				}
				if (num6 == 6)
				{
					type4 = 4225;
				}
				if (num6 == 7)
				{
					type4 = 4314;
				}
				if (num6 == 8)
				{
					type4 = 4583;
				}
				if (num6 == 9)
				{
					type4 = 5165;
				}
				if (num6 == 10)
				{
					type4 = 5186;
				}
				if (num6 == 11)
				{
					type4 = 5207;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type4);
				break;
			}
			case 114:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 398);
				break;
			case 26:
				if (!noTileActions && !IsGeneratingHardMode)
				{
					SmashAltar(i, j);
				}
				break;
			case 298:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2190);
				break;
			case 299:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2191);
				break;
			case 361:
			case 362:
			case 363:
			case 364:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3073 + type - 361);
				break;
			default:
				if (type >= 391 && type <= 394)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 48, 32, 3254 + type - 391);
					break;
				}
				switch (type)
				{
				case 285:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2174);
					break;
				case 286:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2175);
					break;
				case 582:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4850);
					break;
				case 619:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4963);
					break;
				case 310:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2207);
					break;
				case 339:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2741);
					break;
				case 538:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4380);
					break;
				case 544:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4399);
					break;
				case 532:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4364);
					break;
				case 533:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4376);
					break;
				case 555:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4475);
					break;
				case 556:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4476);
					break;
				case 629:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5133);
					break;
				case 217:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 995);
					break;
				case 218:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 996);
					break;
				case 219:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
					break;
				case 642:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
					break;
				case 220:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
					break;
				case 377:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3198);
					break;
				case 228:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
					break;
				case 405:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3364);
					break;
				case 486:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4063);
					break;
				case 488:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 9, genRand.Next(10, 21));
					break;
				case 215:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetCampfireItemDrop(num6));
					break;
				case 244:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1449);
					break;
				case 647:
				{
					int num13 = 0;
					if (num6 < 7)
					{
						num13 = 154;
					}
					else if (num6 < 13)
					{
						num13 = 3;
					}
					else if (num6 < 16)
					{
						num13 = 3;
					}
					else if (num6 < 18)
					{
						num13 = 71;
					}
					else if (num6 < 20)
					{
						num13 = 72;
					}
					else if (num6 < 22)
					{
						num13 = 73;
					}
					else if (num6 < 26)
					{
						num13 = 9;
					}
					else if (num6 < 32)
					{
						num13 = 593;
					}
					else if (num6 < 35)
					{
						num13 = 183;
					}
					if (num13 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num13);
					}
					break;
				}
				case 648:
				{
					num6 += num3 * 35;
					int num12 = 0;
					if (num6 < 6)
					{
						num12 = 195;
					}
					else if (num6 < 9)
					{
						num12 = 174;
					}
					else if (num6 < 14)
					{
						num12 = 150;
					}
					else if (num6 < 17)
					{
						num12 = 3;
					}
					else if (num6 < 18)
					{
						num12 = 989;
					}
					else if (num6 < 21)
					{
						num12 = 1101;
					}
					else if (num6 < 29)
					{
						num12 = 9;
					}
					else if (num6 < 35)
					{
						num12 = 3271;
					}
					else if (num6 < 41)
					{
						num12 = 3086;
					}
					else if (num6 < 47)
					{
						num12 = 3081;
					}
					else if (num6 < 52)
					{
						num12 = 62;
					}
					else if (num6 < 55)
					{
						num12 = 154;
					}
					if (num12 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num12);
					}
					break;
				}
				case 651:
				{
					int num14 = 0;
					num14 = ((num6 < 3) ? 195 : ((num6 >= 6) ? 331 : 62));
					if (num14 != 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num14);
					}
					break;
				}
				case 17:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 33);
					break;
				case 77:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 221);
					break;
				case 86:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 332);
					break;
				case 237:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1292);
					break;
				case 87:
				{
					int type3;
					if (num6 >= 1 && num6 <= 3)
					{
						type3 = 640 + num6;
					}
					else
					{
						switch (num6)
						{
						case 4:
							type3 = 919;
							break;
						case 5:
						case 6:
						case 7:
							type3 = 2245 + num6 - 5;
							break;
						default:
							type3 = ((num6 >= 8 && num6 <= 10) ? (2254 + num6 - 8) : ((num6 >= 11 && num6 <= 20) ? (2376 + num6 - 11) : (num6 switch
							{
								21 => 2531, 
								22 => 2548, 
								23 => 2565, 
								24 => 2580, 
								25 => 2671, 
								26 => 2821, 
								27 => 3141, 
								28 => 3143, 
								29 => 3142, 
								30 => 3915, 
								31 => 3916, 
								32 => 3944, 
								33 => 3971, 
								34 => 4158, 
								35 => 4179, 
								36 => 4200, 
								37 => 4221, 
								38 => 4310, 
								39 => 4579, 
								40 => 5161, 
								41 => 5182, 
								42 => 5203, 
								_ => 333, 
							})));
							break;
						}
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type3);
					break;
				}
				case 88:
				{
					int dresserItemDrop = GetDresserItemDrop(num6);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, dresserItemDrop);
					break;
				}
				case 89:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, GetItemDrop_Benches(num6));
					break;
				case 133:
					if (frameX >= 54)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1221);
					}
					else
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 524);
					}
					break;
				case 186:
					if (frameX < 864)
					{
						break;
					}
					if (frameX <= 954)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) != 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(20, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(30, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 71, genRand.Next(40, 100));
						}
					}
					else if (frameX <= 1062)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(10, 100));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(20, 100));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(30, 100));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(40, 100));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, genRand.Next(50, 100));
						}
					}
					else if (frameX <= 1170)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(1, 7));
						if (genRand.Next(2) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(2, 7));
						}
						if (genRand.Next(3) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(3, 7));
						}
						if (genRand.Next(4) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(4, 7));
						}
						if (genRand.Next(5) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73, genRand.Next(5, 7));
						}
					}
					break;
				case 187:
					if (frameX >= 918 && frameX <= 970)
					{
						if (Main.rand.Next(50) == 0)
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4144);
						}
						else
						{
							Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 989);
						}
					}
					break;
				}
				break;
			}
			destroyObject = false;
			for (int num15 = num5 - 1; num15 < num5 + 4; num15++)
			{
				for (int num16 = num - 1; num16 < num + 4; num16++)
				{
					TileFrame(num15, num16);
				}
			}
			if (type == 488)
			{
				mysticLogsEvent.FallenLogDestroyed();
			}
		}

		private static int GetDresserItemDrop(int style)
		{
			if (style >= 1 && style <= 3)
			{
				return 646 + style;
			}
			switch (style)
			{
			case 4:
				return 918;
			case 5:
			case 6:
			case 7:
			case 8:
			case 9:
			case 10:
			case 11:
			case 12:
			case 13:
			case 14:
			case 15:
				return 2386 + style - 5;
			default:
				return style switch
				{
					16 => 2529, 
					17 => 2545, 
					18 => 2562, 
					19 => 2577, 
					20 => 2637, 
					21 => 2638, 
					22 => 2639, 
					23 => 2640, 
					24 => 2816, 
					25 => 3132, 
					26 => 3134, 
					27 => 3133, 
					28 => 3911, 
					29 => 3912, 
					30 => 3913, 
					31 => 3914, 
					32 => 3934, 
					33 => 3968, 
					34 => 4148, 
					35 => 4169, 
					36 => 4190, 
					37 => 4211, 
					38 => 4301, 
					39 => 4569, 
					40 => 5151, 
					41 => 5172, 
					42 => 5193, 
					_ => 334, 
				};
			}
		}

		private static int GetCampfireItemDrop(int style)
		{
			switch (style)
			{
			case 0:
				return 966;
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
				return 3046 + style - 1;
			default:
				switch (style)
				{
				case 6:
					return 3723;
				case 7:
					return 3724;
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
					return 4689 + style - 8;
				default:
					return style switch
					{
						14 => 5299, 
						15 => 5357, 
						_ => 966, 
					};
				}
			}
		}

		public static void Check3x4(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4 = 0;
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = Main.tile[i, j].frameY / 18;
			while (num5 >= 3)
			{
				num3++;
				num5 -= 3;
			}
			while (num6 >= 4)
			{
				num4++;
				num6 -= 4;
			}
			num -= num5;
			num2 -= num6;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 54 + (k - num) * 18 || Main.tile[k, l].frameY != num4 * 72 + (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 4] == null)
				{
					Main.tile[k, num2 + 4] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 3; m++)
			{
				for (int n = num2; n < num2 + 4; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			switch (type)
			{
			case 101:
			{
				int type4;
				switch (num3)
				{
				case 1:
					type4 = 1414;
					break;
				case 2:
					type4 = 1415;
					break;
				case 3:
					type4 = 1416;
					break;
				case 4:
					type4 = 1463;
					break;
				case 5:
					type4 = 1512;
					break;
				case 6:
					type4 = 2020;
					break;
				case 7:
					type4 = 2021;
					break;
				case 8:
					type4 = 2022;
					break;
				case 9:
					type4 = 2023;
					break;
				case 10:
					type4 = 2024;
					break;
				case 11:
					type4 = 2025;
					break;
				case 12:
					type4 = 2026;
					break;
				case 13:
					type4 = 2027;
					break;
				case 14:
					type4 = 2028;
					break;
				case 15:
					type4 = 2029;
					break;
				case 16:
					type4 = 2030;
					break;
				case 17:
					type4 = 2031;
					break;
				case 18:
				case 19:
				case 20:
				case 21:
					type4 = 2135 + num3 - 18;
					break;
				default:
					type4 = num3 switch
					{
						22 => 2233, 
						23 => 2536, 
						24 => 2540, 
						25 => 2554, 
						26 => 2569, 
						27 => 2670, 
						28 => 2817, 
						29 => 3165, 
						30 => 3167, 
						31 => 3166, 
						32 => 3917, 
						33 => 3933, 
						34 => 3960, 
						35 => 4147, 
						36 => 4168, 
						37 => 4189, 
						38 => 4210, 
						39 => 4300, 
						40 => 4568, 
						41 => 5150, 
						42 => 5171, 
						43 => 5192, 
						_ => 354, 
					};
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type4);
				break;
			}
			case 102:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 355);
				break;
			case 463:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3813);
				break;
			case 617:
				if (num3 == 27)
				{
					short type2 = 5110;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
				}
				else
				{
					int type3 = 4924 + num3;
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type3);
				}
				break;
			}
			destroyObject = false;
			for (int num7 = num - 1; num7 < num + 4; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 4; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}

		public static void Check5x4(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5)
			{
				num3++;
			}
			num -= num4;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 5; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 * 90 + (k - num) * 18 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 4] == null)
				{
					Main.tile[k, num2 + 4] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 5; m++)
			{
				for (int n = num2; n < num2 + 4; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 464)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3814);
			}
			if (type == 466)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3816);
			}
			destroyObject = false;
			for (int num5 = num - 1; num5 < num + 6; num5++)
			{
				for (int num6 = num2 - 1; num6 < num2 + 5; num6++)
				{
					TileFrame(num5, num6);
				}
			}
		}

		public static void Check6x3(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18 * -1;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num; k < num + 6; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					int num3 = (k - num) * 18;
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num3 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 3] == null)
				{
					Main.tile[k, num2 + 3] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num2 + 3) && (!Main.tile[k, num2 + 3].nactive() || !Main.tileSolidTop[Main.tile[k, num2 + 3].type] || Main.tile[k, num2 + 3].frameY != 0))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 6; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 275)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2162);
			}
			if (type == 413)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3565);
			}
			if (type == 414)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3566);
			}
			if (type == 276)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2163);
			}
			if (type == 277)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2164);
			}
			if (type == 278)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2165);
			}
			if (type == 279)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2166);
			}
			if (type == 280)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2167);
			}
			if (type == 281)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2168);
			}
			if (type == 296)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2186);
			}
			if (type == 297)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2187);
			}
			if (type == 309)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2206);
			}
			if (type == 358)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3070);
			}
			if (type == 359)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3071);
			}
			if (type == 542)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4396);
			}
			if (type == 550)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4461);
			}
			if (type == 551)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4462);
			}
			if (type == 553)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4473);
			}
			if (type == 554)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4474);
			}
			if (type == 558)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4481);
			}
			if (type == 559)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4483);
			}
			if (type == 599)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4882);
			}
			if (type == 600)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4883);
			}
			if (type == 601)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4884);
			}
			if (type == 602)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4885);
			}
			if (type == 603)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4886);
			}
			if (type == 604)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4887);
			}
			if (type == 605)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4888);
			}
			if (type == 606)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4889);
			}
			if (type == 607)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4890);
			}
			if (type == 608)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4891);
			}
			if (type == 609)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4892);
			}
			if (type == 610)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4893);
			}
			if (type == 611)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4894);
			}
			if (type == 612)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4895);
			}
			if (type == 632)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5213);
			}
			if (type == 640)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5301);
			}
			if (type == 643)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5314);
			}
			if (type == 644)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5315);
			}
			if (type == 645)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5316);
			}
			destroyObject = false;
			for (int num4 = num - 1; num4 < num + 7; num4++)
			{
				for (int num5 = num2 - 1; num5 < num2 + 4; num5++)
				{
					TileFrame(num4, num5);
				}
			}
		}

		public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 3; i < x + 3; i++)
			{
				for (int j = y - 2; j <= y; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			int num = 0;
			for (int k = x - 3; k < x + 3; k++)
			{
				int num2 = 0;
				for (int l = y - 2; l <= y; l++)
				{
					Main.tile[k, l].active(active: true);
					Main.tile[k, l].frameY = (short)num2;
					Main.tile[k, l].frameX = (short)num;
					Main.tile[k, l].type = type;
					num2 += 18;
				}
				num += 18;
			}
		}

		public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 3; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			short num = 0;
			if (direction == 1)
			{
				num = 72;
			}
			int num2 = 36 * style;
			if (flag)
			{
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = (short)num2;
				Main.tile[x - 1, y - 1].frameX = num;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = (short)num2;
				Main.tile[x, y - 1].frameX = (short)(18 + num);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = (short)num2;
				Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x + 2, y - 1].active(active: true);
				Main.tile[x + 2, y - 1].frameY = (short)num2;
				Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num2 + 18);
				Main.tile[x - 1, y].frameX = num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num2 + 18);
				Main.tile[x, y].frameX = (short)(18 + num);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = (short)(num2 + 18);
				Main.tile[x + 1, y].frameX = (short)(36 + num);
				Main.tile[x + 1, y].type = type;
				Main.tile[x + 2, y].active(active: true);
				Main.tile[x + 2, y].frameY = (short)(num2 + 18);
				Main.tile[x + 2, y].frameX = (short)(54 + num);
				Main.tile[x + 2, y].type = type;
			}
		}

		public static void ShootFromCannon(int x, int y, int angle, int ammo, int Damage, float KnockBack, int owner, bool fromWire)
		{
			float num = 14f;
			float num2 = 0f;
			float num3 = 0f;
			int type = 162;
			if (ammo == 2)
			{
				type = 281;
			}
			if (ammo == 3)
			{
				type = 178;
			}
			if (ammo == 4)
			{
				type = 601;
				num = 3f;
			}
			if (ammo == 5)
			{
				type = 601;
				num = 3f;
			}
			int num4 = 0;
			int num5 = 0;
			if (ammo == 5)
			{
				num4 = 1;
			}
			if (ammo == 2)
			{
				num5 = owner + 1;
			}
			if (angle == 0)
			{
				num2 = 10f;
				num3 = 0f;
			}
			if (angle == 1)
			{
				num2 = 7.5f;
				num3 = -2.5f;
			}
			if (angle == 2)
			{
				num2 = 5f;
				num3 = -5f;
			}
			if (angle == 3)
			{
				num2 = 2.75f;
				num3 = -6f;
			}
			if (angle == 4)
			{
				num2 = 0f;
				num3 = -10f;
			}
			if (angle == 5)
			{
				num2 = -2.75f;
				num3 = -6f;
			}
			if (angle == 6)
			{
				num2 = -5f;
				num3 = -5f;
			}
			if (angle == 7)
			{
				num2 = -7.5f;
				num3 = -2.5f;
			}
			if (angle == 8)
			{
				num2 = -10f;
				num3 = 0f;
			}
			Vector2 vector = new Vector2((x + 2) * 16, (y + 2) * 16);
			float num6 = num2;
			float num7 = num3;
			float num8 = (float)Math.Sqrt(num6 * num6 + num7 * num7);
			if (ammo == 4 || ammo == 5)
			{
				if (angle == 4)
				{
					vector.X += 5f;
				}
				vector.Y += 5f;
			}
			bool flag = true;
			if (ammo == 2 && !BunnyCannonCanFire())
			{
				flag = false;
			}
			if (!flag)
			{
				return;
			}
			num8 = num / num8;
			num6 *= num8;
			num7 *= num8;
			if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5))
			{
				NetMessage.SendData(108, owner, -1, null, Damage, KnockBack, x, y, angle, ammo, owner);
				return;
			}
			if (Main.netMode == 2)
			{
				owner = Main.myPlayer;
			}
			int num9 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWire, Main.player[owner]), vector.X, vector.Y, num6, num7, type, Damage, KnockBack, owner, num4, num5);
			Main.projectile[num9].originatedFromActivableTile = true;
		}

		public static bool BunnyCannonCanFire()
		{
			int num = 1;
			int num2 = 0;
			int num3 = 100;
			for (int i = 0; i < num3; i++)
			{
				NPC nPC = Main.npc[i];
				if (nPC == null || !nPC.active)
				{
					num2++;
				}
			}
			for (int j = 0; j < Main.projectile.Length; j++)
			{
				Projectile projectile = Main.projectile[j];
				if (projectile != null && projectile.active && projectile.type == 281)
				{
					num2--;
					if (num2 <= 0)
					{
						return false;
					}
				}
			}
			return num2 >= num;
		}

		public static void SwitchCannon(int i, int j)
		{
			int num;
			for (num = Main.tile[i, j].frameX / 18; num >= 4; num -= 4)
			{
			}
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 >= 3; num2 -= 3)
			{
			}
			int num3 = 1;
			if (num < 2)
			{
				num3 = -1;
			}
			num = i - num;
			num2 = j - num2;
			if ((num3 == 1 && Main.tile[num, num2].frameY <= 52) || (num3 == -1 && Main.tile[num, num2].frameY >= 432))
			{
				return;
			}
			num3 *= -54;
			for (int k = num; k < num + 4; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 209)
					{
						Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num3);
					}
				}
			}
			NetMessage.SendTileSquare(-1, num, num2, 4, 3);
		}

		public static void CheckCannon(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = Main.tile[i, j].frameX / 18;
			int num2 = 0;
			while (num >= 4)
			{
				num2++;
				num -= 4;
			}
			num = i - num;
			int num3 = Main.tile[i, j].frameY / 18;
			int num4 = 0;
			while (num3 >= 3)
			{
				num4 += 54;
				num3 -= 3;
			}
			num3 = j - num3;
			int num5 = 72 * num2;
			for (int k = num; k < num + 4; k++)
			{
				int num6 = num4;
				for (int l = num3; l < num3 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != num5 || Main.tile[k, l].frameY != num6)
					{
						flag = true;
					}
					num6 += 18;
				}
				if (Main.tile[k, num3 + 3] == null)
				{
					Main.tile[k, num3 + 3] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(k, num3 + 3) && k != num && k != num + 3)
				{
					flag = true;
				}
				num5 += 18;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 4; m++)
			{
				for (int n = num3; n < num3 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			int type2 = 928;
			switch (num2)
			{
			case 1:
				type2 = 1337;
				break;
			case 2:
				type2 = 3369;
				break;
			case 3:
			case 4:
				type2 = 3664;
				break;
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			destroyObject = false;
			for (int num7 = num; num7 < num + 4; num7++)
			{
				for (int num8 = num3; num8 < num3 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
		}

		public static void PlaceCannon(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 3; i++)
			{
				for (int j = y - 2; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
				{
					flag = false;
				}
			}
			int num = 72 * style;
			int num2 = 0;
			if (flag)
			{
				Main.tile[x - 1, y - 2].active(active: true);
				Main.tile[x - 1, y - 2].frameY = (short)num2;
				Main.tile[x - 1, y - 2].frameX = (short)num;
				Main.tile[x - 1, y - 2].type = type;
				Main.tile[x, y - 2].active(active: true);
				Main.tile[x, y - 2].frameY = (short)num2;
				Main.tile[x, y - 2].frameX = (short)(18 + num);
				Main.tile[x, y - 2].type = type;
				Main.tile[x + 1, y - 2].active(active: true);
				Main.tile[x + 1, y - 2].frameY = (short)num2;
				Main.tile[x + 1, y - 2].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 2].type = type;
				Main.tile[x + 2, y - 2].active(active: true);
				Main.tile[x + 2, y - 2].frameY = (short)num2;
				Main.tile[x + 2, y - 2].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 2].type = type;
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x - 1, y - 1].frameX = (short)num;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x, y - 1].frameX = (short)(18 + num);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x + 1, y - 1].frameX = (short)(36 + num);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x + 2, y - 1].active(active: true);
				Main.tile[x + 2, y - 1].frameY = (short)(num2 + 18);
				Main.tile[x + 2, y - 1].frameX = (short)(54 + num);
				Main.tile[x + 2, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num2 + 36);
				Main.tile[x - 1, y].frameX = (short)num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num2 + 36);
				Main.tile[x, y].frameX = (short)(18 + num);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = (short)(num2 + 36);
				Main.tile[x + 1, y].frameX = (short)(36 + num);
				Main.tile[x + 1, y].type = type;
				Main.tile[x + 2, y].active(active: true);
				Main.tile[x + 2, y].frameY = (short)(num2 + 36);
				Main.tile[x + 2, y].frameX = (short)(54 + num);
				Main.tile[x + 2, y].type = type;
			}
		}

		public static void SwitchMB(int i, int j)
		{
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameY / 18; num3 >= 2; num3 -= 2)
			{
			}
			int num4 = Main.tile[i, j].frameX / 18;
			if (num4 >= 2)
			{
				num4 -= 2;
			}
			num = i - num4;
			num2 = j - num3;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 139 || Main.tile[k, l].type == 35))
					{
						if (Main.tile[k, l].frameX < 36)
						{
							Main.tile[k, l].frameX += 36;
						}
						else
						{
							Main.tile[k, l].frameX -= 36;
						}
					}
				}
			}
			if (Wiring.running)
			{
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 1);
			}
			NetMessage.SendTileSquare(-1, num, num2, 2, 2);
		}

		public static void SwitchMonolith(int i, int j)
		{
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2)
			{
			}
			int num4;
			for (num4 = Main.tile[i, j].frameY / 18; num4 >= 3; num4 -= 3)
			{
			}
			num = i - num3;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					Tile tile = Main.tile[k, l];
					if (!tile.active())
					{
						continue;
					}
					if (tile.type == 410)
					{
						if (tile.frameY < 56)
						{
							tile.frameY += 56;
						}
						else
						{
							tile.frameY -= 56;
						}
					}
					else if (tile.type == 480)
					{
						if (tile.frameY < 54)
						{
							tile.frameY += 54;
						}
						else
						{
							tile.frameY -= 54;
						}
					}
					else if (tile.type == 509)
					{
						if (tile.frameY < 54)
						{
							tile.frameY += 54;
						}
						else
						{
							tile.frameY -= 54;
						}
					}
					else if (tile.type == 657)
					{
						if (tile.frameY < 54)
						{
							tile.frameY += 54;
						}
						else
						{
							tile.frameY -= 54;
						}
					}
					else if (tile.type == 658)
					{
						short num5 = 54;
						short num6 = 3;
						short num7 = (short)(num5 * num6);
						tile.frameY += num5;
						if (tile.frameY >= num7)
						{
							tile.frameY -= num7;
						}
					}
				}
			}
			if (Wiring.running)
			{
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num, num2 + 2);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num + 1, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 2);
			}
			NetMessage.SendTileSquare(-1, num, num2, 2, 3);
		}

		public static void SwitchFountain(int i, int j)
		{
			int num = i;
			int num2 = j;
			int num3;
			for (num3 = Main.tile[i, j].frameX / 18; num3 >= 2; num3 -= 2)
			{
			}
			int num4 = Main.tile[i, j].frameY / 18;
			if (num4 >= 4)
			{
				num4 -= 4;
			}
			num = i - num3;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 207)
					{
						if (Main.tile[k, l].frameY < 72)
						{
							Main.tile[k, l].frameY += 72;
						}
						else
						{
							Main.tile[k, l].frameY -= 72;
						}
					}
				}
			}
			if (Wiring.running)
			{
				Wiring.SkipWire(num, num2);
				Wiring.SkipWire(num, num2 + 1);
				Wiring.SkipWire(num, num2 + 2);
				Wiring.SkipWire(num, num2 + 3);
				Wiring.SkipWire(num + 1, num2);
				Wiring.SkipWire(num + 1, num2 + 1);
				Wiring.SkipWire(num + 1, num2 + 2);
				Wiring.SkipWire(num + 1, num2 + 3);
			}
			NetMessage.SendTileSquare(-1, num, num2, 2, 4);
		}

		public static void CheckMB(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 0;
			int num4;
			for (num4 = Main.tile[i, j].frameY / 18; num4 >= 2; num4 -= 2)
			{
				num3++;
			}
			int num5 = Main.tile[i, j].frameX / 18;
			int num6 = 0;
			if (num5 >= 2)
			{
				num5 -= 2;
				num6++;
			}
			num = i - num5;
			num2 = j - num4;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num) * 18 + num6 * 36 || Main.tile[k, l].frameY != (l - num2) * 18 + num3 * 36)
					{
						flag = true;
					}
				}
				if (!Main.tile[k, num2 + 2].nactive())
				{
					flag = true;
				}
				else if (!Main.tileSolid[Main.tile[k, num2 + 2].type] && !Main.tileTable[Main.tile[k, num2 + 2].type])
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 35)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1813);
			}
			else if (num3 == 28)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1963);
			}
			else if (num3 == 29)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1964);
			}
			else if (num3 == 30)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1965);
			}
			else if (num3 == 31)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2742);
			}
			else if (num3 == 32)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3044);
			}
			else if (num3 == 33)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3235);
			}
			else if (num3 == 34)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3236);
			}
			else if (num3 == 35)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3237);
			}
			else if (num3 == 36)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3370);
			}
			else if (num3 == 37)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3371);
			}
			else if (num3 == 38)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3796);
			}
			else if (num3 == 39)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3869);
			}
			else if (num3 == 43)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4077);
			}
			else if (num3 == 41)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4078);
			}
			else if (num3 == 42)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4079);
			}
			else if (num3 == 44)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4080);
			}
			else if (num3 == 45)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4081);
			}
			else if (num3 == 40)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4082);
			}
			else if (num3 == 46)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4237);
			}
			else if (num3 == 47)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4356);
			}
			else if (num3 == 48)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4357);
			}
			else if (num3 == 49)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4358);
			}
			else if (num3 == 50)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4421);
			}
			else if (num3 == 51)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4606);
			}
			else if (num3 == 52)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4979);
			}
			else if (num3 == 53)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4985);
			}
			else if (num3 == 54)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4990);
			}
			else if (num3 == 55)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4991);
			}
			else if (num3 == 56)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4992);
			}
			else if (num3 == 57)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5006);
			}
			else if (num3 == 58)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5014);
			}
			else if (num3 == 59)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5015);
			}
			else if (num3 == 60)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5016);
			}
			else if (num3 == 61)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5017);
			}
			else if (num3 == 62)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5018);
			}
			else if (num3 == 63)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5019);
			}
			else if (num3 == 64)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5020);
			}
			else if (num3 == 65)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5021);
			}
			else if (num3 == 66)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5022);
			}
			else if (num3 == 67)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5023);
			}
			else if (num3 == 68)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5024);
			}
			else if (num3 == 69)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5025);
			}
			else if (num3 == 70)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5026);
			}
			else if (num3 == 71)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5027);
			}
			else if (num3 == 72)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5028);
			}
			else if (num3 == 73)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5029);
			}
			else if (num3 == 74)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5030);
			}
			else if (num3 == 75)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5031);
			}
			else if (num3 == 76)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5032);
			}
			else if (num3 == 77)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5033);
			}
			else if (num3 == 78)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5034);
			}
			else if (num3 == 79)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5035);
			}
			else if (num3 == 80)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5036);
			}
			else if (num3 == 81)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5037);
			}
			else if (num3 == 82)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5038);
			}
			else if (num3 == 83)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5039);
			}
			else if (num3 == 84)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5040);
			}
			else if (num3 == 85)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5044);
			}
			else if (num3 == 86)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5112);
			}
			else if (num3 == 87)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5362);
			}
			else if (num3 >= 13)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1596 + num3 - 13);
			}
			else
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 562 + num3);
			}
			for (int num7 = num - 1; num7 < num + 3; num7++)
			{
				for (int num8 = num2 - 1; num8 < num2 + 3; num8++)
				{
					TileFrame(num7, num8);
				}
			}
			destroyObject = false;
		}

		public static void PlaceMB(int X, int y, ushort type, int style)
		{
			int num = X + 1;
			if (num < 5 || num > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = num - 1; i < num + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!Main.tile[i, y + 1].active() || Main.tile[i, y + 1].halfBrick() || (!Main.tileSolid[Main.tile[i, y + 1].type] && !Main.tileTable[Main.tile[i, y + 1].type]))
				{
					flag = false;
				}
			}
			if (flag)
			{
				Main.tile[num - 1, y - 1].active(active: true);
				Main.tile[num - 1, y - 1].frameY = (short)(style * 36);
				Main.tile[num - 1, y - 1].frameX = 0;
				Main.tile[num - 1, y - 1].type = type;
				Main.tile[num, y - 1].active(active: true);
				Main.tile[num, y - 1].frameY = (short)(style * 36);
				Main.tile[num, y - 1].frameX = 18;
				Main.tile[num, y - 1].type = type;
				Main.tile[num - 1, y].active(active: true);
				Main.tile[num - 1, y].frameY = (short)(style * 36 + 18);
				Main.tile[num - 1, y].frameX = 0;
				Main.tile[num - 1, y].type = type;
				Main.tile[num, y].active(active: true);
				Main.tile[num, y].frameY = (short)(style * 36 + 18);
				Main.tile[num, y].frameX = 18;
				Main.tile[num, y].type = type;
			}
		}

		public static void Place2x2(int x, int y, ushort type, int style)
		{
			if (type == 95 || type == 126)
			{
				y++;
			}
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			if (type == 172)
			{
				if (!CanPlaceSink(x, y, type, style))
				{
					return;
				}
			}
			else
			{
				for (int i = x - 1; i < x + 1; i++)
				{
					for (int j = y - 1; j < y + 1; j++)
					{
						Tile tileSafely = Framing.GetTileSafely(i, j);
						if (tileSafely.active() || (type == 98 && tileSafely.liquid > 0))
						{
							return;
						}
					}
					switch (type)
					{
					case 95:
					case 126:
					{
						Tile tileSafely = Framing.GetTileSafely(i, y - 2);
						if (!tileSafely.nactive() || !Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type])
						{
							return;
						}
						break;
					}
					default:
					{
						Tile tileSafely = Framing.GetTileSafely(i, y + 1);
						if (!tileSafely.nactive() || (!SolidTile2(tileSafely) && !Main.tileTable[tileSafely.type]))
						{
							return;
						}
						break;
					}
					case 132:
						break;
					}
				}
			}
			if (type == 132)
			{
				bool flag = true;
				if (Main.tile[x - 1, y + 1] == null)
				{
					Main.tile[x - 1, y + 1] = new Tile();
				}
				if (Main.tile[x, y + 1] == null)
				{
					Main.tile[x, y + 1] = new Tile();
				}
				if (!Main.tile[x - 1, y + 1].nactive() || (!SolidTile2(x - 1, y + 1) && !Main.tileTable[Main.tile[x - 1, y + 1].type]))
				{
					flag = false;
				}
				if (!Main.tile[x, y + 1].nactive() || (!SolidTile2(x, y + 1) && !Main.tileTable[Main.tile[x, y + 1].type]))
				{
					flag = false;
				}
				if (!flag && (Main.tile[x - 1, y - 1].wall < 1 || Main.tile[x, y - 1].wall < 1 || Main.tile[x - 1, y].wall < 1 || Main.tile[x - 1, y].wall < 1))
				{
					return;
				}
			}
			x--;
			y--;
			int num = ((type == 172) ? 38 : 36);
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Tile tileSafely = Main.tile[x + k, y + l];
					tileSafely.active(active: true);
					tileSafely.frameX = (short)(k * 18);
					tileSafely.frameY = (short)(style * num + l * 18);
					tileSafely.type = type;
				}
			}
		}

		public static bool PlaceObject(int x, int y, int type, bool mute = false, int style = 0, int alternate = 0, int random = -1, int direction = -1)
		{
			if (type >= 693)
			{
				return false;
			}
			if (!TileObject.CanPlace(x, y, type, style, direction, out var objectData))
			{
				return false;
			}
			objectData.random = random;
			if (TileObject.Place(objectData))
			{
				SquareTileFrame(x, y);
				if (!mute)
				{
					SoundEngine.PlaySound(0, x * 16, y * 16);
				}
			}
			return true;
		}

		public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type == 386 && onlyCloseOrOpen != 1)
			{
				Point topLeftAndStyles = GetTopLeftAndStyles(ref x, ref y, 2, 2, 18, 18);
				if (topLeftAndStyles.X == 0)
				{
					if (Main.netMode != 1 && Wiring.running)
					{
						Wiring.SkipWire(x, y);
						Wiring.SkipWire(x, y + 1);
						Wiring.SkipWire(x + 1, y);
						Wiring.SkipWire(x + 1, y + 1);
					}
					if (!Collision.EmptyTile(x, y + 1, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y + 1, ignoreTiles: true))
					{
						return false;
					}
					SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
					for (int i = 0; i < 2; i++)
					{
						tileSafely = Framing.GetTileSafely(x + i, y);
						tileSafely.ClearTile();
					}
					for (int j = 0; j < 2; j++)
					{
						tileSafely = Framing.GetTileSafely(x + j, y + 1);
						tileSafely.type = 387;
						tileSafely.frameX = (short)(j * 18);
						tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
					}
					for (int k = -1; k < 3; k++)
					{
						for (int l = 0; l < 3; l++)
						{
							TileFrame(x + k, y + l);
						}
					}
					return true;
				}
				if (topLeftAndStyles.X == 1)
				{
					if (Main.netMode != 1 && Wiring.running)
					{
						Wiring.SkipWire(x, y - 1);
						Wiring.SkipWire(x, y);
						Wiring.SkipWire(x + 1, y - 1);
						Wiring.SkipWire(x + 1, y);
					}
					if (!Collision.EmptyTile(x, y, ignoreTiles: true) || !Collision.EmptyTile(x + 1, y, ignoreTiles: true))
					{
						return false;
					}
					SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
					for (int m = 0; m < 2; m++)
					{
						tileSafely = Framing.GetTileSafely(x + m, y + 1);
						tileSafely.ClearTile();
					}
					for (int n = 0; n < 2; n++)
					{
						tileSafely = Framing.GetTileSafely(x + n, y);
						tileSafely.type = 387;
						tileSafely.frameX = (short)(n * 18);
						tileSafely.frameY = (short)(topLeftAndStyles.Y * 18);
					}
					for (int num = -1; num < 3; num++)
					{
						for (int num2 = -1; num2 < 2; num2++)
						{
							TileFrame(x + num, y + num2);
						}
					}
					return true;
				}
			}
			if (tileSafely.type == 387 && onlyCloseOrOpen != 0)
			{
				GetTopLeftAndStyles(ref x, ref y, 2, 1, 18, 18);
				int num3 = playerAbove.ToDirectionInt();
				for (int num4 = 0; num4 < 2; num4++)
				{
					tileSafely = Framing.GetTileSafely(x + num4, y + num3);
					if (tileSafely.active() && !Main.tileCut[tileSafely.type])
					{
						return false;
					}
				}
				if (Main.netMode != 1 && Wiring.running)
				{
					Wiring.SkipWire(x, y);
					Wiring.SkipWire(x, y + num3);
					Wiring.SkipWire(x + 1, y);
					Wiring.SkipWire(x + 1, y + num3);
				}
				SoundEngine.PlaySound(8, x * 16 + 16, y * 16);
				for (int num5 = 0; num5 < 2; num5++)
				{
					tileSafely = Framing.GetTileSafely(x + num5, y + num3);
					if (tileSafely.active() && Main.tileCut[tileSafely.type])
					{
						KillTile(x + num5, y + num3);
					}
				}
				for (int num6 = 0; num6 < 2; num6++)
				{
					tileSafely = Framing.GetTileSafely(x + num6, y);
					TileColorCache cache = tileSafely.BlockColorAndCoating();
					for (int num7 = 0; num7 < 2; num7++)
					{
						tileSafely = Framing.GetTileSafely(x + num6, y + num7 - (!playerAbove).ToInt());
						tileSafely.type = 386;
						tileSafely.frameX = (short)(num6 * 18 + playerAbove.ToInt() * 36);
						tileSafely.frameY = (short)(num7 * 18);
						tileSafely.UseBlockColors(cache);
						tileSafely.active(active: true);
					}
				}
				for (int num8 = -1; num8 < 3; num8++)
				{
					for (int num9 = -1; num9 < 3; num9++)
					{
						TileFrame(x + num8, y + num9 - (!playerAbove).ToInt() * 2);
					}
				}
				return true;
			}
			SoundEngine.PlaySound(9, x * 16, y * 16);
			return false;
		}

		public static void CheckTrapDoor(int x, int y, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = 0;
			Point point = default(Point);
			if (type == 387)
			{
				num = 2;
				num2 = 1;
				point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
				flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18) || !CheckTileAnchors(x, y, num, num2, 1, AnchorType.SolidTile);
			}
			if (type == 386)
			{
				num = 2;
				num2 = 2;
				point = GetTopLeftAndStyles(ref x, ref y, num, num2, 18, 18);
				flag = flag || !CheckTileFrames(type, x, y, num, num2, point.X, 18, point.Y, 18);
				if (point.X == 0)
				{
					flag = flag || !CheckTileAnchors(x, y + 1, num, 1, 1, AnchorType.SolidTile);
				}
				else if (point.X == 1)
				{
					flag = flag || !CheckTileAnchors(x, y, num, 1, 1, AnchorType.SolidTile);
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int i = x; i < x + num; i++)
			{
				for (int j = y; j < y + num2; j++)
				{
					KillTile(i, j);
				}
			}
			int type2 = 3239;
			if (point.Y == 0)
			{
				type2 = 3239;
			}
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, num * 16, num2 * 16, type2);
			for (int k = x - 1; k < x + num + 1; k++)
			{
				for (int l = y - 1; l < y + num2 + 1; l++)
				{
					TileFrame(k, l);
				}
			}
			destroyObject = false;
		}

		public static void CheckTallGate(int x, int y, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			Tile tileSafely = Framing.GetTileSafely(x, y);
			Point point = new Point(tileSafely.frameX / 18, 0);
			TileObjectData tileData = TileObjectData.GetTileData(type, point.X);
			point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
			int width = tileData.Width;
			int height = tileData.Height;
			int i = 0;
			for (int num = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num - tileData.CoordinateHeights[i] >= 0; i++)
			{
				num -= tileData.CoordinateHeights[i];
			}
			_ = tileData.CoordinateFullHeight;
			y -= i;
			int num2 = point.Y * tileData.CoordinateFullHeight;
			for (int j = 0; j < height; j++)
			{
				tileSafely = Framing.GetTileSafely(x, y + j);
				if (tileSafely.frameX != point.X * tileData.CoordinateFullWidth || tileSafely.frameY != num2)
				{
					flag = true;
					break;
				}
				num2 += tileData.CoordinateHeights[j] + tileData.CoordinatePadding;
			}
			if (!flag && CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
			{
				return;
			}
			destroyObject = true;
			for (int k = x; k < x + width; k++)
			{
				for (int l = y; l < y + height; l++)
				{
					KillTile(k, l);
				}
			}
			int type2 = 3240;
			if (point.Y == 0)
			{
				type2 = 3240;
			}
			Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, width * 16, height * 16, type2);
			for (int m = x - 1; m < x + width + 1; m++)
			{
				for (int n = y - 1; n < y + height + 1; n++)
				{
					TileFrame(m, n);
				}
			}
			destroyObject = false;
		}

		public static bool ShiftTallGate(int x, int y, bool closing, bool forced = false)
		{
			ushort type = (ushort)(closing ? 388 : 389);
			ushort num = (ushort)(closing ? 389 : 388);
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type != num)
			{
				return false;
			}
			Point point = new Point(tileSafely.frameX / 18, 0);
			TileObjectData tileData = TileObjectData.GetTileData(388, point.X);
			point.Y = tileSafely.frameY / tileData.CoordinateFullHeight;
			_ = tileData.Width;
			int height = tileData.Height;
			int i = 0;
			for (int num2 = tileSafely.frameY % tileData.CoordinateFullHeight; i < height && num2 - tileData.CoordinateHeights[i] >= 0; i++)
			{
				num2 -= tileData.CoordinateHeights[i];
			}
			_ = tileData.CoordinateFullHeight;
			y -= i;
			if (Main.netMode != 1 && Wiring.running)
			{
				for (int j = 0; j < height; j++)
				{
					Wiring.SkipWire(x, y + j);
				}
			}
			for (int k = 0; k < height; k++)
			{
				if (!forced && !Collision.EmptyTile(x, y + k, ignoreTiles: true))
				{
					return false;
				}
			}
			SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16);
			for (int l = 0; l < height; l++)
			{
				tileSafely = Framing.GetTileSafely(x, y + l);
				tileSafely.type = type;
			}
			for (int m = -1; m < 2; m++)
			{
				for (int n = -1; n < height + 1; n++)
				{
					TileFrame(x + m, y + n);
				}
			}
			return true;
		}

		public static Point GetTopLeftAndStyles(ref int x, ref int y, int w, int h, int frameXinc, int frameYinc)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			Point result = new Point(tileSafely.frameX / (w * frameXinc), tileSafely.frameY / (h * frameYinc));
			if (frameXinc != 0)
			{
				x -= tileSafely.frameX / frameXinc % w;
			}
			if (frameYinc != 0)
			{
				y -= tileSafely.frameY / frameYinc % h;
			}
			return result;
		}

		public static bool CheckTileFrames(int type, int sx, int sy, int w, int h, int styleX, int frameXinc, int styleY, int frameYinc)
		{
			for (int i = 0; i < w; i++)
			{
				for (int j = 0; j < h; j++)
				{
					Tile tileSafely = Framing.GetTileSafely(sx + i, sy + j);
					if (!tileSafely.active() || tileSafely.type != type || tileSafely.frameX != styleX * w * frameXinc + i * frameXinc || tileSafely.frameY != styleY * h * frameYinc + j * frameYinc)
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool CheckTileAnchors(int sx, int sy, int w, int h, int mode, AnchorType anchor)
		{
			if ((mode & 1) == 1)
			{
				for (int i = sy; i < sy + h; i++)
				{
					if (!AnchorValid(Framing.GetTileSafely(sx - 1, i), anchor))
					{
						return false;
					}
					if (!AnchorValid(Framing.GetTileSafely(sx + w, i), anchor))
					{
						return false;
					}
				}
			}
			if ((mode & 2) == 2)
			{
				for (int j = sx; j < sx + w; j++)
				{
					if (!AnchorValid(Framing.GetTileSafely(j, sy - 1), anchor))
					{
						return false;
					}
					if (!AnchorValid(Framing.GetTileSafely(j, sy + h), anchor))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static bool AnchorValid(Tile tileCache, AnchorType anchor)
		{
			bool flag = false;
			if (tileCache.nactive())
			{
				if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type] && !Main.tileNoAttach[tileCache.type] && tileCache.blockType() == 0)
				{
					flag = true;
				}
				if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && ((Main.tileSolid[tileCache.type] && (!Main.tileSolidTop[tileCache.type] || (TileID.Sets.Platforms[tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())))) || tileCache.topSlope() || tileCache.halfBrick()) && !TileID.Sets.NotReallySolid[tileCache.type] && !tileCache.bottomSlope())
				{
					flag = true;
				}
				if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table))
				{
					if (TileID.Sets.Platforms[tileCache.type])
					{
						int num = tileCache.frameX / TileObjectData.PlatformFrameWidth();
						if ((!tileCache.halfBrick() && num >= 0 && num <= 7) || (num >= 12 && num <= 16) || (num >= 25 && num <= 26))
						{
							flag = true;
						}
					}
					else if (Main.tileSolid[tileCache.type] && Main.tileSolidTop[tileCache.type])
					{
						flag = true;
					}
				}
				if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && !TileID.Sets.Platforms[tileCache.type] && Main.tileTable[tileCache.type] && tileCache.blockType() == 0)
				{
					flag = true;
				}
				if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && Main.tileSolid[tileCache.type] && !Main.tileSolidTop[tileCache.type])
				{
					int num2 = tileCache.blockType();
					if ((uint)(num2 - 4) <= 1u)
					{
						flag = true;
					}
				}
			}
			else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile)
			{
				flag = true;
			}
			return flag;
		}

		public static bool CanPlaceSink(int x, int y, ushort type, int style)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return false;
			}
			bool result = true;
			x--;
			y--;
			for (int i = 0; i < 2; i++)
			{
				Tile tileSafely;
				for (int j = 0; j < 2; j++)
				{
					tileSafely = Framing.GetTileSafely(x + i, y + j);
					if (tileSafely.active())
					{
						result = false;
					}
				}
				tileSafely = Framing.GetTileSafely(x + i, y + 2);
				if (!tileSafely.nactive() || !SolidTile(tileSafely))
				{
					result = false;
				}
			}
			return result;
		}

		public static void Place3x4(int x, int y, ushort type, int style)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = y - 3; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num = style * 54;
				for (int k = -3; k <= 0; k++)
				{
					short frameY = (short)((3 + k) * 18);
					Main.tile[x - 1, y + k].active(active: true);
					Main.tile[x - 1, y + k].frameY = frameY;
					Main.tile[x - 1, y + k].frameX = (short)num;
					Main.tile[x - 1, y + k].type = type;
					Main.tile[x, y + k].active(active: true);
					Main.tile[x, y + k].frameY = frameY;
					Main.tile[x, y + k].frameX = (short)(num + 18);
					Main.tile[x, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 36);
					Main.tile[x + 1, y + k].type = type;
				}
			}
		}

		public static void Place5x4(int x, int y, ushort type, int style)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 2; i < x + 3; i++)
			{
				for (int j = y - 3; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num = style * 54;
				for (int k = -3; k <= 0; k++)
				{
					short frameY = (short)((3 + k) * 18);
					Main.tile[x - 2, y + k].active(active: true);
					Main.tile[x - 2, y + k].frameY = frameY;
					Main.tile[x - 2, y + k].frameX = (short)(num - 36);
					Main.tile[x - 2, y + k].type = type;
					Main.tile[x - 1, y + k].active(active: true);
					Main.tile[x - 1, y + k].frameY = frameY;
					Main.tile[x - 1, y + k].frameX = (short)(num - 18);
					Main.tile[x - 1, y + k].type = type;
					Main.tile[x, y + k].active(active: true);
					Main.tile[x, y + k].frameY = frameY;
					Main.tile[x, y + k].frameX = (short)num;
					Main.tile[x, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 18);
					Main.tile[x + 1, y + k].type = type;
					Main.tile[x + 1, y + k].active(active: true);
					Main.tile[x + 1, y + k].frameY = frameY;
					Main.tile[x + 1, y + k].frameX = (short)(num + 36);
					Main.tile[x + 1, y + k].type = type;
				}
			}
		}

		public static void Place3x1(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 2; i++)
			{
				if (Main.tile[i, y] == null)
				{
					Main.tile[i, y] = new Tile();
				}
				if (Main.tile[i, y].active())
				{
					flag = false;
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile2(i, y + 1))
				{
					flag = false;
				}
			}
			if (flag)
			{
				short num = (short)(54 * style);
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 0;
				Main.tile[x - 1, y].frameX = num;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(num + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 0;
				Main.tile[x + 1, y].frameX = (short)(num + 36);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Place3x2(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = false;
			bool flag2 = true;
			if (type == 14 && style == 25)
			{
				flag = true;
			}
			int num = y - 1;
			if (flag)
			{
				num = y;
			}
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = num; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag2 = false;
					}
					if (type == 215 && Main.tile[i, j].liquid > 0)
					{
						flag2 = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				switch (type)
				{
				default:
					if (type != 582 && type != 619)
					{
						if (type == 26 && TileID.Sets.Boulders[Main.tile[i, y + 1].type])
						{
							flag2 = false;
						}
						if (!SolidTile2(i, y + 1))
						{
							flag2 = false;
						}
						break;
					}
					goto case 285;
				case 285:
				case 286:
				case 298:
				case 299:
				case 310:
				case 361:
				case 362:
				case 363:
				case 364:
					if (!SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != 0))
					{
						flag2 = false;
					}
					break;
				}
			}
			if (type == 88)
			{
				if (Chest.CreateChest(x - 1, y - 1) == -1)
				{
					flag2 = false;
				}
				else if (Main.netMode == 1)
				{
					NetMessage.SendData(34, -1, -1, null, 2, x, y, style);
				}
			}
			if (flag2)
			{
				short num2 = (short)(54 * style);
				if (flag)
				{
					Main.tile[x - 1, y].active(active: true);
					Main.tile[x - 1, y].frameY = 0;
					Main.tile[x - 1, y].frameX = num2;
					Main.tile[x - 1, y].type = type;
					Main.tile[x, y].active(active: true);
					Main.tile[x, y].frameY = 0;
					Main.tile[x, y].frameX = (short)(num2 + 18);
					Main.tile[x, y].type = type;
					Main.tile[x + 1, y].active(active: true);
					Main.tile[x + 1, y].frameY = 0;
					Main.tile[x + 1, y].frameX = (short)(num2 + 36);
					Main.tile[x + 1, y].type = type;
					return;
				}
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = 0;
				Main.tile[x - 1, y - 1].frameX = num2;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = 0;
				Main.tile[x, y - 1].frameX = (short)(num2 + 18);
				Main.tile[x, y - 1].type = type;
				Main.tile[x + 1, y - 1].active(active: true);
				Main.tile[x + 1, y - 1].frameY = 0;
				Main.tile[x + 1, y - 1].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = 18;
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = 18;
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
				Main.tile[x + 1, y].active(active: true);
				Main.tile[x + 1, y].frameY = 18;
				Main.tile[x + 1, y].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y].type = type;
			}
		}

		public static void Place2x2Style(int x, int y, ushort type, int style = 0)
		{
			if (x < 5 || x > Main.maxTilesX - 5 || y < 5 || y > Main.maxTilesY - 5)
			{
				return;
			}
			short num = 0;
			if (type == 254)
			{
				num = (short)(x % 12 / 2);
				num = (short)(num * 36);
			}
			bool flag = true;
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!SolidTile(i, y + 1))
				{
					flag = false;
				}
				if (type == 254 && Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 477 && Main.tile[i, y + 1].type != 492 && Main.tile[i, y + 1].type != 109)
				{
					flag = false;
				}
			}
			if (flag)
			{
				short num2 = (short)(36 * style);
				Main.tile[x - 1, y - 1].active(active: true);
				Main.tile[x - 1, y - 1].frameY = num;
				Main.tile[x - 1, y - 1].frameX = num2;
				Main.tile[x - 1, y - 1].type = type;
				Main.tile[x, y - 1].active(active: true);
				Main.tile[x, y - 1].frameY = num;
				Main.tile[x, y - 1].frameX = (short)(num2 + 18);
				Main.tile[x, y - 1].type = type;
				Main.tile[x - 1, y].active(active: true);
				Main.tile[x - 1, y].frameY = (short)(num + 18);
				Main.tile[x - 1, y].frameX = num2;
				Main.tile[x - 1, y].type = type;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].frameY = (short)(num + 18);
				Main.tile[x, y].frameX = (short)(num2 + 18);
				Main.tile[x, y].type = type;
			}
		}

		public static bool NearFriendlyWall(int x, int y)
		{
			try
			{
				if (x < 2 || x >= Main.maxTilesX - 2 || y < 2 || y >= Main.maxTilesY - 2)
				{
					return true;
				}
				if (Main.tile[x, y].wall == 0 || Main.wallHouse[Main.tile[x, y].wall])
				{
					return true;
				}
				if (Main.tile[x - 1, y].wall == 0 || Main.wallHouse[Main.tile[x - 1, y].wall])
				{
					return true;
				}
				if (Main.tile[x + 1, y].wall == 0 || Main.wallHouse[Main.tile[x + 1, y].wall])
				{
					return true;
				}
				if (Main.tile[x, y - 1].wall == 0 || Main.wallHouse[Main.tile[x, y - 1].wall])
				{
					return true;
				}
				if (Main.tile[x, y + 1].wall == 0 || Main.wallHouse[Main.tile[x, y + 1].wall])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static void Check2x2Style(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = j;
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
			{
			}
			num -= num2;
			int num3 = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num3 > 1)
			{
				num3 -= 2;
				num4++;
			}
			num3 = i - num3;
			int num5 = num4 * 36;
			for (int k = num3; k < num3 + 2; k++)
			{
				for (int l = num; l < num + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
					{
						flag = true;
					}
				}
				if (!SolidTileAllowBottomSlope(k, num + 2))
				{
					flag = true;
				}
				else
				{
					if (type != 254)
					{
						continue;
					}
					Tile tile = Main.tile[k, num + 2];
					if (tile != null && tile.active() && tile.type >= 0 && tile.type < 693)
					{
						ushort type2 = tile.type;
						if (type2 != 2 && type2 != 109 && type2 != 477 && type2 != 492)
						{
							flag = true;
						}
					}
				}
			}
			if (!flag)
			{
				return;
			}
			int frameX = Main.tile[i, j].frameX;
			destroyObject = true;
			for (int m = num3; m < num3 + 2; m++)
			{
				for (int n = num; n < num + 2; n++)
				{
					if (Main.tile[m, n] == null)
					{
						Main.tile[m, n] = new Tile();
					}
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			switch (type)
			{
			case 254:
				if (frameX < 72)
				{
					break;
				}
				if (frameX < 108)
				{
					if (genRand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(1, 3));
					}
					break;
				}
				if (frameX < 144)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(2, 6));
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1725, genRand.Next(5, 11));
				if (Main.halloween && genRand.Next(200) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1799);
				}
				break;
			case 457:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3749);
				break;
			case 96:
				if (num4 == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 345);
				}
				if (num4 == 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1791);
				}
				break;
			case 441:
			{
				int num7 = -1;
				switch (num4)
				{
				case 0:
					num7 = 3665;
					break;
				case 1:
					num7 = 3666;
					break;
				case 3:
					num7 = 3667;
					break;
				case 7:
					num7 = 3668;
					break;
				case 8:
					num7 = 3669;
					break;
				case 9:
					num7 = 3670;
					break;
				case 10:
					num7 = 3671;
					break;
				case 11:
					num7 = 3672;
					break;
				case 12:
					num7 = 3673;
					break;
				case 13:
					num7 = 3674;
					break;
				case 14:
					num7 = 3675;
					break;
				case 15:
					num7 = 3676;
					break;
				case 16:
					num7 = 3677;
					break;
				case 17:
					num7 = 3678;
					break;
				case 18:
					num7 = 3679;
					break;
				case 19:
					num7 = 3680;
					break;
				case 20:
					num7 = 3681;
					break;
				case 21:
					num7 = 3682;
					break;
				case 22:
					num7 = 3683;
					break;
				case 28:
					num7 = 3684;
					break;
				case 29:
					num7 = 3685;
					break;
				case 30:
					num7 = 3686;
					break;
				case 31:
					num7 = 3687;
					break;
				case 32:
					num7 = 3688;
					break;
				case 33:
					num7 = 3689;
					break;
				case 34:
					num7 = 3690;
					break;
				case 35:
					num7 = 3691;
					break;
				case 37:
					num7 = 3692;
					break;
				case 39:
					num7 = 3693;
					break;
				case 41:
					num7 = 3694;
					break;
				case 42:
					num7 = 3695;
					break;
				case 43:
					num7 = 3696;
					break;
				case 44:
					num7 = 3697;
					break;
				case 45:
					num7 = 3698;
					break;
				case 46:
					num7 = 3699;
					break;
				case 47:
					num7 = 3700;
					break;
				case 48:
					num7 = 3701;
					break;
				case 49:
					num7 = 3702;
					break;
				case 50:
					num7 = 3703;
					break;
				case 51:
					num7 = 3704;
					break;
				}
				if (num7 != -1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num7);
				}
				break;
			}
			case 468:
			{
				int num6 = -1;
				switch (num4)
				{
				case 0:
					num6 = 3886;
					break;
				case 1:
					num6 = 3887;
					break;
				case 2:
					num6 = 3950;
					break;
				case 3:
					num6 = 3976;
					break;
				case 4:
					num6 = -1;
					break;
				case 5:
					num6 = 4164;
					break;
				case 6:
					num6 = 4185;
					break;
				case 7:
					num6 = 4206;
					break;
				case 8:
					num6 = 4227;
					break;
				case 9:
					num6 = 4266;
					break;
				case 10:
					num6 = 4268;
					break;
				case 11:
					num6 = 4585;
					break;
				case 12:
					num6 = 4713;
					break;
				case 13:
					num6 = -1;
					break;
				case 14:
					num6 = 5167;
					break;
				case 15:
					num6 = 5188;
					break;
				case 16:
					num6 = 5209;
					break;
				}
				if (num6 != -1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, num6);
				}
				break;
			}
			}
			destroyObject = false;
			for (int num8 = num3 - 1; num8 < num3 + 3; num8++)
			{
				for (int num9 = num - 1; num9 < num + 3; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void PlacePumpkin(int x, int superY)
		{
			ushort type = 254;
			int num = genRand.Next(6) * 36;
			if (x < 5 || x > Main.maxTilesX - 5 || superY < 5 || superY > Main.maxTilesY - 5)
			{
				return;
			}
			bool flag = true;
			for (int i = x - 1; i < x + 1; i++)
			{
				for (int j = superY - 1; j < superY + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active() && Main.tile[i, j].type != 3 && Main.tile[i, j].type != 73 && Main.tile[i, j].type != 113 && Main.tile[i, j].type != 110 && (Main.tile[i, j].type != 185 || Main.tile[i, j].frameY != 0))
					{
						flag = false;
					}
					if (Main.tile[i, j].liquid > 0)
					{
						flag = false;
					}
				}
				if (!SolidTile(i, superY + 1) || (Main.tile[i, superY + 1].type != 2 && Main.tile[i, superY + 1].type != 109))
				{
					flag = false;
				}
			}
			if (flag)
			{
				Main.tile[x - 1, superY - 1].active(active: true);
				Main.tile[x - 1, superY - 1].frameY = (short)num;
				Main.tile[x - 1, superY - 1].frameX = 0;
				Main.tile[x - 1, superY - 1].type = type;
				Main.tile[x, superY - 1].active(active: true);
				Main.tile[x, superY - 1].frameY = (short)num;
				Main.tile[x, superY - 1].frameX = 18;
				Main.tile[x, superY - 1].type = type;
				Main.tile[x - 1, superY].active(active: true);
				Main.tile[x - 1, superY].frameY = (short)(num + 18);
				Main.tile[x - 1, superY].frameX = 0;
				Main.tile[x - 1, superY].type = type;
				Main.tile[x, superY].active(active: true);
				Main.tile[x, superY].frameY = (short)(num + 18);
				Main.tile[x, superY].frameX = 18;
				Main.tile[x, superY].type = type;
			}
		}

		public static void GrowPumpkin(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = j;
			int num2;
			for (num2 = Main.tile[i, j].frameY / 18; num2 > 1; num2 -= 2)
			{
			}
			num -= num2;
			int num3 = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num3 > 1)
			{
				num3 -= 2;
				num4++;
			}
			num3 = i - num3;
			int num5 = num4 * 36;
			if (num4 >= 4)
			{
				return;
			}
			for (int k = num3; k < num3 + 2; k++)
			{
				for (int l = num; l < num + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num3) * 18 + num5)
					{
						flag = true;
					}
				}
				if (!SolidTile(k, num + 2) || (Main.tile[k, num + 2].type != 2 && Main.tile[k, num + 2].type != 477 && Main.tile[k, num + 2].type != 492 && Main.tile[k, num + 2].type != 109))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				for (int m = num3; m < num3 + 2; m++)
				{
					for (int n = num; n < num + 2; n++)
					{
						if (Main.tile[m, n] == null)
						{
							Main.tile[m, n] = new Tile();
						}
						if (Main.tile[m, n].type == type && Main.tile[m, n].active())
						{
							Main.tile[m, n].frameX += 36;
						}
					}
				}
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, num3, num, 2, 2);
			}
		}

		public static void FixHearts()
		{
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile.active() && tile.type == 12 && tile.frameX == 0 && tile.frameY == 0)
					{
						FixHeart(i, j);
					}
				}
			}
		}

		public static void DestroyHeart(int i, int j)
		{
			destroyObject = true;
			for (int k = i; k < i + 2; k++)
			{
				for (int l = j; l < j + 2; l++)
				{
					if (k < Main.maxTilesX && l < Main.maxTilesY)
					{
						Tile tile = Main.tile[k, l];
						if (tile.active() && tile.type == 12)
						{
							KillTile(k, l);
						}
					}
				}
			}
			destroyObject = false;
		}

		public static void FixHeart(int i, int j)
		{
			if (i < 40 || i >= Main.maxTilesX - 40 || j < 40 || j >= Main.maxTilesY - 40)
			{
				DestroyHeart(i, j);
				return;
			}
			Tile tile = Main.tile[i, j + 2];
			Tile tile2 = Main.tile[i + 1, j + 2];
			if (tile.active() && !Main.tileSolid[tile.type] && Main.tileCut[tile.type])
			{
				KillTile(i, j + 2);
			}
			if (tile2.active() && !Main.tileSolid[tile2.type] && Main.tileCut[tile2.type])
			{
				KillTile(i + 1, j + 2);
			}
			if (!tile.active())
			{
				if (!tile2.active())
				{
					DestroyHeart(i, j);
					return;
				}
				if (Main.tileSolid[tile2.type])
				{
					tile.type = tile2.type;
					tile.active(active: true);
				}
			}
			if (!tile2.active() && Main.tileSolid[tile.type])
			{
				tile2.type = tile.type;
				tile2.active(active: true);
			}
			if (!tile.nactive() || !Main.tileSolid[tile.type] || !tile2.nactive() || !Main.tileSolid[tile2.type])
			{
				DestroyHeart(i, j);
				return;
			}
			if (tile.blockType() != 0)
			{
				tile.slope(0);
				tile.halfBrick(halfBrick: false);
			}
			if (tile2.blockType() != 0)
			{
				tile2.slope(0);
				tile2.halfBrick(halfBrick: false);
			}
		}

		public static void FixChands()
		{
			for (int i = 5; i < Main.maxTilesX - 5; i++)
			{
				for (int j = 5; j < Main.maxTilesY - 5; j++)
				{
					if (Main.tile[i, j].active())
					{
						int type = Main.tile[i, j].type;
						if (Main.tile[i, j].active() && (type == 35 || type == 36 || type == 170 || type == 171 || type == 172))
						{
							FixChand(i, j);
						}
					}
				}
			}
		}

		public static void FixChand(int i, int j)
		{
			int num = 0;
			int type = Main.tile[i, j].type;
			if (Main.tile[i, j].active())
			{
				if (type == 35)
				{
					num = 1;
				}
				if (type == 36)
				{
					num = 2;
				}
				if (type == 170)
				{
					num = 3;
				}
				if (type == 171)
				{
					num = 4;
				}
				if (type == 172)
				{
					num = 5;
				}
			}
			if (num <= 0)
			{
				return;
			}
			int num2 = i;
			int num3 = j;
			for (num2 = Main.tile[i, j].frameX / 18; num2 >= 3; num2 -= 3)
			{
			}
			if (num2 >= 3)
			{
				num2 -= 3;
			}
			num2 = i - num2;
			num3 += Main.tile[i, j].frameY / 18 * -1;
			for (int k = num2; k < num2 + 3; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (Main.tile[k, l].active() && Main.tile[k, l].type == type)
					{
						Main.tile[k, l].type = 34;
						Main.tile[k, l].frameY = (short)(Main.tile[k, l].frameY + num * 54);
					}
				}
			}
		}

		public static void PlaceChand(int x, int y, ushort type, int style = 0)
		{
			bool flag = true;
			int num = 0;
			for (int i = x - 1; i < x + 2; i++)
			{
				for (int j = y; j < y + 3; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
			{
				flag = false;
			}
			if (flag)
			{
				int num2 = style / 36 * 18 * 6;
				int num3 = style * 18 * 3;
				Main.tile[x - 1, y + num].active(active: true);
				Main.tile[x - 1, y + num].frameY = (short)num3;
				Main.tile[x - 1, y + num].frameX = (short)num2;
				Main.tile[x - 1, y + num].type = type;
				Main.tile[x, y + num].active(active: true);
				Main.tile[x, y + num].frameY = (short)num3;
				Main.tile[x, y + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + num].type = type;
				Main.tile[x + 1, y + num].active(active: true);
				Main.tile[x + 1, y + num].frameY = (short)num3;
				Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + num].type = type;
				Main.tile[x - 1, y + 1 + num].active(active: true);
				Main.tile[x - 1, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 1 + num].type = type;
				Main.tile[x, y + 1 + num].active(active: true);
				Main.tile[x, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 1 + num].type = type;
				Main.tile[x + 1, y + 1 + num].active(active: true);
				Main.tile[x + 1, y + 1 + num].frameY = (short)(num3 + 18);
				Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 1 + num].type = type;
				Main.tile[x - 1, y + 2 + num].active(active: true);
				Main.tile[x - 1, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 2 + num].type = type;
				Main.tile[x, y + 2 + num].active(active: true);
				Main.tile[x, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 2 + num].type = type;
				Main.tile[x + 1, y + 2 + num].active(active: true);
				Main.tile[x + 1, y + 2 + num].frameY = (short)(num3 + 36);
				Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 2 + num].type = type;
			}
		}

		public static void CheckChand(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			int num3 = 3;
			if (type == 454)
			{
				num3 = 4;
			}
			num = Main.tile[i, j].frameX / 18;
			int num4 = 0;
			while (num >= num3)
			{
				num4++;
				num -= num3;
			}
			int num5 = i - num;
			int num6 = 18 * num3 * num4;
			if (num >= num3)
			{
				num -= num3;
			}
			num = i - num;
			num2 = Main.tile[i, j].frameY / 18;
			int num7 = 0;
			while (num2 >= 3)
			{
				num7++;
				num2 -= 3;
			}
			if (num6 >= 108)
			{
				num7 += 37 * (num6 / 108);
			}
			int num8 = 54 * num7;
			if (num6 >= 108)
			{
				num8 -= 54 * (num6 / 108) * 37;
			}
			if (num2 >= 3)
			{
				num2 -= 3;
			}
			num2 = j - num2;
			for (int k = num; k < num + num3; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num5) * 18 + num6 || Main.tile[k, l].frameY != (l - num2) * 18 + num8)
					{
						flag = true;
					}
				}
			}
			if (Main.tile[num + 1, num2 - 1] == null)
			{
				Main.tile[num + 1, num2 - 1] = new Tile();
			}
			if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
			{
				flag = true;
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + num3; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			if (type == 454)
			{
				switch (Main.rand.Next(9))
				{
				case 2:
				case 3:
				case 4:
				{
					int num13 = Main.rand.Next(10, 31);
					while (num13 > 0)
					{
						int num14 = Main.rand.Next(2, 11);
						if (num14 > num13)
						{
							num14 = num13;
						}
						num13 -= num14;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 72, num14);
					}
					break;
				}
				case 5:
				case 6:
				{
					int num17 = Main.rand.Next(60, 80);
					while (num17 > 0)
					{
						int num18 = Main.rand.Next(3, 16);
						if (num18 > num17)
						{
							num18 = num17;
						}
						num17 -= num18;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num18);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
					break;
				}
				case 7:
				{
					int num15 = Main.rand.Next(10, 31);
					while (num15 > 0)
					{
						int num16 = Main.rand.Next(2, 9);
						if (num16 > num15)
						{
							num16 = num15;
						}
						num15 -= num16;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num16);
					}
					if (Main.rand.Next(8) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3532);
					}
					if (Main.rand.Next(8) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3532);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
					break;
				}
				case 8:
				{
					int num9 = 100;
					while (num9 > 0)
					{
						int num10 = Main.rand.Next(3, 16);
						if (num10 > num9)
						{
							num10 = num9;
						}
						num9 -= num10;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 72, num10);
					}
					int num11 = Main.rand.Next(30, 91);
					while (num11 > 0)
					{
						int num12 = Main.rand.Next(7, 14);
						if (num12 > num11)
						{
							num12 = num11;
						}
						num11 -= num12;
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16 - 10, j * 16 - 10, 52, 52, 1349, num12);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1358);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 73);
					break;
				}
				}
			}
			if (type == 34)
			{
				int type2;
				switch (num7)
				{
				case 1:
					type2 = 107;
					break;
				case 2:
					type2 = 108;
					break;
				case 3:
					type2 = 710;
					break;
				case 4:
					type2 = 711;
					break;
				case 5:
					type2 = 712;
					break;
				case 6:
					type2 = 1812;
					break;
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
					type2 = 2055 + num7 - 7;
					break;
				default:
					type2 = ((num7 >= 18 && num7 <= 21) ? (2141 + num7 - 18) : (num7 switch
					{
						22 => 2224, 
						23 => 2525, 
						24 => 2543, 
						25 => 2558, 
						26 => 2573, 
						27 => 2652, 
						28 => 2653, 
						29 => 2654, 
						30 => 2655, 
						31 => 2656, 
						32 => 2657, 
						33 => 2813, 
						34 => 3177, 
						35 => 3179, 
						36 => 3178, 
						37 => 3894, 
						38 => 3938, 
						39 => 3964, 
						40 => 4152, 
						41 => 4173, 
						42 => 4194, 
						43 => 4215, 
						44 => 4305, 
						45 => 4573, 
						46 => 5155, 
						47 => 5176, 
						48 => 5197, 
						_ => 106, 
					}));
					break;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, type2);
			}
			destroyObject = false;
			for (int num19 = num - 1; num19 < num + num3 + 1; num19++)
			{
				for (int num20 = num2 - 1; num20 < num2 + 4; num20++)
				{
					TileFrame(num19, num20);
				}
			}
		}

		public static void Check3x3(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3)
			{
				num3++;
				num -= 3;
			}
			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY / 54;
			int num7 = Main.tile[i, j].frameY % 54 / 18;
			if (num >= 3)
			{
				num -= 3;
			}
			num = i - num;
			num2 -= num7;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 3; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18 + num6 * 54)
					{
						flag = true;
					}
				}
			}
			if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 499 || type == 406 || type == 412 || type == 452 || type == 455 || type == 491 || type == 642)
			{
				for (int m = num; m < num + 3; m++)
				{
					if (Main.tile[m, num2 + 3] == null)
					{
						Main.tile[m, num2 + 3] = new Tile();
					}
					if (!SolidTileAllowBottomSlope(m, num2 + 3))
					{
						flag = true;
						break;
					}
				}
			}
			else
			{
				if (Main.tile[num + 1, num2 - 1] == null)
				{
					Main.tile[num + 1, num2 - 1] = new Tile();
				}
				if (!Main.tile[num + 1, num2 - 1].nactive() || !Main.tileSolid[Main.tile[num + 1, num2 - 1].type] || Main.tileSolidTop[Main.tile[num + 1, num2 - 1].type])
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 3; n++)
			{
				for (int num8 = num2; num8 < num2 + 3; num8++)
				{
					if (Main.tile[n, num8].type == type && Main.tile[n, num8].active())
					{
						KillTile(n, num8);
					}
				}
			}
			switch (type)
			{
			case 106:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 363);
				break;
			case 243:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1430);
				break;
			case 212:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 951);
				break;
			case 219:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 997);
				break;
			case 642:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5296);
				break;
			case 220:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 998);
				break;
			case 228:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1120);
				break;
			case 247:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 1551);
				break;
			case 283:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2172);
				break;
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2192 + type - 300);
				break;
			default:
				switch (type)
				{
				case 307:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2203);
					break;
				case 308:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2204);
					break;
				case 406:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3365);
					break;
				case 452:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3742);
					break;
				case 354:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 2999);
					break;
				case 355:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3000);
					break;
				case 499:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4142);
					break;
				case 412:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3549);
					break;
				case 455:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 3747);
					break;
				case 491:
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4076);
					break;
				case 231:
				{
					int num9 = (i + 1) * 16 + 8;
					int num10 = j * 16;
					Gore.NewGore(new Vector2(num9, num10), default(Vector2), 300);
					Gore.NewGore(new Vector2(num9, num10 + 8), default(Vector2), 301);
					Gore.NewGore(new Vector2(num9, num10 + 16), default(Vector2), 302);
					float num11 = i * 16;
					float num12 = j * 16;
					float num13 = -1f;
					int plr = 0;
					for (int num14 = 0; num14 < 255; num14++)
					{
						if (Main.player[num14].active && !Main.player[num14].dead)
						{
							float num15 = Math.Abs(Main.player[num14].position.X - num11) + Math.Abs(Main.player[num14].position.Y - num12);
							if (num15 < num13 || num13 == -1f)
							{
								plr = num14;
								num13 = num15;
							}
						}
					}
					if (num13 < 4800f && !Main.gameMenu)
					{
						NPC.SpawnOnPlayer(plr, 222);
					}
					break;
				}
				}
				break;
			}
			destroyObject = false;
			for (int num16 = num - 1; num16 < num + 4; num16++)
			{
				for (int num17 = num2 - 1; num17 < num2 + 4; num17++)
				{
					TileFrame(num16, num17);
				}
			}
		}

		public static void Check2x5(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 2)
			{
				num3++;
				num -= 2;
			}
			int num4 = i - num;
			int num5 = 36 * num3;
			int num6 = Main.tile[i, j].frameY % 80 / 18;
			if (num >= 3)
			{
				num -= 2;
			}
			num = i - num;
			num2 -= num6;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 5; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
			}
			for (int m = num; m < num + 2; m++)
			{
				if (Main.tile[m, num2 + 5] == null)
				{
					Main.tile[m, num2 + 5] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 5))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 2; n++)
			{
				for (int num7 = num2; num7 < num2 + 5; num7++)
				{
					if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
					{
						KillTile(n, num7);
					}
				}
			}
			switch (type)
			{
			case 547:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4430 + num3);
				break;
			case 623:
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 5081 + num3);
				break;
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 3; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void Check3x5(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3)
			{
				num3++;
				num -= 3;
			}
			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY % 90 / 18;
			if (num >= 4)
			{
				num -= 3;
			}
			num = i - num;
			num2 -= num6;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 5; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
			}
			for (int m = num; m < num + 3; m++)
			{
				if (Main.tile[m, num2 + 5] == null)
				{
					Main.tile[m, num2 + 5] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 5))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 3; n++)
			{
				for (int num7 = num2; num7 < num2 + 5; num7++)
				{
					if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
					{
						KillTile(n, num7);
					}
				}
			}
			if (type == 613)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4904 + num3);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 6; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void Check3x6(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = i;
			int num2 = j;
			num = Main.tile[i, j].frameX / 18;
			int num3 = 0;
			while (num >= 3)
			{
				num3++;
				num -= 3;
			}
			int num4 = i - num;
			int num5 = 54 * num3;
			int num6 = Main.tile[i, j].frameY % 96 / 18;
			if (num >= 4)
			{
				num -= 3;
			}
			num = i - num;
			num2 -= num6;
			for (int k = num; k < num + 3; k++)
			{
				for (int l = num2; l < num2 + 6; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || Main.tile[k, l].frameX != (k - num4) * 18 + num5 || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
			}
			for (int m = num; m < num + 3; m++)
			{
				if (Main.tile[m, num2 + 6] == null)
				{
					Main.tile[m, num2 + 6] = new Tile();
				}
				if (!SolidTileAllowBottomSlope(m, num2 + 6))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int n = num; n < num + 3; n++)
			{
				for (int num7 = num2; num7 < num2 + 6; num7++)
				{
					if (Main.tile[n, num7].type == type && Main.tile[n, num7].active())
					{
						KillTile(n, num7);
					}
				}
			}
			if (type == 548)
			{
				if (num3 >= 7)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4902 + num3 - 7);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4435 + num3);
				}
			}
			if (type == 614)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 4906);
			}
			destroyObject = false;
			for (int num8 = num - 1; num8 < num + 4; num8++)
			{
				for (int num9 = num2 - 1; num9 < num2 + 7; num9++)
				{
					TileFrame(num8, num9);
				}
			}
		}

		public static void Place3x3(int x, int y, ushort type, int style = 0)
		{
			bool flag = true;
			int num = 0;
			if (type == 106 || type == 212 || type == 219 || type == 220 || type == 228 || type == 231 || type == 243 || type == 247 || type == 283 || (type >= 300 && type <= 308) || type == 354 || type == 355 || type == 642)
			{
				num = -2;
				for (int i = x - 1; i < x + 2; i++)
				{
					for (int j = y - 2; j < y + 1; j++)
					{
						if (Main.tile[i, j] == null)
						{
							Main.tile[i, j] = new Tile();
						}
						if (Main.tile[i, j].active())
						{
							flag = false;
						}
					}
				}
				for (int k = x - 1; k < x + 2; k++)
				{
					if (Main.tile[k, y + 1] == null)
					{
						Main.tile[k, y + 1] = new Tile();
					}
					if (!SolidTile2(k, y + 1))
					{
						flag = false;
						break;
					}
				}
			}
			else
			{
				for (int l = x - 1; l < x + 2; l++)
				{
					for (int m = y; m < y + 3; m++)
					{
						if (Main.tile[l, m] == null)
						{
							Main.tile[l, m] = new Tile();
						}
						if (Main.tile[l, m].active())
						{
							flag = false;
						}
					}
				}
				if (Main.tile[x, y - 1] == null)
				{
					Main.tile[x, y - 1] = new Tile();
				}
				if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[Main.tile[x, y - 1].type] || Main.tileSolidTop[Main.tile[x, y - 1].type])
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num2 = style * 18 * 3;
				Main.tile[x - 1, y + num].active(active: true);
				Main.tile[x - 1, y + num].frameY = 0;
				Main.tile[x - 1, y + num].frameX = (short)num2;
				Main.tile[x - 1, y + num].type = type;
				Main.tile[x, y + num].active(active: true);
				Main.tile[x, y + num].frameY = 0;
				Main.tile[x, y + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + num].type = type;
				Main.tile[x + 1, y + num].active(active: true);
				Main.tile[x + 1, y + num].frameY = 0;
				Main.tile[x + 1, y + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + num].type = type;
				Main.tile[x - 1, y + 1 + num].active(active: true);
				Main.tile[x - 1, y + 1 + num].frameY = 18;
				Main.tile[x - 1, y + 1 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 1 + num].type = type;
				Main.tile[x, y + 1 + num].active(active: true);
				Main.tile[x, y + 1 + num].frameY = 18;
				Main.tile[x, y + 1 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 1 + num].type = type;
				Main.tile[x + 1, y + 1 + num].active(active: true);
				Main.tile[x + 1, y + 1 + num].frameY = 18;
				Main.tile[x + 1, y + 1 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 1 + num].type = type;
				Main.tile[x - 1, y + 2 + num].active(active: true);
				Main.tile[x - 1, y + 2 + num].frameY = 36;
				Main.tile[x - 1, y + 2 + num].frameX = (short)num2;
				Main.tile[x - 1, y + 2 + num].type = type;
				Main.tile[x, y + 2 + num].active(active: true);
				Main.tile[x, y + 2 + num].frameY = 36;
				Main.tile[x, y + 2 + num].frameX = (short)(num2 + 18);
				Main.tile[x, y + 2 + num].type = type;
				Main.tile[x + 1, y + 2 + num].active(active: true);
				Main.tile[x + 1, y + 2 + num].frameY = 36;
				Main.tile[x + 1, y + 2 + num].frameX = (short)(num2 + 36);
				Main.tile[x + 1, y + 2 + num].type = type;
			}
		}

		public static void PlaceSunflower(int x, int y, ushort type = 27)
		{
			if ((double)y > Main.worldSurface - 1.0 && !Main.remixWorld)
			{
				return;
			}
			bool flag = true;
			for (int i = x; i < x + 2; i++)
			{
				for (int j = y - 3; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active() || Main.tile[i, j].wall > 0)
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || (Main.tile[i, y + 1].type != 2 && Main.tile[i, y + 1].type != 109))
				{
					flag = false;
				}
			}
			if (!flag)
			{
				return;
			}
			int num = genRand.Next(3);
			for (int k = 0; k < 2; k++)
			{
				for (int l = -3; l < 1; l++)
				{
					int num2 = k * 18 + genRand.Next(3) * 36;
					if (l <= -2)
					{
						num2 = k * 18 + num * 36;
					}
					int num3 = (l + 3) * 18;
					Main.tile[x + k, y + l].active(active: true);
					Main.tile[x + k, y + l].frameX = (short)num2;
					Main.tile[x + k, y + l].frameY = (short)num3;
					Main.tile[x + k, y + l].type = type;
				}
			}
		}

		public static void FixSunflowers()
		{
			for (int i = 5; i < Main.maxTilesX - 5; i++)
			{
				for (int j = 5; (double)j < Main.worldSurface; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == 27)
					{
						FixSunflower(i, j);
					}
				}
			}
		}

		public static void FixSunflower(int i, int j)
		{
			if (Main.tile[i, j].type != 27)
			{
				return;
			}
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1)
			{
				num -= 2;
			}
			num *= -1;
			num += i;
			int num3 = genRand.Next(3) * 36;
			int num4 = 0;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					Main.tile[k, l].frameX = (short)(num4 + num3);
				}
				num4 += 18;
			}
		}

		public static void CheckSunflower(int i, int j, int type = 27)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1)
			{
				num -= 2;
			}
			num *= -1;
			num += i;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 4; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					int num3;
					for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
					{
					}
					if (!Main.tile[k, l].nactive() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 4] == null)
				{
					Main.tile[k, num2 + 4] = new Tile();
				}
				if (!Main.tile[k, num2 + 4].nactive() || (Main.tile[k, num2 + 4].type != 2 && Main.tile[k, num2 + 4].type != 477 && Main.tile[k, num2 + 4].type != 492 && Main.tile[k, num2 + 4].type != 109 && Main.tile[k, num2 + 4].type != 60 && Main.tile[k, num2 + 4].type != 633))
				{
					flag = true;
				}
				if (!SolidTile(k, num2 + 4))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 4; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, 63);
			destroyObject = false;
		}

		public static void CheckDye(int x, int y)
		{
			switch (Main.tile[x, y].frameX / 34)
			{
			case 7:
				if (!SolidTile(x, y - 1))
				{
					KillTile(x, y);
				}
				break;
			case 6:
				if (!Main.tile[x, y + 1].nactive() || Main.tile[x, y + 1].type != 80)
				{
					KillTile(x, y);
				}
				break;
			default:
				if (!SolidTile(x, y + 1))
				{
					KillTile(x, y);
				}
				break;
			}
		}

		public static void CheckRockGolemHead(int x, int y)
		{
			if (!SolidTileAllowBottomSlope(x, y + 1))
			{
				KillTile(x, y);
			}
		}

		public static void CheckStinkbugBlocker(int x, int y)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			int num = tileSafely.frameX / 18;
			int style = -1;
			if (AttemptReorientingStinkbugBlocker(x, y, tileSafely.wall, ref style))
			{
				if (style != num)
				{
					tileSafely.frameX = (short)(style * 18);
				}
			}
			else
			{
				KillTile(x, y);
			}
		}

		public static bool AttemptReorientingStinkbugBlocker(int x, int y, int wall, ref int style)
		{
			style = -1;
			if (style == -1 && SolidTileAllowBottomSlope(x, y + 1))
			{
				style = 0;
			}
			if (style == -1 && SolidTileAllowBottomSlope(x, y - 1))
			{
				style = 1;
			}
			if (style == -1 && SolidTileAllowBottomSlope(x + 1, y))
			{
				style = 2;
			}
			if (style == -1 && SolidTileAllowBottomSlope(x - 1, y))
			{
				style = 3;
			}
			if (style == -1 && wall > 0)
			{
				style = 4;
			}
			return style > -1;
		}

		public static void CheckGnome(int x, int j)
		{
			if (destroyObject)
			{
				return;
			}
			int num = 567;
			int num2 = j;
			bool flag = true;
			Tile tileSafely = Framing.GetTileSafely(x, num2);
			Tile tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
			if (tileSafely.frameY > 0)
			{
				num2--;
				tileSafely = Framing.GetTileSafely(x, num2);
				tileSafely2 = Framing.GetTileSafely(x, num2 + 1);
			}
			_ = tileSafely.frameX / 28;
			if (tileSafely.frameY == 0 && tileSafely2.frameY == 20 && tileSafely.type == num && tileSafely2.type == num)
			{
				flag = false;
			}
			if (Main.tile[x, num2 + 2] == null)
			{
				Main.tile[x, num2 + 2] = new Tile();
			}
			if (!SolidTileAllowBottomSlope(x, num2 + 2) && !TileID.Sets.Platforms[Main.tile[x, num2 + 2].type])
			{
				flag = true;
			}
			if (flag)
			{
				destroyObject = true;
				if (tileSafely.type == num)
				{
					KillTile(x, num2);
				}
				if (tileSafely2.type == num)
				{
					KillTile(x, num2 + 1);
				}
				Item.NewItem(GetItemSource_FromTileBreak(x, num2), x * 16, num2 * 16, 16, 32, 4609);
				destroyObject = false;
			}
		}

		public static void PlaceGnome(int x, int y, int style)
		{
			PlaceObject(x, y, 567, mute: false, style);
		}

		public static void PlaceDye(int x, int y, int style)
		{
			bool flag = false;
			if (Main.tile[x, y + 1] == null || Main.tile[x, y - 1] == null)
			{
				return;
			}
			if (style == 7)
			{
				if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != 3 && Main.tile[x, y + 1].type != 51 && Main.tile[x, y + 1].type != 61 && Main.tile[x, y + 1].type != 73 && Main.tile[x, y + 1].type != 74 && Main.tile[x, y + 1].type != 184)
				{
					return;
				}
				if (SolidTile(x, y - 1) && !Main.tile[x, y + 1].active())
				{
					flag = true;
				}
			}
			else
			{
				if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != 3 && Main.tile[x, y - 1].type != 51 && Main.tile[x, y - 1].type != 61 && Main.tile[x, y - 1].type != 73 && Main.tile[x, y - 1].type != 74 && Main.tile[x, y - 1].type != 184)
				{
					return;
				}
				if (style == 6)
				{
					if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == 80 && !Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active())
					{
						flag = true;
					}
				}
				else if (SolidTile(x, y + 1) && !Main.tile[x, y - 1].active())
				{
					switch (style)
					{
					case 5:
						if (Main.tile[x, y].liquid == byte.MaxValue && !Main.tile[x, y].lava() && !Main.tile[x, y].honey() && !Main.tile[x, y].shimmer())
						{
							flag = true;
						}
						break;
					case 8:
					case 9:
					case 10:
					case 11:
						flag = true;
						break;
					default:
						if (Main.tile[x, y].liquid != 0)
						{
							break;
						}
						if (style == 3 || style == 4)
						{
							if (Main.tile[x, y].wall == 0)
							{
								flag = true;
							}
						}
						else
						{
							flag = true;
						}
						break;
					}
				}
			}
			if (flag)
			{
				Main.tile[x, y].type = 227;
				Main.tile[x, y].active(active: true);
				Main.tile[x, y].halfBrick(halfBrick: false);
				Main.tile[x, y].slope(0);
				Main.tile[x, y].frameY = 0;
				Main.tile[x, y].frameX = (short)(34 * style);
			}
		}

		public static bool PlacePot(int x, int y, ushort type = 28, int style = 0)
		{
			bool flag = true;
			if (remixWorldGen && (double)x > (double)Main.maxTilesX * 0.48 && (double)x < (double)Main.maxTilesX * 0.52 && y > Main.maxTilesY - 220)
			{
				flag = false;
			}
			for (int i = x; i < x + 2; i++)
			{
				for (int j = y - 1; j < y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					if (Main.tile[i, j].active())
					{
						flag = false;
					}
				}
				if (Main.tile[i, y + 1] == null)
				{
					Main.tile[i, y + 1] = new Tile();
				}
				if (!Main.tile[i, y + 1].nactive() || Main.tile[i, y + 1].halfBrick() || Main.tile[i, y + 1].slope() != 0 || !Main.tileSolid[Main.tile[i, y + 1].type])
				{
					flag = false;
				}
			}
			if (flag)
			{
				int num = genRand.Next(3) * 36;
				for (int k = 0; k < 2; k++)
				{
					for (int l = -1; l < 1; l++)
					{
						int num2 = k * 18 + num;
						int num3 = (l + 1) * 18;
						Main.tile[x + k, y + l].active(active: true);
						Main.tile[x + k, y + l].frameX = (short)num2;
						Main.tile[x + k, y + l].frameY = (short)(num3 + style * 36);
						Main.tile[x + k, y + l].type = type;
						Main.tile[x + k, y + l].halfBrick(halfBrick: false);
					}
				}
				return true;
			}
			return false;
		}

		public static bool CheckCactus(int i, int j)
		{
			int num = j;
			int num2 = i;
			while (Main.tile[num2, num] != null && Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
			{
				num++;
				if (Main.tile[num2, num] == null)
				{
					return false;
				}
				if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
				{
					if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1] != null && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
					{
						num2--;
					}
					if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1] != null && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
					{
						num2++;
					}
				}
			}
			if (!Main.tile[num2, num].nactive() || Main.tile[num2, num].halfBrick() || Main.tile[num2, num].slope() != 0 || (Main.tile[num2, num].type != 53 && Main.tile[num2, num].type != 112 && Main.tile[num2, num].type != 116 && Main.tile[num2, num].type != 234))
			{
				KillTile(i, j);
				return true;
			}
			if (i != num2)
			{
				if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != 80))
				{
					KillTile(i, j);
					return true;
				}
			}
			else if (i == num2 && (!Main.tile[i, j + 1].active() || (Main.tile[i, j + 1].type != 80 && Main.tile[i, j + 1].type != 53 && Main.tile[i, j + 1].type != 112 && Main.tile[i, j + 1].type != 116 && Main.tile[i, j + 1].type != 234)))
			{
				KillTile(i, j);
				return true;
			}
			return false;
		}

		public static void PlantCactus(int i, int j)
		{
			GrowCactus(i, j);
			for (int k = 0; k < 150; k++)
			{
				int i2 = genRand.Next(i - 1, i + 2);
				int j2 = genRand.Next(j - 10, j + 2);
				GrowCactus(i2, j2);
			}
		}

		public static void CheckOrb(int i, int j, int type)
		{
			if (Main.tile[i, j] == null)
			{
				return;
			}
			short frameX = Main.tile[i, j].frameX;
			bool flag = false;
			if (frameX >= 36)
			{
				flag = true;
			}
			if (destroyObject)
			{
				return;
			}
			int num = i;
			int num2 = j;
			num = ((Main.tile[i, j].frameX != 0 && Main.tile[i, j].frameX != 36) ? (i - 1) : i);
			num2 = ((Main.tile[i, j].frameY != 0) ? (j - 1) : j);
			for (int k = 0; k < 2; k++)
			{
				for (int l = 0; l < 2; l++)
				{
					Tile tile = Main.tile[num + k, num2 + l];
					if (tile != null && (!tile.nactive() || tile.type != type))
					{
						destroyObject = true;
						break;
					}
				}
				if (destroyObject)
				{
					break;
				}
				if (type == 12 || type == 639)
				{
					Tile tile = Main.tile[num + k, num2 + 2];
					if (tile != null && !SolidTileAllowBottomSlope(num + k, num2 + 2))
					{
						destroyObject = true;
						break;
					}
				}
			}
			if (!destroyObject)
			{
				return;
			}
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 2; n++)
				{
					if (Main.tile[m, n] != null && Main.tile[m, n].type == type)
					{
						KillTile(m, n);
					}
				}
			}
			if (Main.netMode != 1 && !noTileActions)
			{
				switch (type)
				{
				case 12:
					Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 29);
					break;
				case 639:
					Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 109);
					break;
				case 31:
					if (flag)
					{
						int num3 = Main.rand.Next(5);
						if (!shadowOrbSmashed)
						{
							num3 = 0;
						}
						switch (num3)
						{
						case 0:
						{
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 800, 1, noBroadcast: false, -1);
							int stack = genRand.Next(100, 101);
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 97, stack);
							break;
						}
						case 1:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 1256, 1, noBroadcast: false, -1);
							break;
						case 2:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 802, 1, noBroadcast: false, -1);
							break;
						case 3:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 3062, 1, noBroadcast: false, -1);
							break;
						case 4:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 1290, 1, noBroadcast: false, -1);
							break;
						}
					}
					else
					{
						int num4 = Main.rand.Next(5);
						if (!shadowOrbSmashed)
						{
							num4 = 0;
						}
						switch (num4)
						{
						case 0:
						{
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 96, 1, noBroadcast: false, -1);
							int stack2 = genRand.Next(100, 101);
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 97, stack2);
							break;
						}
						case 1:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 64, 1, noBroadcast: false, -1);
							break;
						case 2:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 162, 1, noBroadcast: false, -1);
							break;
						case 3:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 115, 1, noBroadcast: false, -1);
							break;
						case 4:
							Item.NewItem(GetItemSource_FromTileBreak(num, num2), num * 16, num2 * 16, 32, 32, 111, 1, noBroadcast: false, -1);
							break;
						}
					}
					shadowOrbSmashed = true;
					shadowOrbCount++;
					if (shadowOrbCount >= 3)
					{
						if (!(NPC.AnyNPCs(266) && flag) && (!NPC.AnyNPCs(13) || flag))
						{
							shadowOrbCount = 0;
							float num5 = num * 16;
							float num6 = num2 * 16;
							float num7 = -1f;
							int plr = 0;
							for (int num8 = 0; num8 < 255; num8++)
							{
								float num9 = Math.Abs(Main.player[num8].position.X - num5) + Math.Abs(Main.player[num8].position.Y - num6);
								if (num9 < num7 || num7 == -1f)
								{
									plr = num8;
									num7 = num9;
								}
							}
							if (flag)
							{
								NPC.SpawnOnPlayer(plr, 266);
							}
							else
							{
								NPC.SpawnOnPlayer(plr, 13);
							}
						}
					}
					else
					{
						LocalizedText localizedText = Lang.misc[10];
						if (shadowOrbCount == 2)
						{
							localizedText = Lang.misc[11];
						}
						if (Main.netMode == 0)
						{
							Main.NewText(localizedText.ToString(), 50, byte.MaxValue, 130);
						}
						else if (Main.netMode == 2)
						{
							ChatHelper.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, 255, 130));
						}
					}
					AchievementsHelper.NotifyProgressionEvent(7);
					break;
				}
			}
			if (flag)
			{
				SoundEngine.PlaySound(4, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			destroyObject = false;
		}

		public static void CheckPalmTree(int i, int j)
		{
			int num = -1;
			int num2 = -1;
			int type = Main.tile[i, j].type;
			int frameX = Main.tile[i, j].frameX;
			int frameY = Main.tile[i, j].frameY;
			if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
			{
				num = Main.tile[i, j - 1].type;
			}
			if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
			{
				num2 = Main.tile[i, j + 1].type;
			}
			if (num2 == 53)
			{
				num2 = 53;
			}
			if (num2 == 234)
			{
				num2 = 53;
			}
			if (num2 == 116)
			{
				num2 = 53;
			}
			if (num2 == 112)
			{
				num2 = 53;
			}
			if (num2 != 53 && num2 != type)
			{
				KillTile(i, j);
			}
			if ((Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 220) && num2 != 53)
			{
				KillTile(i, j);
			}
			if (num != type && Main.tile[i, j].frameX <= 44)
			{
				Main.tile[i, j].frameX = (short)(genRand.Next(7, 10) * 22);
			}
			else if (num != type && Main.tile[i, j].frameX == 66)
			{
				Main.tile[i, j].frameX = 220;
			}
			if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}

		public static void CheckTreeWithSettings(int x, int y, CheckTreeSettings settings)
		{
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			Tile tile = Main.tile[x, y];
			int type = tile.type;
			int frameX = tile.frameX;
			int frameY = tile.frameY;
			if (Main.tile[x - 1, y] != null && Main.tile[x - 1, y].active())
			{
				num2 = Main.tile[x - 1, y].type;
			}
			if (Main.tile[x + 1, y] != null && Main.tile[x + 1, y].active())
			{
				num3 = Main.tile[x + 1, y].type;
			}
			if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active())
			{
				num = Main.tile[x, y - 1].type;
			}
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active())
			{
				num4 = Main.tile[x, y + 1].type;
			}
			bool flag = settings.IsGroundValid(num4);
			bool flag2 = num3 == type;
			bool flag3 = num2 == type;
			if (!flag && num4 != type && ((tile.frameX == 0 && tile.frameY <= 130) || (tile.frameX == 22 && tile.frameY <= 130) || (tile.frameX == 44 && tile.frameY <= 130)))
			{
				KillTile(x, y);
			}
			if (tile.frameX >= 22 && tile.frameX <= 44 && tile.frameY >= 132 && tile.frameY <= 176)
			{
				if (!flag)
				{
					KillTile(x, y);
				}
				else if (!(tile.frameX == 22 && flag3) && !(tile.frameX == 44 && flag2))
				{
					KillTile(x, y);
				}
			}
			else if ((tile.frameX == 88 && tile.frameY >= 0 && tile.frameY <= 44) || (tile.frameX == 66 && tile.frameY >= 66 && tile.frameY <= 130) || (tile.frameX == 110 && tile.frameY >= 66 && tile.frameY <= 110) || (tile.frameX == 132 && tile.frameY >= 0 && tile.frameY <= 176))
			{
				if (flag3 && flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 110;
						tile.frameY = 66;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 110;
						tile.frameY = 88;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 110;
						tile.frameY = 110;
					}
				}
				else if (flag3)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 88;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 88;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 88;
						tile.frameY = 44;
					}
				}
				else if (flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 66;
						tile.frameY = 66;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 66;
						tile.frameY = 88;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 66;
						tile.frameY = 110;
					}
				}
				else
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 0;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 0;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 0;
						tile.frameY = 44;
					}
				}
			}
			if (tile.frameY >= 132 && tile.frameY <= 176 && (tile.frameX == 0 || tile.frameX == 66 || tile.frameX == 88))
			{
				if (!flag)
				{
					KillTile(x, y);
				}
				if (!flag3 && !flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 0;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 0;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 0;
						tile.frameY = 44;
					}
				}
				else if (!flag3)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 0;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 0;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 0;
						tile.frameY = 176;
					}
				}
				else if (!flag2)
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 66;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 66;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 66;
						tile.frameY = 176;
					}
				}
				else
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 88;
						tile.frameY = 132;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 88;
						tile.frameY = 154;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 88;
						tile.frameY = 176;
					}
				}
			}
			if ((tile.frameX == 66 && (tile.frameY == 0 || tile.frameY == 22 || tile.frameY == 44)) || (tile.frameX == 44 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
			{
				if (!flag2)
				{
					KillTile(x, y);
				}
			}
			else if ((tile.frameX == 88 && (tile.frameY == 66 || tile.frameY == 88 || tile.frameY == 110)) || (tile.frameX == 66 && (tile.frameY == 198 || tile.frameY == 220 || tile.frameY == 242)))
			{
				if (!flag3)
				{
					KillTile(x, y);
				}
			}
			else if (num4 == -1)
			{
				KillTile(x, y);
			}
			else if (num != type && tile.frameY < 198 && ((tile.frameX != 22 && tile.frameX != 44) || tile.frameY < 132))
			{
				if (flag3 || flag2)
				{
					if (num4 == type)
					{
						if (flag3 && flag2)
						{
							if (tile.frameNumber() == 0)
							{
								tile.frameX = 132;
								tile.frameY = 132;
							}
							if (tile.frameNumber() == 1)
							{
								tile.frameX = 132;
								tile.frameY = 154;
							}
							if (tile.frameNumber() == 2)
							{
								tile.frameX = 132;
								tile.frameY = 176;
							}
						}
						else if (flag3)
						{
							if (tile.frameNumber() == 0)
							{
								tile.frameX = 132;
								tile.frameY = 0;
							}
							if (tile.frameNumber() == 1)
							{
								tile.frameX = 132;
								tile.frameY = 22;
							}
							if (tile.frameNumber() == 2)
							{
								tile.frameX = 132;
								tile.frameY = 44;
							}
						}
						else if (flag2)
						{
							if (tile.frameNumber() == 0)
							{
								tile.frameX = 132;
								tile.frameY = 66;
							}
							if (tile.frameNumber() == 1)
							{
								tile.frameX = 132;
								tile.frameY = 88;
							}
							if (tile.frameNumber() == 2)
							{
								tile.frameX = 132;
								tile.frameY = 110;
							}
						}
					}
					else if (flag3 && flag2)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 154;
							tile.frameY = 132;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 154;
							tile.frameY = 154;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 154;
							tile.frameY = 176;
						}
					}
					else if (flag3)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 154;
							tile.frameY = 0;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 154;
							tile.frameY = 22;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 154;
							tile.frameY = 44;
						}
					}
					else if (flag2)
					{
						if (tile.frameNumber() == 0)
						{
							tile.frameX = 154;
							tile.frameY = 66;
						}
						if (tile.frameNumber() == 1)
						{
							tile.frameX = 154;
							tile.frameY = 88;
						}
						if (tile.frameNumber() == 2)
						{
							tile.frameX = 154;
							tile.frameY = 110;
						}
					}
				}
				else
				{
					if (tile.frameNumber() == 0)
					{
						tile.frameX = 110;
						tile.frameY = 0;
					}
					if (tile.frameNumber() == 1)
					{
						tile.frameX = 110;
						tile.frameY = 22;
					}
					if (tile.frameNumber() == 2)
					{
						tile.frameX = 110;
						tile.frameY = 44;
					}
				}
			}
			if (tile.frameX != frameX && tile.frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(x - 1, y);
				TileFrame(x + 1, y);
				TileFrame(x, y - 1);
				TileFrame(x, y + 1);
			}
		}

		public static void CheckTree(int i, int j)
		{
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int type = Main.tile[i, j].type;
			int frameX = Main.tile[i, j].frameX;
			int frameY = Main.tile[i, j].frameY;
			if (Main.tile[i - 1, j] != null && Main.tile[i - 1, j].active())
			{
				num2 = Main.tile[i - 1, j].type;
			}
			if (Main.tile[i + 1, j] != null && Main.tile[i + 1, j].active())
			{
				num3 = Main.tile[i + 1, j].type;
			}
			if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
			{
				num = Main.tile[i, j - 1].type;
			}
			if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
			{
				num4 = Main.tile[i, j + 1].type;
			}
			if (Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].active())
			{
				_ = Main.tile[i - 1, j - 1].type;
			}
			if (Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].active())
			{
				_ = Main.tile[i + 1, j - 1].type;
			}
			if (Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].active())
			{
				_ = Main.tile[i - 1, j + 1].type;
			}
			if (Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].active())
			{
				_ = Main.tile[i + 1, j + 1].type;
			}
			if (num4 == 23 || num4 == 661)
			{
				num4 = 2;
			}
			if (num4 == 477)
			{
				num4 = 2;
			}
			if (num4 == 60)
			{
				num4 = 2;
			}
			if (num4 == 70)
			{
				num4 = 2;
			}
			if (num4 == 109)
			{
				num4 = 2;
			}
			if (num4 == 147)
			{
				num4 = 2;
			}
			if (num4 == 199 || num4 == 662)
			{
				num4 = 2;
			}
			if (num4 == 492)
			{
				num4 = 2;
			}
			if (num4 != 2 && num4 != type && ((Main.tile[i, j].frameX == 0 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 22 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 44 && Main.tile[i, j].frameY <= 130)))
			{
				KillTile(i, j);
			}
			if (Main.tile[i, j].frameX >= 22 && Main.tile[i, j].frameX <= 44 && Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176)
			{
				if (num4 != 2)
				{
					KillTile(i, j);
				}
				else if ((Main.tile[i, j].frameX != 22 || num2 != type) && (Main.tile[i, j].frameX != 44 || num3 != type))
				{
					KillTile(i, j);
				}
			}
			else if ((Main.tile[i, j].frameX == 88 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 44) || (Main.tile[i, j].frameX == 66 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 130) || (Main.tile[i, j].frameX == 110 && Main.tile[i, j].frameY >= 66 && Main.tile[i, j].frameY <= 110) || (Main.tile[i, j].frameX == 132 && Main.tile[i, j].frameY >= 0 && Main.tile[i, j].frameY <= 176))
			{
				if (num2 == type && num3 == type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 66;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 88;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 110;
					}
				}
				else if (num2 == type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 44;
					}
				}
				else if (num3 == type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 66;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 88;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 110;
					}
				}
				else
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
				}
			}
			if (Main.tile[i, j].frameY >= 132 && Main.tile[i, j].frameY <= 176 && (Main.tile[i, j].frameX == 0 || Main.tile[i, j].frameX == 66 || Main.tile[i, j].frameX == 88))
			{
				if (num4 != 2)
				{
					KillTile(i, j);
				}
				if (num2 != type && num3 != type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 44;
					}
				}
				else if (num2 != type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 132;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 154;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 0;
						Main.tile[i, j].frameY = 176;
					}
				}
				else if (num3 != type)
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 132;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 154;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 66;
						Main.tile[i, j].frameY = 176;
					}
				}
				else
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 132;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 154;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 88;
						Main.tile[i, j].frameY = 176;
					}
				}
			}
			if ((Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 0 || Main.tile[i, j].frameY == 22 || Main.tile[i, j].frameY == 44)) || (Main.tile[i, j].frameX == 44 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242)))
			{
				if (num3 != type)
				{
					KillTile(i, j);
				}
			}
			else if ((Main.tile[i, j].frameX == 88 && (Main.tile[i, j].frameY == 66 || Main.tile[i, j].frameY == 88 || Main.tile[i, j].frameY == 110)) || (Main.tile[i, j].frameX == 66 && (Main.tile[i, j].frameY == 198 || Main.tile[i, j].frameY == 220 || Main.tile[i, j].frameY == 242)))
			{
				if (num2 != type)
				{
					KillTile(i, j);
				}
			}
			else if (num4 == -1 || num4 == 23)
			{
				KillTile(i, j);
			}
			else if (num != type && Main.tile[i, j].frameY < 198 && ((Main.tile[i, j].frameX != 22 && Main.tile[i, j].frameX != 44) || Main.tile[i, j].frameY < 132))
			{
				if (num2 == type || num3 == type)
				{
					if (num4 == type)
					{
						if (num2 == type && num3 == type)
						{
							if (Main.tile[i, j].frameNumber() == 0)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 132;
							}
							if (Main.tile[i, j].frameNumber() == 1)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 154;
							}
							if (Main.tile[i, j].frameNumber() == 2)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 176;
							}
						}
						else if (num2 == type)
						{
							if (Main.tile[i, j].frameNumber() == 0)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 0;
							}
							if (Main.tile[i, j].frameNumber() == 1)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 22;
							}
							if (Main.tile[i, j].frameNumber() == 2)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 44;
							}
						}
						else if (num3 == type)
						{
							if (Main.tile[i, j].frameNumber() == 0)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 66;
							}
							if (Main.tile[i, j].frameNumber() == 1)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 88;
							}
							if (Main.tile[i, j].frameNumber() == 2)
							{
								Main.tile[i, j].frameX = 132;
								Main.tile[i, j].frameY = 110;
							}
						}
					}
					else if (num2 == type && num3 == type)
					{
						if (Main.tile[i, j].frameNumber() == 0)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 132;
						}
						if (Main.tile[i, j].frameNumber() == 1)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 154;
						}
						if (Main.tile[i, j].frameNumber() == 2)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 176;
						}
					}
					else if (num2 == type)
					{
						if (Main.tile[i, j].frameNumber() == 0)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 0;
						}
						if (Main.tile[i, j].frameNumber() == 1)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 22;
						}
						if (Main.tile[i, j].frameNumber() == 2)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 44;
						}
					}
					else if (num3 == type)
					{
						if (Main.tile[i, j].frameNumber() == 0)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 66;
						}
						if (Main.tile[i, j].frameNumber() == 1)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 88;
						}
						if (Main.tile[i, j].frameNumber() == 2)
						{
							Main.tile[i, j].frameX = 154;
							Main.tile[i, j].frameY = 110;
						}
					}
				}
				else
				{
					if (Main.tile[i, j].frameNumber() == 0)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 0;
					}
					if (Main.tile[i, j].frameNumber() == 1)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 22;
					}
					if (Main.tile[i, j].frameNumber() == 2)
					{
						Main.tile[i, j].frameX = 110;
						Main.tile[i, j].frameY = 44;
					}
				}
			}
			if (Main.tile[i, j].frameX != frameX && Main.tile[i, j].frameY != frameY && frameX >= 0 && frameY >= 0)
			{
				TileFrame(i - 1, j);
				TileFrame(i + 1, j);
				TileFrame(i, j - 1);
				TileFrame(i, j + 1);
			}
		}

		public static bool TileIsExposedToAir(int x, int y)
		{
			if (!InWorld(x, y, 2))
			{
				return false;
			}
			for (int i = x - 1; i <= x + 1; i++)
			{
				for (int j = y - 1; j <= y + 1; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile != null && (!tile.active() || !Main.tileSolid[tile.type] || TileID.Sets.Platforms[tile.type]))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void Convert(int i, int j, int conversionType, int size = 4)
		{
			for (int k = i - size; k <= i + size; k++)
			{
				for (int l = j - size; l <= j + size; l++)
				{
					if (!InWorld(k, l, 1) || Math.Abs(k - i) + Math.Abs(l - j) >= 6)
					{
						continue;
					}
					Tile tile = Main.tile[k, l];
					int type = tile.type;
					int wall = tile.wall;
					switch (conversionType)
					{
					case 4:
						if (type <= 693 && wall <= 347)
						{
							if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
							{
								tile.wall = 81;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
							{
								tile.wall = 83;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
							{
								tile.wall = 218;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
							{
								tile.wall = 221;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
							{
								tile.wall = 192;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
							{
								tile.wall = 193;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
							{
								tile.wall = 194;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
							{
								tile.wall = 195;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
							{
								tile.type = 203;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.JungleGrass[type] && type != 662)
							{
								tile.type = 662;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Grass[type] && type != 199)
							{
								tile.type = 199;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Ice[type] && type != 200)
							{
								tile.type = 200;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Sand[type] && type != 234)
							{
								tile.type = 234;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
							{
								tile.type = 399;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
							{
								tile.type = 401;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
							{
								tile.type = 352;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
						}
						continue;
					case 2:
						if (type > 693 || wall > 347)
						{
							continue;
						}
						if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
						{
							tile.wall = 70;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
						{
							tile.wall = 28;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
						{
							tile.wall = 219;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
						{
							tile.wall = 222;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
						{
							tile.wall = 200;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
						{
							tile.wall = 201;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
						{
							tile.wall = 202;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
						{
							tile.wall = 203;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
						{
							tile.type = 117;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
						{
							tile.type = 492;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
						{
							tile.type = 109;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Ice[type] && type != 164)
						{
							tile.type = 164;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Sand[type] && type != 116)
						{
							tile.type = 116;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
						{
							tile.type = 402;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
						{
							tile.type = 403;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type])
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						if (type == 59 && (Main.tile[k - 1, l].type == 109 || Main.tile[k + 1, l].type == 109 || Main.tile[k, l - 1].type == 109 || Main.tile[k, l + 1].type == 109))
						{
							tile.type = 0;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						continue;
					case 1:
						if (type <= 693 && wall <= 347)
						{
							if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
							{
								tile.wall = 69;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.JungleGrass[type] && type != 661)
							{
								tile.type = 661;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
							{
								tile.wall = 3;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
							{
								tile.wall = 217;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
							{
								tile.wall = 220;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
							{
								tile.wall = 188;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
							{
								tile.wall = 189;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
							{
								tile.wall = 190;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
							{
								tile.wall = 191;
								SquareWallFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
							{
								tile.type = 25;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Grass[type] && type != 23)
							{
								tile.type = 23;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Ice[type] && type != 163)
							{
								tile.type = 163;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Sand[type] && type != 112)
							{
								tile.type = 112;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
							{
								tile.type = 398;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
							{
								tile.type = 400;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
							else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
							{
								tile.type = 32;
								SquareTileFrame(k, l);
								NetMessage.SendTileSquare(-1, k, l);
							}
						}
						continue;
					case 3:
						if (WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
						{
							tile.wall = 80;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if (tile.type == 60)
						{
							tile.type = 70;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type])
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						continue;
					case 5:
						if (type < 0 || type > 693 || wall < 0 || wall > 347)
						{
							continue;
						}
						if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 187)
						{
							tile.wall = 187;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 216)
						{
							tile.wall = 216;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 53)
						{
							if (BlockBelowMakesSandConvertIntoHardenedSand(k, l))
							{
								tile.type = 397;
							}
							else
							{
								tile.type = 53;
							}
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
						{
							tile.type = 397;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 396)
						{
							tile.type = 396;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						continue;
					case 6:
						if (type < 0 || type > 693 || wall < 0 || wall > 347)
						{
							continue;
						}
						if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.NewWall1[wall] || WallID.Sets.Conversion.NewWall2[wall] || WallID.Sets.Conversion.NewWall3[wall] || WallID.Sets.Conversion.NewWall4[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 71)
						{
							tile.wall = 71;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Dirt[wall] || WallID.Sets.Conversion.Snow[wall]) && wall != 40)
						{
							tile.wall = 40;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 147)
						{
							tile.type = 147;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 161)
						{
							tile.type = 161;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						continue;
					case 7:
						if (type < 0 || type > 693 || wall < 0 || wall > 347)
						{
							continue;
						}
						if ((WallID.Sets.Conversion.Stone[wall] || WallID.Sets.Conversion.Ice[wall] || WallID.Sets.Conversion.Sandstone[wall]) && wall != 1)
						{
							tile.wall = 1;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if ((WallID.Sets.Conversion.HardenedSand[wall] || WallID.Sets.Conversion.Snow[wall] || WallID.Sets.Conversion.Dirt[wall]) && wall != 2)
						{
							tile.wall = 2;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 196)
						{
							tile.wall = 196;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 197)
						{
							tile.wall = 197;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 198)
						{
							tile.wall = 198;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 199)
						{
							tile.wall = 199;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						if ((TileID.Sets.Conversion.Stone[type] || TileID.Sets.Conversion.Ice[type] || TileID.Sets.Conversion.Sandstone[type]) && type != 1)
						{
							tile.type = 1;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.GolfGrass[type] && type != 477)
						{
							tile.type = 477;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
						{
							tile.type = 2;
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if ((TileID.Sets.Conversion.Sand[type] || TileID.Sets.Conversion.HardenedSand[type] || TileID.Sets.Conversion.Snow[type] || TileID.Sets.Conversion.Dirt[type]) && type != 0)
						{
							if (TileIsExposedToAir(k, l))
							{
								tile.type = 2;
							}
							else
							{
								tile.type = 0;
							}
							SquareTileFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else if (TileID.Sets.Conversion.Thorn[type] && type != 69)
						{
							KillTile(k, l);
							if (Main.netMode == 1)
							{
								NetMessage.SendData(17, -1, -1, null, 0, k, l);
							}
						}
						continue;
					}
					if (tile.wall == 69 || tile.wall == 70 || tile.wall == 81)
					{
						if ((double)l < Main.worldSurface)
						{
							if (genRand.Next(10) == 0)
							{
								tile.wall = 65;
							}
							else
							{
								tile.wall = 63;
							}
						}
						else
						{
							tile.wall = 64;
						}
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall != 1 && wall != 262 && wall != 274 && wall != 61 && wall != 185)
					{
						tile.wall = 1;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall == 262)
					{
						tile.wall = 61;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.Stone[wall] && wall == 274)
					{
						tile.wall = 185;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
					{
						tile.wall = 212;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
					{
						tile.wall = 213;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
					{
						tile.wall = 214;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
					{
						tile.wall = 215;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (tile.wall == 80)
					{
						if ((double)l < Main.worldSurface + 4.0 + (double)genRand.Next(3) || (double)l > ((double)Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double)genRand.Next(3))
						{
							tile.wall = 15;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
						else
						{
							tile.wall = 64;
							SquareWallFrame(k, l);
							NetMessage.SendTileSquare(-1, k, l);
						}
					}
					else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
					{
						tile.wall = 216;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
					{
						tile.wall = 187;
						SquareWallFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					if (tile.type == 492)
					{
						tile.type = 477;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.JungleGrass[type] && type != 60)
					{
						tile.type = 60;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Grass[type] && type != 2 && type != 477)
					{
						tile.type = 2;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Stone[type] && type != 1)
					{
						tile.type = 1;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Sand[type] && type != 53)
					{
						tile.type = 53;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
					{
						tile.type = 397;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
					{
						tile.type = 396;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.Ice[type] && type != 161)
					{
						tile.type = 161;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (TileID.Sets.Conversion.MushroomGrass[type])
					{
						tile.type = 60;
						SquareTileFrame(k, l);
						NetMessage.SendTileSquare(-1, k, l);
					}
					else if (tile.type == 32 || Main.tile[k, l].type == 352)
					{
						KillTile(k, l);
						if (Main.netMode == 1)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
				}
			}
		}

		public static void CactusFrame(int i, int j)
		{
			try
			{
				int num = j;
				int num2 = i;
				if (CheckCactus(i, j))
				{
					return;
				}
				while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
				{
					num++;
					if (Main.tile[num2, num] == null)
					{
						return;
					}
					if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
					{
						if (Main.tile[num2 - 1, num] != null && Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
						{
							num2--;
						}
						if (Main.tile[num2 + 1, num] != null && Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
						{
							num2++;
						}
					}
				}
				num--;
				int num3 = i - num2;
				num2 = i;
				num = j;
				if (Main.tile[i - 2, j] == null)
				{
					return;
				}
				int type = Main.tile[i - 2, j].type;
				if (Main.tile[i - 1, j] == null)
				{
					return;
				}
				int num4 = Main.tile[i - 1, j].type;
				if (Main.tile[i + 1, j] == null)
				{
					return;
				}
				int num5 = Main.tile[i + 1, j].type;
				if (Main.tile[i, j - 1] == null)
				{
					return;
				}
				int num6 = Main.tile[i, j - 1].type;
				if (num6 == 227)
				{
					num6 = 80;
				}
				int num7 = Main.tile[i, j + 1].type;
				int num8 = Main.tile[i - 1, j + 1].type;
				int num9 = Main.tile[i + 1, j + 1].type;
				if (!Main.tile[i - 1, j].active())
				{
					num4 = -1;
				}
				if (!Main.tile[i + 1, j].active())
				{
					num5 = -1;
				}
				if (!Main.tile[i, j - 1].active())
				{
					num6 = -1;
				}
				if (!Main.tile[i, j + 1].active())
				{
					num7 = -1;
				}
				if (!Main.tile[i - 1, j + 1].active())
				{
					num8 = -1;
				}
				if (!Main.tile[i + 1, j + 1].active())
				{
					num9 = -1;
				}
				short num10 = Main.tile[i, j].frameX;
				short num11 = Main.tile[i, j].frameY;
				switch (num3)
				{
				case 0:
					if (num6 != 80)
					{
						if (num4 == 80 && num5 == 80 && num8 != 80 && num9 != 80 && type != 80)
						{
							num10 = 90;
							num11 = 0;
						}
						else if (num4 == 80 && num8 != 80 && type != 80)
						{
							num10 = 72;
							num11 = 0;
						}
						else if (num5 == 80 && num9 != 80)
						{
							num10 = 18;
							num11 = 0;
						}
						else
						{
							num10 = 0;
							num11 = 0;
						}
					}
					else if (num4 == 80 && num5 == 80 && num8 != 80 && num9 != 80 && type != 80)
					{
						num10 = 90;
						num11 = 36;
					}
					else if (num4 == 80 && num8 != 80 && type != 80)
					{
						num10 = 72;
						num11 = 36;
					}
					else if (num5 == 80 && num9 != 80)
					{
						num10 = 18;
						num11 = 36;
					}
					else if (num7 >= 0 && Main.tileSolid[num7])
					{
						num10 = 0;
						num11 = 36;
					}
					else
					{
						num10 = 0;
						num11 = 18;
					}
					break;
				case -1:
					if (num5 == 80)
					{
						if (num6 != 80 && num7 != 80)
						{
							num10 = 108;
							num11 = 36;
						}
						else if (num7 != 80)
						{
							num10 = 54;
							num11 = 36;
						}
						else if (num6 != 80)
						{
							num10 = 54;
							num11 = 0;
						}
						else
						{
							num10 = 54;
							num11 = 18;
						}
					}
					else if (num6 != 80)
					{
						num10 = 54;
						num11 = 0;
					}
					else
					{
						num10 = 54;
						num11 = 18;
					}
					break;
				case 1:
					if (num4 == 80)
					{
						if (num6 != 80 && num7 != 80)
						{
							num10 = 108;
							num11 = 18;
						}
						else if (num7 != 80)
						{
							num10 = 36;
							num11 = 36;
						}
						else if (num6 != 80)
						{
							num10 = 36;
							num11 = 0;
						}
						else
						{
							num10 = 36;
							num11 = 18;
						}
					}
					else if (num6 != 80)
					{
						num10 = 36;
						num11 = 0;
					}
					else
					{
						num10 = 36;
						num11 = 18;
					}
					break;
				}
				if (num10 != Main.tile[i, j].frameX || num11 != Main.tile[i, j].frameY)
				{
					Main.tile[i, j].frameX = num10;
					Main.tile[i, j].frameY = num11;
					DiamondTileFrame(i, j);
				}
			}
			catch
			{
				Main.tile[i, j].frameX = 0;
				Main.tile[i, j].frameY = 0;
			}
		}

		public static void GrowCactus(int i, int j)
		{
			int num = j;
			int num2 = i;
			if (!Main.tile[i, j].nactive() || Main.tile[i, j].halfBrick() || (!gen && Main.tile[i, j].slope() != 0) || Main.tile[i, j - 1].liquid > 0 || (Main.tile[i, j].type != 53 && Main.tile[i, j].type != 80 && Main.tile[i, j].type != 234 && Main.tile[i, j].type != 112 && Main.tile[i, j].type != 116))
			{
				return;
			}
			int num3 = 0;
			for (int k = i - cactusWaterWidth; k < i + cactusWaterWidth; k++)
			{
				for (int l = j - cactusWaterHeight; l < j + cactusWaterHeight; l++)
				{
					num3 += Main.tile[k, l].liquid;
				}
			}
			if ((!Main.remixWorld || !((double)j > Main.worldSurface)) && num3 / 255 > cactusWaterLimit)
			{
				return;
			}
			if (Main.tile[i, j].type == 53 || Main.tile[i, j].type == 112 || Main.tile[i, j].type == 116 || Main.tile[i, j].type == 234)
			{
				if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
				{
					return;
				}
				int num4 = 0;
				int num5 = 0;
				for (int m = i - 6; m <= i + 6; m++)
				{
					for (int n = j - 3; n <= j + 1; n++)
					{
						try
						{
							if (!Main.tile[m, n].active())
							{
								continue;
							}
							if (Main.tile[m, n].type == 80)
							{
								num4++;
								if (num4 >= 4)
								{
									return;
								}
							}
							if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 116 || Main.tile[m, n].type == 234)
							{
								num5++;
							}
						}
						catch
						{
						}
					}
				}
				if (num5 > 10)
				{
					if (gen && genRand.Next(2) == 0)
					{
						Main.tile[i, j].slope(0);
					}
					Main.tile[i, j - 1].active(active: true);
					Main.tile[i, j - 1].type = 80;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j - 1);
					}
					SquareTileFrame(num2, num - 1);
				}
			}
			else
			{
				if (Main.tile[i, j].type != 80)
				{
					return;
				}
				while (Main.tile[num2, num].active() && Main.tile[num2, num].type == 80)
				{
					num++;
					if (!Main.tile[num2, num].active() || Main.tile[num2, num].type != 80)
					{
						if (Main.tile[num2 - 1, num].active() && Main.tile[num2 - 1, num].type == 80 && Main.tile[num2 - 1, num - 1].active() && Main.tile[num2 - 1, num - 1].type == 80 && num2 >= i)
						{
							num2--;
						}
						if (Main.tile[num2 + 1, num].active() && Main.tile[num2 + 1, num].type == 80 && Main.tile[num2 + 1, num - 1].active() && Main.tile[num2 + 1, num - 1].type == 80 && num2 <= i)
						{
							num2++;
						}
					}
				}
				num--;
				int num6 = num - j;
				int num7 = i - num2;
				num2 = i - num7;
				num = j;
				int num8 = 11 - num6;
				int num9 = 0;
				for (int num10 = num2 - 2; num10 <= num2 + 2; num10++)
				{
					for (int num11 = num - num8; num11 <= num + num6; num11++)
					{
						if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 80)
						{
							num9++;
						}
					}
				}
				if (Main.drunkWorld)
				{
					if (num9 >= genRand.Next(11, 20))
					{
						return;
					}
				}
				else if (num9 >= genRand.Next(11, 13))
				{
					return;
				}
				num2 = i;
				num = j;
				if (num7 == 0)
				{
					if (num6 == 0)
					{
						if (!Main.tile[num2, num - 1].active())
						{
							Main.tile[num2, num - 1].active(active: true);
							Main.tile[num2, num - 1].type = 80;
							SquareTileFrame(num2, num - 1);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num2, num - 1);
							}
						}
						return;
					}
					bool flag = false;
					bool flag2 = false;
					if (Main.tile[num2, num - 1].active() && Main.tile[num2, num - 1].type == 80)
					{
						if (!Main.tile[num2 - 1, num].active() && !Main.tile[num2 - 2, num + 1].active() && !Main.tile[num2 - 1, num - 1].active() && !Main.tile[num2 - 1, num + 1].active() && !Main.tile[num2 - 2, num].active())
						{
							flag = true;
						}
						if (!Main.tile[num2 + 1, num].active() && !Main.tile[num2 + 2, num + 1].active() && !Main.tile[num2 + 1, num - 1].active() && !Main.tile[num2 + 1, num + 1].active() && !Main.tile[num2 + 2, num].active())
						{
							flag2 = true;
						}
					}
					int num12 = genRand.Next(3);
					if (num12 == 0 && flag)
					{
						Main.tile[num2 - 1, num].active(active: true);
						Main.tile[num2 - 1, num].type = 80;
						SquareTileFrame(num2 - 1, num);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num2 - 1, num);
						}
					}
					else if (num12 == 1 && flag2)
					{
						Main.tile[num2 + 1, num].active(active: true);
						Main.tile[num2 + 1, num].type = 80;
						SquareTileFrame(num2 + 1, num);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num2 + 1, num);
						}
					}
					else
					{
						if (num6 >= genRand.Next(2, 8))
						{
							return;
						}
						if (Main.tile[num2 - 1, num - 1].active())
						{
							_ = Main.tile[num2 - 1, num - 1].type;
							_ = 80;
						}
						if ((!Main.tile[num2 + 1, num - 1].active() || Main.tile[num2 + 1, num - 1].type != 80) && !Main.tile[num2, num - 1].active())
						{
							Main.tile[num2, num - 1].active(active: true);
							Main.tile[num2, num - 1].type = 80;
							SquareTileFrame(num2, num - 1);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num2, num - 1);
							}
						}
					}
				}
				else if (!Main.tile[num2, num - 1].active() && !Main.tile[num2, num - 2].active() && !Main.tile[num2 + num7, num - 1].active() && Main.tile[num2 - num7, num - 1].active() && Main.tile[num2 - num7, num - 1].type == 80)
				{
					Main.tile[num2, num - 1].active(active: true);
					Main.tile[num2, num - 1].type = 80;
					SquareTileFrame(num2, num - 1);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num2, num - 1);
					}
				}
			}
		}

		public static void CheckPot(int i, int j, int type = 28)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = j;
			for (num += Main.tile[i, j].frameX / 18; num > 1; num -= 2)
			{
			}
			num *= -1;
			num += i;
			int num3 = Main.tile[i, j].frameY / 18;
			int num4 = 0;
			while (num3 > 1)
			{
				num3 -= 2;
				num4++;
			}
			num2 -= num3;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					int num5;
					for (num5 = Main.tile[k, l].frameX / 18; num5 > 1; num5 -= 2)
					{
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num5 != k - num || Main.tile[k, l].frameY != (l - num2) * 18 + num4 * 36)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 2] == null)
				{
					Main.tile[k, num2 + 2] = new Tile();
				}
				if (!SolidTile2(k, num2 + 2))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			destroyObject = true;
			if (num4 >= 7 && num4 <= 9)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else if (num4 >= 16 && num4 <= 24)
			{
				SoundEngine.PlaySound(4, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 2; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						KillTile(m, n);
					}
				}
			}
			switch (num4)
			{
			case 0:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 51);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 52);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 53);
				break;
			case 1:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 166);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 167);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 168);
				break;
			case 2:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 169);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 170);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 171);
				break;
			case 3:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 172);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 173);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 174);
				break;
			case 4:
			case 5:
			case 6:
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 197);
				Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 198);
				break;
			default:
				if (num4 >= 7 && num4 <= 9)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 199);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 200);
				}
				else if (num4 >= 10 && num4 <= 12)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 201);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 202);
				}
				else if (num4 >= 13 && num4 <= 15)
				{
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 203);
					Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 204);
				}
				else
				{
					if ((num4 >= 16 && num4 <= 18) || (num4 >= 19 && num4 <= 21) || (num4 >= 22 && num4 <= 24))
					{
						break;
					}
					if (num4 >= 25 && num4 <= 27)
					{
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(217, 220));
					}
					else if (num4 >= 28 && num4 <= 30)
					{
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), genRand.Next(315, 317));
					}
					else if (num4 >= 31 && num4 <= 33)
					{
						int num6 = genRand.Next(2, 5);
						for (int num7 = 0; num7 < num6; num7++)
						{
							Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 698 + genRand.Next(6));
						}
					}
					else if (num4 >= 34 && num4 <= 36)
					{
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1122);
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1123);
						Gore.NewGore(new Vector2(i * 16, j * 16), default(Vector2), 1124);
					}
				}
				break;
			}
			if (Main.netMode != 1 && type != 653)
			{
				SpawnThingsFromPot(i, j, num, num2, num4);
			}
			destroyObject = false;
		}

		private static void SpawnThingsFromPot(int i, int j, int x2, int y2, int style)
		{
			bool flag = (double)j < Main.rockLayer;
			bool flag2 = j < Main.UnderworldLayer;
			if (Main.remixWorld)
			{
				flag = (double)j > Main.rockLayer && j < Main.UnderworldLayer;
				flag2 = (double)j > Main.worldSurface && (double)j < Main.rockLayer;
			}
			float num = 1f;
			bool flag3 = style >= 34 && style <= 36;
			switch (style)
			{
			case 4:
			case 5:
			case 6:
				num = 1.25f;
				break;
			default:
				if (style >= 7 && style <= 9)
				{
					num = 1.75f;
				}
				else if (style >= 10 && style <= 12)
				{
					num = 1.9f;
				}
				else if (style >= 13 && style <= 15)
				{
					num = 2.1f;
				}
				else if (style >= 16 && style <= 18)
				{
					num = 1.6f;
				}
				else if (style >= 19 && style <= 21)
				{
					num = 3.5f;
				}
				else if (style >= 22 && style <= 24)
				{
					num = 1.6f;
				}
				else if (style >= 25 && style <= 27)
				{
					num = 10f;
				}
				else if (style >= 28 && style <= 30)
				{
					if (Main.hardMode)
					{
						num = 4f;
					}
				}
				else if (style >= 31 && style <= 33)
				{
					num = 2f;
				}
				else if (style >= 34 && style <= 36)
				{
					num = 1.25f;
				}
				break;
			case 0:
			case 1:
			case 2:
			case 3:
				break;
			}
			num = (num * 2f + 1f) / 3f;
			int range = (int)(500f / ((num + 1f) / 2f));
			if (gen)
			{
				return;
			}
			if (Player.GetClosestRollLuck(i, j, range) == 0f)
			{
				if (Main.netMode != 1)
				{
					Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 16, j * 16 + 16, 0f, -12f, 518, 0, 0f, Main.myPlayer);
				}
				return;
			}
			if (genRand.Next(35) == 0 && Main.wallDungeon[Main.tile[i, j].wall] && (double)j > Main.worldSurface)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 327);
				return;
			}
			if (Main.getGoodWorld && genRand.Next(6) == 0)
			{
				Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 16, j * 16 + 8, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Main.myPlayer, 16f, 16f);
				return;
			}
			if (Main.remixWorld && Main.netMode != 1 && genRand.Next(5) == 0)
			{
				Player player = Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)];
				if (Main.rand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
				}
				else if (player.ZoneJungle)
				{
					int num2 = -1;
					num2 = NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -10);
					if (num2 > -1)
					{
						Main.npc[num2].ai[1] = 75f;
						Main.npc[num2].netUpdate = true;
					}
				}
				else if ((double)j > Main.rockLayer && j < Main.maxTilesY - 350)
				{
					int num3 = -1;
					num3 = ((Main.rand.Next(9) == 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -7) : ((Main.rand.Next(7) == 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -8) : ((Main.rand.Next(6) == 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -9) : ((Main.rand.Next(3) != 0) ? NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, 1) : NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -3)))));
					if (num3 > -1)
					{
						Main.npc[num3].ai[1] = 75f;
						Main.npc[num3].netUpdate = true;
					}
				}
				else if ((double)j > Main.worldSurface && (double)j <= Main.rockLayer)
				{
					int num4 = -1;
					num4 = NPC.NewNPC(NPC.GetSpawnSourceForNaturalSpawn(), x2 * 16 + 16, y2 * 16 + 32, -6);
					if (num4 > -1)
					{
						Main.npc[num4].ai[1] = 75f;
						Main.npc[num4].netUpdate = true;
					}
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 75);
				}
				return;
			}
			if (Main.remixWorld && (double)i > (double)Main.maxTilesX * 0.37 && (double)i < (double)Main.maxTilesX * 0.63 && j > Main.maxTilesY - 220)
			{
				int stack = Main.rand.Next(20, 41);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, stack);
				return;
			}
			if (genRand.Next(45) == 0 || (Main.rand.Next(45) == 0 && Main.expertMode))
			{
				if ((double)j < Main.worldSurface)
				{
					int num5 = genRand.Next(10);
					if (num5 == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 292);
					}
					if (num5 == 1)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
					}
					if (num5 == 2)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
					}
					if (num5 == 3)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
					}
					if (num5 == 4)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
					}
					if (num5 == 5)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2324);
					}
					if (num5 == 6)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2325);
					}
					if (num5 >= 7)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
					}
				}
				else if (flag)
				{
					int num6 = genRand.Next(11);
					if (num6 == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 289);
					}
					if (num6 == 1)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 298);
					}
					if (num6 == 2)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
					}
					if (num6 == 3)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 290);
					}
					if (num6 == 4)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
					}
					if (num6 == 5)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 291);
					}
					if (num6 == 6)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
					}
					if (num6 == 7)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
					}
					if (num6 == 8)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
					}
					if (num6 >= 7)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
					}
				}
				else if (flag2)
				{
					int num7 = genRand.Next(15);
					if (num7 == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
					}
					if (num7 == 1)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
					}
					if (num7 == 2)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 299);
					}
					if (num7 == 3)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
					}
					if (num7 == 4)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 303);
					}
					if (num7 == 5)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
					}
					if (num7 == 6)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
					}
					if (num7 == 7)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
					}
					if (num7 == 8)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
					}
					if (num7 == 9)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
					}
					if (num7 == 10)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2322);
					}
					if (num7 == 11)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
					}
					if (num7 == 12)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2327);
					}
					if (num7 == 13)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2329);
					}
					if (num7 >= 7)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2350, genRand.Next(1, 3));
					}
				}
				else
				{
					int num8 = genRand.Next(14);
					if (num8 == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 296);
					}
					if (num8 == 1)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 295);
					}
					if (num8 == 2)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 293);
					}
					if (num8 == 3)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
					}
					if (num8 == 4)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 294);
					}
					if (num8 == 5)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 297);
					}
					if (num8 == 6)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 304);
					}
					if (num8 == 7)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 305);
					}
					if (num8 == 8)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 301);
					}
					if (num8 == 9)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 302);
					}
					if (num8 == 10)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 288);
					}
					if (num8 == 11)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 300);
					}
					if (num8 == 12)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2323);
					}
					if (num8 == 13)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2326);
					}
					if (genRand.Next(5) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 4870);
					}
				}
				return;
			}
			if (Main.netMode == 2 && Main.rand.Next(30) == 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 2997);
				return;
			}
			int num9 = Main.rand.Next(7);
			if (Main.expertMode)
			{
				num9--;
			}
			Player player2 = Main.player[Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16)];
			int num10 = 0;
			int num11 = 20;
			for (int k = 0; k < 50; k++)
			{
				Item item = player2.inventory[k];
				if (!item.IsAir && item.createTile == 4)
				{
					num10 += item.stack;
					if (num10 >= num11)
					{
						break;
					}
				}
			}
			bool flag4 = num10 < num11;
			if (num9 == 0 && player2.statLife < player2.statLifeMax2)
			{
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
				if (Main.rand.Next(2) == 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
				}
				if (Main.expertMode)
				{
					if (Main.rand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
					}
					if (Main.rand.Next(2) == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 58);
					}
				}
				return;
			}
			if (num9 == 1 || (num9 == 0 && flag4))
			{
				int num12 = Main.rand.Next(2, 7);
				if (Main.expertMode)
				{
					num12 += Main.rand.Next(1, 7);
				}
				int type = 8;
				int type2 = 282;
				if (player2.ZoneHallow)
				{
					num12 += Main.rand.Next(2, 7);
					type = 4387;
				}
				else if ((style >= 22 && style <= 24) || player2.ZoneCrimson)
				{
					num12 += Main.rand.Next(2, 7);
					type = 4386;
				}
				else if ((style >= 16 && style <= 18) || player2.ZoneCorrupt)
				{
					num12 += Main.rand.Next(2, 7);
					type = 4385;
				}
				else if (style >= 7 && style <= 9)
				{
					num12 += Main.rand.Next(2, 7);
					num12 = (int)((float)num12 * 1.5f);
					type = 4388;
				}
				else if (style >= 4 && style <= 6)
				{
					type = 974;
					type2 = 286;
				}
				else if (style >= 34 && style <= 36)
				{
					num12 += Main.rand.Next(2, 7);
					type = 4383;
				}
				else if (player2.ZoneGlowshroom)
				{
					num12 += Main.rand.Next(2, 7);
					type = 5293;
				}
				if (Main.tile[i, j].liquid > 0)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type2, num12);
				}
				else
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type, num12);
				}
				return;
			}
			switch (num9)
			{
			case 2:
			{
				int stack2 = Main.rand.Next(10, 21);
				int type4 = 40;
				if (flag && genRand.Next(2) == 0)
				{
					type4 = ((!Main.hardMode) ? 42 : 168);
				}
				if (j > Main.UnderworldLayer)
				{
					type4 = 265;
				}
				else if (Main.hardMode)
				{
					type4 = ((Main.rand.Next(2) != 0) ? 47 : ((SavedOreTiers.Silver != 168) ? 278 : 4915));
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type4, stack2);
				return;
			}
			case 3:
			{
				int type5 = 28;
				if (j > Main.UnderworldLayer || Main.hardMode)
				{
					type5 = 188;
				}
				int num14 = 1;
				if (Main.expertMode && Main.rand.Next(3) != 0)
				{
					num14++;
				}
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type5, num14);
				return;
			}
			case 4:
				if (flag3 || flag2)
				{
					int type3 = 166;
					if (flag3)
					{
						type3 = 4423;
					}
					int num13 = Main.rand.Next(4) + 1;
					if (Main.expertMode)
					{
						num13 += Main.rand.Next(4);
					}
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, type3, num13);
					return;
				}
				break;
			}
			if ((num9 == 4 || num9 == 5) && j < Main.UnderworldLayer && !Main.hardMode)
			{
				int stack3 = Main.rand.Next(20, 41);
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 965, stack3);
				return;
			}
			float num15 = 200 + genRand.Next(-100, 101);
			if ((double)j < Main.worldSurface)
			{
				num15 *= 0.5f;
			}
			else if (flag)
			{
				num15 *= 0.75f;
			}
			else if (j > Main.maxTilesY - 250)
			{
				num15 *= 1.25f;
			}
			num15 *= 1f + (float)Main.rand.Next(-20, 21) * 0.01f;
			if (Main.rand.Next(4) == 0)
			{
				num15 *= 1f + (float)Main.rand.Next(5, 11) * 0.01f;
			}
			if (Main.rand.Next(8) == 0)
			{
				num15 *= 1f + (float)Main.rand.Next(10, 21) * 0.01f;
			}
			if (Main.rand.Next(12) == 0)
			{
				num15 *= 1f + (float)Main.rand.Next(20, 41) * 0.01f;
			}
			if (Main.rand.Next(16) == 0)
			{
				num15 *= 1f + (float)Main.rand.Next(40, 81) * 0.01f;
			}
			if (Main.rand.Next(20) == 0)
			{
				num15 *= 1f + (float)Main.rand.Next(50, 101) * 0.01f;
			}
			if (Main.expertMode)
			{
				num15 *= 2.5f;
			}
			if (Main.expertMode && Main.rand.Next(2) == 0)
			{
				num15 *= 1.25f;
			}
			if (Main.expertMode && Main.rand.Next(3) == 0)
			{
				num15 *= 1.5f;
			}
			if (Main.expertMode && Main.rand.Next(4) == 0)
			{
				num15 *= 1.75f;
			}
			num15 *= num;
			if (NPC.downedBoss1)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedBoss2)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedBoss3)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedMechBoss1)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedMechBoss2)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedMechBoss3)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedPlantBoss)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedQueenBee)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedGolemBoss)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedPirates)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedGoblins)
			{
				num15 *= 1.1f;
			}
			if (NPC.downedFrost)
			{
				num15 *= 1.1f;
			}
			while ((int)num15 > 0)
			{
				if (num15 > 1000000f)
				{
					int num16 = (int)(num15 / 1000000f);
					if (num16 > 50 && Main.rand.Next(2) == 0)
					{
						num16 /= Main.rand.Next(3) + 1;
					}
					if (Main.rand.Next(2) == 0)
					{
						num16 /= Main.rand.Next(3) + 1;
					}
					num15 -= (float)(1000000 * num16);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 74, num16);
					continue;
				}
				if (num15 > 10000f)
				{
					int num17 = (int)(num15 / 10000f);
					if (num17 > 50 && Main.rand.Next(2) == 0)
					{
						num17 /= Main.rand.Next(3) + 1;
					}
					if (Main.rand.Next(2) == 0)
					{
						num17 /= Main.rand.Next(3) + 1;
					}
					num15 -= (float)(10000 * num17);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 73, num17);
					continue;
				}
				if (num15 > 100f)
				{
					int num18 = (int)(num15 / 100f);
					if (num18 > 50 && Main.rand.Next(2) == 0)
					{
						num18 /= Main.rand.Next(3) + 1;
					}
					if (Main.rand.Next(2) == 0)
					{
						num18 /= Main.rand.Next(3) + 1;
					}
					num15 -= (float)(100 * num18);
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 72, num18);
					continue;
				}
				int num19 = (int)num15;
				if (num19 > 50 && Main.rand.Next(2) == 0)
				{
					num19 /= Main.rand.Next(3) + 1;
				}
				if (Main.rand.Next(2) == 0)
				{
					num19 /= Main.rand.Next(4) + 1;
				}
				if (num19 < 1)
				{
					num19 = 1;
				}
				num15 -= (float)num19;
				Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 71, num19);
			}
		}

		public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
		{
			int num = -1;
			if (TileID.Sets.Boulders[Main.tile[x, y + 1].type] || TileID.Sets.Boulders[Main.tile[x + 1, y + 1].type])
			{
				return -1;
			}
			if (TileObject.CanPlace(x, y, type, style, 1, out var objectData))
			{
				bool flag = true;
				if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
				{
					flag = false;
				}
				if (flag)
				{
					TileObject.Place(objectData);
					num = Chest.CreateChest(objectData.xCoord, objectData.yCoord);
				}
			}
			else
			{
				num = -1;
			}
			if (num != -1 && Main.netMode == 1 && type == 21)
			{
				NetMessage.SendData(34, -1, -1, null, 0, x, y, style);
			}
			if (num != -1 && Main.netMode == 1 && type == 467)
			{
				NetMessage.SendData(34, -1, -1, null, 4, x, y, style);
			}
			return num;
		}

		public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
		{
			Chest.CreateChest(x, y - 1, id);
			for (int i = 0; i <= 1; i++)
			{
				for (int j = -1; j <= 0; j++)
				{
					if (Main.tile[x + i, y + j] == null)
					{
						Main.tile[x + i, y + j] = new Tile();
					}
				}
			}
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(36 * style);
			Main.tile[x, y - 1].type = type;
			Main.tile[x, y - 1].halfBrick(halfBrick: false);
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(18 + 36 * style);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x + 1, y - 1].halfBrick(halfBrick: false);
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(36 * style);
			Main.tile[x, y].type = type;
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(18 + 36 * style);
			Main.tile[x + 1, y].type = type;
			Main.tile[x + 1, y].halfBrick(halfBrick: false);
		}

		public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id)
		{
			Chest.CreateChest(x - 1, y - 1, id);
			for (int i = -1; i <= 1; i++)
			{
				for (int j = -1; j <= 0; j++)
				{
					if (Main.tile[x + i, y + j] == null)
					{
						Main.tile[x + i, y + j] = new Tile();
					}
				}
			}
			short num = (short)(style * 54);
			Main.tile[x - 1, y - 1].active(active: true);
			Main.tile[x - 1, y - 1].frameY = 0;
			Main.tile[x - 1, y - 1].frameX = num;
			Main.tile[x - 1, y - 1].type = type;
			Main.tile[x, y - 1].active(active: true);
			Main.tile[x, y - 1].frameY = 0;
			Main.tile[x, y - 1].frameX = (short)(num + 18);
			Main.tile[x, y - 1].type = type;
			Main.tile[x + 1, y - 1].active(active: true);
			Main.tile[x + 1, y - 1].frameY = 0;
			Main.tile[x + 1, y - 1].frameX = (short)(num + 36);
			Main.tile[x + 1, y - 1].type = type;
			Main.tile[x - 1, y].active(active: true);
			Main.tile[x - 1, y].frameY = 18;
			Main.tile[x - 1, y].frameX = num;
			Main.tile[x - 1, y].type = type;
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].frameY = 18;
			Main.tile[x, y].frameX = (short)(num + 18);
			Main.tile[x, y].type = type;
			Main.tile[x + 1, y].active(active: true);
			Main.tile[x + 1, y].frameY = 18;
			Main.tile[x + 1, y].frameX = (short)(num + 36);
			Main.tile[x + 1, y].type = type;
		}

		public static void CheckChest(int i, int j, int type)
		{
			if (destroyObject)
			{
				return;
			}
			bool flag = false;
			int num = 0;
			int num2 = j;
			num += Main.tile[i, j].frameX / 18;
			num2 += Main.tile[i, j].frameY / 18 * -1;
			while (num > 1)
			{
				num -= 2;
			}
			num *= -1;
			num += i;
			for (int k = num; k < num + 2; k++)
			{
				for (int l = num2; l < num2 + 2; l++)
				{
					if (Main.tile[k, l] == null)
					{
						Main.tile[k, l] = new Tile();
					}
					int num3;
					for (num3 = Main.tile[k, l].frameX / 18; num3 > 1; num3 -= 2)
					{
					}
					if (!Main.tile[k, l].active() || Main.tile[k, l].type != type || num3 != k - num || Main.tile[k, l].frameY != (l - num2) * 18)
					{
						flag = true;
					}
				}
				if (Main.tile[k, num2 + 2] == null)
				{
					Main.tile[k, num2 + 2] = new Tile();
				}
				if ((!Main.tile[k, num2 + 2].active() || !Main.tileSolid[Main.tile[k, num2 + 2].type]) && Chest.CanDestroyChest(num, num2))
				{
					flag = true;
				}
			}
			if (!flag)
			{
				return;
			}
			int chestItemDrop = GetChestItemDrop(i, j, type);
			destroyObject = true;
			for (int m = num; m < num + 2; m++)
			{
				for (int n = num2; n < num2 + 3; n++)
				{
					if (Main.tile[m, n].type == type && Main.tile[m, n].active())
					{
						Chest.DestroyChest(m, n);
						KillTile(m, n);
					}
				}
			}
			Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 32, 32, chestItemDrop);
			destroyObject = false;
		}

		private static int GetChestItemDrop(int x, int y, int type)
		{
			int num = Main.tile[x, y].frameX / 36;
			if (type == 467)
			{
				return Chest.chestItemSpawn2[num];
			}
			return Chest.chestItemSpawn[num];
		}

		public static bool PlaceActuator(int i, int j)
		{
			if (!Main.tile[i, j].actuator())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].actuator(actuator: true);
				return true;
			}
			return false;
		}

		public static bool KillActuator(int i, int j)
		{
			if (Main.tile[i, j].actuator())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].actuator(actuator: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 849);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire(int i, int j)
		{
			if (!Main.tile[i, j].wire())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire(wire: true);
				return true;
			}
			return false;
		}

		public static bool KillWire(int i, int j)
		{
			if (Main.tile[i, j].wire())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire(wire: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire2(int i, int j)
		{
			if (!Main.tile[i, j].wire2())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire2(wire2: true);
				return true;
			}
			return false;
		}

		public static bool KillWire2(int i, int j)
		{
			if (Main.tile[i, j].wire2())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire2(wire2: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire3(int i, int j)
		{
			if (!Main.tile[i, j].wire3())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire3(wire3: true);
				return true;
			}
			return false;
		}

		public static bool KillWire3(int i, int j)
		{
			if (Main.tile[i, j].wire3())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire3(wire3: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool PlaceWire4(int i, int j)
		{
			if (!Main.tile[i, j].wire4())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire4(wire4: true);
				return true;
			}
			return false;
		}

		public static bool KillWire4(int i, int j)
		{
			if (Main.tile[i, j].wire4())
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
				Main.tile[i, j].wire4(wire4: false);
				if (Main.netMode != 1)
				{
					Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, 530);
				}
				for (int k = 0; k < 5; k++)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 50);
				}
				return true;
			}
			return false;
		}

		public static bool IsFitToPlaceFlowerIn(int x, int y, int typeAttemptedToPlace)
		{
			if (y < 1 || y > Main.maxTilesY - 1)
			{
				return false;
			}
			Tile tile = Main.tile[x, y + 1];
			if (tile.active() && tile.slope() == 0 && !tile.halfBrick())
			{
				if (((tile.type != 2 && tile.type != 78 && tile.type != 380 && tile.type != 477 && tile.type != 579) || typeAttemptedToPlace != 3) && ((tile.type != 23 && tile.type != 661) || typeAttemptedToPlace != 24) && ((tile.type != 109 && tile.type != 492) || typeAttemptedToPlace != 110) && ((tile.type != 199 && tile.type != 662) || typeAttemptedToPlace != 201))
				{
					if (tile.type == 633)
					{
						return typeAttemptedToPlace == 637;
					}
					return false;
				}
				return true;
			}
			return false;
		}

		private static bool SeaOatWaterCheck(int x, int y)
		{
			int num = 45;
			int num2 = 20;
			int num3 = 20;
			int num4 = -1;
			int num5 = num + 1;
			int num6 = 0;
			bool flag = false;
			if (x <= beachDistance || x >= Main.maxTilesX - beachDistance)
			{
				flag = true;
				num4 = 40;
				num = 65;
				num2 += 5;
			}
			for (int i = x - num; i <= x + num; i++)
			{
				for (int j = y - num2; j <= y + num2; j++)
				{
					if (InWorld(i, j) && !SolidTile(i, j) && Main.tile[i, j].liquid > 0)
					{
						num6 += Main.tile[i, j].liquid;
						int num7 = Math.Abs(i - x);
						if (num7 < num5)
						{
							num5 = num7;
						}
					}
				}
			}
			if (num6 / 255 >= num3)
			{
				if (flag)
				{
					return false;
				}
				return true;
			}
			if (flag)
			{
				return true;
			}
			return false;
		}

		private static bool PlantSeaOat(int x, int y)
		{
			if (Main.tile[x, y].wall > 0 || Main.tile[x, y].active() || Main.tile[x, y].liquid > 0 || !SolidTileAllowBottomSlope(x, y + 1) || !TileID.Sets.Conversion.Sand[Main.tile[x, y + 1].type])
			{
				return false;
			}
			if (!SeaOatWaterCheck(x, y))
			{
				return false;
			}
			Main.tile[x, y].active(active: true);
			Main.tile[x, y].slope(0);
			Main.tile[x, y].halfBrick(halfBrick: false);
			Main.tile[x, y].type = 529;
			Main.tile[x, y].frameX = (short)(genRand.Next(5) * 18);
			int num = 0;
			Main.tile[x, y].frameY = (short)(num * 34);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
			return true;
		}

		private static bool CheckSeaOat(int x, int y)
		{
			if (!SeaOatWaterCheck(x, y))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				return false;
			}
			return true;
		}

		private static bool GrowSeaOat(int x, int y)
		{
			if (Main.tile[x, y].frameX < 180)
			{
				Main.tile[x, y].frameX += 90;
			}
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, y);
			}
			return false;
		}

		private static int GetWaterDepth(int x, int y)
		{
			int num = y;
			while (!SolidTile(x, num))
			{
				num++;
				if (num > Main.maxTilesY - 1)
				{
					return 0;
				}
			}
			num--;
			int num2 = num;
			while (Main.tile[x, num2].liquid > 0 && !SolidTile(x, num2))
			{
				num2--;
			}
			return num - num2;
		}

		private static int CountGrowingPlantTiles(int x, int y, int range, int type)
		{
			int num = 0;
			for (int i = x - range; i <= x + range; i++)
			{
				for (int j = y - range * 3; j <= y + range * 3; j++)
				{
					if (Main.tile[i, j].active() && Main.tile[i, j].type == type)
					{
						num++;
					}
				}
			}
			return num;
		}

		private static bool PlaceBamboo(int x, int y)
		{
			int num = 2;
			int num2 = 5;
			int num3 = genRand.Next(1, 21);
			Tile tile = Main.tile[x, y];
			if (tile.wall > 0 && (double)y <= Main.worldSurface)
			{
				return false;
			}
			if (tile.active() && tile.type == 314)
			{
				return false;
			}
			Tile tile2 = Main.tile[x, y + 1];
			if (tile2.type == 571 || tile2.type == 60)
			{
				int waterDepth = GetWaterDepth(x, y);
				if (waterDepth < num || waterDepth > num2)
				{
					return false;
				}
				int num4 = CountGrowingPlantTiles(x, y, 5, 571);
				int i = 1;
				if (tile2.type == 571)
				{
					for (; !SolidTile(x, y + i); i++)
					{
					}
					if (i + num4 / genRand.Next(1, 21) > num3)
					{
						return false;
					}
				}
				else
				{
					num4 += 25;
				}
				num4 += i * 2;
				if (num4 > genRand.Next(40, 61))
				{
					return false;
				}
				tile = Main.tile[x, y];
				tile.active(active: true);
				tile.type = 571;
				tile.frameX = 0;
				tile.frameY = 0;
				tile.slope(0);
				tile.halfBrick(halfBrick: false);
				SquareTileFrame(x, y);
				return true;
			}
			return false;
		}

		public static void CheckBamboo(int x, int y)
		{
			Tile tile = Main.tile[x, y + 1];
			if (tile == null)
			{
				return;
			}
			if (!tile.active() || (tile.type != 60 && tile.type != 571))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				SquareTileFrame(x, y);
				return;
			}
			Tile tile2 = Main.tile[x, y - 1];
			if (tile2 == null)
			{
				return;
			}
			Tile tile3 = Main.tile[x, y];
			if (tile3 == null)
			{
				return;
			}
			bool num = tile2.active() && tile2.type == 571;
			bool flag = tile.active() && tile.type == 571;
			int num2 = tile3.frameX / 18;
			tile3.frameY = 0;
			if (num)
			{
				if (flag)
				{
					if (num2 < 5 || num2 > 14)
					{
						tile3.frameX = (short)(genRand.Next(5, 15) * 18);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y);
						}
					}
				}
				else if (num2 < 1 || num2 > 4)
				{
					tile3.frameX = (short)(genRand.Next(1, 5) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (flag)
			{
				if (num2 < 15 || num2 > 19)
				{
					tile3.frameX = (short)(genRand.Next(15, 20) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (num2 != 0)
			{
				tile3.frameX = 0;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}

		public static void PlaceUnderwaterPlant(ushort type, int x, int y)
		{
			if (CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: false))
			{
				Tile tileSafely = Framing.GetTileSafely(x, y + 1);
				tileSafely.slope(0);
				tileSafely.halfBrick(halfBrick: false);
				Tile tileSafely2 = Framing.GetTileSafely(x, y);
				tileSafely2.active(active: true);
				tileSafely2.type = type;
				tileSafely2.frameX = 0;
				tileSafely2.frameY = 0;
				tileSafely2.slope(0);
				tileSafely2.halfBrick(halfBrick: false);
				SquareTileFrame(x, y);
			}
		}

		public static bool CanUnderwaterPlantGrowHere(ushort type, int x, int y, bool ignoreSelf)
		{
			if (!InWorld(x, y, 50))
			{
				return false;
			}
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (!ignoreSelf && tileSafely.active())
			{
				return false;
			}
			for (int i = 0; i < 3; i++)
			{
				tileSafely = Framing.GetTileSafely(x, y - i);
				if (tileSafely.liquid == 0 || tileSafely.liquidType() != 0)
				{
					return false;
				}
			}
			Tile tileSafely2 = Framing.GetTileSafely(x, y + 1);
			if (!tileSafely2.nactive())
			{
				return false;
			}
			if (!TileID.Sets.Conversion.Sand[tileSafely2.type] && type != tileSafely2.type)
			{
				return false;
			}
			tileSafely = Framing.GetTileSafely(x, y);
			ushort wall = tileSafely.wall;
			if (wall != 0 && (uint)(wall - 63) > 6u && (uint)(wall - 80) > 1u)
			{
				return false;
			}
			return true;
		}

		public static void CheckUnderwaterPlant(ushort type, int x, int y)
		{
			if (!CanUnderwaterPlantGrowHere(type, x, y, ignoreSelf: true))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				SquareTileFrame(x, y);
				return;
			}
			Tile tileSafely = Framing.GetTileSafely(x, y - 1);
			Tile tileSafely2 = Framing.GetTileSafely(x, y);
			Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
			bool num = tileSafely.active() && tileSafely.type == type;
			bool flag = tileSafely3.active() && tileSafely3.type == type;
			int num2 = tileSafely2.frameX / 18;
			tileSafely2.frameY = 0;
			if (num)
			{
				if (1 > num2 || num2 > 7)
				{
					tileSafely2.frameX = (short)(genRand.Next(1, 8) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (flag)
			{
				if (7 > num2 || num2 > 12)
				{
					tileSafely2.frameX = (short)(genRand.Next(7, 13) * 18);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
			}
			else if (num2 != 0)
			{
				tileSafely2.frameX = 0;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}

		public static Point PlaceCatTail(int x, int j)
		{
			int num = j;
			Point result = new Point(-1, -1);
			if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
			{
				return result;
			}
			if ((Main.tile[x, num].active() && Main.tile[x, num].type != 71) || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return result;
			}
			while (Main.tile[x, num].liquid > 0 && num > 50)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return result;
			}
			if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 80 && Main.tile[x, num].wall != 81 && Main.tile[x, num].wall != 69 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
			{
				return result;
			}
			int num2 = 7;
			int num3 = 0;
			for (int i = x - num2; i <= x + num2; i++)
			{
				for (int k = num - num2; k <= num + num2; k++)
				{
					if (Main.tile[i, k].active() && Main.tile[i, k].type == 519)
					{
						num3++;
						break;
					}
				}
			}
			if (num3 > 3)
			{
				return result;
			}
			int l;
			for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
			{
				if (Main.tile[x, l].active() && Main.tile[x, l].type != 71)
				{
					return result;
				}
			}
			int num4 = catTailDistance - 1;
			if (l - num > num4)
			{
				return result;
			}
			if (l - num < 2)
			{
				return result;
			}
			int type = Main.tile[x, l].type;
			if (!Main.tile[x, l].nactive())
			{
				return result;
			}
			int num5 = -1;
			switch (type)
			{
			case 2:
			case 477:
				num5 = 0;
				break;
			case 53:
				if (x < beachDistance || x > Main.maxTilesX - beachDistance)
				{
					return result;
				}
				num5 = 18;
				break;
			case 199:
			case 234:
			case 662:
				num5 = 54;
				break;
			case 23:
			case 112:
			case 661:
				num5 = 72;
				break;
			case 70:
				num5 = 90;
				break;
			}
			if (num5 < 0)
			{
				return result;
			}
			if (Main.tile[x, l].topSlope() && gen && genRand.Next(3) != 0)
			{
				Main.tile[x, l].slope(0);
			}
			else if (Main.tile[x, l].topSlope() || Main.tile[x, l].halfBrick())
			{
				return result;
			}
			num = l - 1;
			Main.tile[x, num].active(active: true);
			Main.tile[x, num].type = 519;
			Main.tile[x, num].frameX = 0;
			Main.tile[x, num].frameY = (short)num5;
			Main.tile[x, num].halfBrick(halfBrick: false);
			Main.tile[x, num].slope(0);
			Main.tile[x, num].CopyPaintAndCoating(Main.tile[x, num + 1]);
			SquareTileFrame(x, num);
			return new Point(x, num);
		}

		public static void CheckCatTail(int x, int j)
		{
			if (Main.tile[x, j] == null)
			{
				return;
			}
			int num = j;
			bool flag = false;
			int num2 = num;
			while ((!Main.tile[x, num2].active() || !Main.tileSolid[Main.tile[x, num2].type] || Main.tileSolidTop[Main.tile[x, num2].type]) && num2 < Main.maxTilesY - 50)
			{
				if (Main.tile[x, num2].active() && Main.tile[x, num2].type != 519)
				{
					flag = true;
				}
				if (!Main.tile[x, num2].active())
				{
					break;
				}
				num2++;
				if (Main.tile[x, num2] == null)
				{
					return;
				}
			}
			num = num2 - 1;
			if (Main.tile[x, num] == null)
			{
				return;
			}
			while (Main.tile[x, num] != null && Main.tile[x, num].liquid > 0 && num > 50)
			{
				if ((Main.tile[x, num].active() && Main.tile[x, num].type != 519) || Main.tile[x, num].liquidType() != 0)
				{
					flag = true;
				}
				num--;
				if (Main.tile[x, num] == null)
				{
					return;
				}
			}
			num++;
			if (Main.tile[x, num] == null)
			{
				return;
			}
			int num3 = num;
			int num4 = catTailDistance;
			if (num2 - num3 > num4)
			{
				flag = true;
			}
			int type = Main.tile[x, num2].type;
			int num5 = -1;
			switch (type)
			{
			case 2:
			case 477:
				num5 = 0;
				break;
			case 53:
				num5 = 18;
				break;
			case 199:
			case 234:
			case 662:
				num5 = 54;
				break;
			case 23:
			case 112:
			case 661:
				num5 = 72;
				break;
			case 70:
				num5 = 90;
				break;
			}
			if (!Main.tile[x, num2].nactive())
			{
				flag = true;
			}
			if (num5 < 0)
			{
				flag = true;
			}
			num = num2 - 1;
			if (Main.tile[x, num] != null && !Main.tile[x, num].active())
			{
				for (int num6 = num; num6 >= num3; num6--)
				{
					if (Main.tile[x, num6] == null)
					{
						return;
					}
					if (Main.tile[x, num6].active() && Main.tile[x, num6].type == 519)
					{
						num = num6;
						break;
					}
				}
			}
			while (Main.tile[x, num] != null && Main.tile[x, num].active() && Main.tile[x, num].type == 519)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num2 - 1] != null && Main.tile[x, num2 - 1].liquid < 127 && genRand.Next(4) == 0)
			{
				flag = true;
			}
			if (Main.tile[x, num] != null && Main.tile[x, num].frameX >= 180 && Main.tile[x, num].liquid > 127 && genRand.Next(4) == 0)
			{
				flag = true;
			}
			if (Main.tile[x, num] != null && Main.tile[x, num2 - 1] != null && Main.tile[x, num].frameX > 18)
			{
				if (Main.tile[x, num2 - 1].frameX < 36 || Main.tile[x, num2 - 1].frameX > 72)
				{
					flag = true;
				}
				else if (Main.tile[x, num].frameX < 90)
				{
					flag = true;
				}
				else if (Main.tile[x, num].frameX >= 108 && Main.tile[x, num].frameX <= 162)
				{
					Main.tile[x, num].frameX = 90;
				}
			}
			if (num2 > num + 4 && Main.tile[x, num + 4] != null && Main.tile[x, num + 3] != null && Main.tile[x, num + 4].liquid == 0 && Main.tile[x, num + 3].type == 519)
			{
				flag = true;
			}
			if (flag)
			{
				int num7 = num3;
				if (num < num3)
				{
					num7 = num;
				}
				num7 -= 4;
				for (int i = num7; i <= num2; i++)
				{
					if (Main.tile[x, i] != null && Main.tile[x, i].active() && Main.tile[x, i].type == 519)
					{
						KillTile(x, i);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, x, i);
						}
						SquareTileFrame(x, i);
					}
				}
			}
			else
			{
				if (num5 == Main.tile[x, num].frameY)
				{
					return;
				}
				for (int k = num; k < num2; k++)
				{
					if (Main.tile[x, k] != null && Main.tile[x, k].active() && Main.tile[x, k].type == 519)
					{
						Main.tile[x, k].frameY = (short)num5;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, num);
						}
					}
				}
			}
		}

		public static void GrowCheckSeaweed(int x, int y)
		{
			int maxValue = 1;
			if (Main.netMode == 1)
			{
				return;
			}
			if ((Main.tile[x, y].type == 549 && Main.tile[x, y].liquid < 200) || Main.tile[x, y - 1].liquid < 200)
			{
				if (Main.tile[x, y].active() && Main.tile[x, y].type == 549 && genRand.Next(2) == 0)
				{
					KillTile(x, y);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, x, y);
					}
				}
			}
			else
			{
				if (Main.tile[x, y - 1].active() || Main.tile[x, y - 2].active() || genRand.Next(maxValue) != 0 || Main.tile[x, y - 2].liquid != byte.MaxValue || Main.tile[x, y - 3].liquid != byte.MaxValue)
				{
					return;
				}
				int num = 17;
				int num2 = 4;
				int num3 = 30;
				int num4 = 0;
				for (int i = x - num2; i <= x + num2; i++)
				{
					for (int j = y; j <= y + num2 * 3; j++)
					{
						if (Main.tile[i, j].active() && Main.tile[i, j].type == 549)
						{
							num4++;
							if (num4 > num3)
							{
								return;
							}
						}
					}
				}
				int k;
				for (k = y; !SolidTile(x, k) && k < Main.maxTilesY - 50; k++)
				{
				}
				if (k - y < num - genRand.Next(20))
				{
					PlaceTile(x, y - 1, 549, mute: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y - 1);
					}
				}
			}
		}

		public static void GrowCatTail(int x, int j)
		{
			if (Main.netMode == 1)
			{
				return;
			}
			int num = j;
			while (Main.tile[x, num].liquid > 0 && num > 50)
			{
				num--;
			}
			num++;
			int i;
			for (i = num; (!Main.tile[x, i].active() || !Main.tileSolid[Main.tile[x, i].type] || Main.tileSolidTop[Main.tile[x, i].type]) && i < Main.maxTilesY - 50; i++)
			{
			}
			num = i - 1;
			while (Main.tile[x, num].active() && Main.tile[x, num].type == 519)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num].frameX == 90 && Main.tile[x, num - 1].active() && Main.tileCut[Main.tile[x, num - 1].type])
			{
				KillTile(x, num - 1);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, num - 1);
				}
			}
			if (Main.tile[x, num - 1].active())
			{
				return;
			}
			if (Main.tile[x, num].frameX == 0)
			{
				Main.tile[x, num].frameX = 18;
				SquareTileFrame(x, num);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, num);
				}
			}
			else if (Main.tile[x, num].frameX == 18)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(2, 5));
				Main.tile[x, num - 1].active(active: true);
				Main.tile[x, num - 1].type = 519;
				Main.tile[x, num - 1].frameX = 90;
				Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
				Main.tile[x, num - 1].halfBrick(halfBrick: false);
				Main.tile[x, num - 1].slope(0);
				Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
				SquareTileFrame(x, num);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, num);
				}
			}
			else if (Main.tile[x, num].frameX == 90)
			{
				if (Main.tile[x, num - 1].liquid == 0)
				{
					if (!Main.tile[x, num - 2].active() && (Main.tile[x, num].liquid > 0 || Main.tile[x, num + 1].liquid > 0 || Main.tile[x, num + 2].liquid > 0) && genRand.Next(3) == 0)
					{
						Main.tile[x, num].frameX = 108;
						Main.tile[x, num - 1].active(active: true);
						Main.tile[x, num - 1].type = 519;
						Main.tile[x, num - 1].frameX = 90;
						Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
						Main.tile[x, num - 1].halfBrick(halfBrick: false);
						Main.tile[x, num - 1].slope(0);
						Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
						SquareTileFrame(x, num);
					}
					else
					{
						int num2 = genRand.Next(3);
						Main.tile[x, num].frameX = (short)(126 + num2 * 18);
						Main.tile[x, num - 1].active(active: true);
						Main.tile[x, num - 1].type = 519;
						Main.tile[x, num - 1].frameX = (short)(180 + num2 * 18);
						Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
						Main.tile[x, num - 1].halfBrick(halfBrick: false);
						Main.tile[x, num - 1].slope(0);
						Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
						SquareTileFrame(x, num);
					}
				}
				else
				{
					Main.tile[x, num].frameX = 108;
					Main.tile[x, num - 1].active(active: true);
					Main.tile[x, num - 1].type = 519;
					Main.tile[x, num - 1].frameX = 90;
					Main.tile[x, num - 1].frameY = Main.tile[x, num].frameY;
					Main.tile[x, num - 1].halfBrick(halfBrick: false);
					Main.tile[x, num - 1].slope(0);
					Main.tile[x, num - 1].CopyPaintAndCoating(Main.tile[x, num]);
					SquareTileFrame(x, num);
				}
			}
			SquareTileFrame(x, num - 1, resetFrame: false);
			if (Main.netMode == 2)
			{
				NetMessage.SendTileSquare(-1, x, num - 1, 1, 2);
			}
		}

		public static bool PlaceLilyPad(int x, int j)
		{
			int num = j;
			if (x < 50 || x > Main.maxTilesX - 50 || num < 50 || num > Main.maxTilesY - 50)
			{
				return false;
			}
			if (Main.tile[x, num].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return false;
			}
			while (Main.tile[x, num].liquid > 0 && num > 50)
			{
				num--;
			}
			num++;
			if (Main.tile[x, num].active() || Main.tile[x, num - 1].active() || Main.tile[x, num].liquid == 0 || Main.tile[x, num].liquidType() != 0)
			{
				return false;
			}
			if (Main.tile[x, num].wall != 0 && Main.tile[x, num].wall != 15 && Main.tile[x, num].wall != 70 && (Main.tile[x, num].wall < 63 || Main.tile[x, num].wall > 68))
			{
				return false;
			}
			int num2 = 5;
			int num3 = 0;
			for (int i = x - num2; i <= x + num2; i++)
			{
				for (int k = num - num2; k <= num + num2; k++)
				{
					if (Main.tile[i, k].active() && Main.tile[i, k].type == 518)
					{
						num3++;
					}
				}
			}
			if (num3 > 3)
			{
				return false;
			}
			int l;
			for (l = num; (!Main.tile[x, l].active() || !Main.tileSolid[Main.tile[x, l].type] || Main.tileSolidTop[Main.tile[x, l].type]) && l < Main.maxTilesY - 50; l++)
			{
				if (Main.tile[x, l].active() && Main.tile[x, l].type == 519)
				{
					return false;
				}
			}
			int num4 = 12;
			if (l - num > num4)
			{
				return false;
			}
			if (l - num < 3)
			{
				return false;
			}
			int type = Main.tile[x, l].type;
			int num5 = -1;
			if (type == 2 || type == 477)
			{
				num5 = 0;
			}
			if (type == 109 || type == 109 || type == 116)
			{
				num5 = 18;
			}
			if (type == 60)
			{
				num5 = 36;
			}
			if (num5 < 0)
			{
				return false;
			}
			Main.tile[x, num].active(active: true);
			Main.tile[x, num].type = 518;
			if (genRand.Next(2) == 0)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(3));
			}
			else if (genRand.Next(15) == 0)
			{
				Main.tile[x, num].frameX = (short)(18 * genRand.Next(18));
			}
			else
			{
				int num6 = Main.maxTilesX / 5;
				if (x < num6)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(6, 9));
				}
				else if (x < num6 * 2)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(9, 12));
				}
				else if (x < num6 * 3)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(3, 6));
				}
				else if (x < num6 * 4)
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(15, 18));
				}
				else
				{
					Main.tile[x, num].frameX = (short)(18 * genRand.Next(12, 15));
				}
			}
			Main.tile[x, num].frameY = (short)num5;
			Main.tile[x, num].halfBrick(halfBrick: false);
			Main.tile[x, num].slope(0);
			SquareTileFrame(x, num);
			return true;
		}

		public static void CheckLilyPad(int x, int y)
		{
			if (Main.netMode == 1)
			{
				return;
			}
			if (Main.tile[x, y].liquidType() != 0)
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
				return;
			}
			int num = y;
			while ((!Main.tile[x, num].active() || !Main.tileSolid[Main.tile[x, num].type] || Main.tileSolidTop[Main.tile[x, num].type]) && num < Main.maxTilesY - 50)
			{
				num++;
				if (Main.tile[x, num] == null)
				{
					return;
				}
			}
			int type = Main.tile[x, num].type;
			int num2 = -1;
			if (type == 2 || type == 477)
			{
				num2 = 0;
			}
			if (type == 109 || type == 109 || type == 116)
			{
				num2 = 18;
			}
			if (type == 60)
			{
				num2 = 36;
			}
			if (num2 >= 0)
			{
				if (num2 != Main.tile[x, y].frameY)
				{
					Main.tile[x, y].frameY = (short)num2;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y);
					}
				}
				if (Main.tile[x, y - 1].liquid > 0 && !Main.tile[x, y - 1].active())
				{
					Main.tile[x, y - 1].active(active: true);
					Main.tile[x, y - 1].type = 518;
					Main.tile[x, y - 1].frameX = Main.tile[x, y].frameX;
					Main.tile[x, y - 1].frameY = Main.tile[x, y].frameY;
					Main.tile[x, y - 1].halfBrick(halfBrick: false);
					Main.tile[x, y - 1].slope(0);
					Main.tile[x, y].active(active: false);
					Main.tile[x, y].type = 0;
					SquareTileFrame(x, y - 1, resetFrame: false);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, x, y - 1, 1, 2);
					}
				}
				else
				{
					if (Main.tile[x, y].liquid != 0)
					{
						return;
					}
					Tile tileSafely = Framing.GetTileSafely(x, y + 1);
					if (!tileSafely.active())
					{
						Main.tile[x, y + 1].active(active: true);
						Main.tile[x, y + 1].type = 518;
						Main.tile[x, y + 1].frameX = Main.tile[x, y].frameX;
						Main.tile[x, y + 1].frameY = Main.tile[x, y].frameY;
						Main.tile[x, y + 1].halfBrick(halfBrick: false);
						Main.tile[x, y + 1].slope(0);
						Main.tile[x, y].active(active: false);
						Main.tile[x, y].type = 0;
						SquareTileFrame(x, y + 1, resetFrame: false);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, x, y, 1, 2);
						}
					}
					else if (tileSafely.active() && !TileID.Sets.Platforms[tileSafely.type] && (!Main.tileSolid[tileSafely.type] || Main.tileSolidTop[tileSafely.type]))
					{
						KillTile(x, y);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, x, y);
						}
					}
				}
			}
			else
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
		}

		public static bool PlaceTile(int i, int j, int Type, bool mute = false, bool forced = false, int plr = -1, int style = 0)
		{
			int num = Type;
			if (gen && Main.tile[i, j].active() && Main.tile[i, j].type == 488)
			{
				return false;
			}
			if (num >= 693)
			{
				return false;
			}
			bool result = false;
			if (i >= 0 && j >= 0 && i < Main.maxTilesX && j < Main.maxTilesY)
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					tile = new Tile();
					Main.tile[i, j] = tile;
				}
				if (tile.active())
				{
					if (num == 23 && tile.type == 59)
					{
						num = 661;
					}
					if (num == 199 && tile.type == 59)
					{
						num = 662;
					}
				}
				if (forced || Collision.EmptyTile(i, j) || !Main.tileSolid[num] || (num == 23 && tile.type == 0 && tile.active()) || (num == 199 && tile.type == 0 && tile.active()) || (num == 2 && tile.type == 0 && tile.active()) || (num == 109 && tile.type == 0 && tile.active()) || (num == 60 && tile.type == 59 && tile.active()) || (num == 661 && tile.type == 59 && tile.active()) || (num == 662 && tile.type == 59 && tile.active()) || (num == 70 && tile.type == 59 && tile.active()) || (num == 633 && tile.type == 57 && tile.active()) || (Main.tileMoss[num] && (tile.type == 1 || tile.type == 38) && tile.active()))
				{
					if (num == 23 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 199 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 2 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 109 && (tile.type != 0 || !tile.active()))
					{
						return false;
					}
					if (num == 60 && (tile.type != 59 || !tile.active()))
					{
						return false;
					}
					if (num == 661 && (tile.type != 59 || !tile.active()))
					{
						return false;
					}
					if (num == 662 && (tile.type != 59 || !tile.active()))
					{
						return false;
					}
					if (num == 70 && (tile.type != 59 || !tile.active()))
					{
						return false;
					}
					if (num == 633 && (tile.type != 57 || !tile.active()))
					{
						return false;
					}
					if (Main.tileMoss[num])
					{
						if ((tile.type != 1 && tile.type != 38) || !tile.active())
						{
							return false;
						}
						if (tile.type == 38)
						{
							num = num switch
							{
								381 => 517, 
								534 => 535, 
								536 => 537, 
								539 => 540, 
								625 => 626, 
								627 => 628, 
								_ => 512 + num - 179, 
							};
						}
					}
					if (num == 81)
					{
						if (Main.tile[i, j - 1] == null)
						{
							Main.tile[i, j - 1] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if (Main.tile[i, j - 1].active())
						{
							return false;
						}
						if (!Main.tile[i, j + 1].active() || !Main.tileSolid[Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick() || Main.tile[i, j + 1].slope() != 0)
						{
							return false;
						}
					}
					if ((num == 373 || num == 375 || num == 374 || num == 461) && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
					{
						return false;
					}
					if (tile.liquid > 0 || tile.checkingLiquid())
					{
						switch (num)
						{
						case 4:
							if (style != 8 && style != 11 && style != 17)
							{
								return false;
							}
							break;
						case 3:
						case 20:
						case 24:
						case 27:
						case 32:
						case 51:
						case 69:
						case 72:
						case 201:
						case 352:
						case 529:
						case 624:
						case 637:
						case 656:
							return false;
						}
					}
					if (TileID.Sets.ResetsHalfBrickPlacementAttempt[num] && (!tile.active() || !Main.tileFrameImportant[tile.type]))
					{
						tile.halfBrick(halfBrick: false);
						tile.frameY = 0;
						tile.frameX = 0;
					}
					switch (num)
					{
					case 624:
					{
						Tile tile3 = Main.tile[i, j];
						Tile tile4 = Main.tile[i, j + 1];
						if ((!tile3.active() || Main.tileCut[tile3.type] || TileID.Sets.BreakableWhenPlacing[tile3.type]) && tile4.active() && TileID.Sets.Conversion.Grass[tile4.type] && SolidTileAllowBottomSlope(i, j + 1))
						{
							tile.active(active: true);
							tile.type = 624;
							tile.halfBrick(halfBrick: false);
							tile.slope(0);
							tile.frameX = 0;
							tile.frameY = 0;
						}
						break;
					}
					case 656:
					{
						Tile tile2 = Main.tile[i, j];
						if ((!tile2.active() || Main.tileCut[tile2.type] || TileID.Sets.BreakableWhenPlacing[tile2.type]) && HasValidGroundForGlowTulipBelowSpot(i, j))
						{
							tile.active(active: true);
							tile.type = 656;
							tile.halfBrick(halfBrick: false);
							tile.slope(0);
							tile.frameX = 0;
							tile.frameY = 0;
						}
						break;
					}
					}
					if (num == 3 || num == 24 || num == 110 || num == 201 || num == 637)
					{
						if (IsFitToPlaceFlowerIn(i, j, num))
						{
							if (num == 24 && genRand.Next(13) == 0)
							{
								tile.active(active: true);
								tile.type = 32;
								SquareTileFrame(i, j);
							}
							else if (num == 201 && genRand.Next(13) == 0)
							{
								tile.active(active: true);
								tile.type = 352;
								SquareTileFrame(i, j);
							}
							else if (Main.tile[i, j + 1].type == 78 || Main.tile[i, j + 1].type == 380 || Main.tile[i, j + 1].type == 579)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								int num2 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
								switch (num2)
								{
								case 21:
								case 24:
								case 27:
								case 30:
								case 33:
								case 36:
								case 39:
								case 42:
									num2 += genRand.Next(3);
									break;
								}
								tile.frameX = (short)(num2 * 18);
							}
							else if (tile.wall >= 0 && tile.wall < 347 && WallID.Sets.AllowsPlantsToGrow[tile.wall] && Main.tile[i, j + 1].wall >= 0 && Main.tile[i, j + 1].wall < 347 && WallID.Sets.AllowsPlantsToGrow[Main.tile[i, j + 1].wall])
							{
								if (genRand.Next(50) == 0 || ((num == 24 || num == 201) && genRand.Next(40) == 0))
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									if (num == 201)
									{
										tile.frameX = 270;
									}
									else
									{
										tile.frameX = 144;
									}
								}
								else if (genRand.Next(35) == 0 || (Main.tile[i, j].wall >= 63 && Main.tile[i, j].wall <= 70))
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									int num3 = genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
									if (num == 201)
									{
										num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22);
									}
									if (num == 637)
									{
										num3 = genRand.NextFromList<int>(6, 7, 8, 9, 10);
									}
									tile.frameX = (short)(num3 * 18);
								}
								else
								{
									tile.active(active: true);
									tile.type = (ushort)num;
									tile.frameX = (short)(genRand.Next(6) * 18);
								}
							}
						}
					}
					else if (num == 61)
					{
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 60)
						{
							bool flag = (double)j > Main.rockLayer || Main.remixWorld || remixWorldGen;
							if (genRand.Next(16) == 0 && (double)j > Main.worldSurface)
							{
								tile.active(active: true);
								tile.type = 69;
								SquareTileFrame(i, j);
							}
							else if (genRand.Next(60) == 0 && flag)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = 144;
							}
							else if (genRand.Next(230) == 0 && flag)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = 162;
							}
							else if (genRand.Next(15) == 0)
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								if (genRand.Next(3) != 0)
								{
									tile.frameX = (short)(genRand.Next(2) * 18 + 108);
								}
								else
								{
									tile.frameX = (short)(genRand.Next(13) * 18 + 180);
								}
							}
							else
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = (short)(genRand.Next(6) * 18);
							}
						}
					}
					else if (num == 518)
					{
						PlaceLilyPad(i, j);
					}
					else if (num == 519)
					{
						PlaceCatTail(i, j);
					}
					else if (num == 529)
					{
						PlantSeaOat(i, j);
					}
					else if (num == 571)
					{
						PlaceBamboo(i, j);
					}
					else if (num == 549)
					{
						PlaceUnderwaterPlant(549, i, j);
					}
					else if (num == 71)
					{
						if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && Main.tile[i, j + 1].slope() == 0 && !Main.tile[i, j + 1].halfBrick() && Main.tile[i, j + 1].type == 70)
						{
							Point point = new Point(-1, -1);
							if ((double)j > Main.worldSurface)
							{
								point = PlaceCatTail(i, j);
							}
							if (InWorld(point.X, point.Y))
							{
								if (gen)
								{
									int num4 = genRand.Next(14);
									for (int k = 0; k < num4; k++)
									{
										GrowCatTail(point.X, point.Y);
									}
									SquareTileFrame(point.X, point.Y);
								}
							}
							else
							{
								tile.active(active: true);
								tile.type = (ushort)num;
								tile.frameX = (short)(genRand.Next(5) * 18);
							}
						}
					}
					else if (num == 129)
					{
						if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 178)
					{
						if (SolidTile(i - 1, j, noDoors: true) || SolidTile(i + 1, j, noDoors: true) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 184)
					{
						if ((Main.tileMoss[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (Main.tileMoss[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (Main.tileMoss[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (Main.tileMoss[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
						if ((TileID.Sets.tileMossBrick[Main.tile[i - 1, j].type] && SolidTile(i - 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i + 1, j].type] && SolidTile(i + 1, j)) || (TileID.Sets.tileMossBrick[Main.tile[i, j - 1].type] && SolidTile(i, j - 1)) || (TileID.Sets.tileMossBrick[Main.tile[i, j + 1].type] && SolidTile(i, j + 1)))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameX = (short)(style * 18);
							tile.frameY = (short)(genRand.Next(3) * 18);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 485)
					{
						PlaceObject(i, j, num, mute, style);
					}
					else if (num == 171)
					{
						PlaceXmasTree(i, j, 171);
					}
					else if (num == 254)
					{
						Place2x2Style(i, j, (ushort)num, style);
					}
					else if (num == 335 || num == 564 || num == 594)
					{
						Place2x2(i, j, (ushort)num, 0);
					}
					else if (num == 654 || num == 319 || num == 132 || num == 484 || num == 138 || num == 664 || num == 142 || num == 143 || num == 282 || (num >= 288 && num <= 295) || (num >= 316 && num <= 318))
					{
						Place2x2(i, j, (ushort)num, 0);
					}
					else if (num == 411)
					{
						Place2x2(i, j, (ushort)num, 0);
					}
					else if (num == 457)
					{
						Place2x2Horizontal(i, j, 457, style);
					}
					else if (num == 137)
					{
						tile.active(active: true);
						tile.type = (ushort)num;
						tile.frameY = (short)(18 * style);
					}
					else if (num == 136)
					{
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = new Tile();
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0) || tile.wall > 0)
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
					}
					else if (num == 442)
					{
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = new Tile();
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if ((Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == 0 && (SolidTile(i - 1, j) || TileID.Sets.IsBeam[Main.tile[i - 1, j].type] || (Main.tile[i - 1, j].type == 5 && Main.tile[i - 1, j - 1].type == 5 && Main.tile[i - 1, j + 1].type == 5))) || (Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && !TileID.Sets.NotReallySolid[Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == 0 && (SolidTile(i + 1, j) || TileID.Sets.IsBeam[Main.tile[i + 1, j].type] || (Main.tile[i + 1, j].type == 5 && Main.tile[i + 1, j - 1].type == 5 && Main.tile[i + 1, j + 1].type == 5))) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && SolidTile(i, j + 1) && Main.tile[i, j + 1].slope() == 0))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
					}
					else if (num == 4)
					{
						if (Main.tile[i - 1, j] == null)
						{
							Main.tile[i - 1, j] = new Tile();
						}
						if (Main.tile[i + 1, j] == null)
						{
							Main.tile[i + 1, j] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						Tile tile5 = Main.tile[i - 1, j];
						Tile tile6 = Main.tile[i + 1, j];
						Tile tile7 = Main.tile[i, j + 1];
						if (tile.wall > 0 || (tile5.active() && (tile5.slope() == 0 || (int)tile5.slope() % 2 != 1) && ((Main.tileSolid[tile5.type] && !Main.tileSolidTop[tile5.type] && !TileID.Sets.NotReallySolid[tile5.type]) || TileID.Sets.IsBeam[tile5.type] || (IsTreeType(tile5.type) && IsTreeType(Main.tile[i - 1, j - 1].type) && IsTreeType(Main.tile[i - 1, j + 1].type)))) || (tile6.active() && (tile6.slope() == 0 || (int)tile6.slope() % 2 != 0) && ((Main.tileSolid[tile6.type] && !Main.tileSolidTop[tile6.type] && !TileID.Sets.NotReallySolid[tile6.type]) || TileID.Sets.IsBeam[tile6.type] || (IsTreeType(tile6.type) && IsTreeType(Main.tile[i + 1, j - 1].type) && IsTreeType(Main.tile[i + 1, j + 1].type)))) || (tile7.active() && Main.tileSolid[tile7.type] && ((TileID.Sets.Platforms[tile7.type] && TopEdgeCanBeAttachedTo(i, j + 1)) || ((!Main.tileSolidTop[tile7.type] || (tile7.type == 380 && tile7.slope() == 0)) && !TileID.Sets.NotReallySolid[tile7.type] && !tile7.halfBrick() && tile7.slope() == 0))))
						{
							tile.active(active: true);
							tile.type = (ushort)num;
							tile.frameY = (short)(22 * style);
							SquareTileFrame(i, j);
						}
					}
					else if (num == 10)
					{
						if (Main.tile[i, j - 1] == null)
						{
							Main.tile[i, j - 1] = new Tile();
						}
						if (Main.tile[i, j - 2] == null)
						{
							Main.tile[i, j - 2] = new Tile();
						}
						if (Main.tile[i, j - 3] == null)
						{
							Main.tile[i, j - 3] = new Tile();
						}
						if (Main.tile[i, j + 1] == null)
						{
							Main.tile[i, j + 1] = new Tile();
						}
						if (Main.tile[i, j + 2] == null)
						{
							Main.tile[i, j + 2] = new Tile();
						}
						if (Main.tile[i, j + 3] == null)
						{
							Main.tile[i, j + 3] = new Tile();
						}
						if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && Main.tile[i, j - 3].active() && Main.tileSolid[Main.tile[i, j - 3].type])
						{
							PlaceDoor(i, j - 1, num, style);
							SquareTileFrame(i, j);
						}
						else
						{
							if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || !Main.tile[i, j + 3].active() || !Main.tileSolid[Main.tile[i, j + 3].type])
							{
								return false;
							}
							PlaceDoor(i, j + 1, num, style);
							SquareTileFrame(i, j);
						}
					}
					else if ((num >= 275 && num <= 281) || num == 296 || num == 297 || num == 309 || num == 358 || num == 359 || num == 413 || num == 414 || num == 542)
					{
						Place6x3(i, j, (ushort)num);
					}
					else if (num == 237 || num == 244 || num == 285 || num == 286 || num == 298 || num == 299 || num == 310 || num == 339 || num == 538 || (num >= 361 && num <= 364) || num == 532 || num == 533 || num == 486 || num == 488 || num == 544 || num == 582 || num == 619 || num == 629)
					{
						Place3x2(i, j, (ushort)num);
					}
					else if (num == 128)
					{
						PlaceMan(i, j, style);
						SquareTileFrame(i, j);
					}
					else if (num == 269)
					{
						PlaceWoman(i, j, style);
						SquareTileFrame(i, j);
					}
					else if (num == 334)
					{
						int style2 = 0;
						if (style == -1)
						{
							style2 = 1;
						}
						Place3x3Wall(i, j, 334, style2);
						SquareTileFrame(i, j);
					}
					else if (num == 149)
					{
						if (SolidTile(i - 1, j) || SolidTile(i + 1, j) || SolidTile(i, j - 1) || SolidTile(i, j + 1))
						{
							tile.frameX = (short)(18 * style);
							tile.active(active: true);
							tile.type = (ushort)num;
							SquareTileFrame(i, j);
						}
					}
					else if (num == 139 || num == 35)
					{
						PlaceMB(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
					}
					else if (num == 165)
					{
						PlaceTight(i, j);
						SquareTileFrame(i, j);
					}
					else if (num == 235)
					{
						Place3x1(i, j, (ushort)num);
						SquareTileFrame(i, j);
					}
					else if (num == 240)
					{
						Place3x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 440)
					{
						Place3x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 245)
					{
						Place2x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 246)
					{
						Place3x2Wall(i, j, (ushort)num, style);
					}
					else if (num == 241)
					{
						Place4x3Wall(i, j, (ushort)num, style);
					}
					else if (num == 242)
					{
						Place6x4Wall(i, j, (ushort)num, style);
					}
					else if (num == 34)
					{
						PlaceChand(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
					}
					else if (num == 106 || num == 212 || num == 219 || num == 220 || num == 228 || num == 231 || num == 243 || num == 247 || num == 283 || (num >= 300 && num <= 308) || num == 354 || num == 355 || num == 491 || num == 642)
					{
						Place3x3(i, j, (ushort)num, style);
						SquareTileFrame(i, j);
					}
					else
					{
						switch (num)
						{
						case 13:
						case 33:
						case 49:
						case 50:
						case 78:
						case 174:
						case 372:
						case 646:
							PlaceOnTable1x1(i, j, num, style);
							SquareTileFrame(i, j);
							break;
						case 14:
						case 26:
						case 86:
						case 87:
						case 88:
						case 89:
						case 114:
						case 186:
						case 187:
						case 215:
						case 217:
						case 218:
						case 377:
						case 469:
							Place3x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 236:
							PlaceJunglePlant(i, j, (ushort)num, genRand.Next(3), 0);
							SquareTileFrame(i, j);
							break;
						case 238:
							PlaceJunglePlant(i, j, (ushort)num, 0, 0);
							SquareTileFrame(i, j);
							break;
						case 20:
						{
							if (Main.tile[i, j + 1] == null)
							{
								Main.tile[i, j + 1] = new Tile();
							}
							int type = Main.tile[i, j + 1].type;
							if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || type == 147 || type == 60 || type == 23 || type == 199 || type == 661 || type == 662 || type == 53 || type == 234 || type == 116 || type == 112))
							{
								Place1x2(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
							}
							break;
						}
						case 15:
						case 216:
						case 338:
						case 390:
							if (Main.tile[i, j - 1] == null)
							{
								Main.tile[i, j - 1] = new Tile();
							}
							if (Main.tile[i, j] == null)
							{
								Main.tile[i, j] = new Tile();
							}
							Place1x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 227:
							PlaceDye(i, j, style);
							SquareTileFrame(i, j);
							break;
						case 567:
							PlaceGnome(i, j, style);
							SquareTileFrame(i, j);
							break;
						case 16:
						case 18:
						case 29:
						case 103:
						case 134:
						case 462:
							Place2x1(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 92:
						case 93:
						case 453:
							Place1xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 104:
						case 105:
						case 320:
						case 337:
						case 349:
						case 356:
						case 378:
						case 456:
						case 506:
						case 545:
						case 663:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 17:
						case 77:
						case 133:
							Place3x2(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 207:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 410:
						case 480:
						case 509:
						case 657:
						case 658:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						case 465:
						case 531:
						case 591:
						case 592:
							Place2xX(i, j, (ushort)num, style);
							SquareTileFrame(i, j);
							break;
						default:
							if (TileID.Sets.BasicChest[num])
							{
								PlaceChest(i, j, (ushort)num, notNearOtherChests: false, style);
								SquareTileFrame(i, j);
								break;
							}
							switch (num)
							{
							case 91:
								PlaceBanner(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 419:
							case 420:
							case 423:
							case 424:
							case 429:
							case 445:
								PlaceLogicTiles(i, j, num, style);
								SquareTileFrame(i, j);
								break;
							case 36:
							case 135:
							case 141:
							case 144:
							case 210:
							case 239:
							case 324:
							case 476:
							case 494:
								Place1x1(i, j, num, style);
								SquareTileFrame(i, j);
								break;
							case 101:
							case 102:
							case 463:
								Place3x4(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 464:
							case 466:
								Place5x4(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 27:
								PlaceSunflower(i, j, 27);
								SquareTileFrame(i, j);
								break;
							case 28:
								PlacePot(i, j, 28, genRand.Next(4));
								SquareTileFrame(i, j);
								break;
							case 42:
							case 270:
							case 271:
								Place1x2Top(i, j, (ushort)num, style);
								SquareTileFrame(i, j);
								break;
							case 55:
							case 425:
							case 510:
							case 511:
								PlaceSign(i, j, (ushort)num, style);
								break;
							case 85:
							case 376:
								Place2x2Horizontal(i, j, (ushort)num, style);
								break;
							default:
								if (Main.tileAlch[num])
								{
									PlaceAlch(i, j, style);
									break;
								}
								switch (num)
								{
								case 94:
								case 95:
								case 97:
								case 98:
								case 99:
								case 100:
								case 125:
								case 126:
								case 172:
								case 173:
								case 287:
									Place2x2(i, j, (ushort)num, style);
									break;
								case 96:
									Place2x2Style(i, j, (ushort)num, style);
									break;
								case 79:
								case 90:
								{
									int direction = 1;
									if (plr > -1)
									{
										direction = Main.player[plr].direction;
									}
									Place4x2(i, j, (ushort)num, direction, style);
									break;
								}
								case 209:
									PlaceCannon(i, j, (ushort)num, style);
									break;
								case 81:
									tile.frameX = (short)(26 * genRand.Next(6));
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								case 19:
									tile.frameY = (short)(18 * style);
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								case 380:
									tile.frameY = (short)(18 * style);
									tile.active(active: true);
									tile.type = (ushort)num;
									break;
								case 314:
									Minecart.PlaceTrack(tile, style);
									break;
								default:
									tile.active(active: true);
									tile.type = (ushort)num;
									if (Main.tenthAnniversaryWorld && !Main.remixWorld && (num == 53 || num == 396 || num == 397))
									{
										tile.color(7);
									}
									break;
								}
								break;
							}
							break;
						}
					}
					if (tile.active())
					{
						if (TileID.Sets.BlocksWaterDrawingBehindSelf[tile.type])
						{
							SquareWallFrame(i, j);
						}
						SquareTileFrame(i, j);
						result = true;
						if (!mute)
						{
							switch (num)
							{
							case 127:
								SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
								break;
							case 314:
								SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
								break;
							case 330:
							case 331:
							case 332:
							case 333:
								SoundEngine.PlaySound(18, i * 16, j * 16);
								break;
							default:
								SoundEngine.PlaySound(0, i * 16, j * 16);
								break;
							}
							if (num == 22 || num == 140)
							{
								for (int l = 0; l < 3; l++)
								{
									Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 14);
								}
							}
						}
					}
				}
			}
			return result;
		}

		public static void KillWall(int i, int j, bool fail = false)
		{
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
			{
				return;
			}
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[i, j] = tile;
			}
			if (tile.wall <= 0)
			{
				return;
			}
			fail = KillWall_CheckFailure(fail, tile);
			KillWall_PlaySounds(i, j, tile);
			int num = 10;
			if (fail)
			{
				num = 3;
			}
			for (int k = 0; k < num; k++)
			{
				KillWall_MakeWallDust(i, j, tile);
			}
			if (fail)
			{
				SquareWallFrame(i, j);
				return;
			}
			KillWall_DropItems(i, j, tile);
			tile.wall = 0;
			tile.ClearWallPaintAndCoating();
			SquareWallFrame(i, j);
			if (tile.type >= 0 && tile.type < 693 && TileID.Sets.FramesOnKillWall[tile.type])
			{
				TileFrame(i, j);
			}
		}

		private static bool KillWall_CheckFailure(bool fail, Tile tileCache)
		{
			if (Main.wallDungeon[tileCache.wall] && !NPC.downedBoss3)
			{
				fail = true;
			}
			if (tileCache.wall == 87 && !NPC.downedGolemBoss)
			{
				fail = true;
			}
			return fail;
		}

		private static void KillWall_PlaySounds(int i, int j, Tile tileCache)
		{
			if (tileCache.wall == 241 || (tileCache.wall >= 88 && tileCache.wall <= 93) || tileCache.wall == 21 || tileCache.wall == 186 || tileCache.wall == 136 || tileCache.wall == 137 || tileCache.wall == 168 || tileCache.wall == 169 || tileCache.wall == 172 || tileCache.wall == 226 || tileCache.wall == 227 || tileCache.wall == 242 || tileCache.wall == 243)
			{
				SoundEngine.PlaySound(13, i * 16, j * 16);
			}
			else if ((tileCache.wall >= 63 && tileCache.wall <= 70) || tileCache.wall == 264 || tileCache.wall == 268 || tileCache.wall == 265)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else
			{
				SoundEngine.PlaySound(0, i * 16, j * 16);
			}
		}

		private static void KillWall_DropItems(int i, int j, Tile tileCache)
		{
			int num = KillWall_GetItemDrops(tileCache);
			if (num > 0)
			{
				Item.NewItem(GetItemSource_FromWallBreak(i, j), i * 16, j * 16, 16, 16, num);
			}
		}

		private static int KillWall_GetItemDrops(Tile tileCache)
		{
			switch (tileCache.wall)
			{
			case 237:
				return 4233;
			case 238:
				return 4234;
			case 239:
				return 4235;
			case 240:
				return 4236;
			case 246:
				return 4486;
			case 247:
				return 4487;
			case 248:
				return 4488;
			case 249:
				return 4489;
			case 250:
				return 4490;
			case 251:
				return 4491;
			case 252:
				return 4492;
			case 253:
				return 4493;
			case 254:
				return 4494;
			case 255:
				return 4495;
			case 314:
				return 4647;
			case 256:
				return 4496;
			case 257:
				return 4497;
			case 258:
				return 4498;
			case 259:
				return 4499;
			case 260:
				return 4500;
			case 261:
				return 4501;
			case 262:
				return 4502;
			case 263:
				return 4503;
			case 264:
				return 4504;
			case 265:
				return 4505;
			case 266:
				return 4506;
			case 267:
				return 4507;
			case 268:
				return 4508;
			case 269:
				return 4509;
			case 270:
				return 4510;
			case 271:
				return 4511;
			case 274:
				return 4512;
			case 275:
				return 3273;
			case 276:
				return 4513;
			case 277:
				return 4514;
			case 278:
				return 4515;
			case 279:
				return 4516;
			case 280:
				return 4517;
			case 281:
				return 4518;
			case 282:
				return 4519;
			case 283:
				return 4520;
			case 284:
				return 4521;
			case 285:
				return 4522;
			case 286:
				return 4523;
			case 287:
				return 4524;
			case 288:
				return 4525;
			case 289:
				return 4526;
			case 290:
				return 4527;
			case 291:
				return 4528;
			case 292:
				return 4529;
			case 293:
				return 4530;
			case 294:
				return 4531;
			case 295:
				return 4532;
			case 296:
				return 4533;
			case 297:
				return 4534;
			case 298:
				return 4535;
			case 299:
				return 4536;
			case 300:
				return 4537;
			case 301:
				return 4538;
			case 302:
				return 4539;
			case 303:
				return 4540;
			case 304:
				return 3340;
			case 305:
				return 3341;
			case 306:
				return 3342;
			case 307:
				return 3343;
			case 308:
				return 3344;
			case 309:
				return 3345;
			case 310:
				return 3346;
			case 311:
				return 3348;
			default:
			{
				int result = 0;
				if (tileCache.wall == 168)
				{
					result = 2696;
				}
				if (tileCache.wall == 169)
				{
					result = 2698;
				}
				if (tileCache.wall == 226)
				{
					result = 3752;
				}
				if (tileCache.wall == 227)
				{
					result = 3753;
				}
				if (tileCache.wall == 228)
				{
					result = 3760;
				}
				if (tileCache.wall == 229)
				{
					result = 3761;
				}
				if (tileCache.wall == 230)
				{
					result = 3762;
				}
				if (tileCache.wall == 142)
				{
					result = 2263;
				}
				if (tileCache.wall == 143)
				{
					result = 2264;
				}
				if (tileCache.wall == 144)
				{
					result = 2271;
				}
				if (tileCache.wall == 149)
				{
					result = 2505;
				}
				if (tileCache.wall == 150)
				{
					result = 2507;
				}
				if (tileCache.wall == 151)
				{
					result = 2506;
				}
				if (tileCache.wall == 152)
				{
					result = 2508;
				}
				if (tileCache.wall == 316)
				{
					result = 5216;
				}
				if (tileCache.wall == 317)
				{
					result = 5217;
				}
				if (tileCache.wall == 245)
				{
					result = 4424;
				}
				if (tileCache.wall == 315)
				{
					result = 4667;
				}
				if (tileCache.wall == 1)
				{
					result = 26;
				}
				if (tileCache.wall == 4)
				{
					result = 93;
				}
				if (tileCache.wall == 5)
				{
					result = 130;
				}
				if (tileCache.wall == 6)
				{
					result = 132;
				}
				if (tileCache.wall == 7)
				{
					result = 135;
				}
				if (tileCache.wall == 8)
				{
					result = 138;
				}
				if (tileCache.wall == 9)
				{
					result = 140;
				}
				if (tileCache.wall == 10)
				{
					result = 142;
				}
				if (tileCache.wall == 11)
				{
					result = 144;
				}
				if (tileCache.wall == 12)
				{
					result = 146;
				}
				if (tileCache.wall == 14)
				{
					result = 330;
				}
				if (tileCache.wall == 224)
				{
					result = 3472;
				}
				if (tileCache.wall == 323)
				{
					result = 5409;
				}
				if (tileCache.wall == 324)
				{
					result = 5410;
				}
				if (tileCache.wall == 325)
				{
					result = 5411;
				}
				if (tileCache.wall == 326)
				{
					result = 5412;
				}
				if (tileCache.wall == 327)
				{
					result = 5413;
				}
				if (tileCache.wall == 328)
				{
					result = 5414;
				}
				if (tileCache.wall == 329)
				{
					result = 5415;
				}
				if (tileCache.wall == 330)
				{
					result = 5416;
				}
				if (tileCache.wall == 331)
				{
					result = 5418;
				}
				if (tileCache.wall == 332)
				{
					result = 5420;
				}
				if (tileCache.wall == 333)
				{
					result = 5422;
				}
				if (tileCache.wall == 334)
				{
					result = 5424;
				}
				if (tileCache.wall == 335)
				{
					result = 5426;
				}
				if (tileCache.wall == 336)
				{
					result = 5428;
				}
				if (tileCache.wall == 337)
				{
					result = 5434;
				}
				if (tileCache.wall == 338)
				{
					result = 5436;
				}
				if (tileCache.wall == 339)
				{
					result = 5430;
				}
				if (tileCache.wall == 340)
				{
					result = 5432;
				}
				if (tileCache.wall == 341)
				{
					result = 5445;
				}
				if (tileCache.wall == 342)
				{
					result = 5446;
				}
				if (tileCache.wall == 343)
				{
					result = 5447;
				}
				if (tileCache.wall == 344)
				{
					result = 5448;
				}
				if (tileCache.wall == 345)
				{
					result = 5449;
				}
				if (tileCache.wall == 346)
				{
					result = 5450;
				}
				if (tileCache.wall == 177)
				{
					result = 3067;
				}
				if (tileCache.wall == 167)
				{
					result = 2691;
				}
				if (tileCache.wall == 60)
				{
					result = 3584;
				}
				if (tileCache.wall == 231)
				{
					result = 3952;
				}
				if (tileCache.wall == 232)
				{
					result = 3954;
				}
				if (tileCache.wall == 225)
				{
					result = 3751;
				}
				if (tileCache.wall == 233)
				{
					result = 3956;
				}
				if (tileCache.wall == 234)
				{
					result = 4052;
				}
				if (tileCache.wall == 235)
				{
					result = 4053;
				}
				if (tileCache.wall == 236)
				{
					result = 4140;
				}
				if (tileCache.wall == 312)
				{
					result = 4565;
				}
				if (tileCache.wall == 313)
				{
					result = 4548;
				}
				if (tileCache.wall == 319)
				{
					result = 5307;
				}
				if (tileCache.wall == 318)
				{
					result = 5291;
				}
				if (tileCache.wall == 179)
				{
					result = 3083;
				}
				if (tileCache.wall == 183)
				{
					result = 3082;
				}
				if (tileCache.wall == 321)
				{
					result = 5397;
				}
				if (tileCache.wall == 322)
				{
					result = 5399;
				}
				if (tileCache.wall == 181)
				{
					result = 3089;
				}
				if (tileCache.wall == 184)
				{
					result = 3088;
				}
				if (tileCache.wall == 186)
				{
					result = 3238;
				}
				if (tileCache.wall == 320)
				{
					result = 5396;
				}
				if (tileCache.wall >= 153 && tileCache.wall <= 166)
				{
					switch (tileCache.wall)
					{
					case 154:
						result = 2679;
						break;
					case 158:
						result = 2680;
						break;
					case 166:
						result = 2689;
						break;
					case 163:
						result = 2690;
						break;
					case 165:
						result = 2687;
						break;
					case 162:
						result = 2688;
						break;
					case 156:
						result = 2683;
						break;
					case 160:
						result = 2684;
						break;
					case 164:
						result = 2685;
						break;
					case 161:
						result = 2686;
						break;
					case 155:
						result = 2681;
						break;
					case 159:
						result = 2682;
						break;
					case 153:
						result = 2677;
						break;
					case 157:
						result = 2678;
						break;
					}
				}
				if (tileCache.wall == 136)
				{
					result = 2169;
				}
				if (tileCache.wall == 137)
				{
					result = 2170;
				}
				if (tileCache.wall == 172)
				{
					result = 2788;
				}
				if (tileCache.wall == 242)
				{
					result = 4279;
				}
				if (tileCache.wall == 243)
				{
					result = 4280;
				}
				if (tileCache.wall == 145)
				{
					result = 2333;
				}
				if (tileCache.wall == 16)
				{
					result = 30;
				}
				if (tileCache.wall == 17)
				{
					result = 135;
				}
				if (tileCache.wall == 18)
				{
					result = 138;
				}
				if (tileCache.wall == 19)
				{
					result = 140;
				}
				if (tileCache.wall == 20)
				{
					result = 330;
				}
				if (tileCache.wall == 21)
				{
					result = 392;
				}
				if (tileCache.wall == 86 || tileCache.wall == 108)
				{
					result = 1126;
				}
				if (tileCache.wall == 173)
				{
					result = 2789;
				}
				if (tileCache.wall == 174)
				{
					result = 2790;
				}
				if (tileCache.wall == 175)
				{
					result = 2791;
				}
				if (tileCache.wall == 176)
				{
					result = 2861;
				}
				if (tileCache.wall == 182)
				{
					result = 3101;
				}
				if (tileCache.wall == 133)
				{
					result = 2158;
				}
				if (tileCache.wall == 134)
				{
					result = 2159;
				}
				if (tileCache.wall == 135)
				{
					result = 2160;
				}
				else if (tileCache.wall == 113)
				{
					result = 1726;
				}
				else if (tileCache.wall == 114)
				{
					result = 1728;
				}
				else if (tileCache.wall == 115)
				{
					result = 1730;
				}
				else if (tileCache.wall == 146)
				{
					result = 2432;
				}
				else if (tileCache.wall == 147)
				{
					result = 2433;
				}
				else if (tileCache.wall == 148)
				{
					result = 2434;
				}
				if (tileCache.wall >= 116 && tileCache.wall <= 125)
				{
					result = 1948 + tileCache.wall - 116;
				}
				if (tileCache.wall >= 126 && tileCache.wall <= 132)
				{
					result = 2008 + tileCache.wall - 126;
				}
				if (tileCache.wall == 22)
				{
					result = 417;
				}
				if (tileCache.wall == 23)
				{
					result = 418;
				}
				if (tileCache.wall == 24)
				{
					result = 419;
				}
				if (tileCache.wall == 25)
				{
					result = 420;
				}
				if (tileCache.wall == 26)
				{
					result = 421;
				}
				if (tileCache.wall == 29)
				{
					result = 587;
				}
				if (tileCache.wall == 30)
				{
					result = 592;
				}
				if (tileCache.wall == 31)
				{
					result = 595;
				}
				if (tileCache.wall == 32)
				{
					result = 605;
				}
				if (tileCache.wall == 33)
				{
					result = 606;
				}
				if (tileCache.wall == 34)
				{
					result = 608;
				}
				if (tileCache.wall == 35)
				{
					result = 610;
				}
				if (tileCache.wall == 36)
				{
					result = 615;
				}
				if (tileCache.wall == 37)
				{
					result = 616;
				}
				if (tileCache.wall == 38)
				{
					result = 617;
				}
				if (tileCache.wall == 39)
				{
					result = 618;
				}
				if (tileCache.wall == 41)
				{
					result = 622;
				}
				if (tileCache.wall == 42)
				{
					result = 623;
				}
				if (tileCache.wall == 43)
				{
					result = 624;
				}
				if (tileCache.wall == 44)
				{
					result = 663;
				}
				if (tileCache.wall == 45)
				{
					result = 720;
				}
				if (tileCache.wall == 46)
				{
					result = 721;
				}
				if (tileCache.wall == 47)
				{
					result = 722;
				}
				if (tileCache.wall == 66)
				{
					result = 745;
				}
				if (tileCache.wall == 67)
				{
					result = 746;
				}
				if (tileCache.wall == 68)
				{
					result = 747;
				}
				if (tileCache.wall == 84)
				{
					result = 884;
				}
				if (tileCache.wall == 72)
				{
					result = 750;
				}
				if (tileCache.wall == 73)
				{
					result = 752;
				}
				if (tileCache.wall == 74)
				{
					result = 764;
				}
				if (tileCache.wall == 85)
				{
					result = 927;
				}
				if (tileCache.wall == 75)
				{
					result = 768;
				}
				if (tileCache.wall == 76)
				{
					result = 769;
				}
				if (tileCache.wall == 77)
				{
					result = 770;
				}
				if (tileCache.wall == 82)
				{
					result = 825;
				}
				if (tileCache.wall == 27)
				{
					result = 479;
				}
				if (tileCache.wall == 106)
				{
					result = 1447;
				}
				if (tileCache.wall == 107)
				{
					result = 1448;
				}
				if (tileCache.wall == 109)
				{
					result = 1590;
				}
				if (tileCache.wall == 110)
				{
					result = 1592;
				}
				if (tileCache.wall == 111)
				{
					result = 1594;
				}
				if (tileCache.wall == 78)
				{
					result = 1723;
				}
				if (tileCache.wall == 87 || tileCache.wall == 112)
				{
					result = 1102;
				}
				if (tileCache.wall == 94 || tileCache.wall == 100)
				{
					result = 1378;
				}
				if (tileCache.wall == 95 || tileCache.wall == 101)
				{
					result = 1379;
				}
				if (tileCache.wall == 96 || tileCache.wall == 102)
				{
					result = 1380;
				}
				if (tileCache.wall == 97 || tileCache.wall == 103)
				{
					result = 1381;
				}
				if (tileCache.wall == 98 || tileCache.wall == 104)
				{
					result = 1382;
				}
				if (tileCache.wall == 99 || tileCache.wall == 105)
				{
					result = 1383;
				}
				if (tileCache.wall == 241)
				{
					result = 4260;
				}
				if (tileCache.wall >= 88 && tileCache.wall <= 93)
				{
					result = 1267 + tileCache.wall - 88;
				}
				if (tileCache.wall >= 138 && tileCache.wall <= 141)
				{
					result = 2210 + tileCache.wall - 138;
				}
				return result;
			}
			}
		}

		private static void KillWall_MakeWallDust(int i, int j, Tile tileCache)
		{
			int num = 0;
			switch (tileCache.wall)
			{
			case 316:
			case 317:
				num = 36;
				break;
			case 7:
			case 17:
			case 94:
			case 95:
			case 100:
			case 101:
			case 331:
				num = 275;
				break;
			case 8:
			case 18:
			case 98:
			case 99:
			case 104:
			case 105:
			case 332:
				num = 276;
				break;
			case 9:
			case 19:
			case 96:
			case 97:
			case 102:
			case 103:
			case 333:
				num = 277;
				break;
			case 232:
				num = 82;
				break;
			case 231:
				num = 8;
				break;
			case 233:
				num = 18;
				break;
			case 237:
				num = 6;
				break;
			case 238:
				num = 61;
				break;
			case 239:
				num = 242;
				break;
			case 240:
				num = 135;
				break;
			case 3:
			case 246:
				num = ((genRand.Next(2) != 0) ? 1 : 14);
				break;
			case 15:
			case 247:
				num = 38;
				break;
			case 22:
			case 28:
			case 248:
				num = 51;
				break;
			case 40:
			case 249:
				num = 51;
				break;
			case 48:
			case 49:
			case 50:
			case 51:
			case 52:
			case 53:
			case 54:
			case 55:
			case 56:
			case 57:
			case 58:
			case 185:
			case 250:
			case 251:
			case 252:
			case 253:
			case 254:
			case 255:
			case 256:
			case 257:
			case 258:
			case 259:
			case 260:
			case 274:
			case 314:
				num = 1;
				break;
			case 59:
			case 61:
			case 261:
			case 262:
				num = 0;
				break;
			case 62:
			case 263:
				num = 0;
				break;
			case 69:
			case 264:
				num = ((genRand.Next(2) != 0) ? 17 : 14);
				break;
			case 70:
			case 265:
				num = 47;
				break;
			case 71:
			case 266:
				num = 80;
				break;
			case 79:
			case 267:
				num = 37;
				break;
			case 81:
			case 268:
				num = 123;
				break;
			case 83:
			case 234:
			case 269:
				num = ((genRand.Next(2) == 0) ? 1 : 117);
				break;
			case 170:
			case 171:
			case 270:
			case 271:
				num = 0;
				break;
			case 187:
			case 275:
				num = 0;
				break;
			case 188:
			case 189:
			case 190:
			case 191:
			case 276:
			case 277:
			case 278:
			case 279:
				num = 37;
				break;
			case 192:
			case 193:
			case 194:
			case 195:
			case 280:
			case 281:
			case 282:
			case 283:
				num = 117;
				break;
			case 196:
			case 197:
			case 198:
			case 199:
			case 284:
			case 285:
			case 286:
			case 287:
				num = 0;
				break;
			case 200:
			case 202:
			case 288:
			case 290:
				num = ((genRand.Next(2) != 0) ? 70 : 69);
				break;
			case 201:
			case 289:
				num = 17;
				break;
			case 203:
			case 291:
				num = ((genRand.Next(2) != 0) ? 68 : 69);
				break;
			case 204:
			case 205:
			case 207:
			case 292:
			case 293:
			case 295:
				num = 0;
				break;
			case 206:
			case 294:
				num = 1;
				break;
			case 208:
			case 209:
			case 210:
			case 211:
			case 296:
			case 297:
			case 298:
			case 299:
				num = ((genRand.Next(2) != 0) ? 125 : 155);
				break;
			case 212:
			case 213:
			case 214:
			case 215:
			case 300:
			case 301:
			case 302:
			case 303:
				num = 1;
				break;
			case 216:
			case 304:
				num = 0;
				break;
			case 217:
			case 305:
				num = 37;
				break;
			case 218:
			case 306:
				num = 155;
				break;
			case 219:
			case 307:
				num = 17;
				break;
			case 220:
			case 308:
				num = 37;
				break;
			case 221:
			case 309:
				num = 155;
				break;
			case 222:
			case 310:
				num = 37;
				break;
			case 223:
			case 311:
				num = 0;
				break;
			case 312:
			case 313:
			case 315:
				num = -1;
				break;
			}
			if (tileCache.wall == 148)
			{
				num = -1;
			}
			if (tileCache.wall == 1 || tileCache.wall == 5 || tileCache.wall == 6 || tileCache.wall == 107)
			{
				num = 1;
			}
			if (tileCache.wall == 35)
			{
				num = 37;
			}
			if (tileCache.wall == 4 || tileCache.wall == 106)
			{
				num = 7;
			}
			if (tileCache.wall == 12)
			{
				num = 9;
			}
			if (tileCache.wall == 336)
			{
				num = 9;
			}
			if (tileCache.wall == 10)
			{
				num = 10;
			}
			if (tileCache.wall == 334)
			{
				num = 10;
			}
			if (tileCache.wall == 11)
			{
				num = 11;
			}
			if (tileCache.wall == 335)
			{
				num = 11;
			}
			if (tileCache.wall == 21)
			{
				num = 13;
			}
			if (tileCache.wall == 34)
			{
				num = 32;
			}
			if (tileCache.wall == 225)
			{
				num = 1;
			}
			if (tileCache.wall == 145)
			{
				num = 8;
			}
			if (tileCache.wall == 23)
			{
				num = 38;
			}
			if (tileCache.wall == 24)
			{
				num = 36;
			}
			if (tileCache.wall == 25 || tileCache.wall == 339)
			{
				num = 48;
			}
			if (tileCache.wall == 179 || tileCache.wall == 178 || tileCache.wall == 183)
			{
				num = 236;
			}
			if (tileCache.wall == 181 || tileCache.wall == 180 || tileCache.wall == 184)
			{
				num = 240;
			}
			if (tileCache.wall == 113)
			{
				num = 189;
			}
			if (tileCache.wall == 114)
			{
				num = 190;
			}
			if (tileCache.wall == 115)
			{
				num = 191;
			}
			if (tileCache.wall == 177 || tileCache.wall == 13 || tileCache.wall == 338)
			{
				num = 25;
			}
			if (tileCache.wall == 186)
			{
				num = genRand.Next(68, 71);
			}
			if (tileCache.wall == 319)
			{
				num = 171;
			}
			if (tileCache.wall == 321)
			{
				num = 308;
			}
			if (tileCache.wall == 322)
			{
				num = 308;
			}
			if (tileCache.wall == 318)
			{
				num = 226;
			}
			if (tileCache.wall == 142)
			{
				num = 210;
			}
			if (tileCache.wall == 143)
			{
				num = 210;
			}
			if (tileCache.wall == 224)
			{
				num = 265;
			}
			if (tileCache.wall == 323)
			{
				num = 314;
			}
			if (tileCache.wall == 324)
			{
				num = 315;
			}
			if (tileCache.wall == 325)
			{
				num = 316;
			}
			if (tileCache.wall == 326)
			{
				num = 317;
			}
			if (tileCache.wall == 327)
			{
				num = 318;
			}
			if (tileCache.wall == 328)
			{
				num = 319;
			}
			if (tileCache.wall == 329)
			{
				num = 320;
			}
			if (tileCache.wall == 330)
			{
				num = 321;
			}
			if (tileCache.wall == 320)
			{
				num = 0;
			}
			if (tileCache.wall == 341)
			{
				num = 258;
			}
			if (tileCache.wall == 342)
			{
				num = 301;
			}
			if (tileCache.wall == 343)
			{
				num = 299;
			}
			if (tileCache.wall == 344)
			{
				num = 300;
			}
			if (tileCache.wall == 345)
			{
				num = 305;
			}
			if (tileCache.wall == 173)
			{
				num = 128;
			}
			if (tileCache.wall == 174)
			{
				num = 117;
			}
			if (tileCache.wall == 175)
			{
				num = 42;
			}
			if (tileCache.wall == 176)
			{
				num = 226;
			}
			if (tileCache.wall == 182)
			{
				num = ((genRand.Next(2) != 0) ? 23 : 6);
			}
			if (tileCache.wall >= 153 && tileCache.wall <= 166)
			{
				switch (tileCache.wall)
				{
				case 154:
				case 158:
					num = 86;
					break;
				case 163:
				case 166:
					num = 87;
					break;
				case 162:
				case 165:
					num = 88;
					break;
				case 156:
				case 160:
					num = 89;
					break;
				case 161:
				case 164:
					num = 90;
					break;
				case 155:
				case 159:
					num = 91;
					break;
				case 153:
				case 157:
					num = 138;
					break;
				}
			}
			if (tileCache.wall == 26 || tileCache.wall == 30 || tileCache.wall == 340)
			{
				num = 49;
			}
			if (tileCache.wall == 29 || tileCache.wall == 32)
			{
				num = 50;
			}
			if (tileCache.wall == 31)
			{
				num = 51;
			}
			if (tileCache.wall == 14 || tileCache.wall == 20 || tileCache.wall == 337)
			{
				num = 109;
			}
			if (tileCache.wall == 241)
			{
				num = 286;
			}
			if (tileCache.wall >= 88 && tileCache.wall <= 93)
			{
				num = 86 + tileCache.wall - 88;
				if (tileCache.wall == 93)
				{
					num = genRand.Next(88, 94);
				}
			}
			if (tileCache.wall == 33)
			{
				num = 14;
			}
			if (tileCache.wall == 41)
			{
				num = 77;
			}
			if (tileCache.wall == 42)
			{
				num = 78;
			}
			if (tileCache.wall == 43)
			{
				num = 78;
			}
			if (tileCache.wall == 36)
			{
				num = 26;
			}
			if (tileCache.wall == 37)
			{
				num = 32;
			}
			if (tileCache.wall == 38)
			{
				num = 2;
			}
			if (tileCache.wall == 39)
			{
				num = 1;
			}
			if (tileCache.wall == 45)
			{
				num = 81;
			}
			if (tileCache.wall == 46)
			{
				num = 83;
			}
			if (tileCache.wall == 47)
			{
				num = 84;
			}
			if (tileCache.wall == 85)
			{
				num = 126;
			}
			if (tileCache.wall == 63)
			{
				num = 3;
			}
			if (tileCache.wall == 65)
			{
				num = 3;
			}
			if (tileCache.wall == 66)
			{
				num = 3;
			}
			if (tileCache.wall == 68)
			{
				num = 3;
			}
			if (tileCache.wall == 64)
			{
				num = 40;
			}
			if (tileCache.wall == 67)
			{
				num = 40;
			}
			if (tileCache.wall == 84)
			{
				num = 80;
			}
			if (tileCache.wall == 60)
			{
				num = 3;
			}
			if (tileCache.wall == 167)
			{
				num = 81;
			}
			if (tileCache.wall == 147)
			{
				num = 51;
			}
			if (tileCache.wall == 146)
			{
				num = 9;
			}
			if (tileCache.wall == 109)
			{
				num = 144;
			}
			if (tileCache.wall == 110)
			{
				num = 145;
			}
			if (tileCache.wall == 111)
			{
				num = 146;
			}
			if (tileCache.wall == 86 || tileCache.wall == 108)
			{
				num = 147;
			}
			if (tileCache.wall == 87)
			{
				num = 148;
			}
			if (tileCache.wall == 136)
			{
				num = 13;
			}
			if (tileCache.wall == 137)
			{
				num = 13;
			}
			if (tileCache.wall == 168)
			{
				num = 13;
			}
			if (tileCache.wall == 169)
			{
				num = 13;
			}
			if (tileCache.wall == 172)
			{
				num = 13;
			}
			if (tileCache.wall == 226)
			{
				num = 13;
			}
			if (tileCache.wall == 227)
			{
				num = 13;
			}
			if (tileCache.wall == 242)
			{
				num = 13;
			}
			if (tileCache.wall == 243)
			{
				num = 13;
			}
			if (tileCache.wall == 72)
			{
				num = 40;
			}
			if (tileCache.wall == 73)
			{
				num = 16;
			}
			if (tileCache.wall == 74 || tileCache.wall == 80)
			{
				num = 26;
			}
			if (tileCache.wall == 144)
			{
				num = ((genRand.Next(2) != 0) ? 118 : 10);
			}
			if (tileCache.wall == 75)
			{
				num = 26;
			}
			if (tileCache.wall == 76)
			{
				num = 4;
			}
			if (tileCache.wall == 77 || tileCache.wall == 81)
			{
				num = 5;
			}
			if (tileCache.wall == 78 || tileCache.wall == 244)
			{
				num = 7;
			}
			if (tileCache.wall == 82)
			{
				num = 36;
			}
			if (tileCache.wall == 27)
			{
				num = ((genRand.Next(2) != 0) ? 1 : 7);
			}
			if (tileCache.wall == 138)
			{
				num = 77;
			}
			if (tileCache.wall == 139)
			{
				num = 78;
			}
			if (tileCache.wall == 140)
			{
				num = 79;
			}
			if (tileCache.wall == 141)
			{
				num = 126;
			}
			if (tileCache.wall == 149 || tileCache.wall == 150)
			{
				num = 214;
			}
			if (tileCache.wall == 151 || tileCache.wall == 152)
			{
				num = 215;
			}
			if (tileCache.wall == 245)
			{
				num = 195;
			}
			if (tileCache.wall == 44 || tileCache.wall == 346)
			{
				int num2 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
				Main.dust[num2].noGravity = true;
			}
			else if ((tileCache.wall < 133 || tileCache.wall > 135) && (tileCache.wall < 116 || tileCache.wall > 125) && (tileCache.wall < 126 || tileCache.wall > 132))
			{
				if (tileCache.wall == 76)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
				}
				else if (num >= 0)
				{
					Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
				}
			}
		}

		public static void LaunchRocket(int x, int y, bool fromWiring)
		{
			int num = Main.tile[x, y].frameY;
			int num2 = 0;
			while (num >= 40)
			{
				num -= 40;
				num2++;
			}
			if (num == 18)
			{
				y--;
			}
			Vector2 vector = new Vector2(x * 16 + 8, y * 16 + 4);
			int type = 167 + num2;
			int damage = 150;
			int num3 = 7;
			int num4 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector.X, vector.Y + 2f, 0f, -8f, type, damage, num3, Main.myPlayer);
			Main.projectile[num4].originatedFromActivableTile = true;
			Main.tile[x, y].active(active: false);
			Main.tile[x, y + 1].active(active: false);
			NetMessage.SendTileSquare(-1, x, y, 1, 2);
		}

		public static void LaunchRocketSmall(int x, int y, bool fromWiring)
		{
			if (Main.tile[x, y].frameX == 18)
			{
				x--;
			}
			if (Main.tile[x, y].frameY == 18)
			{
				y--;
			}
			Vector2 vector = new Vector2(x * 16 + 16, y * 16);
			int type = 415 + Main.rand.Next(4);
			int damage = 0;
			int num = 0;
			int num2 = Projectile.NewProjectile(GetProjectileSource_PlayerOrWires(x, y, fromWiring, Main.LocalPlayer), vector.X, vector.Y + 2f, 0f, -8f, type, damage, num, Main.myPlayer);
			Main.projectile[num2].originatedFromActivableTile = true;
		}

		public static bool CanKillTile(int i, int j, SpecialKillTileContext context)
		{
			if (context == SpecialKillTileContext.MowingTheGrass)
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return false;
				}
				if (tile.type == 2 || tile.type == 109)
				{
					return true;
				}
			}
			return CanKillTile(i, j);
		}

		public static bool CanKillTile(int i, int j)
		{
			bool blockDamaged;
			return CanKillTile(i, j, out blockDamaged);
		}

		public static bool CanKillTile(int i, int j, out bool blockDamaged)
		{
			blockDamaged = false;
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
			{
				return false;
			}
			Tile tile = Main.tile[i, j];
			Tile tile2 = null;
			if (tile == null)
			{
				return false;
			}
			if (!tile.active())
			{
				return false;
			}
			if (j >= 1)
			{
				tile2 = Main.tile[i, j - 1];
			}
			if (tile2 != null && tile2.active())
			{
				int type = tile2.type;
				if (TileID.Sets.IsATreeTrunk[type] && tile.type != type && (tile2.frameX != 66 || tile2.frameY < 0 || tile2.frameY > 44) && (tile2.frameX != 88 || tile2.frameY < 66 || tile2.frameY > 110) && tile2.frameY < 198)
				{
					return false;
				}
				switch (type)
				{
				case 323:
					if (tile.type != type && (tile2.frameX == 66 || tile2.frameX == 220))
					{
						return false;
					}
					break;
				case 21:
				case 26:
				case 72:
				case 77:
				case 88:
				case 467:
				case 488:
					if (tile.type != type)
					{
						return false;
					}
					break;
				case 80:
					if (tile.type != type)
					{
						int num = tile2.frameX / 18;
						if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
						{
							return false;
						}
					}
					break;
				}
			}
			if (TileID.Sets.Boulders[tile.type] && CheckBoulderChest(i, j))
			{
				blockDamaged = true;
				return false;
			}
			switch (tile.type)
			{
			case 10:
				if (IsLockedDoor(tile))
				{
					blockDamaged = true;
					return false;
				}
				break;
			case 235:
			{
				int num2 = i - tile.frameX % 54 / 18;
				for (int k = 0; k < 3; k++)
				{
					Tile tile3 = Main.tile[num2 + k, j - 1];
					if (tile3.active() && IsAContainer(tile3))
					{
						blockDamaged = true;
						return false;
					}
				}
				break;
			}
			case 21:
			case 467:
				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 2, j - tile.frameY / 18))
				{
					return false;
				}
				break;
			case 88:
				if (!Chest.CanDestroyChest(i - tile.frameX / 18 % 3, j - tile.frameY / 18))
				{
					return false;
				}
				break;
			}
			return true;
		}

		public static bool IsTileReplacable(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (y >= 1)
			{
				Tile tile2 = Main.tile[x, y - 1];
				if (tile == null || tile2 == null)
				{
					return false;
				}
				if (tile2.active())
				{
					if (tile2.type == 80)
					{
						return false;
					}
					if (tile2.type == 488)
					{
						return false;
					}
					if (TileID.Sets.PreventsTileReplaceIfOnTopOfIt[tile2.type] && tile.type != tile2.type)
					{
						if (TileID.Sets.IsATreeTrunk[tile2.type])
						{
							if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
							{
								return true;
							}
							return false;
						}
						if (tile2.type == 323)
						{
							if (tile2.frameX == 66 || tile2.frameX == 220)
							{
								return false;
							}
							return true;
						}
						return false;
					}
				}
			}
			return true;
		}

		public static int CheckTileBreakability(int x, int y)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			Tile tile = Main.tile[x, y];
			if (y >= 1 && y <= Main.maxTilesY - 1)
			{
				if (Main.tile[x, y - 1] == null)
				{
					Main.tile[x, y - 1] = new Tile();
				}
				if (Main.tile[x, y + 1] == null)
				{
					Main.tile[x, y + 1] = new Tile();
				}
				Tile tile2 = Main.tile[x, y - 1];
				Tile tile3 = Main.tile[x, y + 1];
				if (tile3 != null && tile3.active() && IsLockedDoor(x, y + 1))
				{
					return 2;
				}
				if (!Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
				{
					return 0;
				}
				if (tile2.active())
				{
					if ((TileID.Sets.PreventsTileRemovalIfOnTopOfIt[tile2.type] && tile.type != tile2.type) | IsLockedDoor(x, y - 1) | (tile2.type == 77 && tile.type != 77 && !Main.hardMode) | (IsAContainer(tile2) && !IsAContainer(tile)))
					{
						if (TileID.Sets.IsATreeTrunk[tile2.type])
						{
							if ((tile2.frameX == 66 && tile2.frameY >= 0 && tile2.frameY <= 44) || (tile2.frameX == 88 && tile2.frameY >= 66 && tile2.frameY <= 110) || tile2.frameY >= 198)
							{
								return 0;
							}
							return 2;
						}
						if (tile2.type == 323)
						{
							if (tile2.frameX == 66 || tile2.frameX == 220)
							{
								return 2;
							}
							return 0;
						}
						return 2;
					}
					if (tile2.type == 80 && tile2.type != tile.type)
					{
						int num = tile2.frameX / 18;
						if ((uint)num <= 1u || (uint)(num - 4) <= 1u)
						{
							return 2;
						}
					}
					if (tile.type == 10 && IsLockedDoor(tile))
					{
						return 1;
					}
					if (TileID.Sets.Boulders[tile.type])
					{
						if (CheckBoulderChest(x, y))
						{
							return 1;
						}
						return 0;
					}
				}
				if (tile.type == 235)
				{
					int frameX = tile.frameX;
					int num2 = x - frameX % 54 / 18;
					for (int i = 0; i < 3; i++)
					{
						if (Main.tile[num2 + i, y - 1].active() && IsAContainer(Main.tile[num2 + i, y - 1]))
						{
							return 2;
						}
					}
				}
			}
			return 0;
		}

		public static bool CheckTileBreakability2_ShouldTileSurvive(int x, int y)
		{
			if (Main.netMode == 1)
			{
				return false;
			}
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			Tile tile = Main.tile[x, y];
			if (TileID.Sets.BasicChest[tile.type])
			{
				int num = tile.frameX / 18;
				int y2 = y - tile.frameY / 18;
				while (num > 1)
				{
					num -= 2;
				}
				num = x - num;
				if (!Chest.DestroyChest(num, y2))
				{
					return true;
				}
			}
			if (tile.type == 88)
			{
				int num2 = tile.frameX / 18;
				int y3 = y - tile.frameY / 18;
				num2 %= 3;
				num2 = x - num2;
				if (!Chest.DestroyChest(num2, y3))
				{
					return true;
				}
			}
			if (tile.type == 470)
			{
				return !TEDisplayDoll.IsBreakable(x, y);
			}
			if (tile.type == 475)
			{
				return !TEHatRack.IsBreakable(x, y);
			}
			return false;
		}

		public static bool ReplaceWall(int x, int y, ushort targetWall)
		{
			if (targetWall >= 347)
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile.wall == 0 || targetWall == 0)
			{
				return false;
			}
			if (KillWall_CheckFailure(fail: false, tile))
			{
				return false;
			}
			int num = 10;
			for (int i = 0; i < num; i++)
			{
				KillWall_MakeWallDust(x, y, tile);
			}
			KillWall_PlaySounds(x, y, tile);
			KillWall_DropItems(x, y, tile);
			tile.wall = targetWall;
			tile.ClearWallPaintAndCoating();
			SquareWallFrame(x, y);
			return true;
		}

		public static bool ReplaceTile(int x, int y, ushort targetType, int targetStyle)
		{
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (!WouldTileReplacementWork(targetType, x, y))
			{
				return false;
			}
			if (!IsTileReplacable(x, y))
			{
				return false;
			}
			MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
			int num = KillTile_GetTileDustAmount(fail: false, tileSafely);
			for (int i = 0; i < num; i++)
			{
				KillTile_MakeTileDust(x, y, tileSafely);
			}
			KillTile_PlaySounds(x, y, fail: false, tileSafely);
			KillTile_DropItems(x, y, tileSafely, includeLargeObjectDrops: true);
			AttemptFossilShattering(x, y, tileSafely, fail: false);
			ReplaceTIle_DoActualReplacement(targetType, targetStyle, x, y, tileSafely);
			return true;
		}

		private static void ReplaceTIle_DoActualReplacement(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
		{
			if (TileID.Sets.BasicChest[targetType])
			{
				if (IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1)
				{
					Wiring.HitSwitch(topLeftX, topLeftY);
					NetMessage.SendData(59, -1, -1, null, topLeftX, topLeftY);
				}
				ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 2, 2);
			}
			else if (TileID.Sets.BasicDresser[targetType])
			{
				ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
			}
			else if (targetType == 215)
			{
				ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
			}
			else
			{
				ReplaceTile_DoActualReplacement_Single(targetType, targetStyle, topLeftX, topLeftY, t);
			}
		}

		private static void ReplaceTile_DoActualReplacement_Single(ushort targetType, int targetStyle, int topLeftX, int topLeftY, Tile t)
		{
			ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
			int type = t.type;
			t.type = targetType;
			if (TileID.Sets.Platforms[t.type])
			{
				t.frameY = (short)(targetStyle * 18);
			}
			if (t.type == 4)
			{
				t.frameY = (short)(targetStyle * 22);
			}
			t.ClearBlockPaintAndCoating();
			bool flag = !CanPoundTile(topLeftX, topLeftY);
			if (TileID.Sets.Platforms[type] && TileID.Sets.Platforms[t.type])
			{
				flag = false;
			}
			if (flag)
			{
				t.slope(0);
				t.halfBrick(halfBrick: false);
			}
			SquareTileFrame(topLeftX, topLeftY);
		}

		private static void ReplaceTile_EliminateNaturalExtras(int x, int y)
		{
			if (InWorld(x, y, 2))
			{
				if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[Main.tile[x, y - 1].type] || (Main.tile[x, y - 1].type == 165 && (Main.tile[x, y - 1].frameY == 36 || Main.tile[x, y - 1].frameY == 54 || Main.tile[x, y - 1].frameY == 90))))
				{
					KillTile(x, y - 1);
				}
				if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active() && (TileID.Sets.ReplaceTileBreakDown[Main.tile[x, y + 1].type] || (Main.tile[x, y + 1].type == 165 && (Main.tile[x, y + 1].frameY == 0 || Main.tile[x, y + 1].frameY == 18 || Main.tile[x, y + 1].frameY == 72))))
				{
					KillTile(x, y + 1);
				}
			}
		}

		private static void ReplaceTile_DoActualReplacement_Area(ushort targetType, int targetStyle, int topLeftX, int topLeftY, int areaSizeX, int areaSizeY)
		{
			for (int i = 0; i < areaSizeX; i++)
			{
				for (int j = 0; j < areaSizeY; j++)
				{
					Tile tile = Main.tile[topLeftX + i, topLeftY + j];
					tile.type = targetType;
					tile.frameX = (short)(targetStyle * (areaSizeX * 18) + i * 18);
					tile.frameY = (short)(j * 18);
					tile.ClearBlockPaintAndCoating();
				}
			}
			for (int k = 0; k < areaSizeX; k++)
			{
				for (int l = 0; l < areaSizeY; l++)
				{
					SquareTileFrame(topLeftX + k, topLeftY + l);
				}
			}
		}

		private static void MoveReplaceTileAnchor(ref int x, ref int y, ushort targetType, Tile t)
		{
			if (TileID.Sets.BasicChest[t.type])
			{
				x -= t.frameX % 36 / 18;
				y -= t.frameY % 36 / 18;
			}
			if (TileID.Sets.BasicDresser[t.type])
			{
				x -= t.frameX % 54 / 18;
				y -= t.frameY % 36 / 18;
			}
			if (t.type == 215)
			{
				x -= t.frameX % 54 / 18;
				y -= t.frameY % 36 / 18;
			}
		}

		public static bool WouldTileReplacementBeBlockedByLiquid(int x, int y, int liquidType)
		{
			if ((Main.tile[x - 1, y].liquid <= 0 || Main.tile[x - 1, y].liquidType() != liquidType) && (Main.tile[x + 1, y].liquid <= 0 || Main.tile[x + 1, y].liquidType() != liquidType))
			{
				if (Main.tile[x, y - 1].liquid > 0)
				{
					return Main.tile[x, y - 1].liquidType() == liquidType;
				}
				return false;
			}
			return true;
		}

		public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (attemptingToReplaceWith >= 693)
			{
				return false;
			}
			if (TileID.Sets.Conversion.Grass[attemptingToReplaceWith] || attemptingToReplaceWith == 633)
			{
				return false;
			}
			if (Main.tileRope[tile.type] && InWorld(x, y, 2))
			{
				Tile tile2 = Main.tile[x - 1, y];
				Tile tile3 = Main.tile[x + 1, y];
				if (attemptingToReplaceWith == 314 && tile2 != null && tile3 != null && ((tile2.active() && tile2.type == 314) || (tile3.active() && tile3.type == 314)))
				{
					return true;
				}
				if (TileID.Sets.Platforms[attemptingToReplaceWith] && tile2 != null && tile3 != null && ((tile2.active() && TileID.Sets.Platforms[tile2.type]) || (tile3.active() && TileID.Sets.Platforms[tile3.type])))
				{
					return true;
				}
			}
			bool flag = !ReplaceTile_IsValidSolid(attemptingToReplaceWith) || !ReplaceTile_IsValidSolid(tile.type);
			bool flag2 = !ReplaceTile_IsValidTorch(attemptingToReplaceWith) || !ReplaceTile_IsValidTorch(tile.type);
			bool flag3 = !ReplaceTile_IsValidCampfire(attemptingToReplaceWith) || !ReplaceTile_IsValidCampfire(tile.type);
			bool num = !ReplaceTile_IsValidPlatform(attemptingToReplaceWith) || !ReplaceTile_IsValidPlatform(tile.type);
			bool flag4 = (!ReplaceTile_IsValidSolid(attemptingToReplaceWith) && !ReplaceTile_IsValidPlatform(attemptingToReplaceWith)) || (!ReplaceTile_IsValidSolid(tile.type) && !ReplaceTile_IsValidPlatform(tile.type));
			bool flag5 = !ReplaceTile_IsValidChest(attemptingToReplaceWith) || !ReplaceTile_IsValidChest(tile.type) || Chest.IsLocked(tile);
			bool flag6 = !ReplaceTile_IsValidDresser(attemptingToReplaceWith) || !ReplaceTile_IsValidDresser(tile.type);
			return !(num && flag2 && flag3 && flag && flag4 && flag5 && flag6);
		}

		private static bool ReplaceTile_IsValidSolid(int type)
		{
			if (Main.tileSolid[type] && !Main.tileSolidTop[type])
			{
				if (!Main.tileRope[type])
				{
					return !Main.tileFrameImportant[type];
				}
				return true;
			}
			return false;
		}

		private static bool ReplaceTile_IsValidTorch(int type)
		{
			return type == 4;
		}

		private static bool ReplaceTile_IsValidCampfire(int type)
		{
			return type == 215;
		}

		private static bool ReplaceTile_IsValidChest(int type)
		{
			return TileID.Sets.BasicChest[type];
		}

		private static bool ReplaceTile_IsValidDresser(int type)
		{
			return TileID.Sets.BasicDresser[type];
		}

		private static bool ReplaceTile_IsValidPlatform(int type)
		{
			return TileID.Sets.Platforms[type];
		}

		public static bool GetAshTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			_ = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 116;
			topTextureFrameHeight = 96;
			floorY = j;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile = Main.tile[num, floorY];
				if (tile == null)
				{
					return false;
				}
				if (tile.type == 633)
				{
					treeStyle = 31;
					return true;
				}
			}
			return false;
		}

		public static bool GetVanityTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			Tile tile = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 118;
			topTextureFrameHeight = 96;
			floorY = j;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile2 = Main.tile[num, floorY];
				if (tile2 == null)
				{
					return false;
				}
				if (TileID.Sets.Conversion.Grass[tile2.type])
				{
					switch (tile.type)
					{
					case 596:
						treeStyle = 29;
						return true;
					case 616:
						treeStyle = 30;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetGemTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			Tile tile = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 116;
			topTextureFrameHeight = 96;
			floorY = j;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile2 = Main.tile[num, floorY];
				if (tile2 == null)
				{
					return false;
				}
				if (TileID.Sets.Conversion.Stone[tile2.type])
				{
					switch (tile.type)
					{
					case 583:
						treeStyle = 22;
						return true;
					case 584:
						treeStyle = 23;
						return true;
					case 585:
						treeStyle = 24;
						return true;
					case 586:
						treeStyle = 25;
						return true;
					case 587:
						treeStyle = 26;
						return true;
					case 588:
						treeStyle = 27;
						return true;
					case 589:
						treeStyle = 28;
						return true;
					}
				}
			}
			return false;
		}

		public static bool GetCommonTreeFoliageData(int i, int j, int xoffset, ref int treeFrame, ref int treeStyle, out int floorY, out int topTextureFrameWidth, out int topTextureFrameHeight)
		{
			_ = Main.tile[i, j];
			int num = i + xoffset;
			topTextureFrameWidth = 80;
			topTextureFrameHeight = 80;
			floorY = j;
			int num2 = 0;
			for (int k = 0; k < 100; k++)
			{
				floorY = j + k;
				Tile tile = Main.tile[num, floorY];
				if (tile == null)
				{
					return false;
				}
				switch (tile.type)
				{
				case 2:
				case 477:
				{
					int num4 = 0;
					num4 = ((num <= Main.treeX[0]) ? TreeTops.GetTreeStyle(0) : ((num <= Main.treeX[1]) ? TreeTops.GetTreeStyle(1) : ((num > Main.treeX[2]) ? TreeTops.GetTreeStyle(3) : TreeTops.GetTreeStyle(2))));
					switch (num4)
					{
					case 0:
						treeStyle = 0;
						break;
					case 5:
						treeStyle = 10;
						break;
					default:
						treeStyle = 5 + num4;
						break;
					}
					return true;
				}
				case 23:
				case 661:
					treeStyle = 1;
					return true;
				case 70:
					treeStyle = 14;
					return true;
				case 199:
				case 662:
					treeStyle = 5;
					return true;
				case 60:
					topTextureFrameHeight = 96;
					topTextureFrameWidth = 114;
					treeStyle = 2;
					num2 = TreeTops.GetTreeStyle(5);
					if (num2 == 1)
					{
						treeStyle = 11;
						topTextureFrameWidth = 116;
					}
					if ((double)floorY > Main.worldSurface)
					{
						treeStyle = 13;
						topTextureFrameWidth = 116;
					}
					return true;
				case 147:
					treeStyle = 4;
					num2 = TreeTops.GetTreeStyle(6);
					if (num2 == 0)
					{
						treeStyle = 12;
						if (i % 10 == 0)
						{
							treeStyle = 18;
						}
					}
					if (num2 == 2 || num2 == 3 || num2 == 32 || num2 == 4 || num2 == 42 || num2 == 5 || num2 == 7)
					{
						if (num2 % 2 == 0)
						{
							if (i < Main.maxTilesX / 2)
							{
								treeStyle = 16;
							}
							else
							{
								treeStyle = 17;
							}
						}
						else if (i > Main.maxTilesX / 2)
						{
							treeStyle = 16;
						}
						else
						{
							treeStyle = 17;
						}
					}
					return true;
				case 109:
				case 492:
				{
					topTextureFrameHeight = 140;
					int num3 = (treeStyle = GetHollowTreeFoliageStyle());
					if (num3 == 19)
					{
						topTextureFrameWidth = 120;
					}
					if (num3 == 20)
					{
						treeStyle = 20;
						if (i % 6 == 1)
						{
							treeFrame += 3;
						}
						else if (i % 6 == 2)
						{
							treeFrame += 6;
						}
						else if (i % 6 == 3)
						{
							treeFrame += 9;
						}
						else if (i % 6 == 4)
						{
							treeFrame += 12;
						}
						else if (i % 6 == 5)
						{
							treeFrame += 15;
						}
					}
					else if (i % 3 == 1)
					{
						treeFrame += 3;
					}
					else if (i % 3 == 2)
					{
						treeFrame += 6;
					}
					return true;
				}
				}
			}
			return false;
		}

		public static int GetHollowTreeFoliageStyle()
		{
			TreeTops.GetTreeStyle(7);
			switch (hallowBG)
			{
			default:
				return 3;
			case 4:
				return 19;
			case 2:
			case 3:
				return 20;
			}
		}

		public static int GetTreeFrame(Tile t)
		{
			if (t.frameY == 220)
			{
				return 1;
			}
			if (t.frameY == 242)
			{
				return 2;
			}
			return 0;
		}

		public static TreeTypes GetTreeType(int tileType)
		{
			switch (tileType)
			{
			case 2:
			case 477:
				return TreeTypes.Forest;
			case 23:
				return TreeTypes.Corrupt;
			case 70:
				return TreeTypes.Mushroom;
			case 199:
				return TreeTypes.Crimson;
			case 60:
				return TreeTypes.Jungle;
			case 147:
				return TreeTypes.Snow;
			case 109:
			case 492:
				return TreeTypes.Hallowed;
			case 53:
				return TreeTypes.Palm;
			case 112:
				return TreeTypes.PalmCorrupt;
			case 234:
				return TreeTypes.PalmCrimson;
			case 116:
				return TreeTypes.PalmHallowed;
			case 633:
				return TreeTypes.Ash;
			default:
				return TreeTypes.None;
			}
		}

		public static bool IsThisAMushroomTree(int i, int j)
		{
			GetTreeBottom(i, j, out var x, out var y);
			if (GetTreeType(Main.tile[x, y].type) == TreeTypes.Mushroom)
			{
				return true;
			}
			return false;
		}

		public static void ResetTreeShakes()
		{
			numTreeShakes = 0;
		}

		private static void ShakeTree(int i, int j)
		{
			if (numTreeShakes == maxTreeShakes)
			{
				return;
			}
			GetTreeBottom(i, j, out var x, out var y);
			int num = y;
			TreeTypes treeType = GetTreeType(Main.tile[x, y].type);
			if (treeType == TreeTypes.None)
			{
				return;
			}
			for (int k = 0; k < numTreeShakes; k++)
			{
				if (treeShakeX[k] == x && treeShakeY[k] == y)
				{
					return;
				}
			}
			treeShakeX[numTreeShakes] = x;
			treeShakeY[numTreeShakes] = y;
			numTreeShakes++;
			y--;
			while (y > 10 && Main.tile[x, y].active() && TileID.Sets.IsShakeable[Main.tile[x, y].type])
			{
				y--;
			}
			y++;
			if (!IsTileALeafyTreeTop(x, y) || Collision.SolidTiles(x - 2, x + 2, y - 2, y + 2))
			{
				return;
			}
			if (Main.getGoodWorld && genRand.Next(17) == 0)
			{
				Projectile.NewProjectile(GetProjectileSource_ShakeTree(x, y), x * 16, y * 16, (float)Main.rand.Next(-100, 101) * 0.002f, 0f, 28, 0, 0f, Main.myPlayer, 16f, 16f);
			}
			else if (genRand.Next(300) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 832);
			}
			else if (genRand.Next(300) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 933);
			}
			else if (genRand.Next(200) == 0 && treeType == TreeTypes.Jungle)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 3360);
			}
			else if (genRand.Next(200) == 0 && treeType == TreeTypes.Jungle)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 3361);
			}
			else if (genRand.Next(1000) == 0 && treeType == TreeTypes.Forest)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 4366);
			}
			else if (genRand.Next(7) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Snow || treeType == TreeTypes.Hallowed || treeType == TreeTypes.Ash))
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 27, genRand.Next(1, 3));
			}
			else if (genRand.Next(8) == 0 && treeType == TreeTypes.Mushroom)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 194, genRand.Next(1, 2));
			}
			else if (genRand.Next(35) == 0 && Main.halloween)
			{
				Item.NewItem(GetItemSource_ShakeTree(x, y), x * 16, y * 16, 16, 16, 1809, genRand.Next(1, 3));
			}
			else if (genRand.Next(12) == 0)
			{
				int dropItem = 0;
				KillTile_GetItemDrops(i, j, Main.tile[i, j], out dropItem, out var _, out var _, out var _);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, dropItem, genRand.Next(1, 4));
			}
			else if (genRand.Next(20) == 0)
			{
				int type = 71;
				int num2 = genRand.Next(50, 100);
				if (genRand.Next(30) == 0)
				{
					type = 73;
					num2 = 1;
					if (genRand.Next(5) == 0)
					{
						num2++;
					}
					if (genRand.Next(10) == 0)
					{
						num2++;
					}
				}
				else if (genRand.Next(10) == 0)
				{
					type = 72;
					num2 = genRand.Next(1, 21);
					if (genRand.Next(3) == 0)
					{
						num2 += genRand.Next(1, 21);
					}
					if (genRand.Next(4) == 0)
					{
						num2 += genRand.Next(1, 21);
					}
				}
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, type, num2);
			}
			else if (genRand.Next(15) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
			{
				int type2 = genRand.Next(5) switch
				{
					0 => 74, 
					1 => 297, 
					2 => 298, 
					3 => 299, 
					_ => 538, 
				};
				if (Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0f)
				{
					type2 = ((genRand.Next(2) != 0) ? 539 : 442);
				}
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, type2);
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Hallowed && !Main.dayTime)
			{
				int type3 = Main.rand.NextFromList(new short[3] { 583, 584, 585 });
				if (Main.tenthAnniversaryWorld && Main.rand.Next(4) != 0)
				{
					type3 = 583;
				}
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, type3);
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Forest && !Main.dayTime)
			{
				NPC obj = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 611)];
				obj.velocity.Y = 1f;
				obj.netUpdate = true;
			}
			else if (genRand.Next(50) == 0 && treeType == TreeTypes.Jungle && Main.dayTime)
			{
				NPC obj2 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, Main.rand.NextFromList(new short[5] { 671, 672, 673, 674, 675 }))];
				obj2.velocity.Y = 1f;
				obj2.netUpdate = true;
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Forest && !Main.dayTime && Main.halloween)
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 301);
			}
			else if (genRand.Next(50) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
			{
				for (int l = 0; l < 5; l++)
				{
					Point point = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
					int type4 = ((Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) != 0f) ? Main.rand.NextFromList(new short[3] { 74, 297, 298 }) : 442);
					NPC obj3 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), point.X * 16, point.Y * 16, type4)];
					obj3.velocity = Main.rand.NextVector2CircularEdge(3f, 3f);
					obj3.netUpdate = true;
				}
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
			{
				for (int m = 0; m < 5; m++)
				{
					Point point2 = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
					NPC obj4 = Main.npc[NPC.NewNPC(new EntitySource_ShakeTree(x, y), point2.X * 16, point2.Y * 16, Main.rand.NextFromList(new short[2] { 210, 211 }))];
					obj4.ai[1] = 65f;
					obj4.netUpdate = true;
				}
			}
			else if (genRand.Next(20) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !IsPalmOasisTree(x))
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 603);
			}
			else if (genRand.Next(30) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, -22);
			}
			else if (genRand.Next(30) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, -11);
			}
			else if (genRand.Next(30) == 0 && treeType == TreeTypes.Jungle && !Main.dayTime)
			{
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, 51);
			}
			else if (genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
			{
				Projectile.NewProjectile(GetProjectileSource_ShakeTree(x, y), x * 16 + 8, (y - 1) * 16, 0f, 0f, 655, 0, 0f, Main.myPlayer);
			}
			else if (genRand.Next(20) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed) && !Main.raining && !NPC.TooWindyForButterflies && Main.dayTime)
			{
				int type5 = 356;
				if (Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0f)
				{
					type5 = 444;
				}
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, type5);
			}
			else if (genRand.Next(20) == 0 && treeType == TreeTypes.Ash && y > Main.maxTilesY - 250)
			{
				int num3 = genRand.Next(3);
				NPC.NewNPC(new EntitySource_ShakeTree(x, y), x * 16, y * 16, num3 switch
				{
					0 => 654, 
					1 => 653, 
					_ => 655, 
				});
			}
			else if (Main.remixWorld && genRand.Next(20) == 0 && treeType == TreeTypes.Ash && y > Main.maxTilesY - 250)
			{
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, 965, genRand.Next(20, 41));
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Forest)
			{
				int num4 = genRand.Next(5);
				Item.NewItem(GetItemSource_FromTreeShake(x, y), x * 16, y * 16, 16, 16, num4 switch
				{
					0 => 4009, 
					1 => 4293, 
					2 => 4282, 
					3 => 4290, 
					_ => 4291, 
				});
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Snow)
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4295 : 4286, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Jungle)
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4292 : 4294, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed) && !IsPalmOasisTree(x))
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4287 : 4283, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4289 : 4284, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Hallowed || treeType == TreeTypes.PalmHallowed))
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4288 : 4297, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 4285 : 4296, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			else if (genRand.Next(12) == 0 && treeType == TreeTypes.Ash)
			{
				Item.NewItem(Type: (genRand.Next(2) != 0) ? 5278 : 5277, source: GetItemSource_FromTreeShake(x, y), X: x * 16, Y: y * 16, Width: 16, Height: 16);
			}
			int treeHeight = 0;
			int treeFrame = 0;
			int passStyle = 0;
			GetTreeLeaf(x, Main.tile[x, y], Main.tile[x, num], ref treeHeight, out treeFrame, out passStyle);
			if (passStyle != -1)
			{
				if (Main.netMode == 2)
				{
					NetMessage.SendData(112, -1, -1, null, 1, x, y, 1f, passStyle);
				}
				if (Main.netMode == 0)
				{
					TreeGrowFX(x, y, 1, passStyle, hitTree: true);
				}
			}
		}

		private static void GetVineTop(int i, int j, out int x, out int y)
		{
			x = i;
			y = j;
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (TileID.Sets.IsVine[tileSafely.type])
			{
				while (y > 20 && tileSafely.active() && TileID.Sets.IsVine[tileSafely.type])
				{
					y--;
					tileSafely = Framing.GetTileSafely(x, y);
				}
			}
		}

		public static void GetTreeBottom(int i, int j, out int x, out int y)
		{
			x = i;
			y = j;
			Tile tileSafely = Framing.GetTileSafely(x, y);
			if (tileSafely.type == 323)
			{
				while (y < Main.maxTilesY - 50 && (!tileSafely.active() || tileSafely.type == 323))
				{
					y++;
					tileSafely = Framing.GetTileSafely(x, y);
				}
				return;
			}
			int num = tileSafely.frameX / 22;
			int num2 = tileSafely.frameY / 22;
			if (num == 3 && num2 <= 2)
			{
				x++;
			}
			else if (num == 4 && num2 >= 3 && num2 <= 5)
			{
				x--;
			}
			else if (num == 1 && num2 >= 6 && num2 <= 8)
			{
				x--;
			}
			else if (num == 2 && num2 >= 6 && num2 <= 8)
			{
				x++;
			}
			else if (num == 2 && num2 >= 9)
			{
				x++;
			}
			else if (num == 3 && num2 >= 9)
			{
				x--;
			}
			tileSafely = Framing.GetTileSafely(x, y);
			while (y < Main.maxTilesY - 50 && (!tileSafely.active() || TileID.Sets.IsATreeTrunk[tileSafely.type] || tileSafely.type == 72))
			{
				y++;
				tileSafely = Framing.GetTileSafely(x, y);
			}
		}

		private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail)
		{
			if (tileCache.type != 404 || Main.netMode == 1 || fossilBreak)
			{
				return;
			}
			fossilBreak = true;
			for (int k = i - 1; k <= i + 1; k++)
			{
				for (int l = j - 1; l <= j + 1; l++)
				{
					int maxValue = 15;
					if (!SolidTile(k, l + 1))
					{
						maxValue = 4;
					}
					else if (k == i && l == j - 1 && !fail)
					{
						maxValue = 4;
					}
					if ((k != i || l != j) && Main.tile[k, l].active() && Main.tile[k, l].type == 404 && genRand.Next(maxValue) == 0)
					{
						KillTile(k, l, fail: false, effectOnly: false, noItem: true);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, k, l);
						}
					}
				}
			}
			fossilBreak = false;
		}

		public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
		{
			if (i < 0 || j < 0 || i >= Main.maxTilesX || j >= Main.maxTilesY)
			{
				return;
			}
			Tile tile = Main.tile[i, j];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[i, j] = tile;
			}
			if (!tile.active())
			{
				return;
			}
			if (j >= 1 && Main.tile[i, j - 1] == null)
			{
				Main.tile[i, j - 1] = new Tile();
			}
			int num = CheckTileBreakability(i, j);
			if (num == 1)
			{
				fail = true;
			}
			if (num == 2)
			{
				return;
			}
			if (gen)
			{
				noItem = true;
			}
			if (!effectOnly && !stopDrops)
			{
				if (!noItem && FixExploitManEaters.SpotProtected(i, j))
				{
					return;
				}
				if (!gen && !Main.gameMenu)
				{
					KillTile_PlaySounds(i, j, fail, tile);
				}
			}
			if (tile.type == 128 || tile.type == 269)
			{
				int num2 = i;
				int num3 = tile.frameX;
				int num4;
				for (num4 = tile.frameX; num4 >= 100; num4 -= 100)
				{
				}
				while (num4 >= 36)
				{
					num4 -= 36;
				}
				if (num4 == 18)
				{
					num3 = Main.tile[i - 1, j].frameX;
					num2--;
				}
				if (num3 >= 100)
				{
					int num5 = 0;
					while (num3 >= 100)
					{
						num3 -= 100;
						num5++;
					}
					int num6 = Main.tile[num2, j].frameY / 18;
					if (num6 == 0)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.headType[num5]);
					}
					if (num6 == 1)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.bodyType[num5]);
					}
					if (num6 == 2)
					{
						Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, Item.legType[num5]);
					}
					for (num3 = Main.tile[num2, j].frameX; num3 >= 100; num3 -= 100)
					{
					}
					Main.tile[num2, j].frameX = (short)num3;
				}
			}
			if (tile.type == 334)
			{
				int num7 = i;
				int frameX = tile.frameX;
				int num8 = tile.frameX;
				int num9 = 0;
				while (num8 >= 5000)
				{
					num8 -= 5000;
					num9++;
				}
				if (num9 != 0)
				{
					num8 = (num9 - 1) * 18;
				}
				num8 %= 54;
				if (num8 == 18)
				{
					frameX = Main.tile[i - 1, j].frameX;
					num7--;
				}
				if (num8 == 36)
				{
					frameX = Main.tile[i - 2, j].frameX;
					num7 -= 2;
				}
				if (frameX >= 5000)
				{
					int num10 = frameX % 5000;
					num10 -= 100;
					int frameX2 = Main.tile[num7 + 1, j].frameX;
					frameX2 = ((frameX2 < 25000) ? (frameX2 - 10000) : (frameX2 - 25000));
					if (Main.netMode != 1)
					{
						Item item = new Item();
						item.netDefaults(num10);
						item.Prefix(frameX2);
						int num11 = Item.NewItem(GetItemSource_FromTileBreak(i, j), i * 16, j * 16, 16, 16, num10, 1, noBroadcast: true);
						item.position = Main.item[num11].position;
						Main.item[num11] = item;
						NetMessage.SendData(21, -1, -1, null, num11);
					}
					frameX = Main.tile[num7, j].frameX;
					int num12 = 0;
					while (frameX >= 5000)
					{
						frameX -= 5000;
						num12++;
					}
					if (num12 != 0)
					{
						frameX = (num12 - 1) * 18;
					}
					Main.tile[num7, j].frameX = (short)frameX;
					Main.tile[num7 + 1, j].frameX = (short)(frameX + 18);
				}
			}
			if (tile.type == 395)
			{
				int num13 = TEItemFrame.Find(i - tile.frameX % 36 / 18, j - tile.frameY % 36 / 18);
				if (num13 != -1 && ((TEItemFrame)TileEntity.ByID[num13]).item.stack > 0)
				{
					((TEItemFrame)TileEntity.ByID[num13]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
					}
					return;
				}
			}
			if (tile.type == 471)
			{
				int num14 = TEWeaponsRack.Find(i - tile.frameX % 54 / 18, j - tile.frameY % 54 / 18);
				if (num14 != -1 && ((TEWeaponsRack)TileEntity.ByID[num14]).item.stack > 0)
				{
					((TEWeaponsRack)TileEntity.ByID[num14]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(471);
					}
					return;
				}
			}
			if (tile.type == 520)
			{
				int num15 = TEFoodPlatter.Find(i, j);
				if (num15 != -1 && ((TEFoodPlatter)TileEntity.ByID[num15]).item.stack > 0)
				{
					((TEFoodPlatter)TileEntity.ByID[num15]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
					}
					return;
				}
			}
			if ((tile.type == 470 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)) || (tile.type == 475 && (CheckTileBreakability2_ShouldTileSurvive(i, j) || fail)))
			{
				return;
			}
			int num16 = KillTile_GetTileDustAmount(fail, tile);
			for (int k = 0; k < num16; k++)
			{
				KillTile_MakeTileDust(i, j, tile);
			}
			if (effectOnly)
			{
				return;
			}
			AttemptFossilShattering(i, j, tile, fail);
			if (fail)
			{
				if (Main.netMode != 1 && TileID.Sets.IsShakeable[tile.type])
				{
					ShakeTree(i, j);
				}
				if (tile.type == 2 || tile.type == 23 || tile.type == 109 || tile.type == 199 || tile.type == 477 || tile.type == 492)
				{
					tile.type = 0;
				}
				if (tile.type == 633)
				{
					tile.type = 57;
				}
				if (tile.type == 60 || tile.type == 661 || tile.type == 662 || tile.type == 70)
				{
					tile.type = 59;
				}
				if (Main.tileMoss[tile.type])
				{
					tile.type = 1;
				}
				if (TileID.Sets.tileMossBrick[tile.type])
				{
					tile.type = 38;
				}
				SquareTileFrame(i, j);
				return;
			}
			if (Main.getGoodWorld && Main.netMode != 1 && tile.type == 57)
			{
				for (int l = 0; l < 8; l++)
				{
					int maxValue = 2;
					int num17 = i;
					int num18 = j;
					switch (l)
					{
					case 0:
						num17--;
						break;
					case 1:
						num17++;
						break;
					case 2:
						num18--;
						break;
					case 3:
						num18++;
						break;
					case 4:
						num17--;
						num18--;
						break;
					case 5:
						num17++;
						num18--;
						break;
					case 6:
						num17--;
						num18++;
						break;
					case 7:
						num17++;
						num18++;
						break;
					}
					Tile tile2 = Main.tile[num17, num18];
					if (tile2.active() && genRand.Next(maxValue) == 0 && tile2.type == 57 && !SolidTile(num17, num18 + 1))
					{
						KillTile(num17, num18, fail: false, effectOnly: false, noItem: true);
						if (Main.netMode == 2)
						{
							NetMessage.TrySendData(17, -1, -1, null, 20, num17, num18);
						}
						int num19 = Projectile.NewProjectile(GetProjectileSource_TileBreak(num17, num18), num17 * 16 + 8, num18 * 16 + 8, 0f, 0.41f, 40, 15, 0f, Main.myPlayer);
						Main.projectile[num19].netUpdate = true;
					}
				}
			}
			if (Main.netMode != 1 && tile.type >= 481 && tile.type <= 483)
			{
				for (int m = 0; m < 8; m++)
				{
					int num20 = 6;
					int num21 = i;
					int num22 = j;
					switch (m)
					{
					case 0:
						num21--;
						break;
					case 1:
						num21++;
						break;
					case 2:
						num22--;
						num20 /= 2;
						break;
					case 3:
						num22++;
						break;
					case 4:
						num21--;
						num22--;
						break;
					case 5:
						num21++;
						num22--;
						break;
					case 6:
						num21--;
						num22++;
						break;
					case 7:
						num21++;
						num22++;
						break;
					}
					Tile tile3 = Main.tile[num21, num22];
					if (tile3.active() && genRand.Next(num20) == 0 && tile3.type >= 481 && tile3.type <= 483)
					{
						tile.active(active: false);
						KillTile(num21, num22, fail: false, effectOnly: false, noItem: true);
						if (Main.netMode == 2)
						{
							NetMessage.TrySendData(17, -1, -1, null, 20, num21, num22);
						}
					}
				}
				int type = tile.type - 481 + 736;
				int damage = 20;
				EntitySource_TileBreak projectileSource_TileBreak = GetProjectileSource_TileBreak(i, j);
				if (Main.netMode == 0)
				{
					Projectile.NewProjectile(projectileSource_TileBreak, i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
				}
				else if (Main.netMode == 2)
				{
					int num23 = Projectile.NewProjectile(projectileSource_TileBreak, i * 16 + 8, j * 16 + 8, 0f, 0.41f, type, damage, 0f, Main.myPlayer);
					Main.projectile[num23].netUpdate = true;
				}
			}
			if (CheckTileBreakability2_ShouldTileSurvive(i, j))
			{
				return;
			}
			if (tile.type == 51 && tile.wall == 62 && genRand.Next(4) != 0)
			{
				noItem = true;
			}
			if (!noItem && !stopDrops && Main.netMode != 1)
			{
				KillTile_DropBait(i, j, tile);
				KillTile_DropItems(i, j, tile);
			}
			if (tile.type == 520)
			{
				TEFoodPlatter.Kill(i, j);
			}
			if (tile.type == 423)
			{
				TELogicSensor.Kill(i, j);
			}
			if (Main.netMode != 2)
			{
				AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tile.type);
			}
			tile.active(active: false);
			tile.halfBrick(halfBrick: false);
			tile.frameX = -1;
			tile.frameY = -1;
			tile.ClearBlockPaintAndCoating();
			tile.frameNumber(0);
			if (tile.type == 58 && j > Main.UnderworldLayer)
			{
				tile.lava(lava: true);
				tile.liquid = 128;
			}
			else if (tile.type == 230 && Main.getGoodWorld && genRand.Next(2) == 0)
			{
				tile.lava(lava: true);
				tile.liquid = 128;
			}
			else if (tile.type == 419)
			{
				Wiring.PokeLogicGate(i, j + 1);
			}
			else if (TileID.Sets.BlocksWaterDrawingBehindSelf[tile.type])
			{
				SquareWallFrame(i, j);
			}
			tile.type = 0;
			tile.inActive(inActive: false);
			SquareTileFrame(i, j);
			while (!destroyObject && ExploitDestroyQueue.Count > 0)
			{
				Point point = ExploitDestroyQueue.Dequeue();
				if (Framing.GetTileSafely(point.X, point.Y).active())
				{
					SquareTileFrame(point.X, point.Y);
					NetMessage.SendTileSquare(-1, point.X, point.Y);
				}
			}
		}

		private static Player GetPlayerForTile(int x, int y)
		{
			return Main.player[Player.FindClosest(new Vector2(x, y) * 16f, 16, 16)];
		}

		private static void KillTile_DropItems(int x, int y, Tile tileCache, bool includeLargeObjectDrops = false)
		{
			KillTile_GetItemDrops(x, y, tileCache, out var dropItem, out var dropItemStack, out var secondaryItem, out var secondaryItemStack, includeLargeObjectDrops);
			if (!Main.getGoodWorld || tileCache.active())
			{
				if (dropItem > 0)
				{
					int num = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, dropItem, dropItemStack, noBroadcast: false, -1);
					Main.item[num].TryCombiningIntoNearbyItems(num);
				}
				if (secondaryItem > 0)
				{
					int num2 = Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, secondaryItem, secondaryItemStack, noBroadcast: false, -1);
					Main.item[num2].TryCombiningIntoNearbyItems(num2);
				}
			}
		}

		public static void KillTile_GetItemDrops(int x, int y, Tile tileCache, out int dropItem, out int dropItemStack, out int secondaryItem, out int secondaryItemStack, bool includeLargeObjectDrops = false)
		{
			dropItem = 0;
			dropItemStack = 1;
			secondaryItem = 0;
			secondaryItemStack = 1;
			int num = 0;
			if (includeLargeObjectDrops)
			{
				switch (tileCache.type)
				{
				case 21:
				case 467:
					dropItem = GetChestItemDrop(x, y, tileCache.type);
					break;
				case 88:
					num = tileCache.frameX / 54;
					dropItem = GetDresserItemDrop(num);
					break;
				case 215:
					num = tileCache.frameX / 54;
					dropItem = GetCampfireItemDrop(num);
					break;
				}
			}
			switch (tileCache.type)
			{
			case 668:
				dropItem = 5400;
				break;
			case 659:
				dropItem = 5349;
				break;
			case 667:
				dropItem = 5398;
				break;
			case 179:
			case 180:
			case 181:
			case 182:
			case 183:
			case 381:
			case 534:
			case 536:
			case 539:
			case 625:
			case 627:
				dropItem = 3;
				break;
			case 512:
			case 513:
			case 514:
			case 515:
			case 516:
			case 517:
			case 535:
			case 537:
			case 540:
			case 626:
			case 628:
				dropItem = 129;
				break;
			case 0:
			case 2:
			case 109:
			case 199:
			case 477:
			case 492:
				dropItem = 2;
				break;
			case 633:
				dropItem = 172;
				break;
			case 426:
				dropItem = 3621;
				break;
			case 430:
				dropItem = 3633;
				break;
			case 431:
				dropItem = 3634;
				break;
			case 432:
				dropItem = 3635;
				break;
			case 433:
				dropItem = 3636;
				break;
			case 434:
				dropItem = 3637;
				break;
			case 427:
				dropItem = 3622;
				break;
			case 435:
				dropItem = 3638;
				break;
			case 436:
				dropItem = 3639;
				break;
			case 437:
				dropItem = 3640;
				break;
			case 438:
				dropItem = 3641;
				break;
			case 439:
				dropItem = 3642;
				break;
			case 446:
				dropItem = 3736;
				break;
			case 447:
				dropItem = 3737;
				break;
			case 448:
				dropItem = 3738;
				break;
			case 449:
				dropItem = 3739;
				break;
			case 450:
				dropItem = 3740;
				break;
			case 451:
				dropItem = 3741;
				break;
			case 368:
				dropItem = 3086;
				break;
			case 369:
				dropItem = 3087;
				break;
			case 367:
				dropItem = 3081;
				break;
			case 379:
				dropItem = 3214;
				break;
			case 353:
				dropItem = 2996;
				break;
			case 365:
				dropItem = 3077;
				break;
			case 366:
				dropItem = 3078;
				break;
			case 357:
				dropItem = 3066;
				break;
			case 1:
				dropItem = 3;
				break;
			case 442:
				dropItem = 3707;
				break;
			case 383:
				dropItem = 620;
				break;
			case 315:
				dropItem = 2435;
				break;
			case 641:
				dropItem = 5306;
				break;
			case 330:
				dropItem = 71;
				break;
			case 331:
				dropItem = 72;
				break;
			case 332:
				dropItem = 73;
				break;
			case 333:
				dropItem = 74;
				break;
			case 408:
				dropItem = 3460;
				break;
			case 409:
				dropItem = 3461;
				break;
			case 669:
				dropItem = 5401;
				break;
			case 670:
				dropItem = 5402;
				break;
			case 671:
				dropItem = 5403;
				break;
			case 672:
				dropItem = 5404;
				break;
			case 673:
				dropItem = 5405;
				break;
			case 674:
				dropItem = 5406;
				break;
			case 675:
				dropItem = 5407;
				break;
			case 676:
				dropItem = 5408;
				break;
			case 677:
				dropItem = 5417;
				break;
			case 678:
				dropItem = 5419;
				break;
			case 679:
				dropItem = 5421;
				break;
			case 680:
				dropItem = 5423;
				break;
			case 681:
				dropItem = 5425;
				break;
			case 682:
				dropItem = 5427;
				break;
			case 683:
				dropItem = 5433;
				break;
			case 684:
				dropItem = 5435;
				break;
			case 685:
				dropItem = 5429;
				break;
			case 686:
				dropItem = 5431;
				break;
			case 687:
				dropItem = 5439;
				break;
			case 688:
				dropItem = 5440;
				break;
			case 689:
				dropItem = 5441;
				break;
			case 690:
				dropItem = 5442;
				break;
			case 691:
				dropItem = 5443;
				break;
			case 692:
				dropItem = 5444;
				break;
			case 666:
				dropItem = 5395;
				break;
			case 415:
				dropItem = 3573;
				break;
			case 416:
				dropItem = 3574;
				break;
			case 417:
				dropItem = 3575;
				break;
			case 418:
				dropItem = 3576;
				break;
			case 421:
				dropItem = 3609;
				break;
			case 422:
				dropItem = 3610;
				break;
			case 498:
				dropItem = 4139;
				break;
			case 424:
				dropItem = 3616;
				break;
			case 445:
				dropItem = 3725;
				break;
			case 429:
				dropItem = 3629;
				break;
			case 272:
				dropItem = 1344;
				break;
			case 273:
				dropItem = 2119;
				break;
			case 274:
				dropItem = 2120;
				break;
			case 618:
				dropItem = 4962;
				break;
			case 460:
				dropItem = 3756;
				break;
			case 541:
				dropItem = 4392;
				break;
			case 630:
				dropItem = 5137;
				break;
			case 631:
				dropItem = 5138;
				break;
			case 472:
				dropItem = 3951;
				break;
			case 473:
				dropItem = 3953;
				break;
			case 474:
				dropItem = 3955;
				break;
			case 478:
				dropItem = 4050;
				break;
			case 479:
				dropItem = 4051;
				break;
			case 496:
				dropItem = 4091;
				break;
			case 495:
				dropItem = 4090;
				break;
			case 346:
				dropItem = 2792;
				break;
			case 347:
				dropItem = 2793;
				break;
			case 348:
				dropItem = 2794;
				break;
			case 350:
				dropItem = 2860;
				break;
			case 336:
				dropItem = 2701;
				break;
			case 340:
				dropItem = 2751;
				break;
			case 341:
				dropItem = 2752;
				break;
			case 342:
				dropItem = 2753;
				break;
			case 343:
				dropItem = 2754;
				break;
			case 344:
				dropItem = 2755;
				break;
			case 351:
				dropItem = 2868;
				break;
			case 500:
				dropItem = 4229;
				break;
			case 501:
				dropItem = 4230;
				break;
			case 502:
				dropItem = 4231;
				break;
			case 503:
				dropItem = 4232;
				break;
			case 546:
			case 557:
				dropItem = 4422;
				break;
			case 561:
				dropItem = 4554;
				break;
			case 574:
				dropItem = 4717;
				break;
			case 575:
				dropItem = 4718;
				break;
			case 576:
				dropItem = 4719;
				break;
			case 577:
				dropItem = 4720;
				break;
			case 578:
				dropItem = 4721;
				break;
			case 562:
				dropItem = 4564;
				break;
			case 571:
				dropItem = 4564;
				dropItemStack = genRand.Next(1, 3);
				break;
			case 563:
				dropItem = 4547;
				break;
			case 251:
				dropItem = 1725;
				break;
			case 252:
				dropItem = 1727;
				break;
			case 253:
				dropItem = 1729;
				break;
			case 325:
				dropItem = 2692;
				break;
			case 370:
				dropItem = 3100;
				break;
			case 396:
				dropItem = 3271;
				break;
			case 400:
				dropItem = 3276;
				break;
			case 401:
				dropItem = 3277;
				break;
			case 403:
				dropItem = 3339;
				break;
			case 397:
				dropItem = 3272;
				break;
			case 398:
				dropItem = 3274;
				break;
			case 399:
				dropItem = 3275;
				break;
			case 402:
				dropItem = 3338;
				break;
			case 404:
				dropItem = 3347;
				break;
			case 407:
				dropItem = 3380;
				break;
			case 579:
				dropItem = 4761;
				break;
			case 593:
				dropItem = 4868;
				break;
			case 624:
				dropItem = 5114;
				break;
			case 656:
				dropItem = 5333;
				break;
			case 170:
				dropItem = 1872;
				break;
			case 284:
				dropItem = 2173;
				break;
			case 214:
				dropItem = 85;
				break;
			case 213:
				dropItem = 965;
				break;
			case 211:
				dropItem = 947;
				break;
			case 6:
				dropItem = 11;
				break;
			case 7:
				dropItem = 12;
				break;
			case 8:
				dropItem = 13;
				break;
			case 9:
				dropItem = 14;
				break;
			case 202:
				dropItem = 824;
				break;
			case 234:
				dropItem = 1246;
				break;
			case 226:
				dropItem = 1101;
				break;
			case 224:
				dropItem = 1103;
				break;
			case 36:
				dropItem = 1869;
				break;
			case 311:
				dropItem = 2260;
				break;
			case 312:
				dropItem = 2261;
				break;
			case 313:
				dropItem = 2262;
				break;
			case 229:
				dropItem = 1125;
				break;
			case 230:
				dropItem = 1127;
				break;
			case 221:
				dropItem = 1104;
				break;
			case 222:
				dropItem = 1105;
				break;
			case 223:
				dropItem = 1106;
				break;
			case 248:
				dropItem = 1589;
				break;
			case 249:
				dropItem = 1591;
				break;
			case 250:
				dropItem = 1593;
				break;
			case 191:
				dropItem = 9;
				break;
			case 203:
				dropItem = 836;
				break;
			case 204:
				dropItem = 880;
				break;
			case 166:
				dropItem = 699;
				break;
			case 167:
				dropItem = 700;
				break;
			case 168:
				dropItem = 701;
				break;
			case 169:
				dropItem = 702;
				break;
			case 123:
				dropItem = 424;
				break;
			case 124:
				dropItem = 480;
				break;
			case 157:
				dropItem = 619;
				break;
			case 158:
				dropItem = 620;
				break;
			case 159:
				dropItem = 621;
				break;
			case 161:
				dropItem = 664;
				break;
			case 206:
				dropItem = 883;
				break;
			case 232:
				dropItem = 1150;
				break;
			case 198:
				dropItem = 775;
				break;
			case 314:
				dropItem = Minecart.GetTrackItem(tileCache);
				break;
			case 189:
				dropItem = 751;
				break;
			case 195:
				dropItem = 763;
				break;
			case 194:
				dropItem = 154;
				break;
			case 193:
				dropItem = 762;
				break;
			case 196:
				dropItem = 765;
				break;
			case 197:
				dropItem = 767;
				break;
			case 22:
				dropItem = 56;
				break;
			case 140:
				dropItem = 577;
				break;
			case 23:
				dropItem = 2;
				break;
			case 25:
				dropItem = 61;
				break;
			case 30:
				dropItem = 9;
				break;
			case 208:
				dropItem = 911;
				break;
			case 372:
				dropItem = 3117;
				break;
			case 646:
				dropItem = 5322;
				break;
			case 371:
				dropItem = 3113;
				break;
			case 174:
				dropItem = 713;
				break;
			case 37:
				dropItem = 116;
				break;
			case 38:
				dropItem = 129;
				break;
			case 39:
				dropItem = 131;
				break;
			case 40:
				dropItem = 133;
				break;
			case 41:
				dropItem = 134;
				break;
			case 43:
				dropItem = 137;
				break;
			case 44:
				dropItem = 139;
				break;
			case 45:
				dropItem = 141;
				break;
			case 46:
				dropItem = 143;
				break;
			case 47:
				dropItem = 145;
				break;
			case 48:
				dropItem = 147;
				break;
			case 49:
				dropItem = 148;
				break;
			case 51:
				dropItem = 150;
				break;
			case 53:
				dropItem = 169;
				break;
			case 151:
				dropItem = 607;
				break;
			case 152:
				dropItem = 609;
				break;
			case 56:
				dropItem = 173;
				break;
			case 57:
				dropItem = 172;
				break;
			case 58:
				dropItem = 174;
				break;
			case 70:
				dropItem = 176;
				break;
			case 75:
				dropItem = 192;
				break;
			case 76:
				dropItem = 214;
				break;
			case 78:
				dropItem = 222;
				break;
			case 81:
				dropItem = 275;
				break;
			case 80:
				dropItem = 276;
				break;
			case 188:
				dropItem = 276;
				break;
			case 107:
				dropItem = 364;
				break;
			case 108:
				dropItem = 365;
				break;
			case 111:
				dropItem = 366;
				break;
			case 150:
				dropItem = 604;
				break;
			case 112:
				dropItem = 370;
				break;
			case 116:
				dropItem = 408;
				break;
			case 117:
				dropItem = 409;
				break;
			case 118:
				dropItem = 412;
				break;
			case 119:
				dropItem = 413;
				break;
			case 120:
				dropItem = 414;
				break;
			case 121:
				dropItem = 415;
				break;
			case 122:
				dropItem = 416;
				break;
			case 136:
				dropItem = 538;
				break;
			case 385:
				dropItem = 3234;
				break;
			case 141:
				dropItem = 580;
				break;
			case 145:
				dropItem = 586;
				break;
			case 146:
				dropItem = 591;
				break;
			case 147:
				dropItem = 593;
				break;
			case 148:
				dropItem = 594;
				break;
			case 153:
				dropItem = 611;
				break;
			case 154:
				dropItem = 612;
				break;
			case 155:
				dropItem = 613;
				break;
			case 156:
				dropItem = 614;
				break;
			case 160:
				dropItem = 662;
				break;
			case 175:
				dropItem = 717;
				break;
			case 176:
				dropItem = 718;
				break;
			case 177:
				dropItem = 719;
				break;
			case 163:
				dropItem = 833;
				break;
			case 164:
				dropItem = 834;
				break;
			case 200:
				dropItem = 835;
				break;
			case 210:
				dropItem = 937;
				break;
			case 130:
				dropItem = 511;
				break;
			case 131:
				dropItem = 512;
				break;
			case 321:
				dropItem = 2503;
				break;
			case 322:
				dropItem = 2504;
				break;
			case 635:
				dropItem = 5215;
				break;
			case 54:
				dropItem = 170;
				break;
			case 326:
				dropItem = 2693;
				break;
			case 327:
				dropItem = 2694;
				break;
			case 458:
				dropItem = 3754;
				break;
			case 459:
				dropItem = 3755;
				break;
			case 345:
				dropItem = 2787;
				break;
			case 328:
				dropItem = 2695;
				break;
			case 329:
				dropItem = 2697;
				break;
			case 507:
				dropItem = 4277;
				break;
			case 508:
				dropItem = 4278;
				break;
			case 255:
			case 256:
			case 257:
			case 258:
			case 259:
			case 260:
			case 261:
				dropItem = 1970 + tileCache.type - 255;
				break;
			case 262:
			case 263:
			case 264:
			case 265:
			case 266:
			case 267:
			case 268:
				dropItem = 1970 + tileCache.type - 262;
				break;
			case 59:
			case 60:
			case 661:
			case 662:
				dropItem = 176;
				break;
			case 190:
				dropItem = 183;
				break;
			case 63:
			case 64:
			case 65:
			case 66:
			case 67:
			case 68:
				dropItem = tileCache.type - 63 + 177;
				break;
			case 566:
				dropItem = 999;
				break;
			case 637:
				if (Main.rand.Next(100) == 0)
				{
					dropItem = 5214;
				}
				break;
			case 129:
				if (tileCache.frameX >= 324)
				{
					dropItem = 4988;
				}
				else
				{
					dropItem = 502;
				}
				break;
			case 3:
				if (tileCache.frameX == 144)
				{
					dropItem = 5;
				}
				else if (KillTile_ShouldDropSeeds(x, y))
				{
					dropItem = 283;
				}
				break;
			case 519:
				if (tileCache.frameY == 90 && genRand.Next(2) == 0)
				{
					dropItem = 183;
				}
				break;
			case 528:
				if (genRand.Next(2) == 0)
				{
					dropItem = 183;
				}
				break;
			case 110:
				if (tileCache.frameX == 144)
				{
					dropItem = 5;
				}
				break;
			case 24:
				if (tileCache.frameX == 144)
				{
					dropItem = 60;
				}
				break;
			case 201:
				if (tileCache.frameX == 270)
				{
					dropItem = 2887;
				}
				break;
			case 73:
				if (KillTile_ShouldDropSeeds(x, y))
				{
					dropItem = 283;
				}
				break;
			case 52:
			case 62:
			case 382:
				if (Main.rand.Next(2) == 0 && GetPlayerForTile(x, y).cordage)
				{
					dropItem = 2996;
				}
				break;
			case 227:
				num = tileCache.frameX / 34;
				dropItem = 1107 + num;
				if (num >= 8 && num <= 11)
				{
					dropItem = 3385 + num - 8;
				}
				break;
			case 4:
				num = tileCache.frameY / 22;
				switch (num)
				{
				case 0:
					dropItem = 8;
					break;
				case 8:
					dropItem = 523;
					break;
				case 9:
					dropItem = 974;
					break;
				case 10:
					dropItem = 1245;
					break;
				case 11:
					dropItem = 1333;
					break;
				case 12:
					dropItem = 2274;
					break;
				case 13:
					dropItem = 3004;
					break;
				case 14:
					dropItem = 3045;
					break;
				case 15:
					dropItem = 3114;
					break;
				case 16:
					dropItem = 4383;
					break;
				case 17:
					dropItem = 4384;
					break;
				case 18:
					dropItem = 4385;
					break;
				case 19:
					dropItem = 4386;
					break;
				case 20:
					dropItem = 4387;
					break;
				case 21:
					dropItem = 4388;
					break;
				case 22:
					dropItem = 5293;
					break;
				case 23:
					dropItem = 5353;
					break;
				default:
					dropItem = 426 + num;
					break;
				}
				break;
			case 239:
				num = tileCache.frameX / 18;
				if (num == 0)
				{
					dropItem = 20;
				}
				if (num == 1)
				{
					dropItem = 703;
				}
				if (num == 2)
				{
					dropItem = 22;
				}
				if (num == 3)
				{
					dropItem = 704;
				}
				if (num == 4)
				{
					dropItem = 21;
				}
				if (num == 5)
				{
					dropItem = 705;
				}
				if (num == 6)
				{
					dropItem = 19;
				}
				if (num == 7)
				{
					dropItem = 706;
				}
				if (num == 8)
				{
					dropItem = 57;
				}
				if (num == 9)
				{
					dropItem = 117;
				}
				if (num == 10)
				{
					dropItem = 175;
				}
				if (num == 11)
				{
					dropItem = 381;
				}
				if (num == 12)
				{
					dropItem = 1184;
				}
				if (num == 13)
				{
					dropItem = 382;
				}
				if (num == 14)
				{
					dropItem = 1191;
				}
				if (num == 15)
				{
					dropItem = 391;
				}
				if (num == 16)
				{
					dropItem = 1198;
				}
				if (num == 17)
				{
					dropItem = 1006;
				}
				if (num == 18)
				{
					dropItem = 1225;
				}
				if (num == 19)
				{
					dropItem = 1257;
				}
				if (num == 20)
				{
					dropItem = 1552;
				}
				if (num == 21)
				{
					dropItem = 3261;
				}
				if (num == 22)
				{
					dropItem = 3467;
				}
				break;
			case 380:
				num = tileCache.frameY / 18;
				dropItem = 3215 + num;
				break;
			case 5:
			case 596:
			case 616:
			case 634:
			{
				bool bonusWood = false;
				KillTile_GetTreeDrops(x, y, tileCache, ref bonusWood, ref dropItem, ref secondaryItem);
				if (bonusWood)
				{
					dropItemStack++;
				}
				break;
			}
			case 323:
			{
				dropItem = 2504;
				if (Main.tenthAnniversaryWorld)
				{
					dropItemStack += genRand.Next(2, 5);
				}
				if (tileCache.frameX <= 132 && tileCache.frameX >= 88)
				{
					secondaryItem = 27;
				}
				int j;
				for (j = y; !Main.tile[x, j].active() || !Main.tileSolid[Main.tile[x, j].type]; j++)
				{
				}
				if (Main.tile[x, j].active())
				{
					switch (Main.tile[x, j].type)
					{
					case 234:
						dropItem = 911;
						break;
					case 116:
						dropItem = 621;
						break;
					case 112:
						dropItem = 619;
						break;
					}
				}
				break;
			}
			case 171:
				if (tileCache.frameX >= 10)
				{
					dropXmasTree(x, y, 0);
					dropXmasTree(x, y, 1);
					dropXmasTree(x, y, 2);
					dropXmasTree(x, y, 3);
				}
				break;
			case 324:
				switch (tileCache.frameY / 22)
				{
				case 0:
					dropItem = 2625;
					break;
				case 1:
					dropItem = 2626;
					break;
				case 2:
					dropItem = 4072;
					break;
				case 3:
					dropItem = 4073;
					break;
				case 4:
					dropItem = 4071;
					break;
				}
				break;
			case 419:
				switch (tileCache.frameX / 18)
				{
				case 0:
					dropItem = 3602;
					break;
				case 1:
					dropItem = 3618;
					break;
				case 2:
					dropItem = 3663;
					break;
				}
				break;
			case 428:
				switch (tileCache.frameY / 18)
				{
				case 0:
					dropItem = 3630;
					break;
				case 1:
					dropItem = 3632;
					break;
				case 2:
					dropItem = 3631;
					break;
				case 3:
					dropItem = 3626;
					break;
				}
				PressurePlateHelper.DestroyPlate(new Point(x, y));
				break;
			case 420:
				switch (tileCache.frameY / 18)
				{
				case 0:
					dropItem = 3603;
					break;
				case 1:
					dropItem = 3604;
					break;
				case 2:
					dropItem = 3605;
					break;
				case 3:
					dropItem = 3606;
					break;
				case 4:
					dropItem = 3607;
					break;
				case 5:
					dropItem = 3608;
					break;
				}
				break;
			case 650:
				num = tileCache.frameX / 18;
				if (num < 6)
				{
					dropItem = 3;
				}
				else if (num < 12)
				{
					dropItem = 2;
				}
				else if (num < 20)
				{
					dropItem = 154;
				}
				else if (num < 28)
				{
					dropItem = 154;
				}
				else if (num < 36)
				{
					dropItem = 9;
				}
				else if (num < 42)
				{
					dropItem = 593;
				}
				else if (num < 48)
				{
					dropItem = 664;
				}
				else if (num < 54)
				{
					dropItem = 150;
				}
				else if (num < 60)
				{
					dropItem = 3271;
				}
				else if (num < 66)
				{
					dropItem = 3086;
				}
				else if (num < 72)
				{
					dropItem = 3081;
				}
				else if (num < 73)
				{
					dropItem = 62;
				}
				else if (num < 77)
				{
					dropItem = 169;
				}
				break;
			case 476:
				dropItem = 4040;
				break;
			case 494:
				dropItem = 4089;
				break;
			case 423:
				TELogicSensor.Kill(x, y);
				switch (tileCache.frameY / 18)
				{
				case 0:
					dropItem = 3613;
					break;
				case 1:
					dropItem = 3614;
					break;
				case 2:
					dropItem = 3615;
					break;
				case 3:
					dropItem = 3726;
					break;
				case 4:
					dropItem = 3727;
					break;
				case 5:
					dropItem = 3728;
					break;
				case 6:
					dropItem = 3729;
					break;
				}
				break;
			case 520:
				dropItem = 4326;
				break;
			case 225:
				if (Main.rand.Next(3) == 0)
				{
					tileCache.honey(honey: true);
					tileCache.liquid = byte.MaxValue;
					break;
				}
				dropItem = 1124;
				if (Main.netMode != 1 && Main.rand.Next(2) == 0)
				{
					int num3 = 1;
					if (Main.rand.Next(3) == 0)
					{
						num3 = 2;
					}
					for (int i = 0; i < num3; i++)
					{
						int type = Main.rand.Next(210, 212);
						int num4 = NPC.NewNPC(GetNPCSource_TileBreak(x, y), x * 16 + 8, y * 16 + 15, type, 1);
						Main.npc[num4].velocity.X = (float)Main.rand.Next(-200, 201) * 0.002f;
						Main.npc[num4].velocity.Y = (float)Main.rand.Next(-200, 201) * 0.002f;
						Main.npc[num4].netUpdate = true;
					}
				}
				break;
			case 178:
				switch (tileCache.frameX / 18)
				{
				case 0:
					dropItem = 181;
					break;
				case 1:
					dropItem = 180;
					break;
				case 2:
					dropItem = 177;
					break;
				case 3:
					dropItem = 179;
					break;
				case 4:
					dropItem = 178;
					break;
				case 5:
					dropItem = 182;
					break;
				case 6:
					dropItem = 999;
					break;
				}
				break;
			case 149:
				if (tileCache.frameX == 0 || tileCache.frameX == 54)
				{
					dropItem = 596;
				}
				else if (tileCache.frameX == 18 || tileCache.frameX == 72)
				{
					dropItem = 597;
				}
				else if (tileCache.frameX == 36 || tileCache.frameX == 90)
				{
					dropItem = 598;
				}
				break;
			case 13:
				switch (tileCache.frameX / 18)
				{
				case 1:
					dropItem = 28;
					break;
				case 2:
					dropItem = 110;
					break;
				case 3:
					dropItem = 350;
					break;
				case 4:
					dropItem = 351;
					break;
				case 5:
					dropItem = 2234;
					break;
				case 6:
					dropItem = 2244;
					break;
				case 7:
					dropItem = 2257;
					break;
				case 8:
					dropItem = 2258;
					break;
				default:
					dropItem = 31;
					break;
				}
				break;
			case 19:
				num = tileCache.frameY / 18;
				switch (num)
				{
				case 0:
					dropItem = 94;
					break;
				case 1:
					dropItem = 631;
					break;
				case 2:
					dropItem = 632;
					break;
				case 3:
					dropItem = 633;
					break;
				case 4:
					dropItem = 634;
					break;
				case 5:
					dropItem = 913;
					break;
				case 6:
					dropItem = 1384;
					break;
				case 7:
					dropItem = 1385;
					break;
				case 8:
					dropItem = 1386;
					break;
				case 9:
					dropItem = 1387;
					break;
				case 10:
					dropItem = 1388;
					break;
				case 11:
					dropItem = 1389;
					break;
				case 12:
					dropItem = 1418;
					break;
				case 13:
					dropItem = 1457;
					break;
				case 14:
					dropItem = 1702;
					break;
				case 15:
					dropItem = 1796;
					break;
				case 16:
					dropItem = 1818;
					break;
				case 17:
					dropItem = 2518;
					break;
				case 18:
					dropItem = 2549;
					break;
				case 19:
					dropItem = 2566;
					break;
				case 20:
					dropItem = 2581;
					break;
				case 21:
					dropItem = 2627;
					break;
				case 22:
					dropItem = 2628;
					break;
				case 23:
					dropItem = 2629;
					break;
				case 24:
					dropItem = 2630;
					break;
				case 25:
					dropItem = 2744;
					break;
				case 26:
					dropItem = 2822;
					break;
				case 27:
					dropItem = 3144;
					break;
				case 28:
					dropItem = 3146;
					break;
				case 29:
					dropItem = 3145;
					break;
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
					dropItem = 3903 + num - 30;
					break;
				default:
					switch (num)
					{
					case 36:
						dropItem = 3945;
						break;
					case 37:
						dropItem = 3957;
						break;
					case 38:
						dropItem = 4159;
						break;
					case 39:
						dropItem = 4180;
						break;
					case 40:
						dropItem = 4201;
						break;
					case 41:
						dropItem = 4222;
						break;
					case 42:
						dropItem = 4311;
						break;
					case 43:
						dropItem = 4416;
						break;
					case 44:
						dropItem = 4580;
						break;
					case 45:
						dropItem = 5162;
						break;
					case 46:
						dropItem = 5183;
						break;
					case 47:
						dropItem = 5204;
						break;
					case 48:
						dropItem = 5292;
						break;
					}
					break;
				}
				break;
			case 33:
				num = tileCache.frameY / 22;
				dropItem = 105;
				switch (num)
				{
				case 1:
					dropItem = 1405;
					break;
				case 2:
					dropItem = 1406;
					break;
				case 3:
					dropItem = 1407;
					break;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
				case 11:
				case 12:
				case 13:
					dropItem = 2045 + num - 4;
					break;
				default:
					if (num >= 14 && num <= 16)
					{
						dropItem = 2153 + num - 14;
						break;
					}
					switch (num)
					{
					case 17:
						dropItem = 2236;
						break;
					case 18:
						dropItem = 2523;
						break;
					case 19:
						dropItem = 2542;
						break;
					case 20:
						dropItem = 2556;
						break;
					case 21:
						dropItem = 2571;
						break;
					case 22:
						dropItem = 2648;
						break;
					case 23:
						dropItem = 2649;
						break;
					case 24:
						dropItem = 2650;
						break;
					case 25:
						dropItem = 2651;
						break;
					case 26:
						dropItem = 2818;
						break;
					case 27:
						dropItem = 3171;
						break;
					case 28:
						dropItem = 3173;
						break;
					case 29:
						dropItem = 3172;
						break;
					case 30:
						dropItem = 3890;
						break;
					case 31:
						dropItem = 3936;
						break;
					case 32:
						dropItem = 3962;
						break;
					case 33:
						dropItem = 4150;
						break;
					case 34:
						dropItem = 4171;
						break;
					case 35:
						dropItem = 4192;
						break;
					case 36:
						dropItem = 4213;
						break;
					case 37:
						dropItem = 4303;
						break;
					case 38:
						dropItem = 4571;
						break;
					case 39:
						dropItem = 5153;
						break;
					case 40:
						dropItem = 5174;
						break;
					case 41:
						dropItem = 5195;
						break;
					}
					break;
				}
				break;
			case 137:
				num = tileCache.frameY / 18;
				if (num == 0)
				{
					dropItem = 539;
				}
				if (num == 1)
				{
					dropItem = 1146;
				}
				if (num == 2)
				{
					dropItem = 1147;
				}
				if (num == 3)
				{
					dropItem = 1148;
				}
				if (num == 4)
				{
					dropItem = 1149;
				}
				if (num == 5)
				{
					dropItem = 5135;
				}
				break;
			case 135:
				num = tileCache.frameY / 18;
				if (num == 0)
				{
					dropItem = 529;
				}
				if (num == 1)
				{
					dropItem = 541;
				}
				if (num == 2)
				{
					dropItem = 542;
				}
				if (num == 3)
				{
					dropItem = 543;
				}
				if (num == 4)
				{
					dropItem = 852;
				}
				if (num == 5)
				{
					dropItem = 853;
				}
				if (num == 6)
				{
					dropItem = 1151;
				}
				break;
			case 144:
				if (tileCache.frameX == 0)
				{
					dropItem = 583;
				}
				if (tileCache.frameX == 18)
				{
					dropItem = 584;
				}
				if (tileCache.frameX == 36)
				{
					dropItem = 585;
				}
				if (tileCache.frameX == 54)
				{
					dropItem = 4484;
				}
				if (tileCache.frameX == 72)
				{
					dropItem = 4485;
				}
				break;
			case 61:
			case 74:
				if (tileCache.frameX == 144 && tileCache.type == 61)
				{
					dropItem = 331;
					dropItemStack = Main.rand.Next(2, 4);
				}
				else if (tileCache.frameX == 162 && tileCache.type == 61)
				{
					dropItem = 223;
				}
				else if (tileCache.frameX >= 108 && tileCache.frameX <= 126 && tileCache.type == 61 && Main.rand.Next(20) == 0)
				{
					dropItem = 208;
				}
				else if (Main.rand.Next(100) == 0)
				{
					dropItem = 195;
				}
				break;
			case 71:
			case 72:
				if (Main.rand.Next(40) == 0)
				{
					dropItem = 194;
				}
				else if (Main.rand.Next(2) == 0)
				{
					dropItem = 183;
				}
				break;
			case 50:
				if (tileCache.frameX == 90)
				{
					dropItem = 165;
				}
				else
				{
					dropItem = 149;
				}
				break;
			case 83:
			case 84:
			{
				num = tileCache.frameX / 18;
				dropItem = 313 + num;
				int num2 = 307 + num;
				if (num == 6)
				{
					dropItem = 2358;
					num2 = 2357;
				}
				bool flag = IsHarvestableHerbWithSeed(tileCache.type, num);
				Player playerForTile = GetPlayerForTile(x, y);
				if (playerForTile.HeldItem.type == 213 || playerForTile.HeldItem.type == 5295)
				{
					dropItemStack = Main.rand.Next(1, 3);
					secondaryItem = num2;
					secondaryItemStack = Main.rand.Next(1, 6);
				}
				else if (flag)
				{
					secondaryItem = num2;
					secondaryItemStack = Main.rand.Next(1, 4);
				}
				break;
			}
			case 589:
				SetGemTreeDrops(999, 4857, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 584:
				SetGemTreeDrops(181, 4852, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 583:
				SetGemTreeDrops(180, 4851, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 586:
				SetGemTreeDrops(179, 4854, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 585:
				SetGemTreeDrops(177, 4853, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 587:
				SetGemTreeDrops(178, 4855, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 588:
				SetGemTreeDrops(182, 4856, tileCache, ref dropItem, ref secondaryItem);
				if (dropItem == 3)
				{
					dropItemStack = Main.rand.Next(1, 3);
				}
				break;
			case 10:
			case 11:
			case 12:
			case 14:
			case 15:
			case 16:
			case 17:
			case 18:
			case 20:
			case 21:
			case 26:
			case 27:
			case 28:
			case 29:
			case 31:
			case 32:
			case 34:
			case 35:
			case 42:
			case 55:
			case 69:
			case 77:
			case 79:
			case 82:
			case 85:
			case 86:
			case 87:
			case 88:
			case 89:
			case 90:
			case 91:
			case 92:
			case 93:
			case 94:
			case 95:
			case 96:
			case 97:
			case 98:
			case 99:
			case 100:
			case 101:
			case 102:
			case 103:
			case 104:
			case 105:
			case 106:
			case 113:
			case 114:
			case 115:
			case 125:
			case 126:
			case 127:
			case 128:
			case 132:
			case 133:
			case 134:
			case 138:
			case 139:
			case 142:
			case 143:
			case 162:
			case 165:
			case 172:
			case 173:
			case 184:
			case 185:
			case 186:
			case 187:
			case 192:
			case 205:
			case 207:
			case 209:
			case 212:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 228:
			case 231:
			case 233:
			case 235:
			case 236:
			case 237:
			case 238:
			case 240:
			case 241:
			case 242:
			case 243:
			case 244:
			case 245:
			case 246:
			case 247:
			case 254:
			case 269:
			case 270:
			case 271:
			case 275:
			case 276:
			case 277:
			case 278:
			case 279:
			case 280:
			case 281:
			case 282:
			case 283:
			case 285:
			case 286:
			case 287:
			case 288:
			case 289:
			case 290:
			case 291:
			case 292:
			case 293:
			case 294:
			case 295:
			case 296:
			case 297:
			case 298:
			case 299:
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
			case 307:
			case 308:
			case 309:
			case 310:
			case 316:
			case 317:
			case 318:
			case 319:
			case 320:
			case 334:
			case 335:
			case 337:
			case 338:
			case 339:
			case 349:
			case 352:
			case 354:
			case 355:
			case 356:
			case 358:
			case 359:
			case 360:
			case 361:
			case 362:
			case 363:
			case 364:
			case 373:
			case 374:
			case 375:
			case 376:
			case 377:
			case 378:
			case 384:
			case 386:
			case 387:
			case 388:
			case 389:
			case 390:
			case 391:
			case 392:
			case 393:
			case 394:
			case 395:
			case 405:
			case 406:
			case 410:
			case 411:
			case 412:
			case 413:
			case 414:
			case 425:
			case 440:
			case 441:
			case 443:
			case 444:
			case 452:
			case 453:
			case 454:
			case 455:
			case 456:
			case 457:
			case 461:
			case 462:
			case 463:
			case 464:
			case 465:
			case 466:
			case 467:
			case 468:
			case 469:
			case 470:
			case 471:
			case 475:
			case 480:
			case 481:
			case 482:
			case 483:
			case 484:
			case 485:
			case 486:
			case 487:
			case 488:
			case 489:
			case 490:
			case 491:
			case 493:
			case 497:
			case 499:
			case 504:
			case 505:
			case 506:
			case 509:
			case 510:
			case 511:
			case 518:
			case 521:
			case 522:
			case 523:
			case 524:
			case 525:
			case 526:
			case 527:
			case 529:
			case 530:
			case 531:
			case 532:
			case 533:
			case 538:
			case 542:
			case 543:
			case 544:
			case 545:
			case 547:
			case 548:
			case 549:
			case 550:
			case 551:
			case 552:
			case 553:
			case 554:
			case 555:
			case 556:
			case 558:
			case 559:
			case 560:
			case 564:
			case 565:
			case 567:
			case 568:
			case 569:
			case 570:
			case 572:
			case 573:
			case 580:
			case 581:
			case 582:
			case 590:
			case 591:
			case 592:
			case 594:
			case 595:
			case 597:
			case 598:
			case 599:
			case 600:
			case 601:
			case 602:
			case 603:
			case 604:
			case 605:
			case 606:
			case 607:
			case 608:
			case 609:
			case 610:
			case 611:
			case 612:
			case 613:
			case 614:
			case 615:
			case 617:
			case 619:
			case 620:
			case 621:
			case 622:
			case 623:
			case 629:
			case 632:
			case 636:
			case 638:
			case 639:
			case 640:
			case 642:
			case 643:
			case 644:
			case 645:
			case 647:
			case 648:
			case 649:
			case 651:
			case 652:
			case 653:
			case 654:
			case 655:
			case 657:
			case 658:
			case 660:
			case 663:
			case 664:
			case 665:
				break;
			}
		}

		private static void SetGemTreeDrops(int gemType, int seedType, Tile tileCache, ref int dropItem, ref int secondaryItem)
		{
			if (Main.rand.Next(10) == 0)
			{
				dropItem = gemType;
			}
			else
			{
				dropItem = 3;
			}
			if (tileCache.frameX >= 22 && tileCache.frameY >= 198 && Main.rand.Next(2) == 0)
			{
				secondaryItem = seedType;
			}
		}

		private static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem)
		{
			if (Main.rand.Next(2) == 0)
			{
				dropItem = dropType;
			}
		}

		public static bool IsHarvestableHerbWithSeed(int type, int style)
		{
			switch (type)
			{
			case 82:
				return false;
			default:
				return false;
			case 83:
			case 84:
			{
				bool result = false;
				if (type == 84)
				{
					result = true;
				}
				if (style == 0 && Main.dayTime)
				{
					result = true;
				}
				if (style == 1 && !Main.dayTime)
				{
					result = true;
				}
				if (style == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
				{
					result = true;
				}
				if (style == 4 && (Main.raining || Main.cloudAlpha > 0f))
				{
					result = true;
				}
				if (style == 5 && !Main.raining && Main.dayTime && Main.time > 40500.0)
				{
					result = true;
				}
				return result;
			}
			}
		}

		private static bool KillTile_ShouldDropSeeds(int x, int y)
		{
			if (Main.rand.Next(2) == 0)
			{
				if (!GetPlayerForTile(x, y).HasItem(281))
				{
					return GetPlayerForTile(x, y).HasItem(986);
				}
				return true;
			}
			return false;
		}

		private static void KillTile_GetTreeDrops(int i, int j, Tile tileCache, ref bool bonusWood, ref int dropItem, ref int secondaryItem)
		{
			if (tileCache.frameX >= 22 && tileCache.frameY >= 198)
			{
				if (Main.netMode != 1)
				{
					if (genRand.Next(2) == 0)
					{
						int k;
						for (k = j; Main.tile[i, k] != null && (!Main.tile[i, k].active() || !Main.tileSolid[Main.tile[i, k].type] || Main.tileSolidTop[Main.tile[i, k].type]); k++)
						{
						}
						if (Main.tile[i, k] != null)
						{
							Tile tile = Main.tile[i, k];
							if (tile.type == 2 || tile.type == 109 || tile.type == 477 || tile.type == 492 || tile.type == 147 || tile.type == 199 || tile.type == 23 || tile.type == 633)
							{
								dropItem = 9;
								secondaryItem = 27;
							}
							else
							{
								dropItem = 9;
							}
						}
					}
					else
					{
						dropItem = 9;
					}
				}
			}
			else
			{
				dropItem = 9;
			}
			if (dropItem != 9)
			{
				return;
			}
			GetTreeBottom(i, j, out var x, out var y);
			if (Main.tile[x, y].active())
			{
				switch (Main.tile[x, y].type)
				{
				case 633:
					dropItem = 5215;
					break;
				case 23:
				case 661:
					dropItem = 619;
					break;
				case 199:
				case 662:
					dropItem = 911;
					break;
				case 60:
					dropItem = 620;
					break;
				case 109:
				case 492:
					dropItem = 621;
					break;
				case 70:
					if (genRand.Next(2) == 0)
					{
						dropItem = 183;
					}
					else
					{
						dropItem = 0;
					}
					break;
				case 147:
					dropItem = 2503;
					break;
				}
			}
			int num = Player.FindClosest(new Vector2(x * 16, y * 16), 16, 16);
			int axe = Main.player[num].inventory[Main.player[num].selectedItem].axe;
			if (genRand.Next(100) < axe || Main.rand.Next(3) == 0)
			{
				bonusWood = true;
			}
		}

		private static void KillTile_DropBait(int i, int j, Tile tileCache)
		{
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int num5 = Player.FindClosest(new Vector2(i * 16, j * 16), 16, 16);
			if (tileCache.type == 3)
			{
				num = 400;
				num2 = 100;
				if (Main.player[num5].flowerBoots && tileCache.frameX >= 108)
				{
					num *= 10000;
					num2 *= 10000;
				}
			}
			if (tileCache.type == 73)
			{
				num = 200;
				num2 = 50;
				if (Main.player[num5].flowerBoots && tileCache.frameX >= 108)
				{
					num *= 10000;
					num2 *= 10000;
				}
			}
			if (tileCache.type == 637)
			{
				num4 = 100;
				if (Main.player[num5].flowerBoots && tileCache.frameX >= 108)
				{
					num4 *= 10000;
				}
			}
			if (tileCache.type == 61)
			{
				num3 = 80;
				if (Main.player[num5].flowerBoots && tileCache.frameX >= 108)
				{
					num3 *= 10000;
				}
			}
			if (tileCache.type == 74)
			{
				num3 = 40;
				if (Main.player[num5].flowerBoots && tileCache.frameX >= 108)
				{
					num3 *= 10000;
				}
			}
			if (tileCache.type == 62)
			{
				num3 = 250;
			}
			if (tileCache.type == 185)
			{
				if (tileCache.frameY == 0 && tileCache.frameX < 214)
				{
					num = 6;
				}
				if (tileCache.frameY == 18 && (tileCache.frameX < 214 || tileCache.frameX >= 1368))
				{
					num = 6;
				}
			}
			else if (tileCache.type == 186)
			{
				if (tileCache.frameX >= 378 && tileCache.frameX <= 700)
				{
					num = 6;
				}
			}
			else if (tileCache.type == 187)
			{
				if (tileCache.frameX >= 756 && tileCache.frameX <= 916)
				{
					num = 6;
				}
				if (tileCache.frameX <= 322)
				{
					num = 6;
				}
			}
			else if (tileCache.type == 233)
			{
				num3 = 10;
			}
			int num6 = 357;
			if (Main.player[num5].ZoneGraveyard)
			{
				num6 = 606;
			}
			if (num > 0 && NPC.CountNPCS(num6) < 5 && genRand.Next(num) == 0)
			{
				int type = num6;
				if (num6 == 357 && Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
				{
					type = 448;
				}
				int num7 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type);
				Main.npc[num7].TargetClosest();
				Main.npc[num7].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num7].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num7].direction);
				Main.npc[num7].direction *= -1;
				Main.npc[num7].netUpdate = true;
			}
			if (num2 > 0 && NPC.CountNPCS(377) < 5 && genRand.Next(num2) == 0)
			{
				int type2 = 377;
				if (Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0f)
				{
					type2 = 446;
				}
				int num8 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type2);
				Main.npc[num8].TargetClosest();
				Main.npc[num8].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num8].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num8].direction);
				Main.npc[num8].direction *= -1;
				Main.npc[num8].netUpdate = true;
			}
			if (num3 > 0 && NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) < 8 && genRand.Next(num3) == 0)
			{
				int type3 = 485;
				if (genRand.Next(4) == 0)
				{
					type3 = 486;
				}
				if (genRand.Next(12) == 0)
				{
					type3 = 487;
				}
				int num9 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type3);
				Main.npc[num9].TargetClosest();
				Main.npc[num9].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num9].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num9].direction);
				Main.npc[num9].direction *= -1;
				Main.npc[num9].netUpdate = true;
			}
			if (num4 > 0 && NPC.CountNPCS(654) + NPC.CountNPCS(653) < 8 && genRand.Next(num4) == 0)
			{
				int type4 = 653;
				if (genRand.Next(2) == 0)
				{
					type4 = 654;
				}
				int num10 = NPC.NewNPC(GetNPCSource_TileBreak(i, j), i * 16 + 10, j * 16, type4);
				Main.npc[num10].TargetClosest();
				Main.npc[num10].velocity.Y = (float)genRand.Next(-50, -21) * 0.1f;
				Main.npc[num10].velocity.X = (float)genRand.Next(0, 26) * 0.1f * (float)(-Main.npc[num10].direction);
				Main.npc[num10].direction *= -1;
				Main.npc[num10].netUpdate = true;
			}
		}

		public static void KillTile_PlaySounds(int i, int j, bool fail, Tile tileCache)
		{
			if (gen)
			{
				return;
			}
			int type = tileCache.type;
			if (type == 127 || type == 623)
			{
				SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
			}
			else if (type == 147 || type == 224)
			{
				if (genRand.Next(2) == 0)
				{
					SoundEngine.PlaySound(SoundID.Item48, i * 16, j * 16);
				}
				else
				{
					SoundEngine.PlaySound(SoundID.Item49, i * 16, j * 16);
				}
			}
			else if (type == 161 || type == 163 || type == 164 || type == 200 || type == 541)
			{
				SoundEngine.PlaySound(SoundID.Item50, i * 16, j * 16);
			}
			else if (type == 518 || type == 519 || type == 528 || type == 529 || type == 549 || type == 637 || type == 638 || type == 636)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else if (type == 530 && tileCache.frameX < 270)
			{
				SoundEngine.PlaySound(6, i * 16, j * 16);
			}
			else
			{
				switch (type)
				{
				case 3:
				case 110:
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				case 254:
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				case 24:
					SoundEngine.PlaySound(6, i * 16, j * 16);
					break;
				default:
					if (Main.tileAlch[type] || type == 384 || type == 227 || type == 32 || type == 51 || type == 52 || type == 61 || type == 62 || type == 69 || type == 655 || type == 71 || type == 73 || type == 74 || type == 113 || type == 115 || type == 184 || type == 192 || type == 205 || type == 233 || type == 352 || type == 382 || type == 624 || type == 656)
					{
						SoundEngine.PlaySound(6, i * 16, j * 16);
						break;
					}
					if (type == 485)
					{
						SoundEngine.PlaySound(4, i * 16, j * 16, 11);
						break;
					}
					if (type == 201)
					{
						SoundEngine.PlaySound(6, i * 16, j * 16);
						break;
					}
					if (type == 481 || type == 482 || type == 483)
					{
						SoundEngine.PlaySound(SoundID.Item127, i * 16, j * 16);
						break;
					}
					if (type == 1 || type == 6 || type == 7 || type == 8 || type == 9 || type == 22 || type == 140 || type == 25 || type == 37 || type == 38 || type == 39 || type == 41 || type == 43 || type == 44 || type == 45 || type == 46 || type == 47 || type == 48 || type == 56 || type == 58 || type == 63 || type == 64 || type == 65 || type == 66 || type == 67 || type == 68 || type == 75 || type == 76 || type == 107 || type == 108 || type == 111 || type == 117 || type == 118 || type == 119 || type == 120 || type == 121 || type == 122 || type == 150 || type == 151 || type == 152 || type == 153 || type == 154 || type == 155 || type == 156 || type == 160 || type == 161 || type == 166 || type == 167 || type == 168 || type == 169 || type == 175 || type == 176 || type == 177 || type == 203 || type == 202 || type == 204 || type == 206 || type == 211 || type == 221 || type == 222 || type == 223 || type == 226 || type == 248 || type == 249 || type == 250 || type == 272 || type == 273 || type == 274 || type == 478 || type == 284 || type == 325 || type == 346 || type == 347 || type == 348 || type == 350 || type == 367 || type == 357 || type == 368 || type == 369 || type == 370 || type == 407 || type == 472 || type == 473 || type == 500 || type == 501 || type == 502 || type == 503 || type == 546 || type == 557 || type == 566 || type == 618 || type == 408 || type == 409 || type == 669 || type == 670 || type == 671 || type == 672 || type == 673 || type == 674 || type == 675 || type == 676 || type == 677 || type == 678 || type == 679 || type == 680 || type == 681 || type == 682 || type == 683 || type == 684 || type == 685 || type == 686 || type == 687 || type == 689 || type == 688 || type == 690 || type == 691 || type == 692)
					{
						SoundEngine.PlaySound(21, i * 16, j * 16);
						break;
					}
					if (type == 666)
					{
						SoundEngine.PlaySound(SoundID.Item177, i * 16, j * 16);
						break;
					}
					if (type == 231 || type == 195 || type == 474)
					{
						SoundEngine.PlaySound(4, i * 16, j * 16);
						if (type == 231)
						{
							SoundEngine.PlaySound(SoundID.Item173, i * 16, j * 16);
						}
						break;
					}
					if (type == 26 && tileCache.frameX >= 54)
					{
						SoundEngine.PlaySound(4, i * 16, j * 16);
						break;
					}
					switch (type)
					{
					case 314:
						SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
						break;
					case 330:
					case 331:
					case 332:
					case 333:
						SoundEngine.PlaySound(18, i * 16, j * 16);
						break;
					default:
						if ((type == 162 || type == 385 || type == 129 || (type == 165 && tileCache.frameX < 54)) && !fail)
						{
							SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
						}
						else if (type != 138)
						{
							SoundEngine.PlaySound(0, i * 16, j * 16);
						}
						break;
					}
					break;
				}
			}
			if (!fail)
			{
				if (tileCache.type == 13)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 54)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 326)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 327)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 458)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 459)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 345)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 328)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 329)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 507)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
				else if (tileCache.type == 508)
				{
					SoundEngine.PlaySound(13, i * 16, j * 16);
				}
			}
		}

		public static Rectangle? GetTileVisualHitbox(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (tile == null || !tile.nactive())
			{
				return null;
			}
			Rectangle value = new Rectangle(x * 16, y * 16, 16, 16);
			ushort type = tile.type;
			if (type == 323)
			{
				value.X += tile.frameY;
			}
			if (tile.halfBrick())
			{
				value.Y += 8;
				value.Height = 8;
			}
			return value;
		}

		public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache)
		{
			switch (tileCache.type)
			{
			default:
				if (!fail)
				{
					return 10;
				}
				return 3;
			case 654:
				return 0;
			case 630:
			case 631:
				return 0;
			case 231:
				if (!fail)
				{
					return 6;
				}
				return 3;
			case 481:
			case 482:
			case 483:
				return 3;
			case 541:
				return 1;
			case 549:
				return 2;
			case 125:
			case 138:
			case 172:
			case 287:
			case 300:
			case 301:
			case 302:
			case 303:
			case 304:
			case 305:
			case 306:
			case 307:
			case 308:
			case 354:
			case 355:
			case 373:
			case 374:
			case 375:
			case 376:
			case 461:
			case 484:
			case 499:
			case 564:
			case 565:
			case 593:
			case 594:
			case 617:
			case 664:
			case 665:
				return 0;
			case 534:
			case 536:
			case 539:
			case 625:
			case 627:
				if (!fail)
				{
					return 5;
				}
				return 3;
			case 184:
				if (tileCache.frameX / 22 >= 5)
				{
					return 5;
				}
				if (!fail)
				{
					return 10;
				}
				return 3;
			}
		}

		public static int KillTile_MakeTileDust(int i, int j, Tile tileCache)
		{
			int num = 0;
			if (tileCache.type == 216)
			{
				num = -1;
			}
			if (tileCache.type == 324)
			{
				num = ((tileCache.frameY != 0) ? (281 + tileCache.frameX / 18) : 280);
			}
			if (tileCache.type == 216)
			{
				num = -1;
			}
			if (tileCache.type == 335)
			{
				num = -1;
			}
			if (tileCache.type == 338)
			{
				num = -1;
			}
			if (tileCache.type == 0)
			{
				num = 0;
			}
			if (tileCache.type == 192)
			{
				num = 3;
			}
			if (tileCache.type == 208)
			{
				num = 126;
			}
			else if (tileCache.type == 408 || tileCache.type == 409)
			{
				num = 265;
			}
			else if (tileCache.type == 669)
			{
				num = 314;
			}
			else if (tileCache.type == 670)
			{
				num = 315;
			}
			else if (tileCache.type == 671)
			{
				num = 316;
			}
			else if (tileCache.type == 672)
			{
				num = 317;
			}
			else if (tileCache.type == 673)
			{
				num = 318;
			}
			else if (tileCache.type == 674)
			{
				num = 319;
			}
			else if (tileCache.type == 675)
			{
				num = 320;
			}
			else if (tileCache.type == 676)
			{
				num = 321;
			}
			if (tileCache.type == 16)
			{
				num = 1;
				if (tileCache.frameX >= 36)
				{
					num = 82;
				}
			}
			else if (tileCache.type == 415 || tileCache.type == 500)
			{
				num = 6;
			}
			else if (tileCache.type == 416 || tileCache.type == 501)
			{
				num = 61;
			}
			else if (tileCache.type == 417 || tileCache.type == 502)
			{
				num = 242;
			}
			else if (tileCache.type == 418 || tileCache.type == 503)
			{
				num = 135;
			}
			else if (tileCache.type == 474)
			{
				num = 18;
			}
			if (tileCache.type == 1 || tileCache.type == 17 || tileCache.type == 38 || tileCache.type == 39 || tileCache.type == 41 || tileCache.type == 43 || tileCache.type == 44 || tileCache.type == 481 || tileCache.type == 482 || tileCache.type == 483 || tileCache.type == 48 || Main.tileStone[tileCache.type] || tileCache.type == 85 || tileCache.type == 90 || tileCache.type == 92 || tileCache.type == 96 || tileCache.type == 97 || tileCache.type == 99 || tileCache.type == 117 || tileCache.type == 130 || tileCache.type == 131 || tileCache.type == 132 || tileCache.type == 135 || tileCache.type == 135 || tileCache.type == 142 || tileCache.type == 143 || tileCache.type == 144 || tileCache.type == 210 || tileCache.type == 207 || tileCache.type == 235 || tileCache.type == 247 || tileCache.type == 272 || tileCache.type == 273 || tileCache.type == 283 || tileCache.type == 410 || tileCache.type == 480 || tileCache.type == 509 || tileCache.type == 618 || tileCache.type == 657 || tileCache.type == 658 || tileCache.type == 677 || tileCache.type == 678 || tileCache.type == 679)
			{
				num = 1;
			}
			if (tileCache.type == 379)
			{
				num = 257;
			}
			if (tileCache.type == 311)
			{
				num = 207;
			}
			if (tileCache.type == 312)
			{
				num = 208;
			}
			if (tileCache.type == 313)
			{
				num = 209;
			}
			if (tileCache.type == 104)
			{
				num = -1;
			}
			if (tileCache.type == 95 || tileCache.type == 98 || tileCache.type == 100 || tileCache.type == 174 || tileCache.type == 173)
			{
				num = 6;
			}
			if (tileCache.type == 30 || tileCache.type == 86 || tileCache.type == 94 || tileCache.type == 106 || tileCache.type == 114 || tileCache.type == 124 || tileCache.type == 128 || tileCache.type == 269)
			{
				num = 7;
			}
			if (tileCache.type == 372)
			{
				num = 242;
			}
			if (tileCache.type == 646)
			{
				num = 29;
			}
			if (tileCache.type == 49)
			{
				num = 29;
			}
			if (tileCache.type == 371)
			{
				num = 243;
			}
			if (tileCache.type == 334)
			{
				num = 7;
			}
			switch (tileCache.type)
			{
			case 10:
			case 11:
			case 87:
			case 89:
			case 93:
			case 139:
			case 209:
			case 319:
			case 320:
			case 386:
			case 387:
			case 390:
			case 405:
			case 406:
			case 411:
			case 412:
			case 419:
			case 420:
			case 421:
			case 422:
			case 423:
			case 424:
			case 425:
			case 428:
			case 429:
			case 441:
			case 442:
			case 445:
			case 446:
			case 447:
			case 448:
			case 449:
			case 450:
			case 451:
			case 452:
			case 453:
			case 455:
			case 456:
			case 457:
			case 462:
			case 463:
			case 464:
			case 465:
			case 466:
			case 468:
			case 476:
			case 486:
			case 487:
			case 489:
			case 490:
			case 491:
			case 493:
			case 494:
			case 497:
			case 510:
			case 511:
			case 520:
			case 521:
			case 522:
			case 523:
			case 524:
			case 525:
			case 526:
			case 527:
			case 531:
			case 545:
			case 547:
			case 548:
			case 560:
			case 564:
			case 565:
			case 567:
			case 572:
			case 579:
			case 591:
			case 592:
			case 593:
			case 594:
			case 613:
			case 614:
			case 621:
			case 622:
			case 623:
			case 624:
			case 630:
			case 631:
			case 656:
				num = -1;
				break;
			case 668:
				num = 0;
				break;
			case 407:
				num = 10;
				break;
			case 454:
				num = 139;
				break;
			case 41:
			case 481:
			case 677:
				num = 275;
				break;
			case 43:
			case 482:
			case 678:
				num = 276;
				break;
			case 44:
			case 483:
			case 679:
				num = 277;
				break;
			case 473:
				num = 82;
				break;
			case 472:
			case 546:
			case 557:
				num = 8;
				break;
			case 498:
				num = 30;
				break;
			case 517:
			case 687:
				num = 258;
				break;
			case 535:
			case 689:
				num = 299;
				break;
			case 537:
			case 690:
				num = 300;
				break;
			case 540:
			case 688:
				num = 301;
				break;
			case 626:
			case 691:
				num = 305;
				break;
			case 184:
			{
				int num2 = tileCache.frameX / 22;
				num = num2 switch
				{
					5 => 258, 
					6 => 299, 
					7 => 300, 
					8 => 301, 
					9 => 305, 
					10 => 267, 
					_ => 93 + num2, 
				};
				break;
			}
			case 515:
				num = 96;
				break;
			case 516:
				num = 97;
				break;
			case 514:
				num = 95;
				break;
			case 513:
				num = 94;
				break;
			case 512:
				num = 93;
				break;
			case 541:
				num = 226;
				break;
			case 590:
				num = 1;
				break;
			case 583:
				num = ((genRand.Next(10) != 0) ? 1 : 87);
				break;
			case 584:
				num = ((genRand.Next(10) != 0) ? 1 : 86);
				break;
			case 585:
				num = ((genRand.Next(10) != 0) ? 1 : 88);
				break;
			case 586:
				num = ((genRand.Next(10) != 0) ? 1 : 89);
				break;
			case 587:
				num = ((genRand.Next(10) != 0) ? 1 : 90);
				break;
			case 588:
				num = ((genRand.Next(10) != 0) ? 1 : 91);
				break;
			case 589:
				num = ((genRand.Next(10) != 0) ? 1 : 138);
				break;
			case 595:
				num = 78;
				break;
			case 596:
				num = 78;
				break;
			case 615:
				num = 78;
				break;
			case 616:
				num = 78;
				break;
			case 633:
				num = ((genRand.Next(6) != 0) ? 237 : 36);
				break;
			case 637:
			case 638:
				num = 237;
				break;
			case 634:
				num = ((genRand.Next(10) != 0) ? 36 : 31);
				if (genRand.Next(12) == 0)
				{
					num = 6;
				}
				break;
			}
			if (Main.tileMoss[tileCache.type])
			{
				num = ((tileCache.type == 381) ? 258 : ((tileCache.type == 534) ? 299 : ((tileCache.type == 536) ? 300 : ((tileCache.type == 539) ? 301 : ((tileCache.type == 625) ? 305 : ((tileCache.type != 627) ? (tileCache.type - 179 + 93) : 267))))));
			}
			if (tileCache.type == 240)
			{
				int num3 = tileCache.frameX / 54;
				if (tileCache.frameY >= 54)
				{
					num3 += 36 * (tileCache.frameY / 54);
				}
				num = 7;
				if (num3 == 16 || num3 == 17)
				{
					num = 26;
				}
				if (num3 >= 46 && num3 <= 49)
				{
					num = -1;
				}
			}
			if (tileCache.type == 241)
			{
				num = 1;
			}
			if (tileCache.type == 242)
			{
				num = -1;
			}
			if (tileCache.type == 529)
			{
				num = Main.tile[i, j + 1].type switch
				{
					116 => num = 47, 
					234 => num = 125, 
					112 => num = 17, 
					_ => (i >= beachDistance && i <= Main.maxTilesX - beachDistance) ? 289 : 290, 
				};
			}
			if (tileCache.type == 356)
			{
				num = -1;
			}
			if (tileCache.type == 663)
			{
				num = -1;
			}
			if (tileCache.type == 351)
			{
				num = -1;
			}
			if (tileCache.type == 246)
			{
				num = -1;
			}
			if (tileCache.type == 36)
			{
				num = -1;
			}
			if (tileCache.type == 365)
			{
				num = 239;
			}
			if (tileCache.type == 366)
			{
				num = 30;
			}
			if (tileCache.type == 504)
			{
				num = -1;
			}
			if (tileCache.type == 357 || tileCache.type == 367 || tileCache.type == 561)
			{
				num = 236;
			}
			if (tileCache.type == 368 || tileCache.type == 369 || tileCache.type == 576)
			{
				num = 240;
			}
			if (tileCache.type == 170)
			{
				num = 196;
			}
			if (tileCache.type == 315)
			{
				num = 225;
			}
			if (tileCache.type == 641)
			{
				num = ((genRand.Next(2) != 0) ? 161 : 243);
			}
			if (tileCache.type == 659)
			{
				num = 308;
			}
			if (tileCache.type == 667)
			{
				num = 308;
			}
			if (tileCache.type == 346)
			{
				num = 128;
			}
			if (tileCache.type == 347)
			{
				num = 117;
			}
			if (tileCache.type == 348)
			{
				num = 42;
			}
			if (tileCache.type == 350)
			{
				num = 226;
			}
			if (tileCache.type == 370)
			{
				num = ((genRand.Next(2) != 0) ? 23 : 6);
			}
			if (tileCache.type == 171)
			{
				num = ((genRand.Next(2) != 0) ? (-1) : 196);
			}
			if (tileCache.type == 326)
			{
				num = 13;
			}
			if (tileCache.type == 327)
			{
				num = 13;
			}
			if (tileCache.type == 345)
			{
				num = 13;
			}
			if (tileCache.type == 458)
			{
				num = 13;
			}
			if (tileCache.type == 459)
			{
				num = 13;
			}
			if (tileCache.type == 336)
			{
				num = 6;
			}
			if (tileCache.type == 340)
			{
				num = 75;
			}
			if (tileCache.type == 341)
			{
				num = 65;
			}
			if (tileCache.type == 342)
			{
				num = 135;
			}
			if (tileCache.type == 343)
			{
				num = 169;
			}
			if (tileCache.type == 344)
			{
				num = 156;
			}
			if (tileCache.type == 328)
			{
				num = 13;
			}
			if (tileCache.type == 329)
			{
				num = 13;
			}
			if (tileCache.type == 507)
			{
				num = 13;
			}
			if (tileCache.type == 508)
			{
				num = 13;
			}
			if (tileCache.type == 562)
			{
				num = -1;
			}
			if (tileCache.type == 571)
			{
				num = 40;
			}
			if (tileCache.type == 563)
			{
				num = -1;
			}
			if (tileCache.type == 330)
			{
				num = 9;
			}
			if (tileCache.type == 331)
			{
				num = 11;
			}
			if (tileCache.type == 332)
			{
				num = 19;
			}
			if (tileCache.type == 333)
			{
				num = 11;
			}
			if (tileCache.type == 101)
			{
				num = -1;
			}
			if (tileCache.type == 19)
			{
				num = (tileCache.frameY / 18) switch
				{
					0 => 7, 
					1 => 77, 
					2 => 78, 
					3 => 79, 
					4 => 26, 
					5 => 126, 
					6 => 275, 
					7 => 277, 
					8 => 276, 
					9 => 1, 
					10 => 214, 
					11 => 214, 
					12 => 214, 
					13 => 109, 
					14 => 13, 
					15 => 189, 
					16 => 191, 
					17 => 215, 
					18 => 26, 
					19 => 214, 
					20 => 4, 
					21 => 10, 
					22 => 32, 
					23 => 78, 
					24 => 147, 
					25 => 40, 
					26 => 226, 
					27 => 23, 
					28 => 240, 
					29 => 236, 
					30 => 68 + Main.rand.Next(3), 
					31 => 10, 
					32 => 78, 
					33 => 148, 
					34 => 5, 
					35 => 80, 
					37 => 18, 
					38 => 6, 
					39 => 61, 
					40 => 242, 
					41 => 135, 
					42 => 287, 
					44 => 273, 
					45 => 243, 
					46 => 243, 
					47 => 36, 
					48 => 226, 
					_ => 1, 
				};
			}
			if (tileCache.type == 79)
			{
				int num4 = tileCache.frameY / 36;
				num = ((num4 == 0) ? 7 : ((num4 == 1) ? 77 : ((num4 == 2) ? 78 : ((num4 == 3) ? 79 : ((num4 == 4) ? 126 : ((num4 == 8) ? 109 : ((num4 < 9) ? 1 : (-1))))))));
			}
			if (tileCache.type == 18)
			{
				switch (tileCache.frameX / 36)
				{
				case 0:
					num = 7;
					break;
				case 1:
					num = 77;
					break;
				case 2:
					num = 78;
					break;
				case 3:
					num = 79;
					break;
				case 4:
					num = 26;
					break;
				case 5:
					num = 40;
					break;
				case 6:
					num = 5;
					break;
				case 7:
					num = 26;
					break;
				case 8:
					num = 4;
					break;
				case 9:
					num = 126;
					break;
				case 10:
					num = 148;
					break;
				case 11:
				case 12:
				case 13:
					num = 1;
					break;
				case 14:
					num = 109;
					break;
				case 15:
					num = 126;
					break;
				default:
					num = -1;
					break;
				}
			}
			if (tileCache.type == 14 || tileCache.type == 87 || tileCache.type == 88 || tileCache.type == 469)
			{
				num = -1;
			}
			if (tileCache.type >= 255 && tileCache.type <= 261)
			{
				int num5 = tileCache.type - 255;
				num = 86 + num5;
				if (num5 == 6)
				{
					num = 138;
				}
			}
			if (tileCache.type >= 262 && tileCache.type <= 268)
			{
				int num6 = tileCache.type - 262;
				num = 86 + num6;
				if (num6 == 6)
				{
					num = 138;
				}
			}
			if (tileCache.type == 178)
			{
				int num7 = tileCache.frameX / 18;
				num = 86 + num7;
				if (num7 == 6)
				{
					num = 138;
				}
			}
			if (tileCache.type == 440)
			{
				num = (tileCache.frameX / 54) switch
				{
					0 => 90, 
					1 => 88, 
					2 => 89, 
					3 => 87, 
					4 => 86, 
					5 => 91, 
					6 => 138, 
					_ => -1, 
				};
				if (tileCache.frameY < 54)
				{
					num = -1;
				}
			}
			switch (tileCache.type)
			{
			case 426:
			case 427:
				num = 90;
				break;
			case 430:
			case 435:
				num = 89;
				break;
			case 431:
			case 436:
				num = 88;
				break;
			case 432:
			case 437:
				num = 87;
				break;
			case 433:
			case 438:
				num = 86;
				break;
			case 434:
			case 439:
				num = 91;
				break;
			case 496:
				num = 109;
				break;
			case 549:
				num = 3;
				break;
			case 552:
				num = 32;
				break;
			}
			if (tileCache.type == 186)
			{
				num = ((tileCache.frameX <= 360) ? 26 : ((tileCache.frameX <= 846) ? 1 : ((tileCache.frameX <= 954) ? 9 : ((tileCache.frameX <= 1062) ? 11 : ((tileCache.frameX <= 1170) ? 10 : ((tileCache.frameX > 1332) ? ((tileCache.frameX > 1386) ? 80 : 10) : 0))))));
			}
			if (tileCache.type == 187)
			{
				if (tileCache.frameX <= 144)
				{
					num = 1;
				}
				else if (tileCache.frameX <= 306)
				{
					num = 38;
				}
				else if (tileCache.frameX <= 468)
				{
					num = 36;
				}
				else if (tileCache.frameX <= 738)
				{
					num = 30;
				}
				else if (tileCache.frameX <= 970)
				{
					num = 1;
				}
				else if (tileCache.frameX <= 1132)
				{
					num = 148;
				}
				else if (tileCache.frameX <= 1132)
				{
					num = 155;
				}
				else if (tileCache.frameX <= 1348)
				{
					num = 1;
				}
				else if (tileCache.frameX <= 1564)
				{
					num = 0;
				}
				else if (tileCache.frameX <= 1890)
				{
					num = 250;
				}
				else if (tileCache.frameX <= 2196)
				{
					num = 240;
				}
				else if (tileCache.frameX <= 2520)
				{
					num = 236;
				}
			}
			if (tileCache.type == 647)
			{
				int num8 = tileCache.frameX / 54;
				if (num8 < 7)
				{
					num = 26;
				}
				else if (num8 < 16)
				{
					num = 1;
				}
				else if (num8 < 18)
				{
					num = 9;
				}
				else if (num8 < 20)
				{
					num = 11;
				}
				else if (num8 < 22)
				{
					num = 10;
				}
				else if (num8 < 26)
				{
					num = 7;
				}
				else if (num8 < 32)
				{
					num = 80;
				}
				else if (num8 < 35)
				{
					num = 80;
				}
			}
			if (tileCache.type == 648)
			{
				int num9 = tileCache.frameX / 54;
				num9 += tileCache.frameY / 36 * 35;
				if (num9 < 3)
				{
					num = 1;
				}
				else if (num9 < 6)
				{
					num = 38;
				}
				else if (num9 < 9)
				{
					num = 36;
				}
				else if (num9 < 14)
				{
					num = 30;
				}
				else if (num9 < 17)
				{
					num = 1;
				}
				else if (num9 < 18)
				{
					num = 1;
				}
				else if (num9 < 21)
				{
					num = 148;
				}
				else if (num9 < 29)
				{
					num = 155;
				}
				else if (num9 < 35)
				{
					num = 287;
				}
				else if (num9 < 41)
				{
					num = 240;
				}
				else if (num9 < 47)
				{
					num = 236;
				}
				else if (num9 < 50)
				{
					num = 0;
				}
				else if (num9 < 52)
				{
					num = 2;
				}
				else if (num9 < 55)
				{
					num = 26;
				}
			}
			if (tileCache.type == 105)
			{
				num = 1;
				if (tileCache.frameX >= 1548 && tileCache.frameX <= 1654 && tileCache.frameY < 54)
				{
					num = 148;
				}
			}
			if (tileCache.type == 349)
			{
				num = 1;
			}
			if (tileCache.type == 337 || tileCache.type == 506)
			{
				num = 1;
			}
			if (tileCache.type == 239)
			{
				int num10 = tileCache.frameX / 18;
				if (num10 == 0)
				{
					num = 9;
				}
				if (num10 == 1)
				{
					num = 81;
				}
				if (num10 == 2)
				{
					num = 8;
				}
				if (num10 == 3)
				{
					num = 82;
				}
				if (num10 == 4)
				{
					num = 11;
				}
				if (num10 == 5)
				{
					num = 83;
				}
				if (num10 == 6)
				{
					num = 10;
				}
				if (num10 == 7)
				{
					num = 84;
				}
				if (num10 == 8)
				{
					num = 14;
				}
				if (num10 == 9)
				{
					num = 23;
				}
				if (num10 == 10)
				{
					num = 25;
				}
				if (num10 == 11)
				{
					num = 48;
				}
				if (num10 == 12)
				{
					num = 144;
				}
				if (num10 == 13)
				{
					num = 49;
				}
				if (num10 == 14)
				{
					num = 145;
				}
				if (num10 == 15)
				{
					num = 50;
				}
				if (num10 == 16)
				{
					num = 146;
				}
				if (num10 == 17)
				{
					num = 128;
				}
				if (num10 == 18)
				{
					num = 84;
				}
				if (num10 == 19)
				{
					num = 117;
				}
				if (num10 == 20)
				{
					num = 42;
				}
				if (num10 == 21)
				{
					num = -1;
				}
				if (num10 == 22)
				{
					num = 265;
				}
			}
			if (tileCache.type == 185)
			{
				if (tileCache.frameY == 18)
				{
					int num11 = tileCache.frameX / 36;
					if (num11 < 6)
					{
						num = 1;
					}
					else if (num11 < 16)
					{
						num = 26;
					}
					else if (num11 == 16)
					{
						num = 9;
					}
					else if (num11 == 17)
					{
						num = 11;
					}
					else if (num11 == 18)
					{
						num = 10;
					}
					else if (num11 == 19)
					{
						num = 86;
					}
					else if (num11 == 20)
					{
						num = 87;
					}
					else if (num11 == 21)
					{
						num = 88;
					}
					else if (num11 == 22)
					{
						num = 89;
					}
					else if (num11 == 23)
					{
						num = 90;
					}
					else if (num11 == 24)
					{
						num = 91;
					}
					else if (num11 < 31)
					{
						num = 80;
					}
					else if (num11 < 33)
					{
						num = 7;
					}
					else if (num11 < 34)
					{
						num = 8;
					}
					else if (num11 < 38)
					{
						num = 30;
					}
					else if (num11 < 41)
					{
						num = 1;
					}
					else if (num11 < 47)
					{
						num = 287;
					}
					else if (num11 < 53)
					{
						num = 240;
					}
					else if (num11 < 59)
					{
						num = 236;
					}
				}
				else
				{
					int num12 = tileCache.frameX / 18;
					if (num12 < 6)
					{
						num = 1;
					}
					else if (num12 < 12)
					{
						num = 0;
					}
					else if (num12 < 28)
					{
						num = 26;
					}
					else if (num12 < 33)
					{
						num = 1;
					}
					else if (num12 < 36)
					{
						num = 0;
					}
					else if (num12 < 48)
					{
						num = 80;
					}
					else if (num12 < 54)
					{
						num = 30;
					}
					else if (num12 < 60)
					{
						num = 287;
					}
					else if (num12 < 66)
					{
						num = 240;
					}
					else if (num12 < 72)
					{
						num = 236;
					}
					else if (num12 < 73)
					{
						num = 0;
					}
					else if (num12 < 77)
					{
						num = 32;
					}
				}
			}
			if (tileCache.type == 649)
			{
				int num13 = tileCache.frameX / 36 + tileCache.frameY / 18 * 53;
				if (num13 < 6)
				{
					num = 1;
				}
				else if (num13 < 16)
				{
					num = 26;
				}
				else if (num13 == 16)
				{
					num = 9;
				}
				else if (num13 == 17)
				{
					num = 11;
				}
				else if (num13 == 18)
				{
					num = 10;
				}
				else if (num13 == 19)
				{
					num = 86;
				}
				else if (num13 == 20)
				{
					num = 87;
				}
				else if (num13 == 21)
				{
					num = 88;
				}
				else if (num13 == 22)
				{
					num = 89;
				}
				else if (num13 == 23)
				{
					num = 90;
				}
				else if (num13 == 24)
				{
					num = 91;
				}
				else if (num13 < 31)
				{
					num = 80;
				}
				else if (num13 < 33)
				{
					num = 7;
				}
				else if (num13 < 34)
				{
					num = 8;
				}
				else if (num13 < 38)
				{
					num = 30;
				}
				else if (num13 < 41)
				{
					num = 1;
				}
				else if (num13 < 47)
				{
					num = 287;
				}
				else if (num13 < 53)
				{
					num = 240;
				}
				else if (num13 < 59)
				{
					num = 236;
				}
				else if (num13 < 62)
				{
					num = 0;
				}
				else if (num13 < 65)
				{
					num = 32;
				}
			}
			if (tileCache.type == 650)
			{
				int num14 = tileCache.frameX / 18;
				if (num14 < 6)
				{
					num = 1;
				}
				else if (num14 < 12)
				{
					num = 0;
				}
				else if (num14 < 28)
				{
					num = 26;
				}
				else if (num14 < 33)
				{
					num = 1;
				}
				else if (num14 < 36)
				{
					num = 0;
				}
				else if (num14 < 48)
				{
					num = 80;
				}
				else if (num14 < 54)
				{
					num = 30;
				}
				else if (num14 < 60)
				{
					num = 287;
				}
				else if (num14 < 66)
				{
					num = 240;
				}
				else if (num14 < 72)
				{
					num = 236;
				}
				else if (num14 < 73)
				{
					num = 0;
				}
				else if (num14 < 77)
				{
					num = 32;
				}
			}
			if (tileCache.type == 237)
			{
				num = 148;
			}
			if (tileCache.type == 157)
			{
				num = 77;
			}
			if (tileCache.type == 158 || tileCache.type == 232 || tileCache.type == 383 || tileCache.type == 575)
			{
				num = 78;
			}
			if (tileCache.type == 159)
			{
				num = 78;
			}
			if (tileCache.type == 15)
			{
				num = -1;
			}
			if (tileCache.type == 191)
			{
				num = 7;
			}
			if (tileCache.type == 5)
			{
				num = 7;
				if (i > 5 && i < Main.maxTilesX - 5)
				{
					int num15 = i;
					int k = j;
					if (tileCache.frameX == 66 && tileCache.frameY <= 45)
					{
						num15++;
					}
					if (tileCache.frameX == 88 && tileCache.frameY >= 66 && tileCache.frameY <= 110)
					{
						num15--;
					}
					if (tileCache.frameX == 22 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
					{
						num15--;
					}
					if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
					{
						num15++;
					}
					if (tileCache.frameX == 44 && tileCache.frameY >= 132 && tileCache.frameY <= 176)
					{
						num15++;
					}
					if (tileCache.frameX == 44 && tileCache.frameY >= 198)
					{
						num15++;
					}
					if (tileCache.frameX == 66 && tileCache.frameY >= 198)
					{
						num15--;
					}
					for (; Main.tile[num15, k] != null && (!Main.tile[num15, k].active() || !Main.tileSolid[Main.tile[num15, k].type]); k++)
					{
					}
					if (Main.tile[num15, k] != null)
					{
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 23)
						{
							num = 77;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 661)
						{
							num = 77;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 60)
						{
							num = 78;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 70)
						{
							num = 26;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 109)
						{
							num = 79;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 199)
						{
							num = 121;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 662)
						{
							num = 121;
						}
						if (Main.tile[num15, k].active() && Main.tile[num15, k].type == 147)
						{
							num = 122;
						}
					}
				}
			}
			if (tileCache.type == 323)
			{
				num = 215;
				if (i > 5 && i < Main.maxTilesX - 5)
				{
					int l;
					for (l = j; Main.tile[i, l] != null && (!Main.tile[i, l].active() || !Main.tileSolid[Main.tile[i, l].type]); l++)
					{
					}
					if (Main.tile[i, l] != null)
					{
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 234)
						{
							num = 121;
						}
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 116)
						{
							num = 79;
						}
						if (Main.tile[i, l].active() && Main.tile[i, l].type == 112)
						{
							num = 77;
						}
					}
				}
			}
			if (tileCache.type == 137)
			{
				switch (tileCache.frameY / 18)
				{
				default:
					num = 1;
					break;
				case 1:
				case 2:
				case 3:
				case 4:
					num = 148;
					break;
				case 5:
					num = 1;
					break;
				}
			}
			if (tileCache.type == 443)
			{
				num = 1;
			}
			if (tileCache.type == 444)
			{
				num = -1;
			}
			if (tileCache.type == 212)
			{
				num = -1;
			}
			if (tileCache.type == 213)
			{
				num = 129;
			}
			if (tileCache.type == 214)
			{
				num = 1;
			}
			if (tileCache.type == 215)
			{
				num = -6;
			}
			if (tileCache.type == 325)
			{
				num = 81;
			}
			if (tileCache.type == 251)
			{
				num = 189;
			}
			if (tileCache.type == 252)
			{
				num = 190;
			}
			if (tileCache.type == 253)
			{
				num = 191;
			}
			if (tileCache.type == 254)
			{
				if (tileCache.frameX < 72)
				{
					num = 3;
				}
				else if (tileCache.frameX < 108)
				{
					num = 3;
					if (genRand.Next(3) == 0)
					{
						num = 189;
					}
				}
				else if (tileCache.frameX < 144)
				{
					num = 3;
					if (genRand.Next(2) == 0)
					{
						num = 189;
					}
				}
				else
				{
					num = 3;
					if (genRand.Next(4) != 0)
					{
						num = 189;
					}
				}
			}
			if (tileCache.type == 467)
			{
				num = -1;
			}
			if (tileCache.type == 21)
			{
				num = ((tileCache.frameX >= 1008) ? (-1) : ((tileCache.frameX >= 612) ? 11 : ((tileCache.frameX >= 576) ? 148 : ((tileCache.frameX >= 540) ? 26 : ((tileCache.frameX >= 504) ? 126 : ((tileCache.frameX >= 468) ? 116 : ((tileCache.frameX >= 432) ? 7 : ((tileCache.frameX >= 396) ? 11 : ((tileCache.frameX >= 360) ? 10 : ((tileCache.frameX >= 324) ? 79 : ((tileCache.frameX >= 288) ? 78 : ((tileCache.frameX >= 252) ? 77 : ((tileCache.frameX >= 216) ? 1 : ((tileCache.frameX >= 180) ? 7 : ((tileCache.frameX >= 108) ? 37 : ((tileCache.frameX < 36) ? 7 : 10))))))))))))))));
			}
			if (tileCache.type == 382)
			{
				num = 3;
			}
			if (tileCache.type == 2 || tileCache.type == 477)
			{
				num = ((genRand.Next(2) != 0) ? 2 : 0);
			}
			if (tileCache.type == 127)
			{
				num = 67;
			}
			if (tileCache.type == 91)
			{
				num = -1;
			}
			if (tileCache.type == 198)
			{
				num = 109;
			}
			if (tileCache.type == 26)
			{
				num = ((tileCache.frameX < 54) ? 8 : 5);
			}
			if (tileCache.type == 34)
			{
				num = -1;
			}
			if (tileCache.type == 6)
			{
				num = 8;
			}
			if (tileCache.type == 7 || tileCache.type == 47 || tileCache.type == 284 || tileCache.type == 682)
			{
				num = 9;
			}
			if (tileCache.type == 8 || tileCache.type == 45 || tileCache.type == 102 || tileCache.type == 680)
			{
				num = 10;
			}
			if (tileCache.type == 9 || tileCache.type == 42 || tileCache.type == 46 || tileCache.type == 126 || tileCache.type == 136 || tileCache.type == 681)
			{
				num = 11;
			}
			if (tileCache.type == 166 || tileCache.type == 175)
			{
				num = 81;
			}
			if (tileCache.type == 167)
			{
				num = 82;
			}
			if (tileCache.type == 168 || tileCache.type == 176)
			{
				num = 83;
			}
			if (tileCache.type == 169 || tileCache.type == 177)
			{
				num = 84;
			}
			if (tileCache.type == 199 || tileCache.type == 662)
			{
				num = 117;
			}
			if (tileCache.type == 205)
			{
				num = 125;
			}
			if (tileCache.type == 201)
			{
				num = 125;
			}
			if (tileCache.type == 211)
			{
				num = 128;
			}
			if (tileCache.type == 227)
			{
				switch (tileCache.frameX / 34)
				{
				case 0:
				case 1:
					num = 26;
					break;
				case 3:
					num = 3;
					break;
				case 2:
				case 4:
				case 5:
				case 6:
					num = 40;
					break;
				case 7:
					num = 117;
					break;
				case 8:
					num = 17;
					break;
				case 9:
					num = 6;
					break;
				case 10:
					num = 3;
					break;
				case 11:
					num = 26;
					break;
				}
			}
			if (tileCache.type == 204 || tileCache.type == 478)
			{
				num = 117;
				if (genRand.Next(2) == 0)
				{
					num = 1;
				}
			}
			if (tileCache.type == 203)
			{
				num = 117;
			}
			if (tileCache.type == 243)
			{
				num = ((genRand.Next(2) != 0) ? 13 : 7);
			}
			if (tileCache.type == 219)
			{
				num = -1;
			}
			if (tileCache.type == 642)
			{
				num = -128;
			}
			if (tileCache.type == 244)
			{
				num = ((genRand.Next(2) == 0) ? 1 : 13);
			}
			if (tileCache.type == 597)
			{
				num = -1;
			}
			else if ((tileCache.type >= 358 && tileCache.type <= 364) || (tileCache.type >= 275 && tileCache.type <= 282) || tileCache.type == 285 || tileCache.type == 286 || (tileCache.type >= 288 && tileCache.type <= 297) || (tileCache.type >= 316 && tileCache.type <= 318) || tileCache.type == 298 || tileCache.type == 299 || tileCache.type == 309 || tileCache.type == 310 || tileCache.type == 339 || tileCache.type == 538 || tileCache.type == 413 || tileCache.type == 414 || tileCache.type == 505 || tileCache.type == 521 || tileCache.type == 522 || tileCache.type == 523 || tileCache.type == 524 || tileCache.type == 525 || tileCache.type == 526 || tileCache.type == 527 || tileCache.type == 532 || tileCache.type == 543 || tileCache.type == 544 || tileCache.type == 550 || tileCache.type == 551 || tileCache.type == 533 || tileCache.type == 553 || tileCache.type == 554 || tileCache.type == 555 || tileCache.type == 556 || tileCache.type == 558 || tileCache.type == 559 || tileCache.type == 542 || tileCache.type == 391 || tileCache.type == 394 || tileCache.type == 392 || tileCache.type == 393 || tileCache.type == 568 || tileCache.type == 569 || tileCache.type == 570 || tileCache.type == 582 || tileCache.type == 580 || tileCache.type == 598 || tileCache.type == 599 || tileCache.type == 600 || tileCache.type == 601 || tileCache.type == 602 || tileCache.type == 603 || tileCache.type == 604 || tileCache.type == 605 || tileCache.type == 606 || tileCache.type == 607 || tileCache.type == 608 || tileCache.type == 609 || tileCache.type == 610 || tileCache.type == 611 || tileCache.type == 612 || tileCache.type == 619 || tileCache.type == 620 || tileCache.type == 629 || tileCache.type == 632 || tileCache.type == 640 || tileCache.type == 643 || tileCache.type == 644 || tileCache.type == 645)
			{
				num = 13;
				if (genRand.Next(3) != 0)
				{
					num = -1;
				}
			}
			if (tileCache.type == 13)
			{
				num = ((tileCache.frameX < 90) ? 13 : (-1));
			}
			if (tileCache.type == 189)
			{
				num = 16;
			}
			if (tileCache.type == 460)
			{
				num = 16;
			}
			if (tileCache.type == 530)
			{
				num = Main.tile[i, j + 2 - tileCache.frameY / 18].type switch
				{
					116 => 47, 
					234 => 125, 
					112 => 17, 
					_ => (tileCache.frameX >= 270) ? 291 : 40, 
				};
			}
			if (tileCache.type == 518)
			{
				if (tileCache.frameY == 0)
				{
					num = 3;
				}
				else if (tileCache.frameY == 18)
				{
					num = 47;
				}
				else if (tileCache.frameY == 36)
				{
					num = 40;
				}
			}
			else if (tileCache.type == 519)
			{
				if (tileCache.frameY == 0)
				{
					num = 3;
				}
				else if (tileCache.frameY == 18)
				{
					num = 40;
				}
				else if (tileCache.frameY == 36)
				{
					num = 47;
				}
				else if (tileCache.frameY == 54)
				{
					num = 125;
				}
				else if (tileCache.frameY == 72)
				{
					num = 17;
				}
				else if (tileCache.frameY == 90)
				{
					num = 26;
				}
			}
			else if (tileCache.type == 636)
			{
				num = 17;
			}
			else if (tileCache.type == 528)
			{
				num = 26;
			}
			if (tileCache.type == 12)
			{
				num = 12;
			}
			if (tileCache.type == 639)
			{
				num = 48;
			}
			if (tileCache.type == 3 || tileCache.type == 73)
			{
				num = 3;
			}
			if (tileCache.type == 54)
			{
				num = 13;
			}
			if (tileCache.type == 22 || tileCache.type == 140)
			{
				num = 14;
			}
			if (tileCache.type == 78)
			{
				num = 22;
			}
			if (tileCache.type == 28 || tileCache.type == 653)
			{
				num = 22;
				if (tileCache.frameY >= 72 && tileCache.frameY <= 90)
				{
					num = 1;
				}
				if (tileCache.frameY >= 144 && tileCache.frameY <= 234)
				{
					num = 48;
				}
				if (tileCache.frameY >= 252 && tileCache.frameY <= 358)
				{
					num = 85;
				}
				if (tileCache.frameY >= 360 && tileCache.frameY <= 466)
				{
					num = 26;
				}
				if (tileCache.frameY >= 468 && tileCache.frameY <= 574)
				{
					num = 36;
				}
				if (tileCache.frameY >= 576 && tileCache.frameY <= 790)
				{
					num = 18;
				}
				if (tileCache.frameY >= 792 && tileCache.frameY <= 898)
				{
					num = 5;
				}
				if (tileCache.frameY >= 900 && tileCache.frameY <= 1006)
				{
					num = 0;
				}
				if (tileCache.frameY >= 1008 && tileCache.frameY <= 1114)
				{
					num = 148;
				}
				if (tileCache.frameY >= 1116 && tileCache.frameY <= 1222)
				{
					num = 241;
				}
				if (tileCache.frameY >= 1224 && tileCache.frameY <= 1330)
				{
					num = 287;
				}
			}
			if (tileCache.type == 163)
			{
				num = 118;
			}
			if (tileCache.type == 164)
			{
				num = 119;
			}
			if (tileCache.type == 200)
			{
				num = 120;
			}
			if (tileCache.type == 221 || tileCache.type == 248)
			{
				num = 144;
			}
			if (tileCache.type == 222 || tileCache.type == 249)
			{
				num = 145;
			}
			if (tileCache.type == 223 || tileCache.type == 250)
			{
				num = 146;
			}
			if (tileCache.type == 224)
			{
				num = 149;
			}
			if (tileCache.type == 225)
			{
				num = 147;
			}
			if (tileCache.type == 229)
			{
				num = 153;
			}
			if (tileCache.type == 231)
			{
				num = 153;
				if (genRand.Next(3) == 0)
				{
					num = 26;
				}
			}
			if (tileCache.type == 226)
			{
				num = 148;
			}
			if (tileCache.type == 103)
			{
				num = -1;
			}
			if (tileCache.type == 29)
			{
				num = 23;
			}
			if (tileCache.type == 40)
			{
				num = 28;
			}
			if (tileCache.type == 50)
			{
				num = 22;
			}
			if (tileCache.type == 51)
			{
				num = 30;
			}
			if (tileCache.type == 52 || tileCache.type == 353)
			{
				num = 3;
			}
			if (tileCache.type == 53 || tileCache.type == 81 || tileCache.type == 151 || tileCache.type == 202 || tileCache.type == 274 || tileCache.type == 495)
			{
				num = 32;
			}
			if (tileCache.type == 56 || tileCache.type == 152)
			{
				num = 37;
			}
			if (tileCache.type == 75 || tileCache.type == 683)
			{
				num = 109;
			}
			if (tileCache.type == 57 || tileCache.type == 119 || tileCache.type == 141 || tileCache.type == 234 || tileCache.type == 635 || tileCache.type == 654)
			{
				num = 36;
			}
			if (tileCache.type == 59 || tileCache.type == 120)
			{
				num = 38;
			}
			if (tileCache.type == 61 || tileCache.type == 62 || tileCache.type == 74 || tileCache.type == 80 || tileCache.type == 188 || tileCache.type == 233 || tileCache.type == 236 || tileCache.type == 384 || tileCache.type == 652 || tileCache.type == 651)
			{
				num = 40;
			}
			if (tileCache.type == 485)
			{
				num = 32;
			}
			if (tileCache.type == 238)
			{
				num = ((genRand.Next(3) != 0) ? 166 : 167);
			}
			if (tileCache.type == 69)
			{
				num = 7;
			}
			if (tileCache.type == 655)
			{
				num = 166;
			}
			if (tileCache.type == 71 || tileCache.type == 72 || tileCache.type == 190 || tileCache.type == 578)
			{
				num = 26;
			}
			if (tileCache.type == 70)
			{
				num = 17;
			}
			if (tileCache.type == 112)
			{
				num = 14;
			}
			if (tileCache.type == 123)
			{
				num = 53;
			}
			if (tileCache.type == 161)
			{
				num = 80;
			}
			if (tileCache.type == 206)
			{
				num = 80;
			}
			if (tileCache.type == 162)
			{
				num = 80;
			}
			if (tileCache.type == 165)
			{
				num = (tileCache.frameX / 54) switch
				{
					0 => 80, 
					1 => 1, 
					2 => 30, 
					3 => 147, 
					4 => 1, 
					5 => 14, 
					6 => 117, 
					7 => 250, 
					8 => 240, 
					9 => 236, 
					_ => 1, 
				};
			}
			if (tileCache.type == 666)
			{
				num = 322;
			}
			if (tileCache.type == 193)
			{
				num = 4;
			}
			if (tileCache.type == 194)
			{
				num = 26;
			}
			if (tileCache.type == 195)
			{
				num = 5;
			}
			if (tileCache.type == 196)
			{
				num = 108;
			}
			if (tileCache.type == 460)
			{
				num = 108;
			}
			if (tileCache.type == 197)
			{
				num = 4;
			}
			if (tileCache.type == 153)
			{
				num = 26;
			}
			if (tileCache.type == 154)
			{
				num = 32;
			}
			if (tileCache.type == 155)
			{
				num = 2;
			}
			if (tileCache.type == 156)
			{
				num = 1;
			}
			if (tileCache.type == 116 || tileCache.type == 118 || tileCache.type == 147 || tileCache.type == 148)
			{
				num = 51;
			}
			if (tileCache.type == 109 || tileCache.type == 492)
			{
				num = ((genRand.Next(2) != 0) ? 47 : 0);
			}
			if (tileCache.type == 110 || tileCache.type == 113 || tileCache.type == 115)
			{
				num = 47;
			}
			if (tileCache.type == 107 || tileCache.type == 121 || tileCache.type == 685)
			{
				num = 48;
			}
			if (tileCache.type == 108 || tileCache.type == 122 || tileCache.type == 146 || tileCache.type == 686)
			{
				num = 49;
			}
			if (tileCache.type == 111 || tileCache.type == 145 || tileCache.type == 150)
			{
				num = 50;
			}
			if (tileCache.type == 133)
			{
				num = 50;
				if (tileCache.frameX >= 54)
				{
					num = 146;
				}
			}
			if (tileCache.type == 134)
			{
				num = 49;
				if (tileCache.frameX >= 36)
				{
					num = 145;
				}
			}
			if (tileCache.type == 149)
			{
				num = 49;
			}
			if (Main.tileAlch[tileCache.type])
			{
				int num16 = tileCache.frameX / 18;
				if (num16 == 0)
				{
					num = 3;
				}
				if (num16 == 1)
				{
					num = 3;
				}
				if (num16 == 2)
				{
					num = 7;
				}
				if (num16 == 3)
				{
					num = 17;
				}
				if (num16 == 4)
				{
					num = 289;
				}
				if (num16 == 5)
				{
					num = 6;
				}
				if (num16 == 6)
				{
					num = 224;
				}
			}
			if (tileCache.type == 58 || tileCache.type == 76 || tileCache.type == 77 || tileCache.type == 684)
			{
				num = ((genRand.Next(2) != 0) ? 25 : 6);
			}
			if (tileCache.type == 37)
			{
				num = ((genRand.Next(2) != 0) ? 23 : 6);
			}
			if (tileCache.type == 32)
			{
				num = ((genRand.Next(2) != 0) ? 24 : 14);
			}
			if (tileCache.type == 352)
			{
				num = ((genRand.Next(3) != 0) ? 125 : 5);
			}
			if (tileCache.type == 23 || tileCache.type == 24 || tileCache.type == 661)
			{
				num = ((genRand.Next(2) != 0) ? 17 : 14);
			}
			if (tileCache.type == 25 || tileCache.type == 31)
			{
				num = ((tileCache.type == 31 && tileCache.frameX >= 36) ? 5 : ((genRand.Next(2) != 0) ? 1 : 14));
			}
			if (tileCache.type == 20)
			{
				num = (tileCache.frameX / 54) switch
				{
					1 => 122, 
					2 => 78, 
					3 => 77, 
					4 => 121, 
					5 => 79, 
					_ => 7, 
				};
			}
			if (tileCache.type == 27)
			{
				num = ((genRand.Next(2) != 0) ? 19 : 3);
			}
			if (tileCache.type == 129)
			{
				if (tileCache.frameX >= 324)
				{
					num = 69;
				}
				num = ((tileCache.frameX != 0 && tileCache.frameX != 54 && tileCache.frameX != 108) ? ((tileCache.frameX != 18 && tileCache.frameX != 72 && tileCache.frameX != 126) ? 70 : 69) : 68);
			}
			if (tileCache.type == 385)
			{
				num = genRand.Next(68, 71);
			}
			if (tileCache.type == 4)
			{
				int num17 = (int)MathHelper.Clamp(tileCache.frameY / 22, 0f, 23f);
				num = TorchID.Dust[num17];
			}
			if (tileCache.type == 35)
			{
				num = 189;
				if (tileCache.frameX < 36 && genRand.Next(2) == 0)
				{
					num = 6;
				}
			}
			if ((tileCache.type == 34 || tileCache.type == 42) && genRand.Next(2) == 0)
			{
				num = 6;
			}
			if (tileCache.type == 270)
			{
				num = -1;
			}
			if (tileCache.type == 271)
			{
				num = -1;
			}
			if (tileCache.type == 581)
			{
				num = -1;
			}
			if (tileCache.type == 660)
			{
				num = -1;
			}
			if (tileCache.type == 79 || tileCache.type == 90 || tileCache.type == 101)
			{
				num = -1;
			}
			if (tileCache.type == 33 || tileCache.type == 34 || tileCache.type == 42 || tileCache.type == 93 || tileCache.type == 100)
			{
				num = -1;
			}
			if (tileCache.type == 321 || tileCache.type == 574)
			{
				num = 214;
			}
			if (tileCache.type == 322)
			{
				num = 215;
			}
			if (tileCache.type == 635)
			{
				num = 36;
			}
			bool flag = tileCache.type == 178 || tileCache.type == 440;
			ushort type = tileCache.type;
			if (type == 178 || (uint)(type - 426) <= 1u || (uint)(type - 430) <= 10u)
			{
				flag = true;
			}
			if (num >= 0)
			{
				if (tileCache.type == 627 || tileCache.type == 628 || (tileCache.type == 184 && tileCache.frameX / 22 == 10))
				{
					int num18 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB));
					Main.dust[num18].noGravity = true;
					Main.dust[num18].noLightEmittence = true;
					return num18;
				}
				if (tileCache.type == 518)
				{
					int num19 = (int)tileCache.liquid / 16;
					num19 -= 3;
					if (SolidTile(i, j - 1) && num19 > 8)
					{
						num19 = 8;
					}
					return Dust.NewDust(new Vector2(i * 16, j * 16 - num19), 16, 16, num);
				}
				if (tileCache.type == 352 && num == 5)
				{
					int num20 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 5, 0f, 0f, 100);
					Main.dust[num20].scale = 1.5f;
					Main.dust[num20].noGravity = true;
					Main.dust[num20].velocity *= 1.65f;
					Main.dust[num20].fadeIn = 1.6f;
					return num20;
				}
				if (tileCache.type == 160 || tileCache.type == 692)
				{
					int num21 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 66, 0f, 0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
					Main.dust[num21].noGravity = true;
					return num21;
				}
				if (tileCache.type == 323)
				{
					int frameY = tileCache.frameY;
					return Dust.NewDust(new Vector2(i * 16 + frameY, j * 16), 16, 16, num);
				}
				if (tileCache.type == 314)
				{
					int num22 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, 213, genRand.Next(-2, 3), genRand.Next(-2, 3));
					Main.dust[num22].noGravity = true;
					Main.dust[num22].fadeIn = Main.dust[num22].scale + 1f + 0.01f * (float)genRand.Next(0, 51);
					Main.dust[num22].noGravity = true;
					return num22;
				}
				if (flag)
				{
					int num23 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
					Main.dust[num23].noLight = true;
					return num23;
				}
				if (tileCache.type == 193 || (tileCache.type == 18 && num == 4) || (tileCache.type == 19 && num == 4))
				{
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(0, 80, 255, 100), 0.75f);
				}
				if (tileCache.type == 197)
				{
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, new Color(97, 200, 255, 100), 0.75f);
				}
				if (tileCache.type == 185 && num >= 86 && num <= 91)
				{
					int num24 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 75, default(Color), 0.75f);
					Main.dust[num24].noLight = true;
					return num24;
				}
				if (tileCache.type == 4 && num == 66)
				{
					int num25 = Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num, 0f, 0f, 0, new Color((float)Main.DiscoR / 255f, (float)Main.DiscoG / 255f, (float)Main.DiscoB / 255f));
					Main.dust[num25].noGravity = true;
					return num25;
				}
				if (num == 139)
				{
					int type2 = num + Main.rand.Next(4);
					return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, type2);
				}
				return Dust.NewDust(new Vector2(i * 16, j * 16), 16, 16, num);
			}
			return 6000;
		}

		public static bool IsOpenDoorAnchorFrame(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (!tile.active() || tile.type != 11)
			{
				return false;
			}
			int num = tile.frameX % 72;
			if (num >= 18)
			{
				return num >= 54;
			}
			return true;
		}

		public static bool IsLockedDoor(int x, int y)
		{
			return IsLockedDoor(Main.tile[x, y]);
		}

		public static bool IsLockedDoor(Tile t)
		{
			if (t.type == 10 && t.frameY >= 594 && t.frameY <= 646)
			{
				return t.frameX < 54;
			}
			return false;
		}

		public static void DropDoorItem(int x, int y, int doorStyle)
		{
			int num = 0;
			switch (doorStyle)
			{
			case 0:
				num = 25;
				break;
			case 9:
				num = 837;
				break;
			case 10:
				num = 912;
				break;
			case 12:
				num = 1137;
				break;
			case 13:
				num = 1138;
				break;
			case 14:
				num = 1139;
				break;
			case 15:
				num = 1140;
				break;
			case 16:
				num = 1411;
				break;
			case 17:
				num = 1412;
				break;
			case 18:
				num = 1413;
				break;
			case 19:
				num = 1458;
				break;
			case 20:
			case 21:
			case 22:
			case 23:
				num = 1709 + doorStyle - 20;
				break;
			default:
				switch (doorStyle)
				{
				case 24:
					num = 1793;
					break;
				case 25:
					num = 1815;
					break;
				case 26:
					num = 1924;
					break;
				case 27:
					num = 2044;
					break;
				case 28:
					num = 2265;
					break;
				case 29:
					num = 2528;
					break;
				case 30:
					num = 2561;
					break;
				case 31:
					num = 2576;
					break;
				case 32:
					num = 2815;
					break;
				case 33:
					num = 3129;
					break;
				case 34:
					num = 3131;
					break;
				case 35:
					num = 3130;
					break;
				case 36:
					num = 3888;
					break;
				case 37:
					num = 3941;
					break;
				case 38:
					num = 3967;
					break;
				case 39:
					num = 4155;
					break;
				case 40:
					num = 4176;
					break;
				case 41:
					num = 4197;
					break;
				case 42:
					num = 4218;
					break;
				case 43:
					num = 4307;
					break;
				case 44:
					num = 4415;
					break;
				case 45:
					num = 4576;
					break;
				case 46:
					num = 5158;
					break;
				case 47:
					num = 5179;
					break;
				case 48:
					num = 5200;
					break;
				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
					num = 812 + doorStyle;
					break;
				default:
					if (doorStyle != 11)
					{
						num = 649 + doorStyle;
					}
					break;
				}
				break;
			}
			if (num != 0)
			{
				Item.NewItem(GetItemSource_FromTileBreak(x, y), x * 16, y * 16, 16, 16, num);
			}
		}

		public static IEntitySource GetItemSource_FromTileBreak(int x, int y)
		{
			return new EntitySource_TileBreak(x, y);
		}

		public static IEntitySource GetItemSource_FromWallBreak(int x, int y)
		{
			return new EntitySource_TileBreak(x, y);
		}

		public static IEntitySource GetItemSource_FromTreeShake(int x, int y)
		{
			return new EntitySource_ShakeTree(x, y);
		}

		public static bool PlayerLOS(int x, int y)
		{
			Rectangle rectangle = new Rectangle(x * 16, y * 16, 16, 16);
			for (int i = 0; i < 255; i++)
			{
				if (Main.player[i].active)
				{
					Rectangle value = new Rectangle((int)((double)Main.player[i].position.X + (double)Main.player[i].width * 0.5 - (double)NPC.sWidth * 0.6), (int)((double)Main.player[i].position.Y + (double)Main.player[i].height * 0.5 - (double)NPC.sHeight * 0.6), (int)((double)NPC.sWidth * 1.2), (int)((double)NPC.sHeight * 1.2));
					if (rectangle.Intersects(value))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static void ChlorophyteDefense(int x, int y)
		{
			if (!Main.remixWorld)
			{
				return;
			}
			if (Main.tile[x, y].type == 23 || Main.tile[x, y].type == 199 || Main.tile[x, y].type == 661 || Main.tile[x, y].type == 662)
			{
				Main.tile[x, y].type = 60;
				SquareTileFrame(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			else if (Main.tile[x, y].type == 25 || Main.tile[x, y].type == 203)
			{
				Main.tile[x, y].type = 1;
				SquareTileFrame(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			else if (Main.tile[x, y].type == 112 || Main.tile[x, y].type == 234)
			{
				Main.tile[x, y].type = 53;
				SquareTileFrame(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			else if (Main.tile[x, y].type == 398 || Main.tile[x, y].type == 399)
			{
				Main.tile[x, y].type = 397;
				SquareTileFrame(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			else if (Main.tile[x, y].type == 400 || Main.tile[x, y].type == 401)
			{
				Main.tile[x, y].type = 396;
				SquareTileFrame(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
			else if (Main.tile[x, y].type == 24 || Main.tile[x, y].type == 201 || Main.tile[x, y].type == 32 || Main.tile[x, y].type == 352 || Main.tile[x, y].type == 636 || Main.tile[x, y].type == 205)
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, x, y);
				}
			}
		}

		public static bool Chlorophyte(int i, int j)
		{
			int num = 40;
			int num2 = 130;
			int num3 = 35;
			int num4 = 85;
			if (Main.remixWorld)
			{
				num += 5;
				num2 *= 15;
				num3 -= 4;
				num4 -= 8;
			}
			else if ((double)j < Main.rockLayer)
			{
				num /= 2;
				num2 /= 2;
				num3 = (int)((double)num3 * 1.5);
				num4 = (int)((double)num4 * 1.5);
			}
			int num5 = 0;
			for (int k = i - num3; k < i + num3; k++)
			{
				for (int l = j - num3; l < j + num3; l++)
				{
					if (InWorld(k, l) && Main.tile[k, l].active() && Main.tile[k, l].type == 211)
					{
						num5++;
					}
				}
			}
			if (num5 > num)
			{
				return false;
			}
			num5 = 0;
			for (int m = i - num4; m < i + num4; m++)
			{
				for (int n = j - num4; n < j + num4; n++)
				{
					if (InWorld(m, n) && Main.tile[m, n].active() && Main.tile[m, n].type == 211)
					{
						num5++;
					}
				}
			}
			if (num5 > num2)
			{
				return false;
			}
			return true;
		}

		private static bool nearbyChlorophyte(int i, int j)
		{
			double num = 0.0;
			int num2 = 5;
			if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5)
			{
				return false;
			}
			if (j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5)
			{
				return false;
			}
			for (int k = i - num2; k <= i + num2; k++)
			{
				for (int l = j - num2; l <= j + num2; l++)
				{
					if (Main.tile[k, l].active() && (Main.tile[k, l].type == 211 || Main.tile[k, l].type == 346))
					{
						num += 1.0;
						if (num >= 3.0)
						{
							return true;
						}
					}
				}
			}
			if (num > 0.0)
			{
				if (Main.remixWorld)
				{
					if ((double)genRand.Next(-1, 3) < num)
					{
						return true;
					}
				}
				else if ((double)genRand.Next(-1, 4) < num)
				{
					return true;
				}
			}
			return false;
		}

		public static int CountNearBlocksTypes(int i, int j, int radius, int cap = 0, params int[] tiletypes)
		{
			if (tiletypes.Length == 0)
			{
				return 0;
			}
			int value = i - radius;
			int value2 = i + radius;
			int value3 = j - radius;
			int value4 = j + radius;
			int num = Utils.Clamp(value, 0, Main.maxTilesX - 1);
			value2 = Utils.Clamp(value2, 0, Main.maxTilesX - 1);
			value3 = Utils.Clamp(value3, 0, Main.maxTilesY - 1);
			value4 = Utils.Clamp(value4, 0, Main.maxTilesY - 1);
			int num2 = 0;
			for (int k = num; k <= value2; k++)
			{
				for (int l = value3; l <= value4; l++)
				{
					if (!Main.tile[k, l].active())
					{
						continue;
					}
					for (int m = 0; m < tiletypes.Length; m++)
					{
						if (tiletypes[m] == Main.tile[k, l].type)
						{
							num2++;
							if (cap <= 0 || num2 < cap)
							{
								break;
							}
							return num2;
						}
					}
				}
			}
			return num2;
		}

		public static void hardUpdateWorld(int i, int j)
		{
			if (!Main.hardMode || Main.tile[i, j].inActive())
			{
				return;
			}
			int type = Main.tile[i, j].type;
			if (type > 0 && type < 693 && TileID.Sets.CanGrowCrystalShards[type] && ((double)j > Main.rockLayer || Main.remixWorld) && genRand.Next(5) == 0)
			{
				int num = genRand.Next(4);
				int num2 = 0;
				int num3 = 0;
				switch (num)
				{
				case 0:
					num2 = -1;
					break;
				case 1:
					num2 = 1;
					break;
				default:
					num3 = ((num != 0) ? 1 : (-1));
					break;
				}
				if (!Main.tile[i + num2, j + num3].active())
				{
					int num4 = 0;
					int num5 = 6;
					for (int k = i - num5; k <= i + num5; k++)
					{
						for (int l = j - num5; l <= j + num5; l++)
						{
							if (Main.tile[k, l].active() && Main.tile[k, l].type == 129)
							{
								num4++;
							}
						}
					}
					if (num4 < 2)
					{
						int style = (short)genRand.Next(18);
						if (genRand.Next(50) == 0)
						{
							style = (short)(18 + genRand.Next(6));
						}
						PlaceTile(i + num2, j + num3, 129, mute: true, forced: false, -1, style);
						NetMessage.SendTileSquare(-1, i + num2, j + num3);
					}
				}
			}
			if ((double)j > (Main.worldSurface + Main.rockLayer) / 2.0 || Main.remixWorld)
			{
				if (type == 60 && genRand.Next(300) == 0)
				{
					int num6 = i + genRand.Next(-10, 11);
					int num7 = j + genRand.Next(-10, 11);
					if (InWorld(num6, num7, 2) && Main.tile[num6, num7].active() && Main.tile[num6, num7].type == 59 && (!Main.tile[num6, num7 - 1].active() || (Main.tile[num6, num7 - 1].type != 5 && Main.tile[num6, num7 - 1].type != 236 && Main.tile[num6, num7 - 1].type != 238)) && Chlorophyte(num6, num7))
					{
						Main.tile[num6, num7].type = 211;
						SquareTileFrame(num6, num7);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num6, num7);
						}
					}
				}
				if (type == 211 || type == 346)
				{
					int num8 = i;
					int num9 = j;
					if (genRand.Next(3) != 0)
					{
						int num10 = genRand.Next(4);
						if (num10 == 0)
						{
							num8++;
						}
						if (num10 == 1)
						{
							num8--;
						}
						if (num10 == 2)
						{
							num9++;
						}
						if (num10 == 3)
						{
							num9--;
						}
						if (InWorld(num8, num9, 2) && Main.tile[num8, num9].active() && (Main.tile[num8, num9].type == 59 || Main.tile[num8, num9].type == 60) && Chlorophyte(num8, num9))
						{
							Main.tile[num8, num9].type = 211;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
						}
					}
					bool flag = true;
					while (flag)
					{
						flag = false;
						num8 = i + Main.rand.Next(-6, 7);
						num9 = j + Main.rand.Next(-6, 7);
						if (!InWorld(num8, num9, 2) || !Main.tile[num8, num9].active())
						{
							continue;
						}
						if (Main.tile[num8, num9].type == 661 || Main.tile[num8, num9].type == 662 || Main.tile[num8, num9].type == 23 || Main.tile[num8, num9].type == 199 || Main.tile[num8, num9].type == 2 || Main.tile[num8, num9].type == 477 || Main.tile[num8, num9].type == 492 || Main.tile[num8, num9].type == 109)
						{
							Main.tile[num8, num9].type = 60;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 0)
						{
							Main.tile[num8, num9].type = 59;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 25 || Main.tile[num8, num9].type == 203)
						{
							Main.tile[num8, num9].type = 1;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 112 || Main.tile[num8, num9].type == 234)
						{
							Main.tile[num8, num9].type = 53;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 398 || Main.tile[num8, num9].type == 399)
						{
							Main.tile[num8, num9].type = 397;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 400 || Main.tile[num8, num9].type == 401)
						{
							Main.tile[num8, num9].type = 396;
							SquareTileFrame(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
						else if (Main.tile[num8, num9].type == 24 || Main.tile[num8, num9].type == 201 || Main.tile[num8, num9].type == 32 || Main.tile[num8, num9].type == 352 || Main.tile[num8, num9].type == 636 || Main.tile[num8, num9].type == 205)
						{
							KillTile(num8, num9);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num8, num9);
							}
							flag = true;
						}
					}
				}
			}
			if ((NPC.downedPlantBoss && genRand.Next(2) != 0) || !AllowedToSpreadInfections)
			{
				return;
			}
			if (type == 23 || type == 25 || type == 32 || type == 112 || type == 163 || type == 400 || type == 398 || type == 636 || type == 661)
			{
				bool flag2 = true;
				while (flag2)
				{
					flag2 = false;
					int num11 = i + genRand.Next(-3, 4);
					int num12 = j + genRand.Next(-3, 4);
					if (nearbyChlorophyte(num11, num12))
					{
						ChlorophyteDefense(num11, num12);
					}
					else
					{
						if (CountNearBlocksTypes(num11, num12, 2, 1, 27) > 0)
						{
							continue;
						}
						if (Main.tile[num11, num12].type == 2)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 23;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 1 || Main.tileMoss[Main.tile[num11, num12].type])
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 25;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 53)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 112;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 396)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 400;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 397)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 398;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 60)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 661;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 69)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 32;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
						else if (Main.tile[num11, num12].type == 161)
						{
							if (genRand.Next(2) == 0)
							{
								flag2 = true;
							}
							Main.tile[num11, num12].type = 163;
							SquareTileFrame(num11, num12);
							NetMessage.SendTileSquare(-1, num11, num12);
						}
					}
				}
			}
			if (type == 199 || type == 200 || type == 201 || type == 203 || type == 205 || type == 234 || type == 352 || type == 401 || type == 399 || type == 662)
			{
				bool flag3 = true;
				while (flag3)
				{
					flag3 = false;
					int num13 = i + genRand.Next(-3, 4);
					int num14 = j + genRand.Next(-3, 4);
					if (nearbyChlorophyte(num13, num14))
					{
						ChlorophyteDefense(num13, num14);
					}
					else
					{
						if (CountNearBlocksTypes(num13, num14, 2, 1, 27) > 0)
						{
							continue;
						}
						if (Main.tile[num13, num14].type == 2)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 199;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 1 || Main.tileMoss[Main.tile[num13, num14].type])
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 203;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 53)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 234;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 396)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 401;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 397)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 399;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 60)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 662;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 69)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 352;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
						else if (Main.tile[num13, num14].type == 161)
						{
							if (genRand.Next(2) == 0)
							{
								flag3 = true;
							}
							Main.tile[num13, num14].type = 200;
							SquareTileFrame(num13, num14);
							NetMessage.SendTileSquare(-1, num13, num14);
						}
					}
				}
			}
			if (type != 109 && type != 110 && type != 113 && type != 115 && type != 116 && type != 117 && type != 164 && type != 402 && type != 403 && type != 492)
			{
				return;
			}
			bool flag4 = true;
			while (flag4)
			{
				flag4 = false;
				int num15 = i + genRand.Next(-3, 4);
				int num16 = j + genRand.Next(-3, 4);
				if (CountNearBlocksTypes(num15, num16, 2, 1, 27) > 0)
				{
					continue;
				}
				if (Main.tile[num15, num16].type == 2)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 109;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
				else if (Main.tile[num15, num16].type == 477)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 492;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
				else if (Main.tile[num15, num16].type == 1 || Main.tileMoss[Main.tile[num15, num16].type])
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 117;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
				else if (Main.tile[num15, num16].type == 53)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 116;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
				else if (Main.tile[num15, num16].type == 396)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 403;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
				else if (Main.tile[num15, num16].type == 397)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 402;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
				else if (Main.tile[num15, num16].type == 161)
				{
					if (genRand.Next(2) == 0)
					{
						flag4 = true;
					}
					Main.tile[num15, num16].type = 164;
					SquareTileFrame(num15, num16);
					NetMessage.SendTileSquare(-1, num15, num16);
				}
			}
		}

		public static bool SolidTile(Tile testTile)
		{
			try
			{
				if (testTile == null)
				{
					return true;
				}
				if (testTile.active() && Main.tileSolid[testTile.type] && !Main.tileSolidTop[testTile.type] && !testTile.halfBrick() && testTile.slope() == 0 && !testTile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool TileEmpty(int i, int j)
		{
			if (Main.tile[i, j] != null && Main.tile[i, j].active())
			{
				return Main.tile[i, j].inActive();
			}
			return true;
		}

		public static bool SolidOrSlopedTile(Tile tile)
		{
			if (tile != null && tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
			{
				return !tile.inActive();
			}
			return false;
		}

		public static int TileType(int x, int y)
		{
			if (!Main.tile[x, y].active())
			{
				return -1;
			}
			return Main.tile[x, y].type;
		}

		public static bool SolidOrSlopedTile(int x, int y)
		{
			return SolidOrSlopedTile(Main.tile[x, y]);
		}

		public static bool IsRope(int x, int y)
		{
			if (Main.tile[x, y] == null || !Main.tile[x, y].active())
			{
				return false;
			}
			if (Main.tileRope[Main.tile[x, y].type])
			{
				return true;
			}
			if ((Main.tile[x, y].type == 314 || TileID.Sets.Platforms[Main.tile[x, y].type]) && Main.tile[x, y - 1] != null && Main.tile[x, y + 1] != null && Main.tile[x, y - 1].active() && Main.tile[x, y + 1].active() && Main.tileRope[Main.tile[x, y - 1].type] && Main.tileRope[Main.tile[x, y + 1].type])
			{
				return true;
			}
			return false;
		}

		public static bool SolidTile(Point p)
		{
			return SolidTile(p.X, p.Y);
		}

		public static bool SolidTile(int i, int j, bool noDoors = false)
		{
			try
			{
				if (Main.tile[i, j] == null)
				{
					return true;
				}
				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileSolidTop[Main.tile[i, j].type] && !Main.tile[i, j].halfBrick() && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].inActive())
				{
					if (noDoors && Main.tile[i, j].type == 10)
					{
						return false;
					}
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTile2(Tile testTile)
		{
			try
			{
				if (testTile == null)
				{
					return true;
				}
				if (testTile.active() && Main.tileSolid[testTile.type] && testTile.slope() == 0 && !testTile.halfBrick() && !testTile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool PlatformProperTopFrame(short frameX)
		{
			int num = frameX / TileObjectData.PlatformFrameWidth();
			if ((num < 0 || num > 7) && (num < 12 || num > 16))
			{
				if (num >= 25)
				{
					return num <= 26;
				}
				return false;
			}
			return true;
		}

		public static bool SolidTileAllowBottomSlope(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool ActiveAndWalkableTile(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTileAllowTopSlope(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && (Main.tileSolid[tile.type] || tile.type == 380) && (!tile.bottomSlope() || (TileID.Sets.Platforms[tile.type] && tile.halfBrick())) && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTileAllowLeftSlope(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !tile.rightSlope() && !TileID.Sets.Platforms[tile.type] && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTileAllowRightSlope(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !tile.leftSlope() && !TileID.Sets.Platforms[tile.type] && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool TopEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && (Main.tileSolid[tile.type] || Main.tileSolidTop[tile.type]) && (!tile.topSlope() || (TileID.Sets.Platforms[tile.type] && PlatformProperTopFrame(tile.frameX))) && !tile.halfBrick() && !tile.inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool RightEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.rightSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool LeftEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.leftSlope() && !tile.halfBrick() && !tile.inActive() && !Main.tileNoAttach[tile.type])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool BottomEdgeCanBeAttachedTo(int i, int j)
		{
			try
			{
				Tile tile = Main.tile[i, j];
				if (tile == null)
				{
					return true;
				}
				if (tile.active() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type] && !tile.bottomSlope() && !tile.inActive() && !Main.tileNoAttach[tile.type])
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTile3(int i, int j)
		{
			if (!InWorld(i, j, 1))
			{
				return false;
			}
			return SolidTile3(Main.tile[i, j]);
		}

		public static bool SolidTile3(Tile t)
		{
			if (t == null)
			{
				return false;
			}
			if (t.active() && !t.inActive() && Main.tileSolid[t.type])
			{
				return !Main.tileSolidTop[t.type];
			}
			return false;
		}

		public static bool SolidTile2(int i, int j)
		{
			try
			{
				if (Main.tile[i, j] == null)
				{
					return true;
				}
				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && ((TileID.Sets.Platforms[Main.tile[i, j].type] && (Main.tile[i, j].halfBrick() || Main.tile[i, j].topSlope())) || Main.tile[i, j].slope() == 0) && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static bool SolidTileNoAttach(int i, int j)
		{
			try
			{
				if (Main.tile[i, j] == null)
				{
					return true;
				}
				if (Main.tile[i, j].active() && Main.tileSolid[Main.tile[i, j].type] && !Main.tileNoAttach[Main.tile[i, j].type] && Main.tile[i, j].slope() == 0 && !Main.tile[i, j].halfBrick() && !Main.tile[i, j].inActive())
				{
					return true;
				}
			}
			catch
			{
			}
			return false;
		}

		public static void MineHouse(int i, int j)
		{
			if (i < 50 || i > Main.maxTilesX - 50 || j < 50 || j > Main.maxTilesY - 50)
			{
				return;
			}
			int num = genRand.Next(6, 12);
			int num2 = genRand.Next(3, 6);
			int num3 = genRand.Next(15, 30);
			int num4 = genRand.Next(15, 30);
			if (SolidTile(i, j) || Main.tile[i, j].wall > 0)
			{
				return;
			}
			int num5 = j - num;
			int num6 = j + num2;
			for (int k = 0; k < 2; k++)
			{
				bool flag = true;
				int num7 = i;
				int num8 = j;
				int num9 = -1;
				int num10 = num3;
				if (k == 1)
				{
					num9 = 1;
					num10 = num4;
					num7++;
				}
				while (flag)
				{
					if (num8 - num < num5)
					{
						num5 = num8 - num;
					}
					if (num8 + num2 > num6)
					{
						num6 = num8 + num2;
					}
					for (int l = 0; l < 2; l++)
					{
						int num11 = num8;
						bool flag2 = true;
						int num12 = num;
						int num13 = -1;
						if (l == 1)
						{
							num11++;
							num12 = num2;
							num13 = 1;
						}
						while (flag2)
						{
							if (num7 != i && Main.tile[num7 - num9, num11].wall != 27 && (SolidTile(num7 - num9, num11) || !Main.tile[num7 - num9, num11].active() || Main.tile[num7 - num9, num11].halfBrick() || Main.tile[num7 - num9, num11].slope() != 0))
							{
								Main.tile[num7 - num9, num11].active(active: true);
								Main.tile[num7 - num9, num11].type = 30;
							}
							if (SolidTile(num7 - 1, num11) || Main.tile[num7 - 1, num11].halfBrick() || Main.tile[num7 - 1, num11].slope() != 0)
							{
								Main.tile[num7 - 1, num11].type = 30;
							}
							if (SolidTile(num7 + 1, num11) || Main.tile[num7 + 1, num11].halfBrick() || Main.tile[num7 + 1, num11].slope() != 0)
							{
								Main.tile[num7 + 1, num11].type = 30;
							}
							if (SolidTile(num7, num11) || Main.tile[num7, num11].halfBrick() || Main.tile[num7, num11].slope() != 0)
							{
								int num14 = 0;
								if (SolidTile(num7 - 1, num11))
								{
									num14++;
								}
								if (SolidTile(num7 + 1, num11))
								{
									num14++;
								}
								if (SolidTile(num7, num11 - 1))
								{
									num14++;
								}
								if (SolidTile(num7, num11 + 1))
								{
									num14++;
								}
								if (num14 < 2)
								{
									Main.tile[num7, num11].active(active: false);
								}
								else
								{
									flag2 = false;
									Main.tile[num7, num11].type = 30;
								}
							}
							else
							{
								Main.tile[num7, num11].wall = 27;
								Main.tile[num7, num11].liquid = 0;
								Main.tile[num7, num11].lava(lava: false);
							}
							num11 += num13;
							num12--;
							if (num12 <= 0)
							{
								if (!Main.tile[num7, num11].active())
								{
									Main.tile[num7, num11].active(active: true);
									Main.tile[num7, num11].type = 30;
								}
								flag2 = false;
							}
						}
					}
					num10--;
					num7 += num9;
					if (SolidTile(num7, num8))
					{
						int num15 = 0;
						int num16 = 0;
						int num17 = num8;
						bool flag3 = true;
						while (flag3)
						{
							num17--;
							num15++;
							if (SolidTile(num7 - num9, num17))
							{
								num15 = 999;
								flag3 = false;
							}
							else if (!SolidTile(num7, num17))
							{
								flag3 = false;
							}
						}
						num17 = num8;
						flag3 = true;
						while (flag3)
						{
							num17++;
							num16++;
							if (SolidTile(num7 - num9, num17))
							{
								num16 = 999;
								flag3 = false;
							}
							else if (!SolidTile(num7, num17))
							{
								flag3 = false;
							}
						}
						if (num16 <= num15)
						{
							if (num16 > num2)
							{
								num10 = 0;
							}
							else
							{
								num8 += num16 + 1;
							}
						}
						else if (num15 > num)
						{
							num10 = 0;
						}
						else
						{
							num8 -= num15 + 1;
						}
					}
					if (num10 <= 0)
					{
						flag = false;
					}
				}
			}
			int num18 = i - num3 - 1;
			int num19 = i + num4 + 2;
			int num20 = num5 - 1;
			int num21 = num6 + 2;
			for (int m = num18; m < num19; m++)
			{
				for (int n = num20; n < num21; n++)
				{
					if (Main.tile[m, n].wall == 27 && !Main.tile[m, n].active())
					{
						if (Main.tile[m - 1, n].wall != 27 && m < i && !SolidTile(m - 1, n))
						{
							PlaceTile(m, n, 30, mute: true);
							Main.tile[m, n].wall = 0;
						}
						if (Main.tile[m + 1, n].wall != 27 && m > i && !SolidTile(m + 1, n))
						{
							PlaceTile(m, n, 30, mute: true);
							Main.tile[m, n].wall = 0;
						}
						for (int num22 = m - 1; num22 <= m + 1; num22++)
						{
							for (int num23 = n - 1; num23 <= n + 1; num23++)
							{
								if (SolidTile(num22, num23))
								{
									Main.tile[num22, num23].type = 30;
								}
							}
						}
					}
					if (Main.tile[m, n].type == 30 && Main.tile[m - 1, n].wall == 27 && Main.tile[m + 1, n].wall == 27 && (Main.tile[m, n - 1].wall == 27 || Main.tile[m, n - 1].active()) && (Main.tile[m, n + 1].wall == 27 || Main.tile[m, n + 1].active()))
					{
						Main.tile[m, n].active(active: false);
						Main.tile[m, n].wall = 27;
					}
				}
			}
			for (int num24 = num18; num24 < num19; num24++)
			{
				for (int num25 = num20; num25 < num21; num25++)
				{
					if (Main.tile[num24, num25].type == 30)
					{
						if (Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 1, num25].active())
						{
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
						}
						if (!TileID.Sets.BasicChest[Main.tile[num24, num25 - 1].type] && Main.tile[num24 - 1, num25].wall == 27 && Main.tile[num24 + 1, num25].type == 30 && Main.tile[num24 + 2, num25].wall == 27 && !Main.tile[num24 - 1, num25].active() && !Main.tile[num24 + 2, num25].active())
						{
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
							Main.tile[num24 + 1, num25].active(active: false);
							Main.tile[num24 + 1, num25].wall = 27;
						}
						if (Main.tile[num24, num25 - 1].wall == 27 && Main.tile[num24, num25 + 1].wall == 27 && !Main.tile[num24, num25 - 1].active() && !Main.tile[num24, num25 + 1].active())
						{
							Main.tile[num24, num25].active(active: false);
							Main.tile[num24, num25].wall = 27;
						}
					}
				}
			}
			for (int num26 = num18; num26 < num19; num26++)
			{
				for (int num27 = num21; num27 > num20; num27--)
				{
					bool flag4 = false;
					if (Main.tile[num26, num27].active() && Main.tile[num26, num27].type == 30)
					{
						int num28 = -1;
						for (int num29 = 0; num29 < 2; num29++)
						{
							if (!SolidTile(num26 + num28, num27) && Main.tile[num26 + num28, num27].wall == 0)
							{
								int num30 = 0;
								int num31 = num27;
								int num32 = num27;
								while (Main.tile[num26, num31].active() && Main.tile[num26, num31].type == 30 && !SolidTile(num26 + num28, num31) && Main.tile[num26 + num28, num31].wall == 0)
								{
									num31--;
									num30++;
								}
								num31++;
								int num33 = num31 + 1;
								if (num30 > 4)
								{
									if (genRand.Next(2) == 0)
									{
										num31 = num32 - 1;
										bool flag5 = true;
										for (int num34 = num26 - 2; num34 <= num26 + 2; num34++)
										{
											for (int num35 = num31 - 2; num35 <= num31; num35++)
											{
												if (num34 != num26 && Main.tile[num34, num35].active())
												{
													flag5 = false;
												}
											}
										}
										if (flag5)
										{
											Main.tile[num26, num31].active(active: false);
											Main.tile[num26, num31 - 1].active(active: false);
											Main.tile[num26, num31 - 2].active(active: false);
											PlaceTile(num26, num31, 10, mute: true);
											flag4 = true;
										}
									}
									if (!flag4)
									{
										for (int num36 = num33; num36 < num32; num36++)
										{
											Main.tile[num26, num36].type = 124;
										}
									}
								}
							}
							num28 = 1;
						}
					}
					if (flag4)
					{
						break;
					}
				}
			}
			int num37 = genRand.Next(1, 2);
			if (genRand.Next(4) == 0)
			{
				num37 = 0;
			}
			if (genRand.Next(6) == 0)
			{
				num37++;
			}
			if (genRand.Next(10) == 0)
			{
				num37++;
			}
			for (int num38 = 0; num38 < num37; num38++)
			{
				int num39 = 0;
				int num40 = genRand.Next(num18, num19);
				int num41 = genRand.Next(num20, num21);
				while (!Main.wallHouse[Main.tile[num40, num41].wall] || Main.tile[num40, num41].active())
				{
					num39++;
					if (num39 > 1000)
					{
						break;
					}
					num40 = genRand.Next(num18, num19);
					num41 = genRand.Next(num20, num21);
				}
				if (num39 > 1000)
				{
					break;
				}
				int num42 = num40;
				int num43 = num40;
				int num44 = num41;
				int num45 = num41;
				int num46 = 0;
				for (int num47 = 0; num47 < 2; num47++)
				{
					num42 = num40;
					num43 = num40;
					while (!Main.tile[num42, num41].active() && Main.wallHouse[Main.tile[num42, num41].wall])
					{
						num42--;
					}
					num42++;
					for (; !Main.tile[num43, num41].active() && Main.wallHouse[Main.tile[num43, num41].wall]; num43++)
					{
					}
					num43--;
					i = (num42 + num43) / 2;
					num44 = num41;
					num45 = num41;
					while (!Main.tile[num40, num44].active() && Main.wallHouse[Main.tile[num40, num44].wall])
					{
						num44--;
					}
					num44++;
					for (; !Main.tile[num40, num45].active() && Main.wallHouse[Main.tile[num40, num45].wall]; num45++)
					{
					}
					num45--;
					num41 = (num44 + num45) / 2;
				}
				num42 = num40;
				num43 = num40;
				while (!Main.tile[num42, num41].active() && !Main.tile[num42, num41 - 1].active() && !Main.tile[num42, num41 + 1].active())
				{
					num42--;
				}
				num42++;
				for (; !Main.tile[num43, num41].active() && !Main.tile[num43, num41 - 1].active() && !Main.tile[num43, num41 + 1].active(); num43++)
				{
				}
				num43--;
				num44 = num41;
				num45 = num41;
				while (!Main.tile[num40, num44].active() && !Main.tile[num40 - 1, num44].active() && !Main.tile[num40 + 1, num44].active())
				{
					num44--;
				}
				num44++;
				for (; !Main.tile[num40, num45].active() && !Main.tile[num40 - 1, num45].active() && !Main.tile[num40 + 1, num45].active(); num45++)
				{
				}
				num45--;
				num40 = (num42 + num43) / 2;
				num41 = (num44 + num45) / 2;
				int num48 = num43 - num42;
				num46 = num45 - num44;
				if (num48 <= 7 || num46 <= 5)
				{
					continue;
				}
				int num49 = 0;
				if (nearPicture2(i, num41))
				{
					num49 = -1;
				}
				if (num49 == 0)
				{
					PaintingEntry paintingEntry = RandHousePicture();
					if (!nearPicture(num40, num41))
					{
						PlaceTile(num40, num41, paintingEntry.tileType, mute: true, forced: false, -1, paintingEntry.style);
					}
				}
			}
			int num50;
			for (num50 = num18; num50 < num19; num50++)
			{
				bool flag6 = true;
				for (int num51 = num20; num51 < num21; num51++)
				{
					for (int num52 = num50 - 3; num52 <= num50 + 3; num52++)
					{
						if (Main.tile[num52, num51].active() && (!SolidTile(num52, num51) || Main.tile[num52, num51].type == 10))
						{
							flag6 = false;
						}
					}
				}
				if (flag6)
				{
					for (int num53 = num20; num53 < num21; num53++)
					{
						if (Main.tile[num50, num53].wall == 27 && !Main.tile[num50, num53].active())
						{
							PlaceTile(num50, num53, 124, mute: true);
						}
					}
				}
				num50 += genRand.Next(4);
			}
			for (int num54 = 0; num54 < 4; num54++)
			{
				int num55 = genRand.Next(num18 + 2, num19 - 1);
				int num56 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num55, num56].wall != 27)
				{
					num55 = genRand.Next(num18 + 2, num19 - 1);
					num56 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num55, num56].active())
				{
					num56--;
				}
				for (; !Main.tile[num55, num56].active(); num56++)
				{
				}
				num56--;
				if (Main.tile[num55, num56].wall != 27)
				{
					continue;
				}
				if (genRand.Next(3) == 0)
				{
					int num57 = genRand.Next(9);
					if (num57 == 0)
					{
						num57 = 14;
					}
					if (num57 == 1)
					{
						num57 = 16;
					}
					if (num57 == 2)
					{
						num57 = 18;
					}
					if (num57 == 3)
					{
						num57 = 86;
					}
					if (num57 == 4)
					{
						num57 = 87;
					}
					if (num57 == 5)
					{
						num57 = 94;
					}
					if (num57 == 6)
					{
						num57 = 101;
					}
					if (num57 == 7)
					{
						num57 = 104;
					}
					if (num57 == 8)
					{
						num57 = 106;
					}
					PlaceTile(num55, num56, num57, mute: true);
				}
				else if (GenVars.statueList != null)
				{
					int num58 = genRand.Next(2, GenVars.statueList.Length);
					PlaceTile(num55, num56, GenVars.statueList[num58].X, mute: true, forced: true, -1, GenVars.statueList[num58].Y);
				}
			}
			for (int num59 = 0; num59 < 40; num59++)
			{
				int num60 = genRand.Next(num18 + 2, num19 - 1);
				int num61 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num60, num61].wall != 27)
				{
					num60 = genRand.Next(num18 + 2, num19 - 1);
					num61 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num60, num61].active())
				{
					num61--;
				}
				for (; !Main.tile[num60, num61].active(); num61++)
				{
				}
				num61--;
				if (Main.tile[num60, num61].wall == 27 && genRand.Next(2) == 0)
				{
					int style = genRand.Next(22, 26);
					PlaceTile(num60, num61, 186, mute: true, forced: false, -1, style);
				}
			}
			for (int num62 = 0; num62 < 20; num62++)
			{
				int num63 = genRand.Next(num18 + 2, num19 - 1);
				int num64 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num63, num64].wall != 27)
				{
					num63 = genRand.Next(num18 + 2, num19 - 1);
					num64 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num63, num64].active())
				{
					num64--;
				}
				for (; !Main.tile[num63, num64].active(); num64++)
				{
				}
				num64--;
				if (Main.tile[num63, num64].wall == 27 && genRand.Next(2) == 0)
				{
					int x = genRand.Next(31, 34);
					PlaceSmallPile(num63, num64, x, 1, 185);
				}
			}
			for (int num65 = 0; num65 < 15; num65++)
			{
				int num66 = genRand.Next(num18 + 2, num19 - 1);
				int num67 = genRand.Next(num20 + 2, num21 - 1);
				while (Main.tile[num66, num67].wall != 27)
				{
					num66 = genRand.Next(num18 + 2, num19 - 1);
					num67 = genRand.Next(num20 + 2, num21 - 1);
				}
				while (Main.tile[num66, num67].active())
				{
					num67--;
				}
				while (num67 > 0 && !Main.tile[num66, num67 - 1].active())
				{
					num67--;
				}
				if (Main.tile[num66, num67].wall != 27)
				{
					continue;
				}
				int num68 = 4;
				int style2 = 0;
				if (genRand.Next(10) < 9)
				{
					num68 = -1;
				}
				else
				{
					num68 = 34;
					style2 = genRand.Next(6);
				}
				if (num68 <= 0)
				{
					continue;
				}
				PlaceTile(num66, num67, num68, mute: true, forced: false, -1, style2);
				if (Main.tile[num66, num67].type != num68)
				{
					continue;
				}
				if (num68 == 4)
				{
					Main.tile[num66, num67].frameX += 54;
					continue;
				}
				int num69 = num66;
				int num70 = num67;
				num67 = num70 - Main.tile[num69, num70].frameY % 54 / 18;
				num66 = Main.tile[num69, num70].frameX / 18;
				if (num66 > 2)
				{
					num66 -= 3;
				}
				num66 = num69 - num66;
				short num71 = 54;
				if (Main.tile[num66, num67].frameX > 0)
				{
					num71 = -54;
				}
				for (int num72 = num66; num72 < num66 + 3; num72++)
				{
					for (int num73 = num67; num73 < num67 + 3; num73++)
					{
						Main.tile[num72, num73].frameX += num71;
					}
				}
			}
		}

		public static void CountTiles(int X)
		{
			if (X == 0)
			{
				totalEvil = totalEvil2;
				totalBlood = totalBlood2;
				totalSolid = totalSolid2;
				totalGood = totalGood2;
				tGood = (byte)Math.Round((double)totalGood / (double)totalSolid * 100.0);
				tEvil = (byte)Math.Round((double)totalEvil / (double)totalSolid * 100.0);
				tBlood = (byte)Math.Round((double)totalBlood / (double)totalSolid * 100.0);
				if (tGood == 0 && totalGood > 0)
				{
					tGood = 1;
				}
				if (tEvil == 0 && totalEvil > 0)
				{
					tEvil = 1;
				}
				if (tBlood == 0 && totalBlood > 0)
				{
					tBlood = 1;
				}
				if (Main.netMode == 2)
				{
					NetMessage.SendData(57);
				}
				totalEvil2 = 0;
				totalSolid2 = 0;
				totalGood2 = 0;
				totalBlood2 = 0;
			}
			ushort num = 0;
			ushort num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			do
			{
				int num6;
				int num7;
				if (num4 == 0)
				{
					num6 = 0;
					num5 = (int)(Main.worldSurface + 1.0);
					num7 = 5;
				}
				else
				{
					num6 = num5;
					num5 = Main.maxTilesY;
					num7 = 1;
				}
				for (int i = num6; i < num5; i++)
				{
					Tile tile = Main.tile[X, i];
					if (tile == null)
					{
						tile = (Main.tile[X, i] = new Tile());
					}
					num = tile.type;
					if (num != 0 || tile.active())
					{
						if (num == num2)
						{
							num3 += num7;
							continue;
						}
						tileCounts[num2] += num3;
						num2 = num;
						num3 = num7;
					}
				}
				tileCounts[num2] += num3;
				num3 = 0;
				num4++;
			}
			while (num4 < 2);
			AddUpAlignmentCounts();
		}

		public static void AddUpAlignmentCounts(bool clearCounts = false)
		{
			if (clearCounts)
			{
				totalEvil2 = 0;
				totalSolid2 = 0;
				totalGood2 = 0;
				totalBlood2 = 0;
			}
			for (int i = 0; i < TileID.Sets.HallowCountCollection.Count; i++)
			{
				totalGood2 += tileCounts[TileID.Sets.HallowCountCollection[i]];
			}
			for (int j = 0; j < TileID.Sets.CorruptCountCollection.Count; j++)
			{
				totalEvil2 += tileCounts[TileID.Sets.CorruptCountCollection[j]];
			}
			for (int k = 0; k < TileID.Sets.CrimsonCountCollection.Count; k++)
			{
				totalBlood2 += tileCounts[TileID.Sets.CrimsonCountCollection[k]];
			}
			totalSolid2 += tileCounts[2] + tileCounts[477] + tileCounts[1] + tileCounts[60] + tileCounts[53] + tileCounts[161];
			totalSolid2 += tileCounts[164] + tileCounts[109] + tileCounts[492] + tileCounts[117] + tileCounts[116];
			totalSolid2 += tileCounts[23] + tileCounts[661] + tileCounts[163] + tileCounts[112] + tileCounts[25];
			totalSolid2 += tileCounts[199] + tileCounts[662] + tileCounts[234] + tileCounts[203] + tileCounts[200];
			Array.Clear(tileCounts, 0, tileCounts.Length);
		}

		public static void plantDye(int i, int j, bool exoticPlant = false)
		{
			UnifiedRandom unifiedRandom = (gen ? genRand : Main.rand);
			if (!Main.tile[i, j].active() || i < 95 || i > Main.maxTilesX - 95 || j < 95 || j > Main.maxTilesY - 95)
			{
				return;
			}
			int num = 90;
			if (exoticPlant)
			{
				num = 240;
			}
			if (((double)j < Main.worldSurface || remixWorldGen) && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184))
			{
				int num2 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
				int num3 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
				int num4 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
				int num5 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
				for (int k = num2; k < num3; k++)
				{
					for (int l = num4; l < num5; l++)
					{
						if (Main.tile[k, l].active() && Main.tile[k, l].type == 227 && (!exoticPlant || Main.tile[k, l].frameX >= 272) && (exoticPlant || Main.tile[k, l].frameX < 272))
						{
							return;
						}
					}
				}
				if (exoticPlant)
				{
					int type = Main.tile[i, j].type;
					bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
					if (Main.tile[i, j - 1].liquid > 0 && (Main.tile[i, j - 1].lava() || Main.tile[i, j - 1].honey()))
					{
						flag = false;
					}
					if (flag)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
					}
				}
				else if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 109)
				{
					if (unifiedRandom.Next(4) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
					}
					else
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 3);
					}
				}
				else if (Main.tile[i, j].type == 60)
				{
					if (unifiedRandom.Next(2) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
					}
					else
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 4);
					}
				}
				else if (Main.tile[i, j].type == 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
				}
				else if (Main.tile[i, j].type == 80 && !Main.tile[i - 1, j - 1].active() && !Main.tile[i + 1, j - 1].active())
				{
					try
					{
						bool flag2 = true;
						for (int m = i - 5; m <= i + 5; m++)
						{
							for (int n = j - 5; n <= j + 15; n++)
							{
								if (Main.tile[m, n].active() && (Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234))
								{
									flag2 = false;
								}
							}
						}
						if (flag2)
						{
							PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 6);
						}
					}
					catch
					{
					}
				}
			}
			if ((!((double)j >= Main.worldSurface) && !remixWorldGen) || j >= Main.UnderworldLayer)
			{
				return;
			}
			if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 3 || Main.tile[i, j - 1].type == 51 || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 73 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 184)
			{
				int num6 = Utils.Clamp(i - num, 1, Main.maxTilesX - 1 - 1);
				int num7 = Utils.Clamp(i + num, 1, Main.maxTilesX - 1 - 1);
				int num8 = Utils.Clamp(j - num, 1, Main.maxTilesY - 1 - 1);
				int num9 = Utils.Clamp(j + num, 1, Main.maxTilesY - 1 - 1);
				for (int num10 = num6; num10 < num7; num10++)
				{
					for (int num11 = num8; num11 < num9; num11++)
					{
						if (Main.tile[num10, num11].active() && Main.tile[num10, num11].type == 227 && (!exoticPlant || Main.tile[num10, num11].frameX >= 272) && (exoticPlant || Main.tile[num10, num11].frameX < 272))
						{
							return;
						}
					}
				}
				if (exoticPlant)
				{
					int type2 = Main.tile[i, j].type;
					if (TileID.Sets.Conversion.Grass[type2] || TileID.Sets.Conversion.Moss[type2] || type2 == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, genRand.Next(8, 12));
					}
				}
				else if (Main.tile[i, j].type == 60)
				{
					if (unifiedRandom.Next(2) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 2);
					}
					else if (unifiedRandom.Next(2) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true);
					}
					else
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
					}
				}
				else if (Main.tile[i, j].type == 0 || Main.tile[i, j].type == 1 || Main.tile[i, j].type == 59)
				{
					if (unifiedRandom.Next(2) == 0)
					{
						PlaceTile(i, j - 1, 227, mute: true);
					}
					else
					{
						PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 1);
					}
				}
				else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
				{
					PlaceTile(i, j - 1, 227, mute: true, forced: false, -1, 5);
				}
			}
			if (Main.tile[i, j + 1].active() || exoticPlant)
			{
				return;
			}
			for (int num12 = i - num; num12 < i + num; num12++)
			{
				for (int num13 = j - num; num13 < j + num; num13++)
				{
					if (Main.tile[num12, num13].active() && Main.tile[num12, num13].type == 227)
					{
						return;
					}
				}
			}
			if (Main.tile[i, j].type == 0)
			{
				PlaceTile(i, j + 1, 227, mute: true, forced: false, -1, 7);
			}
		}

		private static int MossConversion(int thisType, int otherType)
		{
			if (TileID.Sets.tileMossBrick[thisType] && otherType == 38)
			{
				return thisType;
			}
			if (Main.tileMoss[thisType] && otherType == 1)
			{
				return thisType;
			}
			return thisType switch
			{
				182 => 515, 
				515 => 182, 
				180 => 513, 
				513 => 180, 
				179 => 512, 
				512 => 179, 
				381 => 517, 
				517 => 381, 
				534 => 535, 
				535 => 534, 
				536 => 537, 
				537 => 536, 
				539 => 540, 
				540 => 539, 
				625 => 626, 
				626 => 625, 
				627 => 628, 
				628 => 627, 
				183 => 516, 
				516 => 183, 
				181 => 514, 
				514 => 181, 
				_ => 0, 
			};
		}

		public static void UpdateWorld()
		{
			if (gen)
			{
				return;
			}
			AllowedToSpreadInfections = true;
			CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
			if (power != null && power.GetIsUnlocked())
			{
				AllowedToSpreadInfections = !power.Enabled;
			}
			int wallDist = 3;
			Wiring.UpdateMech();
			TileEntity.UpdateStart();
			foreach (TileEntity value in TileEntity.ByID.Values)
			{
				value.Update();
			}
			TileEntity.UpdateEnd();
			UpdateLunarApocalypse();
			if (Main.netMode != 1)
			{
				totalD++;
				if (totalD >= 30)
				{
					totalD = 0;
					CountTiles(totalX);
					totalX++;
					if (totalX >= Main.maxTilesX)
					{
						totalX = 0;
					}
				}
			}
			Liquid.skipCount++;
			if (Liquid.skipCount > 1)
			{
				Liquid.UpdateLiquid();
				Liquid.skipCount = 0;
			}
			int worldUpdateRate = GetWorldUpdateRate();
			if (worldUpdateRate == 0)
			{
				return;
			}
			double num = 3E-05f * (float)worldUpdateRate;
			double num2 = 1.5E-05f * (float)worldUpdateRate;
			double num3 = 2.5E-05f * (float)worldUpdateRate;
			bool checkNPCSpawns = false;
			spawnDelay++;
			if (Main.invasionType > 0 || Main.eclipse)
			{
				spawnDelay = 0;
			}
			if (spawnDelay >= 20)
			{
				checkNPCSpawns = true;
				spawnDelay = 0;
				if (prioritizedTownNPCType != 37)
				{
					for (int i = 0; i < 200; i++)
					{
						if (Main.npc[i].active && Main.npc[i].homeless && Main.npc[i].townNPC && Main.npc[i].type != 368)
						{
							prioritizedTownNPCType = Main.npc[i].type;
							break;
						}
					}
				}
			}
			double num4 = (double)(Main.maxTilesX * Main.maxTilesY) * num;
			int num5 = 151;
			int num6 = (int)Utils.Lerp(num5, (double)num5 * 2.8, Utils.Clamp((double)Main.maxTilesX / 4200.0 - 1.0, 0.0, 1.0));
			for (int j = 0; (double)j < num4; j++)
			{
				if (Main.rand.Next(num6 * 100) == 0)
				{
					PlantAlch();
				}
				int i2 = genRand.Next(10, Main.maxTilesX - 10);
				int j2 = genRand.Next(10, (int)Main.worldSurface - 1);
				UpdateWorld_OvergroundTile(i2, j2, checkNPCSpawns, wallDist);
			}
			if (Main.remixWorld)
			{
				for (int k = 0; (double)k < (double)(Main.maxTilesX * Main.maxTilesY) * num3; k++)
				{
					int i3 = genRand.Next(10, Main.maxTilesX - 10);
					int j3 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
					growGrassUnderground = true;
					UpdateWorld_UndergroundTile(i3, j3, checkNPCSpawns, wallDist);
					UpdateWorld_OvergroundTile(i3, j3, checkNPCSpawns, wallDist);
					growGrassUnderground = false;
				}
			}
			else
			{
				for (int l = 0; (double)l < (double)(Main.maxTilesX * Main.maxTilesY) * num2; l++)
				{
					int i4 = genRand.Next(10, Main.maxTilesX - 10);
					int j4 = genRand.Next((int)Main.worldSurface - 1, Main.maxTilesY - 20);
					UpdateWorld_UndergroundTile(i4, j4, checkNPCSpawns, wallDist);
				}
			}
			if (Main.dayTime && !Main.remixWorld)
			{
				return;
			}
			for (int m = 0; m < Main.dayRate; m++)
			{
				double num7 = (double)Main.maxTilesX / 4200.0;
				num7 *= (double)Star.starfallBoost;
				if (!((double)Main.rand.Next(8000) < 10.0 * num7))
				{
					continue;
				}
				int num8 = 12;
				int num9 = Main.rand.Next(Main.maxTilesX - 50) + 100;
				num9 *= 16;
				int num10 = Main.rand.Next((int)((double)Main.maxTilesY * 0.05));
				num10 *= 16;
				Vector2 position = new Vector2(num9, num10);
				int num11 = -1;
				if (Main.expertMode && Main.rand.Next(15) == 0)
				{
					int num12 = Player.FindClosest(position, 1, 1);
					if ((double)Main.player[num12].position.Y < Main.worldSurface * 16.0 && Main.player[num12].afkCounter < 3600)
					{
						int num13 = Main.rand.Next(1, 640);
						position.X = Main.player[num12].position.X + (float)Main.rand.Next(-num13, num13 + 1);
						num11 = num12;
					}
				}
				if (!Collision.SolidCollision(position, 16, 16))
				{
					float num14 = Main.rand.Next(-100, 101);
					float num15 = Main.rand.Next(200) + 100;
					float num16 = (float)Math.Sqrt(num14 * num14 + num15 * num15);
					num16 = (float)num8 / num16;
					num14 *= num16;
					num15 *= num16;
					Projectile.NewProjectile(new EntitySource_ByProjectileSourceId(11), position.X, position.Y, num14, num15, 720, 0, 0f, Main.myPlayer, 0f, num11);
				}
			}
		}

		public static int GetWorldUpdateRate()
		{
			int result = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
			if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
			{
				result = 0;
			}
			return result;
		}

		private static void UpdateWorld_OvergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
		{
			int num = i - 1;
			int num2 = i + 2;
			int num3 = j - 1;
			int num4 = j + 2;
			if (num < 10)
			{
				num = 10;
			}
			if (num2 > Main.maxTilesX - 10)
			{
				num2 = Main.maxTilesX - 10;
			}
			if (num3 < 10)
			{
				num3 = 10;
			}
			if (num4 > Main.maxTilesY - 10)
			{
				num4 = Main.maxTilesY - 10;
			}
			if (Main.tile[i, j] == null)
			{
				return;
			}
			if (Main.tile[i, j].type == 655 && !NPC.AnyNPCs(262))
			{
				KillTile(i, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j);
				}
			}
			if (Main.tile[i, j].type == 85)
			{
				TryGrowingAbigailsFlower(i, j);
			}
			else if (Main.tileAlch[Main.tile[i, j].type])
			{
				GrowAlch(i, j);
			}
			else if ((double)j < Main.worldSurface + 10.0 && (i < beachDistance || i > Main.maxTilesX - beachDistance) && !Main.tile[i, j].active())
			{
				int num5 = 3000;
				num5 -= (int)(Math.Abs(Main.windSpeedCurrent) * 1250f);
				if (Main.raining)
				{
					num5 -= (int)(1250f * Main.maxRaining);
				}
				if (num5 < 300)
				{
					num5 = 300;
				}
				if (genRand.Next(num5) == 0)
				{
					int k;
					for (k = j; (double)k < Main.worldSurface + 10.0 && !Main.tile[i, k].active() && k - j < 15; k++)
					{
					}
					if (Main.tile[i, k].active() && Main.tile[i, k].type == 53 && SolidTileAllowBottomSlope(i, k))
					{
						k--;
						int num6 = genRand.Next(2, 5);
						int num7 = genRand.Next(8, 11);
						int num8 = 0;
						for (int l = i - num7; l <= i + num7; l++)
						{
							for (int m = k - num7; m <= k + num7; m++)
							{
								if (Main.tile[l, m].active() && (Main.tile[l, m].type == 324 || Main.tile[l, m].type == 81))
								{
									num8++;
								}
							}
						}
						if (num8 < num6)
						{
							if (genRand.Next(2) == 0 && Main.tile[i, k].liquid >= 230)
							{
								PlaceTile(i, k, 81, mute: true);
								if (Main.netMode == 2 && Main.tile[i, k].active())
								{
									NetMessage.SendTileSquare(-1, i, k);
								}
							}
							else
							{
								PlaceTile(i, k, 324, mute: true, forced: false, -1, RollRandomSeaShellStyle());
								if (Main.netMode == 2 && Main.tile[i, k].active())
								{
									NetMessage.SendTileSquare(-1, i, k);
								}
							}
						}
					}
				}
			}
			if ((Main.tile[i, j].type == 596 || Main.tile[i, j].type == 616 || Main.tile[i, j].type == 595 || Main.tile[i, j].type == 615) && (Main.tile[i, j + 1].type == 199 || Main.tile[i, j + 1].type == 23))
			{
				KillTile(i, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			if ((Main.tile[i, j].type == 571 || (Main.tile[i, j].type == 60 && Main.tile[i, j - 1].liquid > 0)) && genRand.Next(5) == 0 && (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == 61 || Main.tile[i, j - 1].type == 74 || Main.tile[i, j - 1].type == 518) && (Main.tile[i, j].type != 60 || genRand.Next(30) == 0) && PlaceBamboo(i, j - 1))
			{
				NetMessage.SendTileSquare(-1, i, j - 1, 1, 2);
			}
			if (Main.tile[i, j].type == 518)
			{
				if (Main.tile[i, j].liquid == 0 || ((int)Main.tile[i, j].liquid / 16 >= 9 && SolidTile(i, j - 1)) || (Main.tile[i, j - 1].liquid > 0 && Main.tile[i, j - 1].active()))
				{
					KillTile(i, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendData(17, -1, -1, null, 0, i, j);
					}
				}
				else
				{
					CheckLilyPad(i, j);
				}
			}
			else if (Main.tile[i, j].type == 519)
			{
				CheckCatTail(i, j);
				if (Main.tile[i, j].active() && genRand.Next(8) == 0)
				{
					GrowCatTail(i, j);
					CheckCatTail(i, j);
				}
			}
			else if (Main.tile[i, j].liquid > 32)
			{
				if (Main.tile[i, j].active())
				{
					if (TileID.Sets.SlowlyDiesInWater[Main.tile[i, j].type])
					{
						KillTile(i, j);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, i, j);
						}
					}
					else if (Main.tile[i, j].type == 60)
					{
						UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: false);
					}
				}
				else if (genRand.Next(600) == 0)
				{
					PlaceTile(i, j, 518, mute: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
				else if (genRand.Next(600) == 0)
				{
					PlaceTile(i, j, 519, mute: true);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
			}
			else if (Main.tile[i, j].nactive())
			{
				hardUpdateWorld(i, j);
				if (Main.rand.Next(3000) == 0)
				{
					plantDye(i, j);
				}
				else if (Main.hardMode && ((double)i < (double)Main.maxTilesX * 0.4 || (double)i > (double)Main.maxTilesX * 0.6) && Main.rand.Next(15000) == 0)
				{
					plantDye(i, j, exoticPlant: true);
				}
				if (Main.tile[i, j].type == 80)
				{
					if (genRand.Next(15) == 0)
					{
						GrowCactus(i, j);
					}
				}
				else if (Main.tile[i, j].type == 529)
				{
					if (CheckSeaOat(i, j) && genRand.Next(20) == 0)
					{
						GrowSeaOat(i, j);
					}
				}
				else if (TileID.Sets.Conversion.Sand[Main.tile[i, j].type])
				{
					if (!Main.tile[i, num3].active())
					{
						if (genRand.Next(25) == 0)
						{
							PlaceOasisPlant(i, num3, 530);
							if (Main.tile[i, num3].type == 530 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i - 1, num3 - 1, 3, 2);
							}
						}
						if (genRand.Next(20) != 0 || !PlantSeaOat(i, num3))
						{
							if (i < oceanDistance || i > Main.maxTilesX - oceanDistance)
							{
								if (genRand.Next(500) == 0)
								{
									int num9 = 7;
									int num10 = 6;
									int num11 = 0;
									for (int n = i - num9; n <= i + num9; n++)
									{
										for (int num12 = num3 - num9; num12 <= num3 + num9; num12++)
										{
											if (Main.tile[n, num12].active() && Main.tile[n, num12].type == 81)
											{
												num11++;
											}
										}
									}
									if (num11 < num10 && Main.tile[i, num3].liquid == byte.MaxValue && Main.tile[i, num3 - 1].liquid == byte.MaxValue && Main.tile[i, num3 - 2].liquid == byte.MaxValue && Main.tile[i, num3 - 3].liquid == byte.MaxValue && Main.tile[i, num3 - 4].liquid == byte.MaxValue)
									{
										PlaceTile(i, num3, 81, mute: true);
										if (Main.netMode == 2 && Main.tile[i, num3].active())
										{
											NetMessage.SendTileSquare(-1, i, num3);
										}
									}
								}
							}
							else if (i > beachDistance + 20 && i < Main.maxTilesX - beachDistance - 20 && genRand.Next(300) == 0)
							{
								GrowCactus(i, j);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 530)
				{
					if (!OasisPlantWaterCheck(i, j, boost: true))
					{
						KillTile(i, j);
						if (Main.netMode == 2)
						{
							NetMessage.SendData(17, -1, -1, null, 0, i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
				{
					if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
					{
						int num13 = i - 3;
						int num14 = i + 4;
						int num15 = 0;
						for (int num16 = num13; num16 < num14; num16++)
						{
							if (Main.tile[num16, j].type == 165 && Main.tile[num16, j].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 1].type == 165 && Main.tile[num16, j + 1].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 2].type == 165 && Main.tile[num16, j + 2].active())
							{
								num15++;
							}
							if (Main.tile[num16, j + 3].type == 165 && Main.tile[num16, j + 3].active())
							{
								num15++;
							}
						}
						if (num15 < 2)
						{
							PlaceTight(i, j + 1);
							SquareTileFrame(i, j + 1);
							if (Main.netMode == 2 && Main.tile[i, j + 1].active())
							{
								NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 254)
				{
					if (Main.rand.Next((Main.tile[i, j].frameX + 10) / 10) == 0)
					{
						GrowPumpkin(i, j, 254);
					}
				}
				else if (Main.tile[i, j].type == 78 || Main.tile[i, j].type == 380 || Main.tile[i, j].type == 579)
				{
					if (!Main.tile[i, num3].active() && genRand.Next(2) == 0)
					{
						PlaceTile(i, num3, 3, mute: true);
						if (Main.netMode == 2 && Main.tile[i, num3].active())
						{
							NetMessage.SendTileSquare(-1, i, num3);
						}
					}
				}
				else if (TileID.Sets.SpreadOverground[Main.tile[i, j].type])
				{
					UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: false);
					int type = Main.tile[i, j].type;
					if ((type == 32 || type == 352) && genRand.Next(3) == 0)
					{
						if (type == 32)
						{
							GrowSpike(i, j, 32, 23);
						}
						else
						{
							GrowSpike(i, j, 352, 199);
						}
					}
				}
				else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
				{
					if (genRand.NextDouble() < 0.5)
					{
						int type2 = Main.tile[i, j].type;
						bool flag = false;
						TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
						for (int num17 = num; num17 < num2; num17++)
						{
							for (int num18 = num3; num18 < num4; num18++)
							{
								if ((i != num17 || j != num18) && Main.tile[num17, num18].active() && (Main.tile[num17, num18].type == 1 || Main.tile[num17, num18].type == 38))
								{
									int type3 = Main.tile[num17, num18].type;
									int num19 = MossConversion(type2, type3);
									SpreadGrass(num17, num18, Main.tile[num17, num18].type, num19, repeat: false, color);
									if (Main.tile[num17, num18].type == num19)
									{
										SquareTileFrame(num17, num18);
										flag = true;
									}
								}
							}
						}
						if (Main.netMode == 2 && flag)
						{
							NetMessage.SendTileSquare(-1, i, j, 3);
						}
						if (genRand.Next(6) == 0)
						{
							int num20 = i;
							int num21 = j;
							switch (genRand.Next(4))
							{
							case 0:
								num20--;
								break;
							case 1:
								num20++;
								break;
							case 2:
								num21--;
								break;
							default:
								num21++;
								break;
							}
							if (!Main.tile[num20, num21].active())
							{
								if (PlaceTile(num20, num21, 184, mute: true))
								{
									Main.tile[num20, num21].CopyPaintAndCoating(Main.tile[i, j]);
								}
								if (Main.netMode == 2 && Main.tile[num20, num21].active())
								{
									NetMessage.SendTileSquare(-1, num20, num21);
								}
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 20)
				{
					if (genRand.Next(20) == 0)
					{
						AttemptToGrowTreeFromSapling(i, j, underground: false);
					}
				}
				else if (Main.tile[i, j].type == 595)
				{
					if (genRand.Next(5) == 0)
					{
						AttemptToGrowTreeFromSapling(i, j, underground: false);
					}
				}
				else if (Main.tile[i, j].type == 615)
				{
					if (genRand.Next(5) == 0)
					{
						AttemptToGrowTreeFromSapling(i, j, underground: false);
					}
				}
				else if (Main.tile[i, j].type == 3 && genRand.Next(20) == 0)
				{
					if (Main.tile[i, j].frameX != 144)
					{
						Main.tile[i, j].type = 73;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j);
						}
					}
				}
				else if (Main.tile[i, j].type == 110 && genRand.Next(20) == 0 && Main.tile[i, j].frameX < 144)
				{
					Main.tile[i, j].type = 113;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
			}
			else
			{
				if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0)
				{
					GrowWeb(i, j);
				}
				if (checkNPCSpawns)
				{
					TrySpawningTownNPC(i, j);
				}
			}
			if (AllowedToSpreadInfections)
			{
				if (Main.tile[i, j].wall == 81 || Main.tile[i, j].wall == 83 || (Main.tile[i, j].type == 199 && Main.tile[i, j].active()))
				{
					int num22 = i + genRand.Next(-2, 3);
					int num23 = j + genRand.Next(-2, 3);
					if (Main.tile[num22, num23].wall >= 63 && Main.tile[num22, num23].wall <= 68)
					{
						bool flag2 = false;
						for (int num24 = i - wallDist; num24 < i + wallDist; num24++)
						{
							for (int num25 = j - wallDist; num25 < j + wallDist; num25++)
							{
								if (Main.tile[num24, num25].active())
								{
									int type4 = Main.tile[num24, num25].type;
									if (type4 == 199 || type4 == 200 || type4 == 201 || type4 == 203 || type4 == 205 || type4 == 234 || type4 == 352 || type4 == 662)
									{
										flag2 = true;
										break;
									}
								}
							}
						}
						if (flag2)
						{
							Main.tile[num22, num23].wall = 81;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num22, num23);
							}
						}
					}
				}
				else if (Main.tile[i, j].wall == 69 || Main.tile[i, j].wall == 3 || (Main.tile[i, j].type == 23 && Main.tile[i, j].active()))
				{
					int num26 = i + genRand.Next(-2, 3);
					int num27 = j + genRand.Next(-2, 3);
					if (Main.tile[num26, num27].wall >= 63 && Main.tile[num26, num27].wall <= 68)
					{
						bool flag3 = false;
						for (int num28 = i - wallDist; num28 < i + wallDist; num28++)
						{
							for (int num29 = j - wallDist; num29 < j + wallDist; num29++)
							{
								if (Main.tile[num28, num29].active())
								{
									int type5 = Main.tile[num28, num29].type;
									if (type5 == 22 || type5 == 23 || type5 == 24 || type5 == 25 || type5 == 32 || type5 == 112 || type5 == 163 || type5 == 636 || type5 == 661)
									{
										flag3 = true;
										break;
									}
								}
							}
						}
						if (flag3)
						{
							Main.tile[num26, num27].wall = 69;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num26, num27);
							}
						}
					}
				}
				else if (Main.tile[i, j].wall == 70 || (Main.tile[i, j].type == 109 && Main.tile[i, j].active()))
				{
					int num30 = i + genRand.Next(-2, 3);
					int num31 = j + genRand.Next(-2, 3);
					if (Main.tile[num30, num31].wall == 63 || Main.tile[num30, num31].wall == 65 || Main.tile[num30, num31].wall == 66 || Main.tile[num30, num31].wall == 68)
					{
						bool flag4 = false;
						for (int num32 = i - wallDist; num32 < i + wallDist; num32++)
						{
							for (int num33 = j - wallDist; num33 < j + wallDist; num33++)
							{
								if (Main.tile[num32, num33].active())
								{
									int type6 = Main.tile[num32, num33].type;
									if (type6 == 109 || type6 == 110 || type6 == 113 || type6 == 115 || type6 == 116 || type6 == 117 || type6 == 164)
									{
										flag4 = true;
										break;
									}
								}
							}
						}
						if (flag4)
						{
							Main.tile[num30, num31].wall = 70;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num30, num31);
							}
						}
					}
				}
				SpreadDesertWalls(wallDist, i, j);
			}
			if (Main.tile[i, j].nactive())
			{
				if (Main.tile[i, j].type == 2 || Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382 || (Main.tile[i, j].type == 192 && genRand.Next(10) == 0))
				{
					int num34 = 60;
					if (Main.tile[i, j].type == 52 || Main.tile[i, j].type == 382)
					{
						num34 = 20;
					}
					num34 = 1;
					if (genRand.Next(num34) == 0 && GrowMoreVines(i, j) && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag5 = false;
						ushort type7 = 52;
						if (Main.tile[i, j].type == 382)
						{
							type7 = 382;
						}
						else if (Main.tile[i, j].type != 52)
						{
							if (Main.tile[i, j].wall == 68 || Main.tile[i, j].wall == 65 || Main.tile[i, j].wall == 66 || Main.tile[i, j].wall == 63)
							{
								type7 = 382;
							}
							else if (Main.tile[i, j + 1].wall == 68 || Main.tile[i, j + 1].wall == 65 || Main.tile[i, j + 1].wall == 66 || Main.tile[i, j + 1].wall == 63)
							{
								type7 = 382;
							}
							if (Main.remixWorld && genRand.Next(5) == 0)
							{
								type7 = 382;
							}
						}
						for (int num35 = j; num35 > j - 10; num35--)
						{
							if (Main.tile[i, num35].bottomSlope())
							{
								flag5 = false;
								break;
							}
							if (Main.tile[i, num35].active() && Main.tile[i, num35].type == 2 && !Main.tile[i, num35].bottomSlope())
							{
								flag5 = true;
								break;
							}
						}
						if (flag5)
						{
							int num36 = j + 1;
							Main.tile[i, num36].type = type7;
							Main.tile[i, num36].active(active: true);
							Main.tile[i, num36].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num36);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num36);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j].frameX < 144)
				{
					if (Main.rand.Next(4) == 0)
					{
						Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
					}
					Main.tile[i, j].type = 74;
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j);
					}
				}
				if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && GrowMoreVines(i, j))
				{
					int maxValue = 30;
					if (Main.tile[i, j].type == 62)
					{
						maxValue = 10;
					}
					if (genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag6 = false;
						for (int num37 = j; num37 > j - 10; num37--)
						{
							if (Main.tile[i, num37].bottomSlope())
							{
								flag6 = false;
								break;
							}
							if (Main.tile[i, num37].active() && Main.tile[i, num37].type == 60 && !Main.tile[i, num37].bottomSlope())
							{
								flag6 = true;
								break;
							}
						}
						if (flag6)
						{
							int num38 = j + 1;
							Main.tile[i, num38].type = 62;
							Main.tile[i, num38].active(active: true);
							Main.tile[i, num38].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num38);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num38);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
				{
					int maxValue2 = 70;
					if (Main.tile[i, j].type == 528)
					{
						maxValue2 = 7;
					}
					if (genRand.Next(maxValue2) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag7 = false;
						for (int num39 = j; num39 > j - 10; num39--)
						{
							if (Main.tile[i, num39].bottomSlope())
							{
								flag7 = false;
								break;
							}
							if (Main.tile[i, num39].active() && Main.tile[i, num39].type == 70 && !Main.tile[i, num39].bottomSlope())
							{
								flag7 = true;
								break;
							}
						}
						if (flag7)
						{
							int num40 = j + 1;
							Main.tile[i, num40].type = 528;
							Main.tile[i, num40].active(active: true);
							Main.tile[i, num40].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num40);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num40);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 109 || Main.tile[i, j].type == 115) && GrowMoreVines(i, j))
				{
					int maxValue3 = 60;
					if (Main.tile[i, j].type == 115)
					{
						maxValue3 = 20;
					}
					if (genRand.Next(maxValue3) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag8 = false;
						for (int num41 = j; num41 > j - 10; num41--)
						{
							if (Main.tile[i, num41].bottomSlope())
							{
								flag8 = false;
								break;
							}
							if (Main.tile[i, num41].active() && Main.tile[i, num41].type == 109 && !Main.tile[i, num41].bottomSlope())
							{
								flag8 = true;
								break;
							}
						}
						if (flag8)
						{
							int num42 = j + 1;
							Main.tile[i, num42].type = 115;
							Main.tile[i, num42].active(active: true);
							Main.tile[i, num42].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num42);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num42);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 23 || Main.tile[i, j].type == 661 || Main.tile[i, j].type == 636) && GrowMoreVines(i, j))
				{
					int maxValue4 = 60;
					if (Main.tile[i, j].type == 636)
					{
						maxValue4 = 20;
					}
					if (genRand.Next(maxValue4) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag9 = false;
						for (int num43 = j; num43 > j - 10; num43--)
						{
							if (Main.tile[i, num43].bottomSlope())
							{
								flag9 = false;
								break;
							}
							if (Main.tile[i, num43].active() && (Main.tile[i, num43].type == 23 || Main.tile[i, num43].type == 661) && !Main.tile[i, num43].bottomSlope())
							{
								flag9 = true;
								break;
							}
						}
						if (flag9)
						{
							int num44 = j + 1;
							Main.tile[i, num44].type = 636;
							Main.tile[i, num44].active(active: true);
							Main.tile[i, num44].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num44);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num44);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 199 || Main.tile[i, j].type == 662 || Main.tile[i, j].type == 205) && GrowMoreVines(i, j))
				{
					int maxValue5 = 60;
					if (Main.tile[i, j].type == 205)
					{
						maxValue5 = 20;
					}
					if (genRand.Next(maxValue5) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag10 = false;
						for (int num45 = j; num45 > j - 10; num45--)
						{
							if (Main.tile[i, num45].bottomSlope())
							{
								flag10 = false;
								break;
							}
							if (Main.tile[i, num45].active() && (Main.tile[i, num45].type == 199 || Main.tile[i, num45].type == 662) && !Main.tile[i, num45].bottomSlope())
							{
								flag10 = true;
								break;
							}
						}
						if (flag10)
						{
							int num46 = j + 1;
							Main.tile[i, num46].type = 205;
							Main.tile[i, num46].active(active: true);
							Main.tile[i, num46].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num46);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num46);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
				{
					int maxValue6 = 70;
					if (Main.tile[i, j].type == 638)
					{
						maxValue6 = 7;
					}
					if (genRand.Next(maxValue6) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag11 = false;
						for (int num47 = j; num47 > j - 10; num47--)
						{
							if (Main.tile[i, num47].bottomSlope())
							{
								flag11 = false;
								break;
							}
							if (Main.tile[i, num47].active() && Main.tile[i, num47].type == 633 && !Main.tile[i, num47].bottomSlope())
							{
								flag11 = true;
								break;
							}
						}
						if (flag11)
						{
							int num48 = j + 1;
							Main.tile[i, num48].type = 638;
							Main.tile[i, num48].active(active: true);
							Main.tile[i, num48].CopyPaintAndCoating(Main.tile[i, j]);
							SquareTileFrame(i, num48);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num48);
							}
						}
					}
				}
			}
			if (!Main.remixWorld && Main.dontStarveWorld && (float)Main.rand.Next(200) < 100f * Main.maxRaining && Main.maxRaining >= 0.2f)
			{
				DontStarveTryWateringTile(i, j);
			}
		}

		public static bool AttemptToGrowTreeFromSapling(int x, int y, bool underground)
		{
			if (Main.netMode == 1)
			{
				return false;
			}
			if (!InWorld(x, y, 2))
			{
				return false;
			}
			Tile tile = Main.tile[x, y];
			if (tile == null || !tile.active())
			{
				return false;
			}
			bool flag = false;
			int num = 0;
			int num2 = -1;
			switch (tile.type)
			{
			case 20:
				switch (tile.frameX / 54)
				{
				case 10:
					flag = TryGrowingTreeByType(634, x, y);
					break;
				case 6:
				case 7:
				case 8:
				case 9:
					if (underground)
					{
						return false;
					}
					flag = GrowPalmTree(x, y);
					break;
				default:
					if (underground)
					{
						return false;
					}
					flag = GrowTree(x, y);
					break;
				}
				if (flag && PlayerLOS(x, y))
				{
					TreeGrowFXCheck(x, y);
				}
				return flag;
			case 595:
				num = tile.frameX / 54;
				num2 = 596;
				if (num == 0)
				{
					num2 = 596;
				}
				flag = TryGrowingTreeByType(num2, x, y);
				if (flag && PlayerLOS(x, y))
				{
					TreeGrowFXCheck(x, y);
				}
				return flag;
			case 615:
				num = tile.frameX / 54;
				num2 = 616;
				if (num == 0)
				{
					num2 = 616;
				}
				flag = TryGrowingTreeByType(num2, x, y);
				if (flag && PlayerLOS(x, y))
				{
					TreeGrowFXCheck(x, y);
				}
				return flag;
			case 590:
				if (!underground)
				{
					return false;
				}
				num = tile.frameX / 54;
				num2 = 587;
				switch (num)
				{
				case 0:
					num2 = 583;
					break;
				case 1:
					num2 = 584;
					break;
				case 2:
					num2 = 585;
					break;
				case 3:
					num2 = 586;
					break;
				case 4:
					num2 = 587;
					break;
				case 5:
					num2 = 588;
					break;
				case 6:
					num2 = 589;
					break;
				}
				flag = TryGrowingTreeByType(num2, x, y);
				if (flag && PlayerLOS(x, y))
				{
					TreeGrowFXCheck(x, y);
				}
				return flag;
			default:
				return false;
			}
		}

		public static void DontStarveTryWateringTile(int x, int y)
		{
			Tile tile = Main.tile[x, y];
			if (tile.active() && TileObjectData.CheckWaterDeath(tile) && !IsSafeFromRain(x, y) && !HasAnyWireNearby(x, y, 0) && !TryToggleLight(x, y, false, skipWires: false))
			{
				KillTile(x, y);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, x, y);
				}
			}
		}

		public static bool HasAnyWireNearby(int sourceX, int sourceY, int boxSpread)
		{
			int num = Utils.Clamp(sourceX - boxSpread, 0, Main.maxTilesX - 1);
			int num2 = Utils.Clamp(sourceX + boxSpread, 0, Main.maxTilesX - 1);
			int num3 = Utils.Clamp(sourceY - boxSpread, 0, Main.maxTilesY - 1);
			int num4 = Utils.Clamp(sourceY + boxSpread, 0, Main.maxTilesY - 1);
			for (int i = num; i <= num2; i++)
			{
				for (int j = num3; j <= num4; j++)
				{
					Tile tile = Main.tile[i, j];
					if (tile != null && (tile.wire() || tile.wire2() || tile.wire3() || tile.wire4()))
					{
						return true;
					}
				}
			}
			return false;
		}

		public static bool IsSafeFromRain(int startX, int startY)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			Vector2D val = -Rain.GetRainFallVelocity().SafeNormalize(new Vector2(0f, 1f)).ToVector2D();
			Vector2D val2 = new Vector2D((double)startX, (double)startY) * 16.0 + Vector2D.get_One() * 8.0;
			double num = 85.0;
			DelegateMethods.CheckResultOut = false;
			Utils.PlotTileLine(val2, val2 + val * 16.0 * num, 4.0, DelegateMethods.CheckStopForSolids);
			return DelegateMethods.CheckResultOut;
		}

		public static bool TryToggleLight(int x, int y, bool? forcedState, bool skipWires)
		{
			Tile tile = Main.tile[x, y];
			if (!tile.active())
			{
				return false;
			}
			switch (tile.type)
			{
			default:
				return false;
			case 4:
				Wiring.ToggleTorch(x, y, tile, forcedState);
				return true;
			case 33:
			case 49:
			case 174:
			case 372:
			case 646:
				Wiring.ToggleCandle(x, y, tile, forcedState);
				return true;
			case 405:
				Wiring.ToggleFirePlace(x, y, tile, forcedState, skipWires);
				return true;
			case 95:
			case 100:
			case 126:
			case 173:
			case 564:
				Wiring.Toggle2x2Light(x, y, tile, forcedState, skipWires);
				return true;
			case 92:
				Wiring.ToggleLampPost(x, y, tile, forcedState, skipWires);
				return true;
			case 215:
				Wiring.ToggleCampFire(x, y, tile, forcedState, skipWires);
				return true;
			case 34:
				Wiring.ToggleChandelier(x, y, tile, forcedState, skipWires);
				return true;
			case 93:
				Wiring.ToggleLamp(x, y, tile, forcedState, skipWires);
				return true;
			case 42:
				Wiring.ToggleHangingLantern(x, y, tile, forcedState, skipWires);
				return true;
			case 149:
				Wiring.ToggleHolidayLight(x, y, tile, forcedState);
				return true;
			}
		}

		private static void TryGrowingAbigailsFlower(int i, int j)
		{
			if (Main.rand.Next(30) != 0)
			{
				return;
			}
			int num = 1;
			if (Main.dontStarveWorld)
			{
				num = 2;
			}
			for (int k = 0; k < num; k++)
			{
				int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
				int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
				Tile tile = Main.tile[num2, num3];
				_ = Main.tile[num2, num3 - 1];
				if (tile.active() && TileID.Sets.Conversion.Grass[tile.type] && NoNearbyAbigailsFlower(num2, num3) && PlaceTile(num2, num3 - 1, 624, mute: true))
				{
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num2, num3 - 1);
					}
					break;
				}
			}
		}

		private static bool NoNearbyAbigailsFlower(int i, int j)
		{
			int num = Utils.Clamp(i - 120, 10, Main.maxTilesX - 1 - 10);
			int num2 = Utils.Clamp(i + 120, 10, Main.maxTilesX - 1 - 10);
			int num3 = Utils.Clamp(j - 120, 10, Main.maxTilesY - 1 - 10);
			int num4 = Utils.Clamp(j + 120, 10, Main.maxTilesY - 1 - 10);
			for (int k = num; k <= num2; k++)
			{
				for (int l = num3; l <= num4; l++)
				{
					Tile tile = Main.tile[k, l];
					if (tile.active() && tile.type == 624)
					{
						return false;
					}
				}
			}
			return true;
		}

		private static bool HasValidGroundForGlowTulipBelowSpot(int x, int y)
		{
			if (!InWorld(x, y, 2))
			{
				return false;
			}
			Tile tile = Main.tile[x, y + 1];
			if (tile == null || !tile.active())
			{
				return false;
			}
			if (tile.type != 0 && !TileID.Sets.Conversion.Grass[tile.type] && tile.type != 59 && tile.type != 225 && tile.type != 70 && !TileID.Sets.Conversion.Stone[tile.type] && !Main.tileMoss[tile.type])
			{
				return false;
			}
			return SolidTileAllowBottomSlope(x, y + 1);
		}

		private static bool TryGrowingGlowTulip(int i, int j)
		{
			int num = 5;
			for (int k = 0; k < num; k++)
			{
				int num2 = genRand.Next(Math.Max(10, i - 10), Math.Min(Main.maxTilesX - 10, i + 10));
				int num3 = genRand.Next(Math.Max(10, j - 10), Math.Min(Main.maxTilesY - 10, j + 10));
				Tile tile = Main.tile[num2, num3];
				if (!Main.tile[num2, num3 - 1].active() && tile.active() && HasValidGroundForGlowTulipBelowSpot(num2, num3 - 1) && NoNearbyGlowTulips(num2, num3) && PlaceTile(num2, num3 - 1, 656, mute: true))
				{
					if (!gen && Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, num2, num3 - 1);
					}
					return true;
				}
			}
			return false;
		}

		private static bool NoNearbyGlowTulips(int i, int j)
		{
			int num = Utils.Clamp(i - 120, 10, Main.maxTilesX - 1 - 10);
			int num2 = Utils.Clamp(i + 120, 10, Main.maxTilesX - 1 - 10);
			int num3 = Utils.Clamp(j - 120, 10, Main.maxTilesY - 1 - 10);
			int num4 = Utils.Clamp(j + 120, 10, Main.maxTilesY - 1 - 10);
			for (int k = num; k <= num2; k++)
			{
				for (int l = num3; l <= num4; l++)
				{
					Tile tile = Main.tile[k, l];
					if (tile.active() && tile.type == 656)
					{
						return false;
					}
				}
			}
			return true;
		}

		private static void UpdateWorld_UndergroundTile(int i, int j, bool checkNPCSpawns, int wallDist)
		{
			int num = i - 1;
			int num2 = i + 2;
			int num3 = j - 1;
			int num4 = j + 2;
			if (num < 10)
			{
				num = 10;
			}
			if (num2 > Main.maxTilesX - 10)
			{
				num2 = Main.maxTilesX - 10;
			}
			if (num3 < 10)
			{
				num3 = 10;
			}
			if (num4 > Main.maxTilesY - 10)
			{
				num4 = Main.maxTilesY - 10;
			}
			if (Main.tile[i, j] == null)
			{
				return;
			}
			if (Main.tile[i, j].type == 655 && !NPC.AnyNPCs(262))
			{
				KillTile(i, j);
				if (Main.netMode == 2)
				{
					NetMessage.SendData(17, -1, -1, null, 0, i, j);
				}
			}
			if (Main.tileAlch[Main.tile[i, j].type])
			{
				GrowAlch(i, j);
			}
			else if (Main.tile[i, j].nactive())
			{
				hardUpdateWorld(i, j);
				if (Main.rand.Next(2500) == 0)
				{
					plantDye(i, j);
				}
				else if (Main.hardMode && Main.rand.Next(10000) == 0)
				{
					plantDye(i, j, exoticPlant: true);
				}
				if (Main.tile[i, j].type == 519)
				{
					CheckCatTail(i, j);
					if (Main.tile[i, j].active() && genRand.Next(2) == 0)
					{
						GrowCatTail(i, j);
						CheckCatTail(i, j);
					}
				}
				if (Main.tile[i, j].type == 549)
				{
					GrowCheckSeaweed(i, j);
				}
				else if (Main.tile[i, j].type == 53 && !Main.tile[i, j].topSlope() && !Main.tile[i, j].halfBrick() && !Main.tile[i, j - 1].active() && genRand.Next(20) == 0)
				{
					GrowCheckSeaweed(i, j);
				}
				else if (TileID.Sets.SpreadUnderground[Main.tile[i, j].type])
				{
					UpdateWorld_GrassGrowth(i, j, num, num2, num3, num4, underground: true);
					int type = Main.tile[i, j].type;
					if ((type == 32 || type == 352) && genRand.Next(3) == 0)
					{
						if (type == 32)
						{
							GrowSpike(i, j, 32, 23);
						}
						else
						{
							GrowSpike(i, j, 352, 199);
						}
					}
				}
				else if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0)
				{
					if (Main.tile[i, j].frameX < 144)
					{
						if (Main.rand.Next(4) == 0)
						{
							Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
						}
						Main.tile[i, j].type = 74;
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, j);
						}
					}
				}
				else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(5) == 0 && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						bool flag = false;
						for (int num5 = j; num5 > j - 10; num5--)
						{
							if (Main.tile[i, num5].bottomSlope())
							{
								flag = false;
								break;
							}
							if (Main.tile[i, num5].active() && Main.tile[i, num5].type == 60 && !Main.tile[i, num5].bottomSlope())
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							int num6 = j + 1;
							Main.tile[i, num6].type = 62;
							Main.tile[i, num6].active(active: true);
							SquareTileFrame(i, num6);
							Main.tile[i, num6].CopyPaintAndCoating(Main.tile[i, num6 - 1]);
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, num6);
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						int maxValue = 70;
						if (Main.tile[i, j].type == 638)
						{
							maxValue = 7;
						}
						if (genRand.Next(maxValue) == 0)
						{
							bool flag2 = false;
							for (int num7 = j; num7 > j - 10; num7--)
							{
								if (Main.tile[i, num7].bottomSlope())
								{
									flag2 = false;
									break;
								}
								if (Main.tile[i, num7].active() && Main.tile[i, num7].type == 633 && !Main.tile[i, num7].bottomSlope())
								{
									flag2 = true;
									break;
								}
							}
							if (flag2)
							{
								int num8 = j + 1;
								Main.tile[i, num8].type = 638;
								Main.tile[i, num8].active(active: true);
								Main.tile[i, num8].CopyPaintAndCoating(Main.tile[i, num8 - 1]);
								SquareTileFrame(i, num8);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, num8);
								}
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 70 || Main.tile[i, j].type == 528) && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						int maxValue2 = 70;
						if (Main.tile[i, j].type == 528)
						{
							maxValue2 = 7;
						}
						if (genRand.Next(maxValue2) == 0)
						{
							bool flag3 = false;
							for (int num9 = j; num9 > j - 10; num9--)
							{
								if (Main.tile[i, num9].bottomSlope())
								{
									flag3 = false;
									break;
								}
								if (Main.tile[i, num9].active() && Main.tile[i, num9].type == 70 && !Main.tile[i, num9].bottomSlope())
								{
									flag3 = true;
									break;
								}
							}
							if (flag3)
							{
								int num10 = j + 1;
								Main.tile[i, num10].type = 528;
								Main.tile[i, num10].active(active: true);
								Main.tile[i, num10].CopyPaintAndCoating(Main.tile[i, num10 - 1]);
								SquareTileFrame(i, num10);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, num10);
								}
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 661 || Main.tile[i, j].type == 636) && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						int maxValue3 = 70;
						if (Main.tile[i, j].type == 636)
						{
							maxValue3 = 7;
						}
						if (genRand.Next(maxValue3) == 0)
						{
							bool flag4 = false;
							for (int num11 = j; num11 > j - 10; num11--)
							{
								if (Main.tile[i, num11].bottomSlope())
								{
									flag4 = false;
									break;
								}
								if (Main.tile[i, num11].active() && Main.tile[i, num11].type == 661 && !Main.tile[i, num11].bottomSlope())
								{
									flag4 = true;
									break;
								}
							}
							if (flag4)
							{
								int num12 = j + 1;
								Main.tile[i, num12].type = 636;
								Main.tile[i, num12].active(active: true);
								Main.tile[i, num12].CopyPaintAndCoating(Main.tile[i, num12 - 1]);
								SquareTileFrame(i, num12);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, num12);
								}
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 662 || Main.tile[i, j].type == 205) && GrowMoreVines(i, j))
				{
					if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
					{
						int maxValue4 = 70;
						if (Main.tile[i, j].type == 205)
						{
							maxValue4 = 7;
						}
						if (genRand.Next(maxValue4) == 0)
						{
							bool flag5 = false;
							for (int num13 = j; num13 > j - 10; num13--)
							{
								if (Main.tile[i, num13].bottomSlope())
								{
									flag5 = false;
									break;
								}
								if (Main.tile[i, num13].active() && Main.tile[i, num13].type == 662 && !Main.tile[i, num13].bottomSlope())
								{
									flag5 = true;
									break;
								}
							}
							if (flag5)
							{
								int num14 = j + 1;
								Main.tile[i, num14].type = 205;
								Main.tile[i, num14].active(active: true);
								Main.tile[i, num14].CopyPaintAndCoating(Main.tile[i, num14 - 1]);
								SquareTileFrame(i, num14);
								if (Main.netMode == 2)
								{
									NetMessage.SendTileSquare(-1, i, num14);
								}
							}
						}
					}
				}
				else if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && genRand.Next(80) == 0 && !PlayerLOS(i, j))
				{
					bool flag6 = true;
					int num15 = j;
					if (Main.tile[i, j].type == 60)
					{
						num15++;
					}
					for (int k = i; k < i + 2; k++)
					{
						int num16 = num15 - 1;
						if (!AnchorValid(Framing.GetTileSafely(k, num16), AnchorType.SolidTile) || Main.tile[k, num16].bottomSlope())
						{
							flag6 = false;
						}
						if (Main.tile[k, num16].liquid > 0 || Main.wallHouse[Main.tile[k, num16].wall])
						{
							flag6 = false;
						}
						if (!flag6)
						{
							break;
						}
						for (int l = num15; l < num15 + 2; l++)
						{
							if ((Main.tile[k, l].active() && (!Main.tileCut[Main.tile[k, l].type] || Main.tile[k, l].type == 444)) || Main.tile[k, l].lava())
							{
								flag6 = false;
							}
							if (!flag6)
							{
								break;
							}
						}
						if (!flag6)
						{
							break;
						}
					}
					if (flag6 && CountNearBlocksTypes(i, j, 20, 1, 444) > 0)
					{
						flag6 = false;
					}
					if (flag6)
					{
						for (int m = i; m < i + 2; m++)
						{
							Main.tile[m, num15 - 1].slope(0);
							Main.tile[m, num15 - 1].halfBrick(halfBrick: false);
							for (int n = num15; n < num15 + 2; n++)
							{
								if (Main.tile[m, n].active())
								{
									KillTile(m, n);
								}
							}
						}
						for (int num17 = i; num17 < i + 2; num17++)
						{
							for (int num18 = num15; num18 < num15 + 2; num18++)
							{
								Main.tile[num17, num18].active(active: true);
								Main.tile[num17, num18].type = 444;
								Main.tile[num17, num18].frameX = (short)((num17 - i) * 18);
								Main.tile[num17, num18].frameY = (short)((num18 - num15) * 18);
							}
						}
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, num15 - 1, 2, 3);
						}
					}
				}
				else if (Main.tile[i, j].type == 396 && genRand.Next(80) == 0 && !PlayerLOS(i, j))
				{
					bool flag7 = true;
					int num19 = j - 1;
					for (int num20 = i; num20 < i + 2; num20++)
					{
						int num21 = num19 + 1;
						if (!AnchorValid(Framing.GetTileSafely(num20, num21), AnchorType.SolidTile) || Main.tile[num20, num21].topSlope())
						{
							flag7 = false;
						}
						if (Main.tile[num20, num21].liquid > 0 || Main.wallHouse[Main.tile[num20, num21].wall])
						{
							flag7 = false;
						}
						if (!flag7)
						{
							break;
						}
						for (int num22 = num19 - 2; num22 < num19; num22++)
						{
							if ((Main.tile[num20, num22].active() && (!Main.tileCut[Main.tile[num20, num22].type] || Main.tile[num20, num22].type == 485)) || Main.tile[num20, num22].lava())
							{
								flag7 = false;
							}
							if (!flag7)
							{
								break;
							}
						}
						if (!flag7)
						{
							break;
						}
					}
					if (flag7 && CountNearBlocksTypes(i, j, 20, 1, 485) > 0)
					{
						flag7 = false;
					}
					if (flag7)
					{
						bool flag8 = true;
						for (int num23 = -1; num23 >= -3; num23--)
						{
							if (Main.tile[i, j + num23].active())
							{
								flag8 = false;
								break;
							}
						}
						if (flag8)
						{
							PlaceTile(i, j - 1, 485, mute: true, forced: false, -1, genRand.Next(4));
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, j - 2, 2, 2);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 69)
				{
					GrowSpike(i, j, 69, 60);
				}
				else if (Main.tile[i, j].type == 147 || Main.tile[i, j].type == 161 || Main.tile[i, j].type == 163 || Main.tile[i, j].type == 164 || Main.tile[i, j].type == 200)
				{
					if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
					{
						int num24 = i - 3;
						int num25 = i + 4;
						int num26 = 0;
						for (int num27 = num24; num27 < num25; num27++)
						{
							if (Main.tile[num27, j].type == 165 && Main.tile[num27, j].active())
							{
								num26++;
							}
							if (Main.tile[num27, j + 1].type == 165 && Main.tile[num27, j + 1].active())
							{
								num26++;
							}
							if (Main.tile[num27, j + 2].type == 165 && Main.tile[num27, j + 2].active())
							{
								num26++;
							}
							if (Main.tile[num27, j + 3].type == 165 && Main.tile[num27, j + 3].active())
							{
								num26++;
							}
						}
						if (num26 < 2)
						{
							PlaceTight(i, j + 1);
							SquareTileFrame(i, j + 1);
							if (Main.netMode == 2 && Main.tile[i, j + 1].active())
							{
								NetMessage.SendTileSquare(-1, i, j + 1, 1, 2);
							}
						}
					}
				}
				else if (Main.tileMoss[Main.tile[i, j].type] || TileID.Sets.tileMossBrick[Main.tile[i, j].type])
				{
					int type2 = Main.tile[i, j].type;
					bool flag9 = false;
					TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
					for (int num28 = num; num28 < num2; num28++)
					{
						for (int num29 = num3; num29 < num4; num29++)
						{
							if ((i != num28 || j != num29) && Main.tile[num28, num29].active() && (Main.tile[num28, num29].type == 1 || Main.tile[num28, num29].type == 38))
							{
								int type3 = Main.tile[num28, num29].type;
								int num30 = MossConversion(type2, type3);
								SpreadGrass(num28, num29, Main.tile[num28, num29].type, num30, repeat: false, color);
								if (Main.tile[num28, num29].type == num30)
								{
									SquareTileFrame(num28, num29);
									flag9 = true;
								}
							}
						}
					}
					if (Main.netMode == 2 && flag9)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
					if (genRand.Next(6) == 0)
					{
						int num31 = i;
						int num32 = j;
						switch (genRand.Next(4))
						{
						case 0:
							num31--;
							break;
						case 1:
							num31++;
							break;
						case 2:
							num32--;
							break;
						default:
							num32++;
							break;
						}
						if (!Main.tile[num31, num32].active())
						{
							if (PlaceTile(num31, num32, 184, mute: true))
							{
								Main.tile[num31, num32].CopyPaintAndCoating(Main.tile[i, j]);
							}
							if (Main.netMode == 2 && Main.tile[num31, num32].active())
							{
								NetMessage.SendTileSquare(-1, num31, num32);
							}
						}
					}
				}
				else if (Main.tile[i, j].type == 20)
				{
					if (genRand.Next(5) == 0)
					{
						AttemptToGrowTreeFromSapling(i, j, underground: true);
					}
				}
				else if (Main.tile[i, j].type == 590)
				{
					if (genRand.Next(5) == 0)
					{
						AttemptToGrowTreeFromSapling(i, j, underground: true);
					}
				}
				else if (Main.tile[i, j].type == 595)
				{
					if (genRand.Next(5) == 0)
					{
						AttemptToGrowTreeFromSapling(i, j, underground: true);
					}
				}
				else if (Main.tile[i, j].type == 615 && genRand.Next(5) == 0)
				{
					AttemptToGrowTreeFromSapling(i, j, underground: true);
				}
			}
			else
			{
				if (Main.tile[i, j].wall == 62 && Main.tile[i, j].liquid == 0)
				{
					GrowWeb(i, j);
				}
				if (checkNPCSpawns)
				{
					TrySpawningTownNPC(i, j);
				}
			}
			if (AllowedToSpreadInfections)
			{
				if (Main.tile[i, j].wall == 81 || Main.tile[i, j].wall == 83 || (Main.tile[i, j].type == 199 && Main.tile[i, j].active()))
				{
					int num33 = i + genRand.Next(-2, 3);
					int num34 = j + genRand.Next(-2, 3);
					if (Main.tile[num33, num34].wall >= 63 && Main.tile[num33, num34].wall <= 68)
					{
						bool flag10 = false;
						for (int num35 = i - wallDist; num35 < i + wallDist; num35++)
						{
							for (int num36 = j - wallDist; num36 < j + wallDist; num36++)
							{
								if (Main.tile[num35, num36].active())
								{
									int type4 = Main.tile[num35, num36].type;
									if (type4 == 199 || type4 == 200 || type4 == 201 || type4 == 203 || type4 == 205 || type4 == 234 || type4 == 352 || type4 == 662)
									{
										flag10 = true;
										break;
									}
								}
							}
						}
						if (flag10)
						{
							Main.tile[num33, num34].wall = 81;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num33, num34);
							}
						}
					}
				}
				else if (Main.tile[i, j].wall == 69 || Main.tile[i, j].wall == 3 || (Main.tile[i, j].type == 23 && Main.tile[i, j].active()))
				{
					int num37 = i + genRand.Next(-2, 3);
					int num38 = j + genRand.Next(-2, 3);
					if (Main.tile[num37, num38].wall >= 63 && Main.tile[num37, num38].wall <= 68)
					{
						bool flag11 = false;
						for (int num39 = i - wallDist; num39 < i + wallDist; num39++)
						{
							for (int num40 = j - wallDist; num40 < j + wallDist; num40++)
							{
								if (Main.tile[num39, num40].active())
								{
									int type5 = Main.tile[num39, num40].type;
									if (type5 == 22 || type5 == 23 || type5 == 24 || type5 == 25 || type5 == 32 || type5 == 112 || type5 == 163 || type5 == 636 || type5 == 661)
									{
										flag11 = true;
										break;
									}
								}
							}
						}
						if (flag11)
						{
							Main.tile[num37, num38].wall = 69;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num37, num38);
							}
						}
					}
				}
				else if (Main.tile[i, j].wall == 70 || (Main.tile[i, j].type == 109 && Main.tile[i, j].active()))
				{
					int num41 = i + genRand.Next(-2, 3);
					int num42 = j + genRand.Next(-2, 3);
					if (Main.tile[num41, num42].wall == 63 || Main.tile[num41, num42].wall == 65 || Main.tile[num41, num42].wall == 66 || Main.tile[num41, num42].wall == 68)
					{
						bool flag12 = false;
						for (int num43 = i - wallDist; num43 < i + wallDist; num43++)
						{
							for (int num44 = j - wallDist; num44 < j + wallDist; num44++)
							{
								if (Main.tile[num43, num44].active())
								{
									int type6 = Main.tile[num43, num44].type;
									if (type6 == 109 || type6 == 110 || type6 == 113 || type6 == 115 || type6 == 116 || type6 == 117 || type6 == 164)
									{
										flag12 = true;
										break;
									}
								}
							}
						}
						if (flag12)
						{
							Main.tile[num41, num42].wall = 70;
							if (Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, num41, num42);
							}
						}
					}
				}
				SpreadDesertWalls(wallDist, i, j);
			}
			if (!Main.tile[i, j].nactive())
			{
				return;
			}
			if (Main.tile[i, j].type == 61 && genRand.Next(3) == 0 && Main.tile[i, j].frameX < 144)
			{
				if (Main.rand.Next(4) == 0)
				{
					Main.tile[i, j].frameX = (short)(162 + genRand.Next(8) * 18);
				}
				Main.tile[i, j].type = 74;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j);
				}
			}
			if ((Main.tile[i, j].type == 60 || Main.tile[i, j].type == 62) && GrowMoreVines(i, j))
			{
				int maxValue5 = 30;
				if (Main.tile[i, j].type == 62)
				{
					maxValue5 = 10;
				}
				if (genRand.Next(maxValue5) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag13 = false;
				for (int num45 = j; num45 > j - 10; num45--)
				{
					if (Main.tile[i, num45].bottomSlope())
					{
						flag13 = false;
						break;
					}
					if (Main.tile[i, num45].active() && Main.tile[i, num45].type == 60 && !Main.tile[i, num45].bottomSlope())
					{
						flag13 = true;
						break;
					}
				}
				if (flag13)
				{
					int num46 = j + 1;
					Main.tile[i, num46].type = 62;
					Main.tile[i, num46].active(active: true);
					Main.tile[i, num46].CopyPaintAndCoating(Main.tile[i, num46 - 1]);
					SquareTileFrame(i, num46);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num46);
					}
				}
			}
			else if ((Main.tile[i, j].type == 633 || Main.tile[i, j].type == 638) && GrowMoreVines(i, j))
			{
				int maxValue6 = 70;
				if (Main.tile[i, j].type == 638)
				{
					maxValue6 = 7;
				}
				if (genRand.Next(maxValue6) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag14 = false;
				for (int num47 = j; num47 > j - 10; num47--)
				{
					if (Main.tile[i, num47].bottomSlope())
					{
						flag14 = false;
						break;
					}
					if (Main.tile[i, num47].active() && Main.tile[i, num47].type == 633 && !Main.tile[i, num47].bottomSlope())
					{
						flag14 = true;
						break;
					}
				}
				if (flag14)
				{
					int num48 = j + 1;
					Main.tile[i, num48].type = 638;
					Main.tile[i, num48].active(active: true);
					Main.tile[i, num48].CopyPaintAndCoating(Main.tile[i, num48 - 1]);
					SquareTileFrame(i, num48);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num48);
					}
				}
			}
			else
			{
				if ((Main.tile[i, j].type != 70 && Main.tile[i, j].type != 528) || !GrowMoreVines(i, j))
				{
					return;
				}
				int maxValue7 = 70;
				if (Main.tile[i, j].type == 528)
				{
					maxValue7 = 7;
				}
				if (genRand.Next(maxValue7) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
				{
					return;
				}
				bool flag15 = false;
				for (int num49 = j; num49 > j - 10; num49--)
				{
					if (Main.tile[i, num49].bottomSlope())
					{
						flag15 = false;
						break;
					}
					if (Main.tile[i, num49].active() && Main.tile[i, num49].type == 70 && !Main.tile[i, num49].bottomSlope())
					{
						flag15 = true;
						break;
					}
				}
				if (flag15)
				{
					int num50 = j + 1;
					Main.tile[i, num50].type = 528;
					Main.tile[i, num50].active(active: true);
					Main.tile[i, num50].CopyPaintAndCoating(Main.tile[i, num50 - 1]);
					SquareTileFrame(i, num50);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, num50);
					}
				}
			}
		}

		private static void GrowWeb(int i, int j)
		{
			if (genRand.Next(10) != 0)
			{
				return;
			}
			int num = genRand.Next(2, 4);
			int num2 = i - num;
			int num3 = i + num;
			int num4 = j - num;
			int num5 = j + num;
			bool flag = false;
			for (int k = num2; k <= num3; k++)
			{
				for (int l = num4; l <= num5; l++)
				{
					if (SolidTile(k, l))
					{
						flag = true;
						break;
					}
				}
			}
			if (flag && !Main.tile[i, j].active())
			{
				PlaceTile(i, j, 51, mute: true);
				TileFrame(i, j, resetFrame: true);
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, i, j, 1);
				}
			}
		}

		public static bool GeneratePlanteraBulbOnAllMechsDefeated()
		{
			bool num = (double)Main.dungeonX > (double)Main.maxTilesX * 0.5;
			int num2 = (int)(num ? ((double)Main.maxTilesX * 0.15) : ((double)Main.maxTilesX * 0.65));
			int num3 = (int)(num ? ((double)Main.maxTilesX * 0.35) : ((double)Main.maxTilesX * 0.85));
			int num4 = (int)Main.worldSurface;
			int underworldLayer = Main.UnderworldLayer;
			int width = num3 - num2;
			int height = underworldLayer - num4;
			Rectangle rectangle = new Rectangle(num2, num4, width, height);
			int num5 = 2500;
			while (num5 > 0)
			{
				bool flag = num5 < 500;
				bool flag2 = num5 < 200;
				num5--;
				Point point = new Point(rectangle.X + genRand.Next(rectangle.Width), rectangle.Y + genRand.Next(rectangle.Height));
				Tile tile = Main.tile[point.X, point.Y];
				int num6 = 500;
				bool flag3 = false;
				while (!flag3)
				{
					num6--;
					if (num6 <= 0)
					{
						flag3 = true;
					}
					point.Y--;
					if (point.Y < rectangle.Y)
					{
						break;
					}
					tile = Main.tile[point.X, point.Y];
					if (tile != null && (flag2 || tile.active()))
					{
						if (tile.type == 60)
						{
							flag3 = true;
						}
						else if (flag && tile.type == 59)
						{
							flag3 = true;
						}
					}
				}
				if (tile == null)
				{
					continue;
				}
				bool num7 = tile.active() || flag2;
				bool flag4 = tile.type == 60 || (flag && tile.type == 59);
				if (num7 && flag4)
				{
					if (AttemptToGeneratePlanteraBulbAt(point.X, point.Y - 1, flag))
					{
						return true;
					}
					if (AttemptToGeneratePlanteraBulbAt(point.X - 1, point.Y - 1, flag))
					{
						return true;
					}
					if (AttemptToGeneratePlanteraBulbAt(point.X + 1, point.Y - 1, flag))
					{
						return true;
					}
				}
			}
			return false;
		}

		private static bool AttemptToGeneratePlanteraBulbAt(int i, int j, bool forceBulb)
		{
			if (forceBulb)
			{
				int num = 0;
				for (int k = -2; k < 2; k++)
				{
					for (int l = -2; l < 2; l++)
					{
						int num2 = i + k;
						int num3 = j + l;
						Tile tile = Main.tile[num2, num3];
						if (tile.type == 59 || tile.type == 60)
						{
							num++;
						}
						else if (tile.active())
						{
							num--;
						}
						if (IsAContainer(tile) || tile.type == 226 || tile.type == 237 || tile.type == 10 || tile.type == 11 || tile.type == 26 || tile.type == 16 || tile.type == 15 || tile.type == 14 || tile.type == 104 || TileID.Sets.Paintings[tile.type] || tile.type == 158 || tile.type == 105 || tile.type == 531 || tile.type == 349 || tile.type == 138 || tile.type == 664 || tile.type == 665 || tile.type == 137 || tile.type == 443 || tile.type == 12 || tile.type == 665 || tile.type == 314)
						{
							num = -1;
							break;
						}
					}
					if (num <= -1)
					{
						break;
					}
				}
				if (num < 12)
				{
					return false;
				}
				for (int m = -2; m < 2; m++)
				{
					for (int n = -2; n < 2; n++)
					{
						int num4 = i + m;
						int num5 = j + n;
						bool num6 = m == -2 || m == 1 || n == -2 || n == 1;
						Tile tile2 = Main.tile[num4, num5];
						tile2.ClearTile();
						if (num6)
						{
							tile2.type = 60;
							tile2.active(active: true);
						}
						SquareTileFrame(num4, num5);
					}
				}
				PlaceJunglePlant(i, j, 238, 0, 0);
				if (Main.tile[i, j].type == 238)
				{
					SquareTileFrame(i, j);
					SquareTileFrame(i + 2, j);
					SquareTileFrame(i - 1, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j, 8);
					}
					return true;
				}
			}
			else
			{
				PlaceJunglePlant(i, j, 238, 0, 0);
				if (Main.tile[i, j].type == 238)
				{
					SquareTileFrame(i, j);
					SquareTileFrame(i + 2, j);
					SquareTileFrame(i - 1, j);
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, j, 5);
					}
					return true;
				}
			}
			return false;
		}

		private static void UpdateWorld_GrassGrowth(int i, int j, int minI, int maxI, int minJ, int maxJ, bool underground)
		{
			if (underground)
			{
				int type = Main.tile[i, j].type;
				int num = -1;
				int num2 = -1;
				int num3 = -1;
				int maxValue = 1;
				int num4 = type;
				int num5 = -1;
				switch (type)
				{
				case 23:
					num = 0;
					num2 = 59;
					num4 = 23;
					num5 = 661;
					num3 = 24;
					maxValue = 2;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 199:
					num = 0;
					num2 = 59;
					num4 = 199;
					num5 = 662;
					num3 = 201;
					maxValue = 2;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 661:
					num = 59;
					num2 = 0;
					num4 = 661;
					num5 = 23;
					num3 = 24;
					maxValue = 2;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 662:
					num = 59;
					num2 = 0;
					num4 = 662;
					num5 = 199;
					num3 = 201;
					maxValue = 2;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 60:
					num = 59;
					num3 = 61;
					maxValue = 10;
					break;
				case 70:
					num = 59;
					num3 = 71;
					maxValue = 10;
					break;
				case 633:
					num = 57;
					num3 = 637;
					maxValue = 2;
					break;
				}
				bool flag = false;
				if (num3 != -1 && !Main.tile[i, minJ].active() && genRand.Next(maxValue) == 0)
				{
					flag = true;
					if (PlaceTile(i, minJ, num3, mute: true))
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ);
					}
				}
				if (num != -1)
				{
					bool flag2 = false;
					TileColorCache color = Main.tile[i, j].BlockColorAndCoating();
					for (int k = minI; k < maxI; k++)
					{
						for (int l = minJ; l < maxJ; l++)
						{
							if ((i == k && j == l) || !Main.tile[k, l].active())
							{
								continue;
							}
							if (Main.tile[k, l].type == num)
							{
								SpreadGrass(k, l, num, num4, repeat: false, color);
								if (Main.tile[k, l].type == num4)
								{
									SquareTileFrame(k, l);
									flag2 = true;
								}
							}
							else if (num2 > -1 && num5 > -1 && Main.tile[k, l].type == num2)
							{
								SpreadGrass(k, l, num2, num5, repeat: false, color);
								if (Main.tile[k, l].type == num5)
								{
									SquareTileFrame(k, l);
									flag2 = true;
								}
							}
						}
					}
					if (Main.netMode == 2 && flag2)
					{
						NetMessage.SendTileSquare(-1, i, j, 3);
					}
				}
				switch (type)
				{
				case 60:
				{
					if (flag || genRand.Next(25) != 0 || Main.tile[i, minJ].liquid != 0)
					{
						break;
					}
					if (Main.hardMode && NPC.downedMechBoss1 && NPC.downedMechBoss2 && NPC.downedMechBoss3 && genRand.Next(60) == 0)
					{
						bool flag3 = true;
						int num6 = 150;
						for (int m = i - num6; m < i + num6; m += 2)
						{
							for (int n = j - num6; n < j + num6; n += 2)
							{
								if (m > 1 && m < Main.maxTilesX - 2 && n > 1 && n < Main.maxTilesY - 2 && Main.tile[m, n].active() && Main.tile[m, n].type == 238)
								{
									flag3 = false;
									break;
								}
							}
						}
						if (flag3)
						{
							PlaceJunglePlant(i, minJ, 238, 0, 0);
							SquareTileFrame(i, minJ);
							SquareTileFrame(i + 2, minJ);
							SquareTileFrame(i - 1, minJ);
							if (Main.tile[i, minJ].type == 238 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, minJ, 5);
							}
						}
					}
					int maxValue2 = (Main.expertMode ? 30 : 40);
					if (Main.hardMode && NPC.downedMechBossAny && genRand.Next(maxValue2) == 0)
					{
						bool flag4 = true;
						int num7 = 60;
						if (Main.expertMode)
						{
							num7 -= 10;
						}
						for (int num8 = i - num7; num8 < i + num7; num8 += 2)
						{
							for (int num9 = j - num7; num9 < j + num7; num9 += 2)
							{
								if (num8 > 1 && num8 < Main.maxTilesX - 2 && num9 > 1 && num9 < Main.maxTilesY - 2 && Main.tile[num8, num9].active() && Main.tile[num8, num9].type == 236)
								{
									flag4 = false;
									break;
								}
							}
						}
						if (flag4)
						{
							PlaceJunglePlant(i, minJ, 236, genRand.Next(3), 0);
							SquareTileFrame(i, minJ);
							SquareTileFrame(i + 1, minJ + 1);
							if (Main.tile[i, minJ].type == 236 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, minJ, 4);
							}
						}
						break;
					}
					PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0);
					if (Main.tile[i, minJ].type != 233)
					{
						break;
					}
					if (Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 4);
						break;
					}
					PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1);
					if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
					{
						NetMessage.SendTileSquare(-1, i, minJ, 3);
					}
					break;
				}
				case 70:
					if (Main.tile[i, j - 1].liquid > 0)
					{
						PlaceCatTail(i, j - 1);
					}
					if (genRand.Next(250) == 0 && GrowTree(i, j) && PlayerLOS(i, j))
					{
						TreeGrowFXCheck(i, j - 1);
					}
					break;
				}
				return;
			}
			int num10 = Main.tile[i, j].type;
			switch (num10)
			{
			case 2:
			case 23:
			case 32:
			case 109:
			case 199:
			case 352:
			case 477:
			case 492:
			case 661:
			case 662:
			{
				if (Main.halloween && genRand.Next(75) == 0 && (num10 == 2 || num10 == 109))
				{
					int num13 = 100;
					int num14 = 0;
					for (int num15 = i - num13; num15 < i + num13; num15 += 2)
					{
						for (int num16 = j - num13; num16 < j + num13; num16 += 2)
						{
							if (num15 > 1 && num15 < Main.maxTilesX - 2 && num16 > 1 && num16 < Main.maxTilesY - 2 && Main.tile[num15, num16].active() && Main.tile[num15, num16].type == 254)
							{
								num14++;
							}
						}
					}
					if (num14 < 6)
					{
						PlacePumpkin(i, minJ);
						if (Main.netMode == 2 && Main.tile[i, minJ].type == 254)
						{
							NetMessage.SendTileSquare(-1, i - 1, minJ - 1, 2, 2);
						}
					}
				}
				if (!Main.tile[i, minJ].active() && Main.tile[i, minJ].liquid == 0)
				{
					int num17 = -1;
					if (num10 == 2 && genRand.Next(12) == 0)
					{
						num17 = 3;
					}
					else if (num10 == 23 && genRand.Next(10) == 0)
					{
						num17 = 24;
					}
					else if (num10 == 199 && genRand.Next(10) == 0)
					{
						num17 = 201;
					}
					else if (num10 == 661 && genRand.Next(10) == 0)
					{
						num17 = 24;
					}
					else if (num10 == 662 && genRand.Next(10) == 0)
					{
						num17 = 201;
					}
					else if (num10 == 109 && genRand.Next(10) == 0)
					{
						num17 = 110;
					}
					else if (num10 == 633 && genRand.Next(10) == 0)
					{
						num17 = 637;
					}
					if (num17 != -1 && PlaceTile(i, minJ, num17, mute: true))
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ);
						}
					}
				}
				bool flag6 = false;
				switch (num10)
				{
				case 32:
					num10 = 23;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 352:
					num10 = 199;
					if (!AllowedToSpreadInfections)
					{
						return;
					}
					break;
				case 477:
					num10 = 2;
					break;
				case 492:
					num10 = 109;
					break;
				}
				int grass = num10;
				int num18 = -1;
				if (num10 == 23 || num10 == 661)
				{
					grass = 23;
					num18 = 661;
				}
				if (num10 == 199 || num10 == 662)
				{
					grass = 199;
					num18 = 662;
				}
				bool flag7 = AllowedToSpreadInfections && (num10 == 23 || num10 == 199 || num10 == 109 || num10 == 492 || num10 == 661 || num10 == 662);
				for (int num19 = minI; num19 < maxI; num19++)
				{
					for (int num20 = minJ; num20 < maxJ; num20++)
					{
						if ((i == num19 && j == num20) || !Main.tile[num19, num20].active())
						{
							continue;
						}
						int type2 = Main.tile[num19, num20].type;
						if (!flag7 && type2 != 0 && (num18 == -1 || type2 != 59))
						{
							continue;
						}
						TileColorCache color3 = Main.tile[i, j].BlockColorAndCoating();
						if (type2 == 0 || (num18 > -1 && type2 == 59) || ((num10 == 23 || num10 == 661 || num10 == 199 || num10 == 662) && (type2 == 2 || type2 == 109 || type2 == 477 || type2 == 492)))
						{
							SpreadGrass(num19, num20, 0, grass, repeat: false, color3);
							if (num18 > -1)
							{
								SpreadGrass(num19, num20, 59, num18, repeat: false, color3);
							}
							if (AllowedToSpreadInfections && (num10 == 23 || num10 == 199 || num10 == 661 || num10 == 662))
							{
								SpreadGrass(num19, num20, 2, grass, repeat: false, color3);
								SpreadGrass(num19, num20, 109, grass, repeat: false, color3);
								SpreadGrass(num19, num20, 477, grass, repeat: false, color3);
								SpreadGrass(num19, num20, 492, grass, repeat: false, color3);
								if (num18 > -1)
								{
									SpreadGrass(num19, num20, 60, num18, repeat: false, color3);
								}
							}
							if (Main.tile[num19, num20].type == num10 || (num18 > -1 && Main.tile[num19, num20].type == num18))
							{
								SquareTileFrame(num19, num20);
								flag6 = true;
							}
						}
						if (type2 == 0 || ((num10 == 109 || num10 == 492) && (type2 == 2 || type2 == 477 || type2 == 23 || type2 == 199)))
						{
							SpreadGrass(num19, num20, 0, grass, repeat: false, color3);
							if (num10 == 109)
							{
								SpreadGrass(num19, num20, 2, grass, repeat: false, color3);
							}
							switch (num10)
							{
							case 492:
								SpreadGrass(num19, num20, 477, grass, repeat: false, color3);
								break;
							case 109:
								SpreadGrass(num19, num20, 477, 492, repeat: false, color3);
								break;
							}
							if ((num10 == 492 || num10 == 109) && AllowedToSpreadInfections)
							{
								SpreadGrass(num19, num20, 23, 109, repeat: false, color3);
							}
							if ((num10 == 492 || num10 == 109) && AllowedToSpreadInfections)
							{
								SpreadGrass(num19, num20, 199, 109, repeat: false, color3);
							}
							if (Main.tile[num19, num20].type == num10)
							{
								SquareTileFrame(num19, num20);
								flag6 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag6)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			case 70:
			{
				if (!Main.tile[i, j].inActive())
				{
					if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
					{
						PlaceTile(i, minJ, 71, mute: true);
						if (Main.tile[i, minJ].active())
						{
							Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
						}
						if (Main.netMode == 2 && Main.tile[i, minJ].active())
						{
							NetMessage.SendTileSquare(-1, i, minJ);
						}
					}
					if (genRand.Next(300) == 0)
					{
						bool flag8 = PlayerLOS(i, j);
						if (GrowTree(i, j) && flag8)
						{
							TreeGrowFXCheck(i, j - 1);
						}
					}
				}
				bool flag9 = false;
				TileColorCache color4 = Main.tile[i, j].BlockColorAndCoating();
				for (int num21 = minI; num21 < maxI; num21++)
				{
					for (int num22 = minJ; num22 < maxJ; num22++)
					{
						if ((i != num21 || j != num22) && Main.tile[num21, num22].active() && Main.tile[num21, num22].type == 59)
						{
							SpreadGrass(num21, num22, 59, num10, repeat: false, color4);
							if (Main.tile[num21, num22].type == num10)
							{
								SquareTileFrame(num21, num22);
								flag9 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag9)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			case 60:
			{
				if (!Main.tile[i, minJ].active() && genRand.Next(7) == 0)
				{
					PlaceTile(i, minJ, 61, mute: true);
					if (Main.tile[i, minJ].active())
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ);
					}
				}
				else if (genRand.Next(500) == 0 && (!Main.tile[i, minJ].active() || Main.tile[i, minJ].type == 61 || Main.tile[i, minJ].type == 74 || Main.tile[i, minJ].type == 69))
				{
					if (GrowTree(i, j) && PlayerLOS(i, j))
					{
						TreeGrowFXCheck(i, j - 1);
					}
				}
				else if (genRand.Next(25) == 0 && Main.tile[i, minJ].liquid == 0)
				{
					PlaceJunglePlant(i, minJ, 233, genRand.Next(8), 0);
					if (Main.tile[i, minJ].type == 233)
					{
						if (Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, i, minJ, 4);
						}
						else
						{
							PlaceJunglePlant(i, minJ, 233, genRand.Next(12), 1);
							if (Main.tile[i, minJ].type == 233 && Main.netMode == 2)
							{
								NetMessage.SendTileSquare(-1, i, minJ, 3);
							}
						}
					}
				}
				bool flag10 = false;
				TileColorCache color5 = Main.tile[i, j].BlockColorAndCoating();
				for (int num23 = minI; num23 < maxI; num23++)
				{
					for (int num24 = minJ; num24 < maxJ; num24++)
					{
						if ((i != num23 || j != num24) && Main.tile[num23, num24].active() && Main.tile[num23, num24].type == 59)
						{
							SpreadGrass(num23, num24, 59, num10, repeat: false, color5);
							if (Main.tile[num23, num24].type == num10)
							{
								SquareTileFrame(num23, num24);
								flag10 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag10)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			case 633:
			{
				if (!Main.tile[i, minJ].active() && genRand.Next(10) == 0)
				{
					PlaceTile(i, minJ, 637, mute: true);
					if (Main.tile[i, minJ].active())
					{
						Main.tile[i, minJ].CopyPaintAndCoating(Main.tile[i, j]);
					}
					if (Main.netMode == 2 && Main.tile[i, minJ].active())
					{
						NetMessage.SendTileSquare(-1, i, minJ);
					}
				}
				TileColorCache color2 = Main.tile[i, j].BlockColorAndCoating();
				bool flag5 = false;
				for (int num11 = minI; num11 < maxI; num11++)
				{
					for (int num12 = minJ; num12 < maxJ; num12++)
					{
						if ((i != num11 || j != num12) && Main.tile[num11, num12].active() && Main.tile[num11, num12].type == 57)
						{
							SpreadGrass(num11, num12, 57, num10, repeat: false, color2);
							if (Main.tile[num11, num12].type == num10)
							{
								SquareTileFrame(num11, num12);
								flag5 = true;
							}
						}
					}
				}
				if (Main.netMode == 2 && flag5)
				{
					NetMessage.SendTileSquare(-1, i, j, 3);
				}
				break;
			}
			}
		}

		private static void TrySpawningTownNPC(int x, int y)
		{
			bool flag = Main.tileSolid[379];
			Main.tileSolid[379] = true;
			if (prioritizedTownNPCType > 0)
			{
				if (Main.tile[x, y].wall == 34)
				{
					if (Main.rand.Next(4) == 0)
					{
						SpawnTownNPC(x, y);
					}
				}
				else
				{
					SpawnTownNPC(x, y);
				}
			}
			Main.tileSolid[379] = flag;
		}

		public static void SpreadDesertWalls(int wallDist, int i, int j)
		{
			if (!WallID.Sets.Conversion.Sandstone[Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[Main.tile[i, j].wall])
			{
				return;
			}
			int num = 0;
			int wall = Main.tile[i, j].wall;
			int type = Main.tile[i, j].type;
			if (WallID.Sets.Corrupt[wall] || TileID.Sets.Corrupt[type])
			{
				num = 1;
			}
			if (WallID.Sets.Hallow[wall] || TileID.Sets.Hallow[type])
			{
				num = 2;
			}
			if (WallID.Sets.Crimson[wall] || TileID.Sets.Crimson[type])
			{
				num = 3;
			}
			if (num == 0)
			{
				return;
			}
			int num2 = i + genRand.Next(-2, 3);
			int num3 = j + genRand.Next(-2, 3);
			bool flag = false;
			if (WallID.Sets.Conversion.PureSand[Main.tile[num2, num3].wall])
			{
				switch (num)
				{
				case 3:
				{
					for (int m = i - wallDist; m < i + wallDist; m++)
					{
						for (int n = j - wallDist; n < j + wallDist; n++)
						{
							if (Main.tile[m, n].active() && TileID.Sets.Crimson[Main.tile[m, n].type])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					break;
				}
				case 2:
				{
					for (int num4 = i - wallDist; num4 < i + wallDist; num4++)
					{
						for (int num5 = j - wallDist; num5 < j + wallDist; num5++)
						{
							if (Main.tile[num4, num5].active() && TileID.Sets.Hallow[Main.tile[num4, num5].type])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					break;
				}
				case 1:
				{
					for (int k = i - wallDist; k < i + wallDist; k++)
					{
						for (int l = j - wallDist; l < j + wallDist; l++)
						{
							if (Main.tile[k, l].active() && TileID.Sets.Corrupt[Main.tile[k, l].type])
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							break;
						}
					}
					break;
				}
				}
			}
			if (!flag)
			{
				return;
			}
			ushort? num6 = null;
			if (WallID.Sets.Conversion.Sandstone[Main.tile[num2, num3].wall])
			{
				switch (num)
				{
				case 3:
					num6 = 221;
					break;
				case 2:
					num6 = 222;
					break;
				case 1:
					num6 = 220;
					break;
				}
			}
			if (WallID.Sets.Conversion.HardenedSand[Main.tile[num2, num3].wall])
			{
				switch (num)
				{
				case 3:
					num6 = 218;
					break;
				case 2:
					num6 = 219;
					break;
				case 1:
					num6 = 217;
					break;
				}
			}
			if (num6.HasValue && Main.tile[num2, num3].wall != num6.Value)
			{
				Main.tile[num2, num3].wall = num6.Value;
				if (Main.netMode == 2)
				{
					NetMessage.SendTileSquare(-1, num2, num3);
				}
			}
		}

		public static void PlaceWall(int i, int j, int type, bool mute = false)
		{
			if (i <= 1 || j <= 1 || i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2)
			{
				return;
			}
			if (Main.tile[i, j] == null)
			{
				Main.tile[i, j] = new Tile();
			}
			if (Main.tile[i, j].wall == 0)
			{
				Main.tile[i, j].wall = (ushort)type;
				SquareWallFrame(i, j);
				if (!mute)
				{
					SoundEngine.PlaySound(0, i * 16, j * 16);
				}
			}
		}

		public static void SpreadGrass(int i, int j, int dirt = 0, int grass = 2, bool repeat = true, TileColorCache color = default(TileColorCache))
		{
			try
			{
				if (!InWorld(i, j, 1) || !Main.tile[i, j].active() || Main.tile[i, j].type != dirt)
				{
					return;
				}
				if (gen && (grass == 199 || grass == 23))
				{
					int num = beachDistance;
					if ((!tenthAnniversaryWorldGen && (double)i > (double)Main.maxTilesX * 0.45 && (double)i <= (double)Main.maxTilesX * 0.55) || i < num || i >= Main.maxTilesX - num)
					{
						return;
					}
				}
				else if ((gen || (grass != 199 && grass != 23 && grass != 661 && grass != 662)) && (Main.tile[i, j].type != dirt || !Main.tile[i, j].active() || ((double)j >= Main.worldSurface && dirt == 0)) && !growGrassUnderground)
				{
					return;
				}
				int num2 = i - 1;
				int num3 = i + 2;
				int num4 = j - 1;
				int num5 = j + 2;
				if (num2 < 0)
				{
					num2 = 0;
				}
				if (num3 > Main.maxTilesX)
				{
					num3 = Main.maxTilesX;
				}
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesY)
				{
					num5 = Main.maxTilesY;
				}
				bool flag = true;
				for (int k = num2; k < num3; k++)
				{
					for (int l = num4; l < num5; l++)
					{
						if (!Main.tile[k, l].active() || !Main.tileSolid[Main.tile[k, l].type])
						{
							flag = false;
						}
						if (Main.tile[k, l].lava() && Main.tile[k, l].liquid > 0)
						{
							flag = true;
							break;
						}
					}
				}
				if (flag || !TileID.Sets.CanBeClearedDuringGeneration[Main.tile[i, j].type] || ((grass == 23 || grass == 661) && Main.tile[i, j - 1].type == 27) || ((grass == 199 || grass == 662) && Main.tile[i, j - 1].type == 27) || (grass == 109 && Main.tile[i, j - 1].type == 27))
				{
					return;
				}
				Main.tile[i, j].type = (ushort)grass;
				Main.tile[i, j].UseBlockColors(color);
				for (int m = num2; m < num3; m++)
				{
					for (int n = num4; n < num5; n++)
					{
						if (!Main.tile[m, n].active() || Main.tile[m, n].type != dirt)
						{
							continue;
						}
						try
						{
							if (repeat && grassSpread < 1000)
							{
								grassSpread++;
								SpreadGrass(m, n, dirt, grass);
								grassSpread--;
							}
						}
						catch
						{
						}
					}
				}
			}
			catch
			{
			}
		}

		public static void ChasmRunnerSideways(int i, int j, int direction, int steps)
		{
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_0138: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_027f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0280: Unknown result type (might be due to invalid IL or missing references)
			//IL_0281: Unknown result type (might be due to invalid IL or missing references)
			//IL_0286: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_0309: Unknown result type (might be due to invalid IL or missing references)
			//IL_032a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0373: Unknown result type (might be due to invalid IL or missing references)
			//IL_0394: Unknown result type (might be due to invalid IL or missing references)
			//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0412: Unknown result type (might be due to invalid IL or missing references)
			//IL_0428: Unknown result type (might be due to invalid IL or missing references)
			//IL_043d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0496: Unknown result type (might be due to invalid IL or missing references)
			//IL_04a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_05f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_06f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_06fa: Unknown result type (might be due to invalid IL or missing references)
			double num = steps;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(10, 21) * 0.1 * (double)direction;
			val2.Y = (double)genRand.Next(-10, 10) * 0.01;
			double num2 = genRand.Next(5) + 7;
			while (num2 > 0.0)
			{
				if (num > 0.0)
				{
					num2 += (double)genRand.Next(3);
					num2 -= (double)genRand.Next(3);
					if (num2 < 7.0)
					{
						num2 = 7.0;
					}
					if (num2 > 20.0)
					{
						num2 = 20.0;
					}
					if (num == 1.0 && num2 < 10.0)
					{
						num2 = 10.0;
					}
				}
				else
				{
					num2 -= (double)genRand.Next(4);
				}
				if (val.Y > Main.rockLayer && num > 0.0)
				{
					num = 0.0;
				}
				num -= 1.0;
				int num3 = (int)(val.X - num2 * 0.5);
				int num4 = (int)(val.X + num2 * 0.5);
				int num5 = (int)(val.Y - num2 * 0.5);
				int num6 = (int)(val.Y + num2 * 0.5);
				if (num3 < 0)
				{
					num3 = 0;
				}
				if (num4 > Main.maxTilesX - 1)
				{
					num4 = Main.maxTilesX - 1;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int k = num3; k < num4; k++)
				{
					for (int l = num5; l < num6; l++)
					{
						if (Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				val += val2;
				val2.Y += (double)genRand.Next(-10, 10) * 0.1;
				if (val.Y < (double)(j - 20))
				{
					val2.Y += (double)genRand.Next(20) * 0.01;
				}
				if (val.Y > (double)(j + 20))
				{
					val2.Y -= (double)genRand.Next(20) * 0.01;
				}
				if (val2.Y < -0.5)
				{
					val2.Y = -0.5;
				}
				if (val2.Y > 0.5)
				{
					val2.Y = 0.5;
				}
				val2.X += (double)genRand.Next(-10, 11) * 0.01;
				switch (direction)
				{
				case -1:
					if (val2.X > -0.5)
					{
						val2.X = -0.5;
					}
					if (val2.X < -2.0)
					{
						val2.X = -2.0;
					}
					break;
				case 1:
					if (val2.X < 0.5)
					{
						val2.X = 0.5;
					}
					if (val2.X > 2.0)
					{
						val2.X = 2.0;
					}
					break;
				}
				num3 = (int)(val.X - num2 * 1.1);
				num4 = (int)(val.X + num2 * 1.1);
				num5 = (int)(val.Y - num2 * 1.1);
				num6 = (int)(val.Y + num2 * 1.1);
				if (num3 < 1)
				{
					num3 = 1;
				}
				if (num4 > Main.maxTilesX - 1)
				{
					num4 = Main.maxTilesX - 1;
				}
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesY)
				{
					num6 = Main.maxTilesY;
				}
				for (int m = num3; m < num4; m++)
				{
					for (int n = num5; n < num6; n++)
					{
						if (Math.Abs((double)m - val.X) + Math.Abs((double)n - val.Y) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[m, n].wall != 3)
						{
							if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
							{
								Main.tile[m, n].active(active: true);
							}
							Main.tile[m, n].active(active: true);
							if (Main.tile[m, n].type != 31 && Main.tile[m, n].type != 22)
							{
								Main.tile[m, n].type = 25;
							}
							if (Main.tile[m, n].wall == 2)
							{
								Main.tile[m, n].wall = 0;
							}
						}
					}
				}
				for (int num7 = num3; num7 < num4; num7++)
				{
					for (int num8 = num5; num8 < num6; num8++)
					{
						if (Math.Abs((double)num7 - val.X) + Math.Abs((double)num8 - val.Y) < num2 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[num7, num8].wall != 3)
						{
							if (Main.tile[num7, num8].type != 31 && Main.tile[num7, num8].type != 22)
							{
								Main.tile[num7, num8].type = 25;
							}
							Main.tile[num7, num8].active(active: true);
							PlaceWall(num7, num8, 3, mute: true);
						}
					}
				}
			}
			if (genRand.Next(3) == 0)
			{
				int num9 = (int)val.X;
				int num10;
				for (num10 = (int)val.Y; !Main.tile[num9, num10].active(); num10++)
				{
				}
				TileRunner(num9, num10, genRand.Next(2, 6), genRand.Next(3, 7), 22);
			}
		}

		public static void CrimStart(int i, int j)
		{
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0144: Unknown result type (might be due to invalid IL or missing references)
			//IL_0191: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_0219: Unknown result type (might be due to invalid IL or missing references)
			//IL_0252: Unknown result type (might be due to invalid IL or missing references)
			//IL_0262: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0300: Unknown result type (might be due to invalid IL or missing references)
			//IL_0312: Unknown result type (might be due to invalid IL or missing references)
			//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0406: Unknown result type (might be due to invalid IL or missing references)
			//IL_0428: Unknown result type (might be due to invalid IL or missing references)
			//IL_044a: Unknown result type (might be due to invalid IL or missing references)
			//IL_044c: Unknown result type (might be due to invalid IL or missing references)
			//IL_044e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0453: Unknown result type (might be due to invalid IL or missing references)
			//IL_0455: Unknown result type (might be due to invalid IL or missing references)
			//IL_0490: Unknown result type (might be due to invalid IL or missing references)
			//IL_04a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_068b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0695: Unknown result type (might be due to invalid IL or missing references)
			//IL_0754: Unknown result type (might be due to invalid IL or missing references)
			//IL_0760: Unknown result type (might be due to invalid IL or missing references)
			//IL_0783: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_07c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_07e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0835: Unknown result type (might be due to invalid IL or missing references)
			//IL_0837: Unknown result type (might be due to invalid IL or missing references)
			//IL_0842: Unknown result type (might be due to invalid IL or missing references)
			//IL_0847: Unknown result type (might be due to invalid IL or missing references)
			//IL_08de: Unknown result type (might be due to invalid IL or missing references)
			//IL_08f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0bcd: Unknown result type (might be due to invalid IL or missing references)
			int crimDir = 1;
			int k = j;
			if ((double)k > Main.worldSurface)
			{
				k = (int)Main.worldSurface;
			}
			for (; !SolidTile(i, k); k++)
			{
			}
			int num = k;
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)i, (double)k);
			Vector2D val2 = default(Vector2D);
			((Vector2D)(ref val2))._002Ector((double)genRand.Next(-20, 21) * 0.1, (double)genRand.Next(20, 201) * 0.01);
			if (val2.X < 0.0)
			{
				crimDir = -1;
			}
			double num2 = genRand.Next(15, 26);
			bool flag = true;
			int num3 = 0;
			while (flag)
			{
				num2 += (double)genRand.Next(-50, 51) * 0.01;
				if (num2 < 15.0)
				{
					num2 = 15.0;
				}
				if (num2 > 25.0)
				{
					num2 = 25.0;
				}
				for (int l = (int)(val.X - num2 / 2.0); (double)l < val.X + num2 / 2.0; l++)
				{
					for (int m = (int)(val.Y - num2 / 2.0); (double)m < val.Y + num2 / 2.0; m++)
					{
						if (m > num)
						{
							if (Math.Abs((double)l - val.X) + Math.Abs((double)m - val.Y) < num2 * 0.3)
							{
								Main.tile[l, m].active(active: false);
								Main.tile[l, m].wall = 83;
							}
							else if (Math.Abs((double)l - val.X) + Math.Abs((double)m - val.Y) < num2 * 0.8 && Main.tile[l, m].wall != 83)
							{
								Main.tile[l, m].active(active: true);
								Main.tile[l, m].type = 203;
								if (Math.Abs((double)l - val.X) + Math.Abs((double)m - val.Y) < num2 * 0.6)
								{
									Main.tile[l, m].wall = 83;
								}
							}
						}
						else if (Math.Abs((double)l - val.X) + Math.Abs((double)m - val.Y) < num2 * 0.3 && Main.tile[l, m].active())
						{
							Main.tile[l, m].active(active: false);
							Main.tile[l, m].wall = 83;
						}
					}
				}
				if (val.X > (double)(i + 50))
				{
					num3 = -100;
				}
				if (val.X < (double)(i - 50))
				{
					num3 = 100;
				}
				if (num3 < 0)
				{
					val2.X -= (double)genRand.Next(20, 51) * 0.01;
				}
				else if (num3 > 0)
				{
					val2.X += (double)genRand.Next(20, 51) * 0.01;
				}
				else
				{
					val2.X += (double)genRand.Next(-50, 51) * 0.01;
				}
				val2.Y += (double)genRand.Next(-50, 51) * 0.01;
				if (val2.Y < 0.25)
				{
					val2.Y = 0.25;
				}
				if (val2.Y > 2.0)
				{
					val2.Y = 2.0;
				}
				if (val2.X < -2.0)
				{
					val2.X = -2.0;
				}
				if (val2.X > 2.0)
				{
					val2.X = 2.0;
				}
				val += val2;
				if (val.Y > Main.worldSurface + 100.0)
				{
					flag = false;
				}
			}
			num2 = genRand.Next(40, 55);
			for (int n = 0; n < 50; n++)
			{
				int num4 = (int)val.X + genRand.Next(-20, 21);
				int num5 = (int)val.Y + genRand.Next(-20, 21);
				for (int num6 = (int)((double)num4 - num2 / 2.0); (double)num6 < (double)num4 + num2 / 2.0; num6++)
				{
					for (int num7 = (int)((double)num5 - num2 / 2.0); (double)num7 < (double)num5 + num2 / 2.0; num7++)
					{
						double num8 = Math.Abs(num6 - num4);
						double num9 = Math.Abs(num7 - num5);
						double num10 = 1.0 + (double)genRand.Next(-20, 21) * 0.01;
						double num11 = 1.0 + (double)genRand.Next(-20, 21) * 0.01;
						double num12 = num8 * num10;
						num9 *= num11;
						double num13 = Math.Sqrt(num12 * num12 + num9 * num9);
						if (num13 < num2 * 0.25)
						{
							Main.tile[num6, num7].active(active: false);
							Main.tile[num6, num7].wall = 83;
						}
						else if (num13 < num2 * 0.4 && Main.tile[num6, num7].wall != 83)
						{
							Main.tile[num6, num7].active(active: true);
							Main.tile[num6, num7].type = 203;
							if (num13 < num2 * 0.35)
							{
								Main.tile[num6, num7].wall = 83;
							}
						}
					}
				}
			}
			int num14 = genRand.Next(5, 9);
			Vector2D[] array = (Vector2D[])(object)new Vector2D[num14];
			Vector2D val3 = default(Vector2D);
			for (int num15 = 0; num15 < num14; num15++)
			{
				int num16 = (int)val.X;
				int num17 = (int)val.Y;
				int num18 = 0;
				bool flag2 = true;
				((Vector2D)(ref val3))._002Ector((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
				while (flag2)
				{
					((Vector2D)(ref val3))._002Ector((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
					while (Math.Abs(val3.X) + Math.Abs(val3.Y) < 1.5)
					{
						((Vector2D)(ref val3))._002Ector((double)genRand.Next(-20, 21) * 0.15, (double)genRand.Next(0, 21) * 0.15);
					}
					flag2 = false;
					for (int num19 = 0; num19 < num15; num19++)
					{
						if (val2.X > array[num19].X - 0.75 && val2.X < array[num19].X + 0.75 && val2.Y > array[num19].Y - 0.75 && val2.Y < array[num19].Y + 0.75)
						{
							flag2 = true;
							num18++;
							break;
						}
					}
					if (num18 > 10000)
					{
						break;
					}
				}
				array[num15] = val3;
				CrimVein(new Vector2D((double)num16, (double)num17), val3);
			}
			int num20 = Main.maxTilesX;
			int num21 = 0;
			val.X = i;
			val.Y = num;
			num2 = genRand.Next(25, 35);
			double num22 = genRand.Next(0, 6);
			for (int num23 = 0; num23 < 50; num23++)
			{
				if (num22 > 0.0)
				{
					double num24 = (double)genRand.Next(10, 30) * 0.01;
					num22 -= num24;
					val.Y -= num24;
				}
				int num25 = (int)val.X + genRand.Next(-2, 3);
				int num26 = (int)val.Y + genRand.Next(-2, 3);
				for (int num27 = (int)((double)num25 - num2 / 2.0); (double)num27 < (double)num25 + num2 / 2.0; num27++)
				{
					for (int num28 = (int)((double)num26 - num2 / 2.0); (double)num28 < (double)num26 + num2 / 2.0; num28++)
					{
						double num29 = Math.Abs(num27 - num25);
						double num30 = Math.Abs(num28 - num26);
						double num31 = 1.0 + (double)genRand.Next(-20, 21) * 0.005;
						double num32 = 1.0 + (double)genRand.Next(-20, 21) * 0.005;
						double num33 = num29 * num31;
						num30 *= num32;
						double num34 = Math.Sqrt(num33 * num33 + num30 * num30);
						if (num34 < num2 * 0.2 * ((double)genRand.Next(90, 111) * 0.01))
						{
							Main.tile[num27, num28].active(active: false);
							Main.tile[num27, num28].wall = 83;
						}
						else
						{
							if (!(num34 < num2 * 0.45))
							{
								continue;
							}
							if (num27 < num20)
							{
								num20 = num27;
							}
							if (num27 > num21)
							{
								num21 = num27;
							}
							if (Main.tile[num27, num28].wall != 83)
							{
								Main.tile[num27, num28].active(active: true);
								Main.tile[num27, num28].type = 203;
								if (num34 < num2 * 0.35)
								{
									Main.tile[num27, num28].wall = 83;
								}
							}
						}
					}
				}
			}
			for (int num35 = num20; num35 <= num21; num35++)
			{
				int num36;
				for (num36 = num; (Main.tile[num35, num36].type == 203 && Main.tile[num35, num36].active()) || Main.tile[num35, num36].wall == 83; num36++)
				{
				}
				int num37 = genRand.Next(15, 20);
				for (; !Main.tile[num35, num36].active(); num36++)
				{
					if (num37 <= 0)
					{
						break;
					}
					if (Main.tile[num35, num36].wall == 83)
					{
						break;
					}
					num37--;
					Main.tile[num35, num36].type = 203;
					Main.tile[num35, num36].active(active: true);
				}
			}
			CrimEnt(val, crimDir);
		}

		public static void CrimPlaceHearts()
		{
			int num = 16;
			for (int i = 0; i < heartCount; i++)
			{
				num = genRand.Next(16, 21);
				int x = heartPos[i].X;
				int y = heartPos[i].Y;
				for (int j = x - num / 2; j < x + num / 2; j++)
				{
					for (int k = y - num / 2; k < y + num / 2; k++)
					{
						double num2 = Math.Abs(j - x);
						double num3 = Math.Abs(k - y);
						if (Math.Sqrt(num2 * num2 + num3 * num3) < (double)num * 0.4)
						{
							Main.tile[j, k].active(active: true);
							Main.tile[j, k].type = 203;
							Main.tile[j, k].wall = 83;
						}
					}
				}
			}
			for (int l = 0; l < heartCount; l++)
			{
				num = genRand.Next(10, 14);
				int x2 = heartPos[l].X;
				int y2 = heartPos[l].Y;
				for (int m = x2 - num / 2; m < x2 + num / 2; m++)
				{
					for (int n = y2 - num / 2; n < y2 + num / 2; n++)
					{
						double num4 = Math.Abs(m - x2);
						double num5 = Math.Abs(n - y2);
						if (Math.Sqrt(num4 * num4 + num5 * num5) < (double)num * 0.3)
						{
							Main.tile[m, n].active(active: false);
							Main.tile[m, n].wall = 83;
						}
					}
				}
			}
			for (int num6 = 0; num6 < heartCount; num6++)
			{
				AddShadowOrb(heartPos[num6].X, heartPos[num6].Y);
			}
		}

		public static void CrimEnt(Vector2D position, int crimDir)
		{
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
			double num = 0.0;
			double num2 = genRand.Next(6, 11);
			bool flag = true;
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector(2.0, (double)genRand.Next(-20, 0) * 0.01);
			val.X *= -crimDir;
			while (flag)
			{
				num += 1.0;
				if (num >= 20.0)
				{
					flag = false;
				}
				num2 += (double)genRand.Next(-10, 11) * 0.02;
				if (num2 < 6.0)
				{
					num2 = 6.0;
				}
				if (num2 > 10.0)
				{
					num2 = 10.0;
				}
				for (int i = (int)(position.X - num2 / 2.0); (double)i < position.X + num2 / 2.0; i++)
				{
					for (int j = (int)(position.Y - num2 / 2.0); (double)j < position.Y + num2 / 2.0; j++)
					{
						double num3 = Math.Abs((double)i - position.X);
						double num4 = Math.Abs((double)j - position.Y);
						if (Math.Sqrt(num3 * num3 + num4 * num4) < num2 * 0.5 && Main.tile[i, j].active() && Main.tile[i, j].type == 203)
						{
							Main.tile[i, j].active(active: false);
							flag = true;
							num = 0.0;
						}
					}
				}
				position += val;
			}
		}

		public static void CrimVein(Vector2D position, Vector2D velocity)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_022c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0232: Unknown result type (might be due to invalid IL or missing references)
			//IL_0246: Unknown result type (might be due to invalid IL or missing references)
			//IL_025b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0261: Unknown result type (might be due to invalid IL or missing references)
			//IL_0275: Unknown result type (might be due to invalid IL or missing references)
			//IL_028a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0290: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0303: Unknown result type (might be due to invalid IL or missing references)
			//IL_0309: Unknown result type (might be due to invalid IL or missing references)
			//IL_032d: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(15, 26);
			bool flag = true;
			Vector2D val = velocity;
			Vector2D val2 = position;
			int num2 = genRand.Next(100, 150);
			if (velocity.Y < 0.0)
			{
				num2 -= 25;
			}
			while (flag)
			{
				num += (double)genRand.Next(-50, 51) * 0.02;
				if (num < 15.0)
				{
					num = 15.0;
				}
				if (num > 25.0)
				{
					num = 25.0;
				}
				for (int i = (int)(position.X - num / 2.0); (double)i < position.X + num / 2.0; i++)
				{
					for (int j = (int)(position.Y - num / 2.0); (double)j < position.Y + num / 2.0; j++)
					{
						double num3 = Math.Abs((double)i - position.X);
						double num4 = Math.Abs((double)j - position.Y);
						double num5 = Math.Sqrt(num3 * num3 + num4 * num4);
						if (num5 < num * 0.2)
						{
							Main.tile[i, j].active(active: false);
							Main.tile[i, j].wall = 83;
						}
						else if (num5 < num * 0.5 && Main.tile[i, j].wall != 83)
						{
							Main.tile[i, j].active(active: true);
							Main.tile[i, j].type = 203;
							if (num5 < num * 0.4)
							{
								Main.tile[i, j].wall = 83;
							}
						}
					}
				}
				velocity.X += (double)genRand.Next(-50, 51) * 0.05;
				velocity.Y += (double)genRand.Next(-50, 51) * 0.05;
				if (velocity.Y < val.Y - 0.75)
				{
					velocity.Y = val.Y - 0.75;
				}
				if (velocity.Y > val.Y + 0.75)
				{
					velocity.Y = val.Y + 0.75;
				}
				if (velocity.X < val.X - 0.75)
				{
					velocity.X = val.X - 0.75;
				}
				if (velocity.X > val.X + 0.75)
				{
					velocity.X = val.X + 0.75;
				}
				position += velocity;
				if (Math.Abs(position.X - val2.X) + Math.Abs(position.Y - val2.Y) > (double)num2)
				{
					flag = false;
				}
			}
			heartPos[heartCount] = position.ToPoint();
			heartCount++;
		}

		public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false)
		{
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0165: Unknown result type (might be due to invalid IL or missing references)
			//IL_017e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0185: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_026d: Unknown result type (might be due to invalid IL or missing references)
			//IL_027c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0328: Unknown result type (might be due to invalid IL or missing references)
			//IL_035f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0366: Unknown result type (might be due to invalid IL or missing references)
			//IL_038f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0399: Unknown result type (might be due to invalid IL or missing references)
			//IL_03af: Unknown result type (might be due to invalid IL or missing references)
			//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_045d: Unknown result type (might be due to invalid IL or missing references)
			//IL_045e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0460: Unknown result type (might be due to invalid IL or missing references)
			//IL_0465: Unknown result type (might be due to invalid IL or missing references)
			//IL_048a: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_04e4: Unknown result type (might be due to invalid IL or missing references)
			//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
			//IL_0510: Unknown result type (might be due to invalid IL or missing references)
			//IL_056f: Unknown result type (might be due to invalid IL or missing references)
			//IL_057e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0676: Unknown result type (might be due to invalid IL or missing references)
			//IL_0685: Unknown result type (might be due to invalid IL or missing references)
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			if (!makeOrb)
			{
				flag2 = true;
			}
			double num = steps;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(11) * 0.2 + 0.5;
			int num2 = 5;
			double num3 = genRand.Next(5) + 7;
			while (num3 > 0.0)
			{
				if (num > 0.0)
				{
					num3 += (double)genRand.Next(3);
					num3 -= (double)genRand.Next(3);
					if (num3 < 7.0)
					{
						num3 = 7.0;
					}
					if (num3 > 20.0)
					{
						num3 = 20.0;
					}
					if (num == 1.0 && num3 < 10.0)
					{
						num3 = 10.0;
					}
				}
				else if (val.Y > Main.worldSurface + 45.0)
				{
					num3 -= (double)genRand.Next(4);
				}
				if (val.Y > Main.rockLayer && num > 0.0)
				{
					num = 0.0;
				}
				num -= 1.0;
				if (!flag && val.Y > Main.worldSurface + 20.0)
				{
					flag = true;
					ChasmRunnerSideways((int)val.X, (int)val.Y, -1, genRand.Next(20, 40));
					ChasmRunnerSideways((int)val.X, (int)val.Y, 1, genRand.Next(20, 40));
				}
				int num4;
				int num5;
				int num6;
				int num7;
				if (num > (double)num2)
				{
					num4 = (int)(val.X - num3 * 0.5);
					num5 = (int)(val.X + num3 * 0.5);
					num6 = (int)(val.Y - num3 * 0.5);
					num7 = (int)(val.Y + num3 * 0.5);
					if (num4 < 0)
					{
						num4 = 0;
					}
					if (num5 > Main.maxTilesX - 1)
					{
						num5 = Main.maxTilesX - 1;
					}
					if (num6 < 0)
					{
						num6 = 0;
					}
					if (num7 > Main.maxTilesY)
					{
						num7 = Main.maxTilesY;
					}
					for (int k = num4; k < num5; k++)
					{
						for (int l = num6; l < num7; l++)
						{
							if (Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < num3 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].type != 31 && Main.tile[k, l].type != 22)
							{
								Main.tile[k, l].active(active: false);
							}
						}
					}
				}
				if (num <= 2.0 && val.Y < Main.worldSurface + 45.0)
				{
					num = 2.0;
				}
				if (num <= 0.0)
				{
					if (!flag2)
					{
						flag2 = true;
						AddShadowOrb((int)val.X, (int)val.Y);
					}
					else if (!flag3)
					{
						flag3 = false;
						bool flag4 = false;
						int num8 = 0;
						while (!flag4)
						{
							int num9 = genRand.Next((int)val.X - 25, (int)val.X + 25);
							int num10 = genRand.Next((int)val.Y - 50, (int)val.Y);
							if (num9 < 5)
							{
								num9 = 5;
							}
							if (num9 > Main.maxTilesX - 5)
							{
								num9 = Main.maxTilesX - 5;
							}
							if (num10 < 5)
							{
								num10 = 5;
							}
							if (num10 > Main.maxTilesY - 5)
							{
								num10 = Main.maxTilesY - 5;
							}
							if ((double)num10 > Main.worldSurface)
							{
								if (!IsTileNearby(num9, num10, 26, 3))
								{
									Place3x2(num9, num10, 26);
								}
								if (Main.tile[num9, num10].type == 26)
								{
									flag4 = true;
									continue;
								}
								num8++;
								if (num8 >= 10000)
								{
									flag4 = true;
								}
							}
							else
							{
								flag4 = true;
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.01;
				if (val2.X > 0.3)
				{
					val2.X = 0.3;
				}
				if (val2.X < -0.3)
				{
					val2.X = -0.3;
				}
				num4 = (int)(val.X - num3 * 1.1);
				num5 = (int)(val.X + num3 * 1.1);
				num6 = (int)(val.Y - num3 * 1.1);
				num7 = (int)(val.Y + num3 * 1.1);
				if (num4 < 1)
				{
					num4 = 1;
				}
				if (num5 > Main.maxTilesX - 1)
				{
					num5 = Main.maxTilesX - 1;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				for (int m = num4; m < num5; m++)
				{
					for (int n = num6; n < num7; n++)
					{
						if (Math.Abs((double)m - val.X) + Math.Abs((double)n - val.Y) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
						{
							if (Main.tile[m, n].type != 25 && n > j + genRand.Next(3, 20))
							{
								Main.tile[m, n].active(active: true);
							}
							if (steps <= num2)
							{
								Main.tile[m, n].active(active: true);
							}
							if (Main.tile[m, n].type != 31)
							{
								Main.tile[m, n].type = 25;
							}
						}
					}
				}
				for (int num11 = num4; num11 < num5; num11++)
				{
					for (int num12 = num6; num12 < num7; num12++)
					{
						if (Math.Abs((double)num11 - val.X) + Math.Abs((double)num12 - val.Y) < num3 * 1.1 * (1.0 + (double)genRand.Next(-10, 11) * 0.015))
						{
							if (Main.tile[num11, num12].type != 31)
							{
								Main.tile[num11, num12].type = 25;
							}
							if (steps <= num2)
							{
								Main.tile[num11, num12].active(active: true);
							}
							if (num12 > j + genRand.Next(3, 20))
							{
								Main.tile[num11, num12].wall = 3;
							}
						}
					}
				}
			}
		}

		public static void SpawnPlanteraThorns(Vector2 position)
		{
			if (Main.netMode == 1)
			{
				return;
			}
			int num = Main.rand.Next(3, 6);
			for (int i = 0; i < num; i++)
			{
				int num2 = Main.rand.Next(15, 31);
				int num3 = (int)(position.X / 16f);
				int num4 = (int)(position.Y / 16f);
				int num5 = 0;
				int num6 = 0;
				if (Main.rand.Next(2) != 0)
				{
					num6 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
				}
				else
				{
					num5 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
				}
				while (num2 > 0)
				{
					num2--;
					if (!Main.tile[num3, num4].active())
					{
						PlaceTile(num3, num4, 655);
						if (Main.tile[num3, num4].active() && Main.netMode == 2)
						{
							NetMessage.SendTileSquare(-1, num3, num4);
						}
					}
					num3 += num5;
					num4 += num6;
					if (!InWorld(num3, num4))
					{
						return;
					}
					if (Main.rand.Next(5) == 0)
					{
						if (num6 == 0)
						{
							num5 = 0;
							num6 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
						}
						else
						{
							num6 = 0;
							num5 = ((Main.rand.Next(2) == 0) ? 1 : (-1));
						}
					}
				}
			}
		}

		public static void GERunner(int i, int j, double speedX = 0.0, double speedY = 0.0, bool good = true)
		{
			//IL_0129: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_016b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e2d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e2e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e2f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e34: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e59: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e7e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ea3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0eaf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ebb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ecc: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			for (int k = 20; k < Main.maxTilesX - 20; k++)
			{
				for (int l = 20; l < Main.maxTilesY - 20; l++)
				{
					if (Main.tile[k, l].active() && Main.tile[k, l].type == 225)
					{
						num++;
					}
				}
			}
			bool flag = false;
			if (num > 200000)
			{
				flag = true;
			}
			int num2 = genRand.Next(200, 250);
			double num3 = (double)Main.maxTilesX / 4200.0;
			num2 = (int)((double)num2 * num3);
			double num4 = num2;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-10, 11) * 0.1;
			if (speedX != 0.0 || speedY != 0.0)
			{
				val2.X = speedX;
				val2.Y = speedY;
			}
			bool flag2 = true;
			while (flag2)
			{
				int num5 = (int)(val.X - num4 * 0.5);
				int num6 = (int)(val.X + num4 * 0.5);
				int num7 = (int)(val.Y - num4 * 0.5);
				int num8 = (int)(val.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY - 5)
				{
					num8 = Main.maxTilesY - 5;
				}
				for (int m = num5; m < num6; m++)
				{
					for (int n = num7; n < num8; n++)
					{
						if (!(Math.Abs((double)m - val.X) + Math.Abs((double)n - val.Y) < (double)num2 * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
						{
							continue;
						}
						if (good)
						{
							if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68 || Main.tile[m, n].wall == 69 || Main.tile[m, n].wall == 81)
							{
								Main.tile[m, n].wall = 70;
							}
							else if (Main.tile[m, n].wall == 216)
							{
								Main.tile[m, n].wall = 219;
							}
							else if (Main.tile[m, n].wall == 187)
							{
								Main.tile[m, n].wall = 222;
							}
							else if (Main.tile[m, n].wall == 3 || Main.tile[m, n].wall == 83)
							{
								Main.tile[m, n].wall = 28;
							}
							if (flag && Main.tile[m, n].type == 225)
							{
								Main.tile[m, n].type = 117;
								SquareTileFrame(m, n);
							}
							else if (flag && Main.tile[m, n].type == 230)
							{
								Main.tile[m, n].type = 402;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 2)
							{
								Main.tile[m, n].type = 109;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 25 || Main.tile[m, n].type == 203)
							{
								Main.tile[m, n].type = 117;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 112 || Main.tile[m, n].type == 234)
							{
								Main.tile[m, n].type = 116;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 661 || Main.tile[m, n].type == 662)
							{
								Main.tile[m, n].type = 60;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 23 || Main.tile[m, n].type == 199)
							{
								Main.tile[m, n].type = 109;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 163 || Main.tile[m, n].type == 200)
							{
								Main.tile[m, n].type = 164;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 396)
							{
								Main.tile[m, n].type = 403;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 397)
							{
								Main.tile[m, n].type = 402;
								SquareTileFrame(m, n);
							}
						}
						else if (crimson)
						{
							if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
							{
								Main.tile[m, n].wall = 81;
							}
							else if (Main.tile[m, n].wall == 216)
							{
								Main.tile[m, n].wall = 218;
							}
							else if (Main.tile[m, n].wall == 187)
							{
								Main.tile[m, n].wall = 221;
							}
							if (flag && Main.tile[m, n].type == 225)
							{
								Main.tile[m, n].type = 203;
								SquareTileFrame(m, n);
							}
							else if (flag && Main.tile[m, n].type == 230)
							{
								Main.tile[m, n].type = 399;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 60 || Main.tile[m, n].type == 661)
							{
								Main.tile[m, n].type = 662;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 2 || Main.tile[m, n].type == 109)
							{
								Main.tile[m, n].type = 199;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 117)
							{
								Main.tile[m, n].type = 203;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 116)
							{
								Main.tile[m, n].type = 234;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
							{
								Main.tile[m, n].type = 200;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 396)
							{
								Main.tile[m, n].type = 401;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 397)
							{
								Main.tile[m, n].type = 399;
								SquareTileFrame(m, n);
							}
						}
						else
						{
							if (Main.tile[m, n].wall == 63 || Main.tile[m, n].wall == 65 || Main.tile[m, n].wall == 66 || Main.tile[m, n].wall == 68)
							{
								Main.tile[m, n].wall = 69;
							}
							else if (Main.tile[m, n].wall == 216)
							{
								Main.tile[m, n].wall = 217;
							}
							else if (Main.tile[m, n].wall == 187)
							{
								Main.tile[m, n].wall = 220;
							}
							if (flag && Main.tile[m, n].type == 225)
							{
								Main.tile[m, n].type = 25;
								SquareTileFrame(m, n);
							}
							else if (flag && Main.tile[m, n].type == 230)
							{
								Main.tile[m, n].type = 398;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 60 || Main.tile[m, n].type == 662)
							{
								Main.tile[m, n].type = 661;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 2 || Main.tile[m, n].type == 109)
							{
								Main.tile[m, n].type = 23;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 1 || Main.tile[m, n].type == 117)
							{
								Main.tile[m, n].type = 25;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 53 || Main.tile[m, n].type == 123 || Main.tile[m, n].type == 116)
							{
								Main.tile[m, n].type = 112;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 161 || Main.tile[m, n].type == 164)
							{
								Main.tile[m, n].type = 163;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 396)
							{
								Main.tile[m, n].type = 400;
								SquareTileFrame(m, n);
							}
							else if (Main.tile[m, n].type == 397)
							{
								Main.tile[m, n].type = 398;
								SquareTileFrame(m, n);
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > speedX + 1.0)
				{
					val2.X = speedX + 1.0;
				}
				if (val2.X < speedX - 1.0)
				{
					val2.X = speedX - 1.0;
				}
				if (val.X < (double)(-num2) || val.Y < (double)(-num2) || val.X > (double)(Main.maxTilesX + num2) || val.Y > (double)(Main.maxTilesY + num2))
				{
					flag2 = false;
				}
			}
		}

		private static bool badOceanCaveTiles(int x, int y)
		{
			if (Main.tile[x, y].wall == 83 || Main.tile[x, y].wall == 3 || Main.wallDungeon[Main.tile[x, y].wall] || Main.tile[x, y].type == 203 || Main.tile[x, y].type == 25 || Main.tileDungeon[Main.tile[x, y].type] || Main.tile[x, y].type == 26 || Main.tile[x, y].type == 31)
			{
				return true;
			}
			return false;
		}

		public static void oceanCave(int i, int j)
		{
			//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_020f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0225: Unknown result type (might be due to invalid IL or missing references)
			//IL_023b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_035b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0366: Unknown result type (might be due to invalid IL or missing references)
			//IL_037a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0382: Unknown result type (might be due to invalid IL or missing references)
			//IL_0399: Unknown result type (might be due to invalid IL or missing references)
			//IL_043c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0452: Unknown result type (might be due to invalid IL or missing references)
			//IL_04c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_0515: Unknown result type (might be due to invalid IL or missing references)
			//IL_0713: Unknown result type (might be due to invalid IL or missing references)
			//IL_071f: Unknown result type (might be due to invalid IL or missing references)
			//IL_079f: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_07fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0824: Unknown result type (might be due to invalid IL or missing references)
			//IL_0836: Unknown result type (might be due to invalid IL or missing references)
			//IL_085d: Unknown result type (might be due to invalid IL or missing references)
			//IL_086d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0894: Unknown result type (might be due to invalid IL or missing references)
			//IL_08bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_08fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0922: Unknown result type (might be due to invalid IL or missing references)
			//IL_095d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0998: Unknown result type (might be due to invalid IL or missing references)
			//IL_09ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_09cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f2: Unknown result type (might be due to invalid IL or missing references)
			if (GenVars.numOceanCaveTreasure >= GenVars.maxOceanCaveTreasure)
			{
				GenVars.numOceanCaveTreasure = 0;
			}
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			if (i < Main.maxTilesX / 2)
			{
				val2.X = 0.25 + genRand.NextDouble() * 0.25;
			}
			else
			{
				val2.X = -0.35 - genRand.NextDouble() * 0.5;
			}
			val2.Y = 0.4 + genRand.NextDouble() * 0.25;
			ushort num = 264;
			ushort num2 = 53;
			ushort num3 = 397;
			double num4 = genRand.Next(17, 25);
			double num5 = genRand.Next(600, 800);
			double num6 = 4.0;
			bool flag = true;
			while (num4 > num6 && num5 > 0.0)
			{
				bool flag2 = true;
				bool flag3 = true;
				bool flag4 = true;
				if (val.X > (double)(beachDistance - 50) && val.X < (double)(Main.maxTilesX - beachDistance + 50))
				{
					num4 *= 0.96;
					num5 *= 0.96;
				}
				if (num4 < num6 + 2.0 || num5 < 20.0)
				{
					flag4 = false;
				}
				if (flag)
				{
					num4 -= 0.01 + genRand.NextDouble() * 0.01;
					num5 -= 0.5;
				}
				else
				{
					num4 -= 0.02 + genRand.NextDouble() * 0.02;
					num5 -= 1.0;
				}
				if (flag4)
				{
					GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].X = (int)val.X;
					GenVars.oceanCaveTreasure[GenVars.numOceanCaveTreasure].Y = (int)val.Y;
				}
				int num7 = (int)(val.X - num4 * 3.0);
				int num8 = (int)(val.X + num4 * 3.0);
				int num9 = (int)(val.Y - num4 * 3.0);
				int num10 = (int)(val.Y + num4 * 3.0);
				if (num7 < 1)
				{
					num7 = 1;
				}
				if (num8 > Main.maxTilesX - 1)
				{
					num8 = Main.maxTilesX - 1;
				}
				if (num9 < 1)
				{
					num9 = 1;
				}
				if (num10 > Main.maxTilesY - 1)
				{
					num10 = Main.maxTilesY - 1;
				}
				for (int k = num7; k < num8; k++)
				{
					for (int l = num9; l < num10; l++)
					{
						if (badOceanCaveTiles(k, l))
						{
							continue;
						}
						Vector2D val3 = new Vector2D(Math.Abs((double)k - val.X), Math.Abs((double)l - val.Y));
						double num11 = ((Vector2D)(ref val3)).Length();
						if (flag4 && num11 < num4 * 0.5 + 1.0)
						{
							Main.tile[k, l].type = num;
							Main.tile[k, l].active(active: false);
						}
						else if (num11 < num4 * 1.5 + 1.0 && Main.tile[k, l].type != num)
						{
							if ((double)l < val.Y)
							{
								if ((val2.X < 0.0 && (double)k < val.X) || (val2.X > 0.0 && (double)k > val.X))
								{
									if (num11 < num4 * 1.1 + 1.0)
									{
										Main.tile[k, l].type = num3;
										if (Main.tile[k, l].liquid == byte.MaxValue)
										{
											Main.tile[k, l].wall = 0;
										}
									}
									else if (Main.tile[k, l].type != num3)
									{
										Main.tile[k, l].type = num2;
									}
								}
							}
							else if ((val2.X < 0.0 && k < i) || (val2.X > 0.0 && k > i))
							{
								if (Main.tile[k, l].liquid == byte.MaxValue)
								{
									Main.tile[k, l].wall = 0;
								}
								Main.tile[k, l].type = num2;
								Main.tile[k, l].active(active: true);
								if (k == (int)val.X && flag2)
								{
									flag2 = false;
									int num12 = 50 + genRand.Next(3);
									int num13 = 43 + genRand.Next(3);
									int num14 = 20 + genRand.Next(3);
									int num15 = k;
									int num16 = k + num14;
									if (val2.X < 0.0)
									{
										num15 = k - num14;
										num16 = k;
									}
									if (num5 < 100.0)
									{
										num12 = (int)((double)num12 * (num5 / 100.0));
										num13 = (int)((double)num13 * (num5 / 100.0));
										num14 = (int)((double)num14 * (num5 / 100.0));
									}
									if (num4 < num6 + 5.0)
									{
										double num17 = (num4 - num6) / 5.0;
										num12 = (int)((double)num12 * num17);
										num13 = (int)((double)num13 * num17);
										num14 = (int)((double)num14 * num17);
									}
									for (int m = num15; m <= num16; m++)
									{
										for (int n = l; n < l + num12 && !badOceanCaveTiles(m, n); n++)
										{
											if (n > l + num13)
											{
												if (SolidTile(m, n) && Main.tile[m, n].type != num2)
												{
													break;
												}
												Main.tile[m, n].type = num3;
											}
											else
											{
												Main.tile[m, n].type = num2;
											}
											Main.tile[m, n].active(active: true);
											if (genRand.Next(3) == 0)
											{
												Main.tile[m - 1, n].type = num2;
												Main.tile[m - 1, n].active(active: true);
											}
											if (genRand.Next(3) == 0)
											{
												Main.tile[m + 1, n].type = num2;
												Main.tile[m + 1, n].active(active: true);
											}
										}
									}
								}
							}
						}
						if (num11 < num4 * 1.3 + 1.0 && l > j - 10)
						{
							Main.tile[k, l].liquid = byte.MaxValue;
						}
						if (!flag3 || k != (int)val.X || !((double)l > val.Y))
						{
							continue;
						}
						flag3 = false;
						int num18 = 100;
						int num19 = 2;
						for (int num20 = k - num19; num20 <= k + num19; num20++)
						{
							for (int num21 = l; num21 < l + num18; num21++)
							{
								if (!badOceanCaveTiles(num20, num21))
								{
									Main.tile[num20, num21].liquid = byte.MaxValue;
								}
							}
						}
					}
				}
				val += val2;
				val2.X += genRand.NextDouble() * 0.1 - 0.05;
				val2.Y += genRand.NextDouble() * 0.1 - 0.05;
				if (flag)
				{
					if (val.Y > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 && val.Y > (double)(j + 30))
					{
						flag = false;
					}
					val2.Y = Utils.Clamp(val2.Y, 0.35, 1.0);
				}
				else
				{
					if (val.X < (double)(Main.maxTilesX / 2))
					{
						if (val2.X < 0.5)
						{
							val2.X += 0.02;
						}
					}
					else if (val2.X > -0.5)
					{
						val2.X -= 0.02;
					}
					if (!flag4)
					{
						if (val2.Y < 0.0)
						{
							val2.Y *= 0.95;
						}
						val2.Y += 0.04;
					}
					else if (val.Y < (Main.worldSurface * 4.0 + Main.rockLayer) / 5.0)
					{
						if (val2.Y < 0.0)
						{
							val2.Y *= 0.97;
						}
						val2.Y += 0.02;
					}
					else if (val2.Y > -0.1)
					{
						val2.Y *= 0.99;
						val2.Y -= 0.01;
					}
					val2.Y = Utils.Clamp(val2.Y, -1.0, 1.0);
				}
				if (val.X < (double)(Main.maxTilesX / 2))
				{
					val2.X = Utils.Clamp(val2.X, 0.1, 1.0);
				}
				else
				{
					val2.X = Utils.Clamp(val2.X, -1.0, -0.1);
				}
			}
			GenVars.numOceanCaveTreasure++;
		}

		public static void WavyCaverer(int startX, int startY, double waveStrengthScalar, double wavePercentScalar, int steps, int type)
		{
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)startX, (double)startY);
			bool flag = ((startX > Main.maxTilesX / 2) ? true : false);
			int num = 2 + genRand.Next(2);
			int num2 = 15 + genRand.Next(11);
			int num3 = 1 + genRand.Next(2);
			int num4 = (int)Math.Ceiling((double)num2 / (double)num3);
			double num5 = 1.0;
			double num6 = 1.0;
			int num7 = (int)(-1.0 + genRand.NextDouble() * 3.0);
			int num8 = num;
			int num9 = 0;
			for (int i = 0; i < steps; i++)
			{
				bool flag2 = i < num4;
				bool flag3 = i >= steps - num4;
				val.X += ((!flag) ? 1 : (-1));
				if (!flag2 && !flag3)
				{
					num9++;
					num5 = Math.Min(2.0, Math.Max(0.5, num5 + (-0.5 + genRand.NextDouble()) * 0.25));
					num6 = Math.Min(1.1, Math.Max(0.9, num6 + (-0.5 + genRand.NextDouble()) * 0.02));
				}
				double num10 = Math.Sin((double)num9 * 0.1 * num6 * wavePercentScalar) * num5 * waveStrengthScalar;
				val.Y = (double)startY + num10 + (double)(num9 * num7);
				int num11 = num8;
				if (flag2)
				{
					num8 = Math.Min(num2, num8 + num3);
				}
				else if (flag3)
				{
					num8 = Math.Max(num, num8 - num3);
				}
				val.Y -= (num11 + num8) / 4;
				for (int j = 0; j < num8; j++)
				{
					int num12 = (int)val.X;
					int num13 = (int)val.Y + j;
					if (InWorld(num12, num13, 20))
					{
						if (type >= 0)
						{
							PlaceTile(num12, num13, type, mute: true, forced: true);
						}
						else
						{
							KillTile(num12, num13);
						}
					}
				}
			}
		}

		public static void TileRunner(int i, int j, double strength, int steps, int type, bool addTile = false, double speedX = 0.0, double speedY = 0.0, bool noYChange = false, bool overRide = true, int ignoreTileType = -1)
		{
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0239: Unknown result type (might be due to invalid IL or missing references)
			//IL_024e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0264: Unknown result type (might be due to invalid IL or missing references)
			//IL_0279: Unknown result type (might be due to invalid IL or missing references)
			//IL_034a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0359: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0657: Unknown result type (might be due to invalid IL or missing references)
			//IL_0666: Unknown result type (might be due to invalid IL or missing references)
			//IL_06ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_06c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0958: Unknown result type (might be due to invalid IL or missing references)
			//IL_0959: Unknown result type (might be due to invalid IL or missing references)
			//IL_095a: Unknown result type (might be due to invalid IL or missing references)
			//IL_095f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0987: Unknown result type (might be due to invalid IL or missing references)
			//IL_0988: Unknown result type (might be due to invalid IL or missing references)
			//IL_0989: Unknown result type (might be due to invalid IL or missing references)
			//IL_098e: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_09f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_09fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a63: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a64: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a65: Unknown result type (might be due to invalid IL or missing references)
			//IL_0a6a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ad1: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ad2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ad3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ad8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b3f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b40: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b41: Unknown result type (might be due to invalid IL or missing references)
			//IL_0b46: Unknown result type (might be due to invalid IL or missing references)
			//IL_0bad: Unknown result type (might be due to invalid IL or missing references)
			//IL_0bae: Unknown result type (might be due to invalid IL or missing references)
			//IL_0baf: Unknown result type (might be due to invalid IL or missing references)
			//IL_0bb4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c1b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c1c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c1d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c22: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c89: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c8a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c8b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0c90: Unknown result type (might be due to invalid IL or missing references)
			//IL_0cf7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0cf8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0cf9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0cfe: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d65: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d66: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d67: Unknown result type (might be due to invalid IL or missing references)
			//IL_0d6c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0dd3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0dd4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0dd5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0dda: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e3e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e3f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e40: Unknown result type (might be due to invalid IL or missing references)
			//IL_0e45: Unknown result type (might be due to invalid IL or missing references)
			//IL_0eeb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f0c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f55: Unknown result type (might be due to invalid IL or missing references)
			//IL_0f76: Unknown result type (might be due to invalid IL or missing references)
			//IL_0fac: Unknown result type (might be due to invalid IL or missing references)
			//IL_0fcd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0ffe: Unknown result type (might be due to invalid IL or missing references)
			//IL_101f: Unknown result type (might be due to invalid IL or missing references)
			//IL_1040: Unknown result type (might be due to invalid IL or missing references)
			//IL_1067: Unknown result type (might be due to invalid IL or missing references)
			if (!GenVars.mudWall)
			{
				if (drunkWorldGen)
				{
					strength *= 1.0 + (double)genRand.Next(-80, 81) * 0.01;
					steps = (int)((double)steps * (1.0 + (double)genRand.Next(-80, 81) * 0.01));
				}
				else if (remixWorldGen)
				{
					strength *= 1.0 + (double)genRand.Next(-50, 51) * 0.01;
				}
				else if (getGoodWorldGen && type != 57)
				{
					strength *= 1.0 + (double)genRand.Next(-80, 81) * 0.015;
					steps += genRand.Next(3);
				}
			}
			double num = strength;
			double num2 = steps;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-10, 11) * 0.1;
			if (speedX != 0.0 || speedY != 0.0)
			{
				val2.X = speedX;
				val2.Y = speedY;
			}
			bool flag = type == 368;
			bool flag2 = type == 367;
			bool lava = false;
			if (getGoodWorldGen && genRand.Next(4) == 0)
			{
				lava = true;
			}
			while (num > 0.0 && num2 > 0.0)
			{
				if (drunkWorldGen && genRand.Next(30) == 0)
				{
					val.X += (double)genRand.Next(-100, 101) * 0.05;
					val.Y += (double)genRand.Next(-100, 101) * 0.05;
				}
				if (val.Y < 0.0 && num2 > 0.0 && type == 59)
				{
					num2 = 0.0;
				}
				num = strength * (num2 / (double)steps);
				num2 -= 1.0;
				int num3 = (int)(val.X - num * 0.5);
				int num4 = (int)(val.X + num * 0.5);
				int num5 = (int)(val.Y - num * 0.5);
				int num6 = (int)(val.Y + num * 0.5);
				if (num3 < 1)
				{
					num3 = 1;
				}
				if (num4 > Main.maxTilesX - 1)
				{
					num4 = Main.maxTilesX - 1;
				}
				if (num5 < 1)
				{
					num5 = 1;
				}
				if (num6 > Main.maxTilesY - 1)
				{
					num6 = Main.maxTilesY - 1;
				}
				for (int k = num3; k < num4; k++)
				{
					if (k < beachDistance + 50 || k >= Main.maxTilesX - beachDistance - 50)
					{
						lava = false;
					}
					for (int l = num5; l < num6; l++)
					{
						if ((drunkWorldGen && l < Main.maxTilesY - 300 && type == 57) || (ignoreTileType >= 0 && Main.tile[k, l].active() && Main.tile[k, l].type == ignoreTileType) || !(Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < strength * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015)))
						{
							continue;
						}
						if (GenVars.mudWall && (double)l > Main.worldSurface && Main.tile[k, l - 1].wall != 2 && l < Main.maxTilesY - 210 - genRand.Next(3) && Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < strength * 0.45 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
						{
							if (l > GenVars.lavaLine - genRand.Next(0, 4) - 50)
							{
								if (Main.tile[k, l - 1].wall != 64 && Main.tile[k, l + 1].wall != 64 && Main.tile[k - 1, l].wall != 64 && Main.tile[k + 1, l].wall != 64)
								{
									PlaceWall(k, l, 15, mute: true);
								}
							}
							else if (Main.tile[k, l - 1].wall != 15 && Main.tile[k, l + 1].wall != 15 && Main.tile[k - 1, l].wall != 15 && Main.tile[k + 1, l].wall != 15)
							{
								PlaceWall(k, l, 64, mute: true);
							}
						}
						if (type < 0)
						{
							if (Main.tile[k, l].type == 53)
							{
								continue;
							}
							if (type == -2 && Main.tile[k, l].active() && (l < GenVars.waterLine || l > GenVars.lavaLine))
							{
								Main.tile[k, l].liquid = byte.MaxValue;
								Main.tile[k, l].lava(lava);
								if (remixWorldGen)
								{
									if (l > GenVars.lavaLine && ((double)l < Main.rockLayer - 80.0 || l > Main.maxTilesY - 350) && !oceanDepths(k, l))
									{
										Main.tile[k, l].lava(lava: true);
									}
								}
								else if (l > GenVars.lavaLine)
								{
									Main.tile[k, l].lava(lava: true);
								}
							}
							Main.tile[k, l].active(active: false);
							continue;
						}
						if (flag && Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
						{
							PlaceWall(k, l, 180, mute: true);
						}
						if (flag2 && Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < strength * 0.3 * (1.0 + (double)genRand.Next(-10, 11) * 0.01))
						{
							PlaceWall(k, l, 178, mute: true);
						}
						if (overRide || !Main.tile[k, l].active())
						{
							Tile tile = Main.tile[k, l];
							bool flag3 = false;
							flag3 = Main.tileStone[type] && tile.type != 1;
							if (!TileID.Sets.CanBeClearedDuringGeneration[tile.type])
							{
								flag3 = true;
							}
							switch (tile.type)
							{
							case 53:
								if (type == 59 && GenVars.UndergroundDesertLocation.Contains(k, l))
								{
									flag3 = true;
								}
								if (type == 40)
								{
									flag3 = true;
								}
								if ((double)l < Main.worldSurface && type != 59)
								{
									flag3 = true;
								}
								break;
							case 45:
							case 147:
							case 189:
							case 190:
							case 196:
							case 460:
								flag3 = true;
								break;
							case 396:
							case 397:
								flag3 = !TileID.Sets.Ore[type];
								break;
							case 1:
								if (type == 59 && (double)l < Main.worldSurface + (double)genRand.Next(-50, 50))
								{
									flag3 = true;
								}
								break;
							case 367:
							case 368:
								if (type == 59)
								{
									flag3 = true;
								}
								break;
							}
							if (!flag3)
							{
								tile.type = (ushort)type;
							}
						}
						if (addTile)
						{
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].liquid = 0;
							Main.tile[k, l].lava(lava: false);
						}
						if (noYChange && (double)l < Main.worldSurface && type != 59)
						{
							Main.tile[k, l].wall = 2;
						}
						if (type == 59 && l > GenVars.waterLine && Main.tile[k, l].liquid > 0)
						{
							Main.tile[k, l].lava(lava: false);
							Main.tile[k, l].liquid = 0;
						}
					}
				}
				val += val2;
				if ((!drunkWorldGen || genRand.Next(3) != 0) && num > 50.0)
				{
					val += val2;
					num2 -= 1.0;
					val2.Y += (double)genRand.Next(-10, 11) * 0.05;
					val2.X += (double)genRand.Next(-10, 11) * 0.05;
					if (num > 100.0)
					{
						val += val2;
						num2 -= 1.0;
						val2.Y += (double)genRand.Next(-10, 11) * 0.05;
						val2.X += (double)genRand.Next(-10, 11) * 0.05;
						if (num > 150.0)
						{
							val += val2;
							num2 -= 1.0;
							val2.Y += (double)genRand.Next(-10, 11) * 0.05;
							val2.X += (double)genRand.Next(-10, 11) * 0.05;
							if (num > 200.0)
							{
								val += val2;
								num2 -= 1.0;
								val2.Y += (double)genRand.Next(-10, 11) * 0.05;
								val2.X += (double)genRand.Next(-10, 11) * 0.05;
								if (num > 250.0)
								{
									val += val2;
									num2 -= 1.0;
									val2.Y += (double)genRand.Next(-10, 11) * 0.05;
									val2.X += (double)genRand.Next(-10, 11) * 0.05;
									if (num > 300.0)
									{
										val += val2;
										num2 -= 1.0;
										val2.Y += (double)genRand.Next(-10, 11) * 0.05;
										val2.X += (double)genRand.Next(-10, 11) * 0.05;
										if (num > 400.0)
										{
											val += val2;
											num2 -= 1.0;
											val2.Y += (double)genRand.Next(-10, 11) * 0.05;
											val2.X += (double)genRand.Next(-10, 11) * 0.05;
											if (num > 500.0)
											{
												val += val2;
												num2 -= 1.0;
												val2.Y += (double)genRand.Next(-10, 11) * 0.05;
												val2.X += (double)genRand.Next(-10, 11) * 0.05;
												if (num > 600.0)
												{
													val += val2;
													num2 -= 1.0;
													val2.Y += (double)genRand.Next(-10, 11) * 0.05;
													val2.X += (double)genRand.Next(-10, 11) * 0.05;
													if (num > 700.0)
													{
														val += val2;
														num2 -= 1.0;
														val2.Y += (double)genRand.Next(-10, 11) * 0.05;
														val2.X += (double)genRand.Next(-10, 11) * 0.05;
														if (num > 800.0)
														{
															val += val2;
															num2 -= 1.0;
															val2.Y += (double)genRand.Next(-10, 11) * 0.05;
															val2.X += (double)genRand.Next(-10, 11) * 0.05;
															if (num > 900.0)
															{
																val += val2;
																num2 -= 1.0;
																val2.Y += (double)genRand.Next(-10, 11) * 0.05;
																val2.X += (double)genRand.Next(-10, 11) * 0.05;
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (drunkWorldGen)
				{
					val2.X += (double)genRand.Next(-10, 11) * 0.25;
				}
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (!noYChange)
				{
					val2.Y += (double)genRand.Next(-10, 11) * 0.05;
					if (val2.Y > 1.0)
					{
						val2.Y = 1.0;
					}
					if (val2.Y < -1.0)
					{
						val2.Y = -1.0;
					}
				}
				else if (type != 59 && num < 3.0)
				{
					if (val2.Y > 1.0)
					{
						val2.Y = 1.0;
					}
					if (val2.Y < -1.0)
					{
						val2.Y = -1.0;
					}
				}
				if (type == 59 && !noYChange)
				{
					if (val2.Y > 0.5)
					{
						val2.Y = 0.5;
					}
					if (val2.Y < -0.5)
					{
						val2.Y = -0.5;
					}
					if (val.Y < Main.rockLayer + 100.0)
					{
						val2.Y = 1.0;
					}
					if (val.Y > (double)(Main.maxTilesY - 300))
					{
						val2.Y = -1.0;
					}
				}
			}
		}

		public static void DirtyRockRunner(int i, int j)
		{
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_01be: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_020b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0250: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(2, 6);
			double num2 = genRand.Next(5, 50);
			double num3 = num2;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-10, 11) * 0.1;
			while (num > 0.0 && num3 > 0.0)
			{
				double num4 = num * (num3 / num2);
				num3 -= 1.0;
				int num5 = (int)(val.X - num4 * 0.5);
				int num6 = (int)(val.X + num4 * 0.5);
				int num7 = (int)(val.Y - num4 * 0.5);
				int num8 = (int)(val.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						if (Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && Main.tile[k, l].wall == 2)
						{
							Main.tile[k, l].wall = 59;
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.Y > 1.0)
				{
					val2.Y = 1.0;
				}
				if (val2.Y < -1.0)
				{
					val2.Y = -1.0;
				}
			}
		}

		public static void MudWallRunner(int i, int j)
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_023e: Unknown result type (might be due to invalid IL or missing references)
			//IL_025f: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(8, 21);
			double num2 = genRand.Next(8, 33);
			double num3 = num2;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-10, 11) * 0.1;
			while (num > 0.0 && num3 > 0.0)
			{
				double num4 = num * (num3 / num2);
				num3 -= 1.0;
				int num5 = (int)(val.X - num4 * 0.5);
				int num6 = (int)(val.X + num4 * 0.5);
				int num7 = (int)(val.Y - num4 * 0.5);
				int num8 = (int)(val.Y + num4 * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						if (Math.Abs((double)k - val.X) + Math.Abs((double)l - val.Y) < num * 0.5 * (1.0 + (double)genRand.Next(-10, 11) * 0.015) && (double)l > Main.worldSurface)
						{
							Main.tile[k, l].wall = 0;
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.Y > 1.0)
				{
					val2.Y = 1.0;
				}
				if (val2.Y < -1.0)
				{
					val2.Y = -1.0;
				}
			}
		}

		public static void SnowCloudIsland(int i, int j)
		{
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0320: Unknown result type (might be due to invalid IL or missing references)
			//IL_0341: Unknown result type (might be due to invalid IL or missing references)
			//IL_0362: Unknown result type (might be due to invalid IL or missing references)
			//IL_0563: Unknown result type (might be due to invalid IL or missing references)
			//IL_0574: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05de: Unknown result type (might be due to invalid IL or missing references)
			//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0659: Unknown result type (might be due to invalid IL or missing references)
			//IL_0694: Unknown result type (might be due to invalid IL or missing references)
			//IL_069c: Unknown result type (might be due to invalid IL or missing references)
			//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_06df: Unknown result type (might be due to invalid IL or missing references)
			//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_077b: Unknown result type (might be due to invalid IL or missing references)
			//IL_077c: Unknown result type (might be due to invalid IL or missing references)
			//IL_077d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0782: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_07c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_07e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_080a: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(100, 150);
			double num2 = num;
			double num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = (int)(val.Y - num * 0.5);
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num12 = val.Y + 1.0;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (double)genRand.Next(-1, 2);
					}
					if (num12 < val.Y)
					{
						num12 = val.Y;
					}
					if (num12 > val.Y + 2.0)
					{
						num12 = val.Y + 2.0;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((double)l > num12))
						{
							continue;
						}
						double num13 = Math.Abs((double)k - val.X);
						double num14 = Math.Abs((double)l - val.Y) * 3.0;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 460;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							double num19 = Math.Abs(m - num15);
							double num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			val.X = i;
			val.Y = num6;
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num21 = val.Y + 1.0;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (double)genRand.Next(-1, 2);
					}
					if (num21 < val.Y)
					{
						num21 = val.Y;
					}
					if (num21 > val.Y + 2.0)
					{
						num21 = val.Y + 2.0;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if ((double)num23 > num21)
						{
							double num24 = Math.Abs((double)num22 - val.X);
							double num25 = Math.Abs((double)num23 - val.Y) * 3.0;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189)
							{
								Main.tile[num22, num23].type = 147;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5)
			{
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5)
				{
					num27--;
					if (num27 < num6)
					{
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}
				if (num26 >= num5)
				{
					continue;
				}
				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
				{
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
					{
						if (num31 > num6)
						{
							double num32 = Math.Abs(num30 - num26);
							double num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28)
							{
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}
				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}
			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++)
			{
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++)
				{
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++)
					{
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++)
						{
							if (!Main.tile[num36, num37].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}
			for (int num38 = num4; num38 <= num5; num38++)
			{
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++)
				{
				}
				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++)
					{
						if (Main.tile[num41, num39].type == 189 && WillWaterPlacedHereStayPut(num41, num39))
						{
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}
						if (Main.tile[num41, num39 + 1].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 1))
						{
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}
						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 2))
						{
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num38, num39))
				{
					Main.tile[num38, num39].liquid = byte.MaxValue;
				}
				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}
			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++)
			{
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
				{
					num47 = 460;
				}
				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++)
				{
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++)
					{
						double num50 = Math.Abs(num48 - num44);
						double num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2)))
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}
				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++)
				{
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++)
					{
					}
					if (WillWaterPlacedHereStayPut(num52, num53))
					{
						Main.tile[num52, num53].active(active: false);
						Main.tile[num52, num53].liquid = byte.MaxValue;
						SquareTileFrame(num52, num53);
					}
				}
			}
		}

		public static void DesertCloudIsland(int i, int j)
		{
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0320: Unknown result type (might be due to invalid IL or missing references)
			//IL_0341: Unknown result type (might be due to invalid IL or missing references)
			//IL_0362: Unknown result type (might be due to invalid IL or missing references)
			//IL_0563: Unknown result type (might be due to invalid IL or missing references)
			//IL_0574: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05de: Unknown result type (might be due to invalid IL or missing references)
			//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0659: Unknown result type (might be due to invalid IL or missing references)
			//IL_0694: Unknown result type (might be due to invalid IL or missing references)
			//IL_069c: Unknown result type (might be due to invalid IL or missing references)
			//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_06dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_06eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0775: Unknown result type (might be due to invalid IL or missing references)
			//IL_0776: Unknown result type (might be due to invalid IL or missing references)
			//IL_0777: Unknown result type (might be due to invalid IL or missing references)
			//IL_077c: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_07c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_07e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0804: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(100, 150);
			double num2 = num;
			double num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = (int)(val.Y - num * 0.5);
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num12 = val.Y + 1.0;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (double)genRand.Next(-1, 2);
					}
					if (num12 < val.Y)
					{
						num12 = val.Y;
					}
					if (num12 > val.Y + 2.0)
					{
						num12 = val.Y + 2.0;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((double)l > num12))
						{
							continue;
						}
						double num13 = Math.Abs((double)k - val.X);
						double num14 = Math.Abs((double)l - val.Y) * 3.0;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 196;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							double num19 = Math.Abs(m - num15);
							double num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			val.X = i;
			val.Y = num6;
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num21 = val.Y + 1.0;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (double)genRand.Next(-1, 2);
					}
					if (num21 < val.Y)
					{
						num21 = val.Y;
					}
					if (num21 > val.Y + 2.0)
					{
						num21 = val.Y + 2.0;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if ((double)num23 > num21)
						{
							double num24 = Math.Abs((double)num22 - val.X);
							double num25 = Math.Abs((double)num23 - val.Y) * 3.0;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189)
							{
								Main.tile[num22, num23].type = 53;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5)
			{
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5)
				{
					num27--;
					if (num27 < num6)
					{
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}
				if (num26 >= num5)
				{
					continue;
				}
				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
				{
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
					{
						if (num31 > num6)
						{
							double num32 = Math.Abs(num30 - num26);
							double num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28)
							{
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}
				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}
			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++)
			{
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++)
				{
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++)
					{
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++)
						{
							if (!Main.tile[num36, num37].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}
			for (int num38 = num4; num38 <= num5; num38++)
			{
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++)
				{
				}
				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++)
					{
						if (Main.tile[num41, num39].type == 189 && WillWaterPlacedHereStayPut(num41, num39))
						{
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}
						if (Main.tile[num41, num39 + 1].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 1))
						{
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}
						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 2))
						{
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num38, num39))
				{
					Main.tile[num38, num39].liquid = byte.MaxValue;
				}
				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}
			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++)
			{
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
				{
					num47 = 196;
				}
				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++)
				{
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++)
					{
						double num50 = Math.Abs(num48 - num44);
						double num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2)))
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}
				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++)
				{
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++)
					{
					}
					if (WillWaterPlacedHereStayPut(num52, num53))
					{
						Main.tile[num52, num53].active(active: false);
						Main.tile[num52, num53].liquid = byte.MaxValue;
						SquareTileFrame(num52, num53);
					}
				}
			}
		}

		public static void CloudIsland(int i, int j)
		{
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0320: Unknown result type (might be due to invalid IL or missing references)
			//IL_0341: Unknown result type (might be due to invalid IL or missing references)
			//IL_0362: Unknown result type (might be due to invalid IL or missing references)
			//IL_0563: Unknown result type (might be due to invalid IL or missing references)
			//IL_0574: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05de: Unknown result type (might be due to invalid IL or missing references)
			//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0659: Unknown result type (might be due to invalid IL or missing references)
			//IL_0694: Unknown result type (might be due to invalid IL or missing references)
			//IL_069c: Unknown result type (might be due to invalid IL or missing references)
			//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_06dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_06eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0774: Unknown result type (might be due to invalid IL or missing references)
			//IL_0775: Unknown result type (might be due to invalid IL or missing references)
			//IL_0776: Unknown result type (might be due to invalid IL or missing references)
			//IL_077b: Unknown result type (might be due to invalid IL or missing references)
			//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_07c1: Unknown result type (might be due to invalid IL or missing references)
			//IL_07e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0803: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(100, 150);
			double num2 = num;
			double num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = (int)(val.Y - num * 0.5);
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num12 = val.Y + 1.0;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (double)genRand.Next(-1, 2);
					}
					if (num12 < val.Y)
					{
						num12 = val.Y;
					}
					if (num12 > val.Y + 2.0)
					{
						num12 = val.Y + 2.0;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((double)l > num12))
						{
							continue;
						}
						double num13 = Math.Abs((double)k - val.X);
						double num14 = Math.Abs((double)l - val.Y) * 3.0;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 196;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							double num19 = Math.Abs(m - num15);
							double num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			val.X = i;
			val.Y = num6;
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num21 = val.Y + 1.0;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (double)genRand.Next(-1, 2);
					}
					if (num21 < val.Y)
					{
						num21 = val.Y;
					}
					if (num21 > val.Y + 2.0)
					{
						num21 = val.Y + 2.0;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if ((double)num23 > num21)
						{
							double num24 = Math.Abs((double)num22 - val.X);
							double num25 = Math.Abs((double)num23 - val.Y) * 3.0;
							if (Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4 && Main.tile[num22, num23].type == 189)
							{
								Main.tile[num22, num23].type = 0;
								SquareTileFrame(num22, num23);
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num26 = num4;
			num26 += genRand.Next(5);
			while (num26 < num5)
			{
				int num27 = num7;
				while ((!Main.tile[num26, num27].active() || Main.tile[num26, num27].type != 0) && num26 < num5)
				{
					num27--;
					if (num27 < num6)
					{
						num27 = num7;
						num26 += genRand.Next(1, 4);
					}
				}
				if (num26 >= num5)
				{
					continue;
				}
				num27 += genRand.Next(0, 4);
				int num28 = genRand.Next(2, 5);
				int num29 = 189;
				for (int num30 = num26 - num28; num30 <= num26 + num28; num30++)
				{
					for (int num31 = num27 - num28; num31 <= num27 + num28; num31++)
					{
						if (num31 > num6)
						{
							double num32 = Math.Abs(num30 - num26);
							double num33 = Math.Abs(num31 - num27) * 2;
							if (Math.Sqrt(num32 * num32 + num33 * num33) < (double)num28)
							{
								Main.tile[num30, num31].type = (ushort)num29;
								SquareTileFrame(num30, num31);
							}
						}
					}
				}
				num26 += genRand.Next(num28, (int)((double)num28 * 1.5));
			}
			for (int num34 = num4 - 20; num34 <= num5 + 20; num34++)
			{
				for (int num35 = num6 - 20; num35 <= num7 + 20; num35++)
				{
					bool flag = true;
					for (int num36 = num34 - 1; num36 <= num34 + 1; num36++)
					{
						for (int num37 = num35 - 1; num37 <= num35 + 1; num37++)
						{
							if (!Main.tile[num36, num37].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num34, num35].wall = 73;
						SquareWallFrame(num34, num35);
					}
				}
			}
			for (int num38 = num4; num38 <= num5; num38++)
			{
				int num39;
				for (num39 = num6 - 10; !Main.tile[num38, num39 + 1].active(); num39++)
				{
				}
				if (num39 >= num7 || Main.tile[num38, num39 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num40 = genRand.Next(1, 3);
					for (int num41 = num38 - num40; num41 <= num38 + num40; num41++)
					{
						if (Main.tile[num41, num39].type == 189 && WillWaterPlacedHereStayPut(num41, num39))
						{
							Main.tile[num41, num39].active(active: false);
							Main.tile[num41, num39].liquid = byte.MaxValue;
							Main.tile[num41, num39].lava(lava: false);
							SquareTileFrame(num38, num39);
						}
						if (Main.tile[num41, num39 + 1].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 1))
						{
							Main.tile[num41, num39 + 1].active(active: false);
							Main.tile[num41, num39 + 1].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 1].lava(lava: false);
							SquareTileFrame(num38, num39 + 1);
						}
						if (num41 > num38 - num40 && num41 < num38 + 2 && Main.tile[num41, num39 + 2].type == 189 && WillWaterPlacedHereStayPut(num41, num39 + 2))
						{
							Main.tile[num41, num39 + 2].active(active: false);
							Main.tile[num41, num39 + 2].liquid = byte.MaxValue;
							Main.tile[num41, num39 + 2].lava(lava: false);
							SquareTileFrame(num38, num39 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num38, num39))
				{
					Main.tile[num38, num39].liquid = byte.MaxValue;
				}
				Main.tile[num38, num39].lava(lava: false);
				SquareTileFrame(num38, num39);
			}
			int num42 = genRand.Next(4);
			for (int num43 = 0; num43 <= num42; num43++)
			{
				int num44 = genRand.Next(num4 - 5, num5 + 5);
				int num45 = num6 - genRand.Next(20, 40);
				int num46 = genRand.Next(4, 8);
				int num47 = 189;
				if (genRand.Next(2) == 0)
				{
					num47 = 196;
				}
				for (int num48 = num44 - num46; num48 <= num44 + num46; num48++)
				{
					for (int num49 = num45 - num46; num49 <= num45 + num46; num49++)
					{
						double num50 = Math.Abs(num48 - num44);
						double num51 = Math.Abs(num49 - num45) * 2;
						if (Math.Sqrt(num50 * num50 + num51 * num51) < (double)(num46 + genRand.Next(-1, 2)))
						{
							Main.tile[num48, num49].active(active: true);
							Main.tile[num48, num49].type = (ushort)num47;
							SquareTileFrame(num48, num49);
						}
					}
				}
				for (int num52 = num44 - num46 + 2; num52 <= num44 + num46 - 2; num52++)
				{
					int num53;
					for (num53 = num45 - num46; !Main.tile[num52, num53].active(); num53++)
					{
					}
					if (WillWaterPlacedHereStayPut(num52, num53))
					{
						Main.tile[num52, num53].active(active: false);
						Main.tile[num52, num53].liquid = byte.MaxValue;
						SquareTileFrame(num52, num53);
					}
				}
			}
		}

		public static bool WillWaterPlacedHereStayPut(int x, int y)
		{
			if (((Main.tile[x, y + 1].active() && Main.tileSolid[Main.tile[x, y + 1].type] && !Main.tileSolidTop[Main.tile[x, y + 1].type]) || Main.tile[x, y + 1].liquid == byte.MaxValue) && ((Main.tile[x - 1, y].active() && Main.tileSolid[Main.tile[x - 1, y].type] && !Main.tileSolidTop[Main.tile[x - 1, y].type]) || Main.tile[x - 1, y].liquid == byte.MaxValue) && ((Main.tile[x + 1, y].active() && Main.tileSolid[Main.tile[x + 1, y].type] && !Main.tileSolidTop[Main.tile[x + 1, y].type]) || Main.tile[x + 1, y].liquid == byte.MaxValue))
			{
				return true;
			}
			return false;
		}

		public static void CloudLake(int i, int j)
		{
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_0104: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_012f: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0224: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
			//IL_0320: Unknown result type (might be due to invalid IL or missing references)
			//IL_0341: Unknown result type (might be due to invalid IL or missing references)
			//IL_0362: Unknown result type (might be due to invalid IL or missing references)
			//IL_0563: Unknown result type (might be due to invalid IL or missing references)
			//IL_0574: Unknown result type (might be due to invalid IL or missing references)
			//IL_05c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_05de: Unknown result type (might be due to invalid IL or missing references)
			//IL_05f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0659: Unknown result type (might be due to invalid IL or missing references)
			//IL_0694: Unknown result type (might be due to invalid IL or missing references)
			//IL_069c: Unknown result type (might be due to invalid IL or missing references)
			//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_06e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_06f8: Unknown result type (might be due to invalid IL or missing references)
			//IL_07d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_07d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_07d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_07dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0802: Unknown result type (might be due to invalid IL or missing references)
			//IL_0823: Unknown result type (might be due to invalid IL or missing references)
			//IL_0844: Unknown result type (might be due to invalid IL or missing references)
			//IL_0865: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(100, 150);
			double num2 = num;
			double num3 = genRand.Next(20, 30);
			int num4 = i;
			int num5 = i;
			int num6 = i;
			int num7 = j;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = (int)(val.Y - num * 0.5);
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num12 = val.Y + 1.0;
				for (int k = num8; k < num9; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num12 += (double)genRand.Next(-1, 2);
					}
					if (num12 < val.Y)
					{
						num12 = val.Y;
					}
					if (num12 > val.Y + 2.0)
					{
						num12 = val.Y + 2.0;
					}
					for (int l = num10; l < num11; l++)
					{
						if (!((double)l > num12))
						{
							continue;
						}
						double num13 = Math.Abs((double)k - val.X);
						double num14 = Math.Abs((double)l - val.Y) * 3.0;
						if (Math.Sqrt(num13 * num13 + num14 * num14) < num2 * 0.4)
						{
							if (k < num4)
							{
								num4 = k;
							}
							if (k > num5)
							{
								num5 = k;
							}
							if (l < num6)
							{
								num6 = l;
							}
							if (l > num7)
							{
								num7 = l;
							}
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 189;
							SquareTileFrame(k, l);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
			int num15 = num4;
			int num17;
			for (num15 += genRand.Next(5); num15 < num5; num15 += genRand.Next(num17, (int)((double)num17 * 1.5)))
			{
				int num16 = num7;
				while (!Main.tile[num15, num16].active())
				{
					num16--;
				}
				num16 += genRand.Next(-3, 4);
				num17 = genRand.Next(4, 8);
				int num18 = 189;
				if (genRand.Next(4) == 0)
				{
					num18 = 196;
				}
				for (int m = num15 - num17; m <= num15 + num17; m++)
				{
					for (int n = num16 - num17; n <= num16 + num17; n++)
					{
						if (n > num6)
						{
							double num19 = Math.Abs(m - num15);
							double num20 = Math.Abs(n - num16) * 2;
							if (Math.Sqrt(num19 * num19 + num20 * num20) < (double)(num17 + genRand.Next(2)))
							{
								Main.tile[m, n].active(active: true);
								Main.tile[m, n].type = (ushort)num18;
								SquareTileFrame(m, n);
							}
						}
					}
				}
			}
			num = genRand.Next(80, 95);
			num2 = num;
			num3 = genRand.Next(10, 15);
			val.X = i;
			val.Y = num6;
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num8 = (int)(val.X - num * 0.5);
				int num9 = (int)(val.X + num * 0.5);
				int num10 = num6 - 1;
				int num11 = (int)(val.Y + num * 0.5);
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesX)
				{
					num9 = Main.maxTilesX;
				}
				if (num10 < 0)
				{
					num10 = 0;
				}
				if (num11 > Main.maxTilesY)
				{
					num11 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num21 = val.Y + 1.0;
				for (int num22 = num8; num22 < num9; num22++)
				{
					if (genRand.Next(2) == 0)
					{
						num21 += (double)genRand.Next(-1, 2);
					}
					if (num21 < val.Y)
					{
						num21 = val.Y;
					}
					if (num21 > val.Y + 2.0)
					{
						num21 = val.Y + 2.0;
					}
					for (int num23 = num10; num23 < num11; num23++)
					{
						if (!((double)num23 > num21 - 2.0))
						{
							continue;
						}
						double num24 = Math.Abs((double)num22 - val.X);
						double num25 = Math.Abs((double)num23 - val.Y) * 3.0;
						if (!(Math.Sqrt(num24 * num24 + num25 * num25) < num2 * 0.4) || Main.tile[num22, num23].type != 189)
						{
							continue;
						}
						Main.tile[num22, num23].active(active: false);
						if ((double)num23 > num21 + 1.0)
						{
							if (WillWaterPlacedHereStayPut(num22, num23))
							{
								Main.tile[num22, num23].liquid = byte.MaxValue;
							}
							Main.tile[num22, num23].honey(honey: false);
							Main.tile[num22, num23].lava(lava: false);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-20, 21) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < 0.0)
				{
					val2.Y = 0.0;
				}
			}
			for (int num26 = num4 - 20; num26 <= num5 + 20; num26++)
			{
				for (int num27 = num6 - 20; num27 <= num7 + 20; num27++)
				{
					bool flag = true;
					for (int num28 = num26 - 1; num28 <= num26 + 1; num28++)
					{
						for (int num29 = num27 - 1; num29 <= num27 + 1; num29++)
						{
							if (!Main.tile[num28, num29].active())
							{
								flag = false;
							}
						}
					}
					if (flag)
					{
						Main.tile[num26, num27].wall = 73;
					}
				}
			}
			for (int num30 = num4; num30 <= num5; num30++)
			{
				int num31;
				for (num31 = num6 - 10; !Main.tile[num30, num31 + 1].active(); num31++)
				{
				}
				if (num31 >= num7 || Main.tile[num30, num31 + 1].type != 189)
				{
					continue;
				}
				if (genRand.Next(10) == 0)
				{
					int num32 = genRand.Next(1, 3);
					for (int num33 = num30 - num32; num33 <= num30 + num32; num33++)
					{
						if (Main.tile[num33, num31].type == 189 && WillWaterPlacedHereStayPut(num33, num31))
						{
							Main.tile[num33, num31].active(active: false);
							Main.tile[num33, num31].liquid = byte.MaxValue;
							Main.tile[num33, num31].lava(lava: false);
							SquareTileFrame(num30, num31);
						}
						if (Main.tile[num33, num31 + 1].type == 189 && WillWaterPlacedHereStayPut(num33, num31 + 1))
						{
							Main.tile[num33, num31 + 1].active(active: false);
							Main.tile[num33, num31 + 1].liquid = byte.MaxValue;
							Main.tile[num33, num31 + 1].lava(lava: false);
							SquareTileFrame(num30, num31 + 1);
						}
						if (num33 > num30 - num32 && num33 < num30 + 2 && Main.tile[num33, num31 + 2].type == 189 && WillWaterPlacedHereStayPut(num33, num31 + 2))
						{
							Main.tile[num33, num31 + 2].active(active: false);
							Main.tile[num33, num31 + 2].liquid = byte.MaxValue;
							Main.tile[num33, num31 + 2].lava(lava: false);
							SquareTileFrame(num30, num31 + 2);
						}
					}
				}
				if (genRand.Next(5) == 0 && WillWaterPlacedHereStayPut(num30, num31))
				{
					Main.tile[num30, num31].liquid = byte.MaxValue;
				}
				Main.tile[num30, num31].lava(lava: false);
				SquareTileFrame(num30, num31);
			}
			int num34 = genRand.Next(1, 4);
			for (int num35 = 0; num35 <= num34; num35++)
			{
				int num36 = genRand.Next(num4 - 5, num5 + 5);
				int num37 = num6 - genRand.Next(20, 40);
				int num38 = genRand.Next(4, 8);
				int num39 = 189;
				if (genRand.Next(4) != 0)
				{
					num39 = 196;
				}
				for (int num40 = num36 - num38; num40 <= num36 + num38; num40++)
				{
					for (int num41 = num37 - num38; num41 <= num37 + num38; num41++)
					{
						double num42 = Math.Abs(num40 - num36);
						double num43 = Math.Abs(num41 - num37) * 2;
						if (Math.Sqrt(num42 * num42 + num43 * num43) < (double)(num38 + genRand.Next(-1, 2)))
						{
							Main.tile[num40, num41].active(active: true);
							Main.tile[num40, num41].type = (ushort)num39;
							SquareTileFrame(num40, num41);
						}
					}
				}
				for (int num44 = num36 - num38 + 2; num44 <= num36 + num38 - 2; num44++)
				{
					int num45;
					for (num45 = num37 - num38; !Main.tile[num44, num45].active(); num45++)
					{
					}
					if (WillWaterPlacedHereStayPut(num44, num45))
					{
						Main.tile[num44, num45].active(active: false);
						Main.tile[num44, num45].liquid = byte.MaxValue;
						SquareTileFrame(num44, num45);
					}
				}
			}
		}

		public static void FloatingIsland(int i, int j)
		{
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_0180: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_0206: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_0355: Unknown result type (might be due to invalid IL or missing references)
			//IL_036a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0379: Unknown result type (might be due to invalid IL or missing references)
			//IL_03db: Unknown result type (might be due to invalid IL or missing references)
			//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
			//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0407: Unknown result type (might be due to invalid IL or missing references)
			//IL_0428: Unknown result type (might be due to invalid IL or missing references)
			//IL_0449: Unknown result type (might be due to invalid IL or missing references)
			//IL_046a: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(80, 120);
			double num2 = num;
			double num3 = genRand.Next(20, 25);
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-20, 21) * 0.2;
			while (val2.X > -2.0 && val2.X < 2.0)
			{
				val2.X = (double)genRand.Next(-20, 21) * 0.2;
			}
			val2.Y = (double)genRand.Next(-20, -10) * 0.02;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num4 = (int)(val.X - num * 0.5);
				int num5 = (int)(val.X + num * 0.5);
				int num6 = (int)(val.Y - num * 0.5);
				int num7 = (int)(val.Y + num * 0.5);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				double num8 = val.Y + 1.0;
				for (int k = num4; k < num5; k++)
				{
					if (genRand.Next(2) == 0)
					{
						num8 += (double)genRand.Next(-1, 2);
					}
					if (num8 < val.Y)
					{
						num8 = val.Y;
					}
					if (num8 > val.Y + 2.0)
					{
						num8 = val.Y + 2.0;
					}
					for (int l = num6; l < num7; l++)
					{
						if (!((double)l > num8))
						{
							continue;
						}
						double num9 = Math.Abs((double)k - val.X);
						double num10 = Math.Abs((double)l - val.Y) * 2.0;
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4)
						{
							Main.tile[k, l].active(active: true);
							if (Main.tile[k, l].type == 59)
							{
								Main.tile[k, l].type = 0;
							}
						}
					}
				}
				num4 = (int)(val.X - num * 0.4);
				num5 = (int)(val.X + num * 0.4);
				num6 = (int)(val.Y - num * 0.4);
				num7 = (int)(val.Y + num * 0.4);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int m = num4; m < num5; m++)
				{
					for (int n = num6; n < num7; n++)
					{
						if ((double)n > val.Y + 2.0)
						{
							double num11 = Math.Abs((double)m - val.X);
							double num12 = Math.Abs((double)n - val.Y) * 2.0;
							if (Math.Sqrt(num11 * num11 + num12 * num12) < num2 * 0.4)
							{
								Main.tile[m, n].wall = 2;
							}
						}
					}
				}
				val += val2;
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 0.2)
				{
					val2.Y = -0.2;
				}
				if (val2.Y < -0.2)
				{
					val2.Y = -0.2;
				}
			}
		}

		public static void Caverer(int X, int Y)
		{
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			//IL_028b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
			switch (genRand.Next(2))
			{
			case 0:
			{
				int num4 = genRand.Next(7, 9);
				double num5 = (double)genRand.Next(100) * 0.01;
				double num6 = 1.0 - num5;
				if (genRand.Next(2) == 0)
				{
					num5 = 0.0 - num5;
				}
				if (genRand.Next(2) == 0)
				{
					num6 = 0.0 - num6;
				}
				Vector2D val2 = default(Vector2D);
				((Vector2D)(ref val2))._002Ector((double)X, (double)Y);
				for (int j = 0; j < num4; j++)
				{
					val2 = digTunnel(val2.X, val2.Y, num5, num6, genRand.Next(6, 20), genRand.Next(4, 9));
					num5 += (double)genRand.Next(-20, 21) * 0.1;
					num6 += (double)genRand.Next(-20, 21) * 0.1;
					if (num5 < -1.5)
					{
						num5 = -1.5;
					}
					if (num5 > 1.5)
					{
						num5 = 1.5;
					}
					if (num6 < -1.5)
					{
						num6 = -1.5;
					}
					if (num6 > 1.5)
					{
						num6 = 1.5;
					}
					double num7 = (double)genRand.Next(100) * 0.01;
					double num8 = 1.0 - num7;
					if (genRand.Next(2) == 0)
					{
						num7 = 0.0 - num7;
					}
					if (genRand.Next(2) == 0)
					{
						num8 = 0.0 - num8;
					}
					Vector2D val3 = digTunnel(val2.X, val2.Y, num7, num8, genRand.Next(30, 50), genRand.Next(3, 6));
					TileRunner((int)val3.X, (int)val3.Y, genRand.Next(10, 20), genRand.Next(5, 10), -1);
				}
				break;
			}
			case 1:
			{
				int num = genRand.Next(15, 30);
				double num2 = (double)genRand.Next(100) * 0.01;
				double num3 = 1.0 - num2;
				if (genRand.Next(2) == 0)
				{
					num2 = 0.0 - num2;
				}
				if (genRand.Next(2) == 0)
				{
					num3 = 0.0 - num3;
				}
				Vector2D val = default(Vector2D);
				((Vector2D)(ref val))._002Ector((double)X, (double)Y);
				for (int i = 0; i < num; i++)
				{
					val = digTunnel(val.X, val.Y, num2, num3, genRand.Next(5, 15), genRand.Next(2, 6), Wet: true);
					num2 += (double)genRand.Next(-20, 21) * 0.1;
					num3 += (double)genRand.Next(-20, 21) * 0.1;
					if (num2 < -1.5)
					{
						num2 = -1.5;
					}
					if (num2 > 1.5)
					{
						num2 = 1.5;
					}
					if (num3 < -1.5)
					{
						num3 = -1.5;
					}
					if (num3 > 1.5)
					{
						num3 = 1.5;
					}
				}
				break;
			}
			}
		}

		public static Vector2D digTunnel(double X, double Y, double xDir, double yDir, int Steps, int Size, bool Wet = false)
		{
			//IL_024e: Unknown result type (might be due to invalid IL or missing references)
			double num = X;
			double num2 = Y;
			try
			{
				double num3 = 0.0;
				double num4 = 0.0;
				double num5 = Size;
				num = Utils.Clamp(num, num5 + 1.0, (double)Main.maxTilesX - num5 - 1.0);
				num2 = Utils.Clamp(num2, num5 + 1.0, (double)Main.maxTilesY - num5 - 1.0);
				for (int i = 0; i < Steps; i++)
				{
					for (int j = (int)(num - num5); (double)j <= num + num5; j++)
					{
						for (int k = (int)(num2 - num5); (double)k <= num2 + num5; k++)
						{
							if (Math.Abs((double)j - num) + Math.Abs((double)k - num2) < num5 * (1.0 + (double)genRand.Next(-10, 11) * 0.005) && j >= 0 && j < Main.maxTilesX && k >= 0 && k < Main.maxTilesY)
							{
								Main.tile[j, k].active(active: false);
								if (Wet)
								{
									Main.tile[j, k].liquid = byte.MaxValue;
								}
							}
						}
					}
					num5 += (double)genRand.Next(-50, 51) * 0.03;
					if (num5 < (double)Size * 0.6)
					{
						num5 = (double)Size * 0.6;
					}
					if (num5 > (double)(Size * 2))
					{
						num5 = Size * 2;
					}
					num3 += (double)genRand.Next(-20, 21) * 0.01;
					num4 += (double)genRand.Next(-20, 21) * 0.01;
					if (num3 < -1.0)
					{
						num3 = -1.0;
					}
					if (num3 > 1.0)
					{
						num3 = 1.0;
					}
					if (num4 < -1.0)
					{
						num4 = -1.0;
					}
					if (num4 > 1.0)
					{
						num4 = 1.0;
					}
					num += (xDir + num3) * 0.6;
					num2 += (yDir + num4) * 0.6;
				}
			}
			catch
			{
			}
			return new Vector2D(num, num2);
		}

		public static void IslandHouse(int i, int j, int islandStyle)
		{
			//IL_009b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_021d: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0237: Unknown result type (might be due to invalid IL or missing references)
			//IL_0244: Unknown result type (might be due to invalid IL or missing references)
			//IL_0305: Unknown result type (might be due to invalid IL or missing references)
			bool flag = crimson;
			if (drunkWorldGen)
			{
				flag = (GenVars.crimsonLeft && i < Main.maxTilesX / 2) || ((!GenVars.crimsonLeft && i > Main.maxTilesX / 2) ? true : false);
			}
			byte type = 202;
			byte wall = 82;
			Vector2D val = default(Vector2D);
			((Vector2D)(ref val))._002Ector((double)i, (double)j);
			int num = 1;
			if (genRand.Next(2) == 0)
			{
				num = -1;
			}
			int num2 = genRand.Next(7, 12);
			int num3 = genRand.Next(5, 7);
			val.X = i + (num2 + 2) * num;
			for (int k = j - 15; k < j + 30; k++)
			{
				if (Main.tile[(int)val.X, k].active())
				{
					val.Y = k - 1;
					break;
				}
			}
			val.X = i;
			int num4 = (int)(val.X - (double)num2 - 1.0);
			int num5 = (int)(val.X + (double)num2 + 1.0);
			int num6 = (int)(val.Y - (double)num3 - 1.0);
			int num7 = (int)(val.Y + 2.0);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			for (int l = num4; l <= num5; l++)
			{
				for (int m = num6 - 1; m < num7 + 1; m++)
				{
					if (m != num6 - 1 || (l != num4 && l != num5))
					{
						Main.tile[l, m].active(active: true);
						Main.tile[l, m].liquid = 0;
						Main.tile[l, m].type = type;
						Main.tile[l, m].wall = 0;
						Main.tile[l, m].halfBrick(halfBrick: false);
						Main.tile[l, m].slope(0);
					}
				}
			}
			num4 = (int)(val.X - (double)num2);
			num5 = (int)(val.X + (double)num2);
			num6 = (int)(val.Y - (double)num3);
			num7 = (int)(val.Y + 1.0);
			if (num4 < 0)
			{
				num4 = 0;
			}
			if (num5 > Main.maxTilesX)
			{
				num5 = Main.maxTilesX;
			}
			if (num6 < 0)
			{
				num6 = 0;
			}
			if (num7 > Main.maxTilesY)
			{
				num7 = Main.maxTilesY;
			}
			for (int n = num4; n <= num5; n++)
			{
				for (int num8 = num6; num8 < num7; num8++)
				{
					if ((num8 != num6 || (n != num4 && n != num5)) && Main.tile[n, num8].wall == 0)
					{
						Main.tile[n, num8].active(active: false);
						Main.tile[n, num8].wall = wall;
					}
				}
			}
			int num9 = i + (num2 + 1) * num;
			int num10 = (int)val.Y;
			for (int num11 = num9 - 2; num11 <= num9 + 2; num11++)
			{
				Main.tile[num11, num10].active(active: false);
				Main.tile[num11, num10 - 1].active(active: false);
				Main.tile[num11, num10 - 2].active(active: false);
			}
			if (remixWorldGen)
			{
				if (flag)
				{
					PlaceTile(num9, num10, 10, mute: true, forced: false, -1, 5);
				}
				else
				{
					PlaceTile(num9, num10, 10, mute: true, forced: false, -1, 38);
				}
			}
			else
			{
				PlaceTile(num9, num10, 10, mute: true, forced: false, -1, 9);
			}
			num9 = i + (num2 + 1) * -num - num;
			for (int num12 = num6; num12 <= num7 + 1; num12++)
			{
				Main.tile[num9, num12].active(active: true);
				Main.tile[num9, num12].liquid = 0;
				Main.tile[num9, num12].type = type;
				Main.tile[num9, num12].wall = 0;
				Main.tile[num9, num12].halfBrick(halfBrick: false);
				Main.tile[num9, num12].slope(0);
			}
			int contain = 0;
			int num13 = GenVars.skyIslandHouseCount;
			if (num13 > 3)
			{
				num13 = genRand.Next(4);
			}
			switch (num13)
			{
			case 0:
				contain = 159;
				break;
			case 1:
				contain = 65;
				break;
			case 2:
				contain = 158;
				break;
			case 3:
				contain = 2219;
				break;
			}
			if (getGoodWorldGen)
			{
				AddBuriedChest(i, num10 - 3, contain, notNearOtherChests: false, 2, trySlope: false, 0);
			}
			else
			{
				AddBuriedChest(i, num10 - 3, contain, notNearOtherChests: false, 13, trySlope: false, 0);
			}
			if (islandStyle > 0)
			{
				for (int num14 = 0; num14 < 100000; num14++)
				{
					int num15 = i + genRand.Next(-50, 51);
					int num16 = num10 + genRand.Next(21);
					if ((num14 >= 50000 || Main.tile[num15, num16].type != 202) && !Main.tile[num15, num16].active())
					{
						Place2xX(num15, num16, 207, islandStyle);
						if (Main.tile[num15, num16].active())
						{
							SwitchFountain(num15, num16);
							break;
						}
					}
				}
			}
			GenVars.skyIslandHouseCount++;
			if (!remixWorldGen)
			{
				int num17 = i - num2 / 2 + 1;
				int num18 = i + num2 / 2 - 1;
				int num19 = 1;
				if (num2 > 10)
				{
					num19 = 2;
				}
				int num20 = (num6 + num7) / 2 - 1;
				for (int num21 = num17 - num19; num21 <= num17 + num19; num21++)
				{
					for (int num22 = num20 - 1; num22 <= num20 + 1; num22++)
					{
						Main.tile[num21, num22].wall = 21;
					}
				}
				for (int num23 = num18 - num19; num23 <= num18 + num19; num23++)
				{
					for (int num24 = num20 - 1; num24 <= num20 + 1; num24++)
					{
						Main.tile[num23, num24].wall = 21;
					}
				}
			}
			int num25 = i + (num2 / 2 + 1) * -num;
			if (remixWorldGen)
			{
				if (flag)
				{
					PlaceTile(num25, num7 - 1, 14, mute: true, forced: false, -1, 5);
					PlaceTile(num25 - 2, num7 - 1, 15, mute: true, forced: false, 0, 8);
					PlaceTile(num25 + 2, num7 - 1, 15, mute: true, forced: false, 0, 8);
				}
				else
				{
					PlaceTile(num25, num7 - 1, 469, mute: true, forced: false, -1, 2);
					PlaceTile(num25 - 2, num7 - 1, 15, mute: true, forced: false, 0, 38);
					PlaceTile(num25 + 2, num7 - 1, 15, mute: true, forced: false, 0, 38);
				}
			}
			else
			{
				PlaceTile(num25, num7 - 1, 14, mute: true, forced: false, -1, 7);
				PlaceTile(num25 - 2, num7 - 1, 15, mute: true, forced: false, 0, 10);
				PlaceTile(num25 + 2, num7 - 1, 15, mute: true, forced: false, 0, 10);
			}
			Main.tile[num25 - 2, num7 - 1].frameX += 18;
			Main.tile[num25 - 2, num7 - 2].frameX += 18;
			if (!remixWorldGen)
			{
				int i2 = num4 + 1;
				int j2 = num6;
				PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
				i2 = num5 - 1;
				j2 = num6;
				PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
				if (num > 0)
				{
					i2 = num4;
					j2 = num6 + 1;
				}
				else
				{
					i2 = num5;
					j2 = num6 + 1;
				}
				PlaceTile(i2, j2, 91, mute: true, forced: false, -1, genRand.Next(7, 10));
			}
			if (islandStyle != 1)
			{
				return;
			}
			int num26 = genRand.Next(3, 6);
			for (int num27 = 0; num27 < 100000; num27++)
			{
				int num28 = i + genRand.Next(-50, 51);
				int num29 = num10 + genRand.Next(-10, 21);
				if (!Main.tile[num28, num29].active())
				{
					GrowPalmTree(num28, num29 + 1);
					if (Main.tile[num28, num29].active())
					{
						num26--;
					}
				}
				if (num26 <= 0)
				{
					break;
				}
			}
		}

		public static void Mountinater(int i, int j)
		{
			//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_020f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0210: Unknown result type (might be due to invalid IL or missing references)
			//IL_0211: Unknown result type (might be due to invalid IL or missing references)
			//IL_0216: Unknown result type (might be due to invalid IL or missing references)
			//IL_025f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0280: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(80, 120);
			double num2 = num;
			double num3 = genRand.Next(40, 55);
			if (remixWorldGen)
			{
				num2 *= 1.5;
				num3 *= 1.5;
			}
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = (double)j + num3 / 2.0;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-20, -10) * 0.1;
			while (num > 0.0 && num3 > 0.0)
			{
				num -= (double)genRand.Next(4);
				num3 -= 1.0;
				int num4 = (int)(val.X - num * 0.5);
				int num5 = (int)(val.X + num * 0.5);
				int num6 = (int)(val.Y - num * 0.5);
				int num7 = (int)(val.Y + num * 0.5);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						double num8 = Math.Abs((double)k - val.X);
						double num9 = Math.Abs((double)l - val.Y);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4 && !Main.tile[k, l].active())
						{
							Main.tile[k, l].active(active: true);
							Main.tile[k, l].type = 0;
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > 0.5)
				{
					val2.X = 0.5;
				}
				if (val2.X < -0.5)
				{
					val2.X = -0.5;
				}
				if (val2.Y > -0.5)
				{
					val2.Y = -0.5;
				}
				if (val2.Y < -1.5)
				{
					val2.Y = -1.5;
				}
			}
		}

		public static void MakeWateryIceThing(int i, int j)
		{
			if (Main.tile[i, j].liquid <= 0 || Main.tile[i, j].active() || (Main.tile[i, j].lava() && !Main.remixWorld))
			{
				return;
			}
			int num = j;
			while (!Main.tile[i, num].active() && Main.tile[i, num].liquid > 0)
			{
				num++;
				if (num > Main.maxTilesY - 50)
				{
					return;
				}
			}
			if (Main.tile[i, num].type != 147 && Main.tile[i, num].type != 161)
			{
				return;
			}
			num--;
			while (Main.tile[i, num].liquid > 0)
			{
				num--;
				if (num < 10)
				{
					return;
				}
			}
			if (Main.tile[i, num].active())
			{
				return;
			}
			num++;
			if (!Main.tile[i, num].active())
			{
				int num2 = i;
				while (!Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 - 1, num].halfBrick())
				{
					PlaceTile(num2, num, 162, mute: true);
					num2--;
				}
				for (num2 = i + 1; !Main.tile[num2, num].active() && Main.tile[num2, num].liquid > 0 && Main.tile[num2, num - 1].liquid == 0 && !Main.tile[num2, num - 1].active() && !Main.tile[num2 + 1, num].halfBrick(); num2++)
				{
					PlaceTile(num2, num, 162, mute: true);
				}
			}
		}

		public static void Lakinater(int i, int j, double strengthMultiplier = 1.0)
		{
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0107: Unknown result type (might be due to invalid IL or missing references)
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0147: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0251: Unknown result type (might be due to invalid IL or missing references)
			//IL_0252: Unknown result type (might be due to invalid IL or missing references)
			//IL_0253: Unknown result type (might be due to invalid IL or missing references)
			//IL_0258: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_0304: Unknown result type (might be due to invalid IL or missing references)
			double num = (double)genRand.Next(25, 50) * strengthMultiplier;
			double num2 = num;
			double num3 = genRand.Next(30, 80);
			if (genRand.Next(5) == 0)
			{
				num *= 1.5;
				num2 *= 1.5;
				num3 *= 1.2;
			}
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = (double)j - num3 * 0.3;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-10, 11) * 0.1;
			val2.Y = (double)genRand.Next(-20, -10) * 0.1;
			while (num > 0.0 && num3 > 0.0)
			{
				if (val.Y + num2 * 0.5 > Main.worldSurface)
				{
					num3 = 0.0;
				}
				num -= (double)genRand.Next(3);
				num3 -= 1.0;
				int num4 = (int)(val.X - num * 0.5);
				int num5 = (int)(val.X + num * 0.5);
				int num6 = (int)(val.Y - num * 0.5);
				int num7 = (int)(val.Y + num * 0.5);
				if (num4 < 0)
				{
					num4 = 0;
				}
				if (num5 > Main.maxTilesX)
				{
					num5 = Main.maxTilesX;
				}
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesY)
				{
					num7 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num4; k < num5; k++)
				{
					for (int l = num6; l < num7; l++)
					{
						double num8 = Math.Abs((double)k - val.X);
						double num9 = Math.Abs((double)l - val.Y);
						if (Math.Sqrt(num8 * num8 + num9 * num9) < num2 * 0.4)
						{
							if (Main.tile[k, l].active())
							{
								Main.tile[k, l].liquid = byte.MaxValue;
							}
							Main.tile[k, l].active(active: false);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > 0.5)
				{
					val2.X = 0.5;
				}
				if (val2.X < -0.5)
				{
					val2.X = -0.5;
				}
				if (val2.Y > 1.5)
				{
					val2.Y = 1.5;
				}
				if (val2.Y < 0.5)
				{
					val2.Y = 0.5;
				}
			}
		}

		public static void SonOfLakinater(int i, int j, double strengthMultiplier = 1.0)
		{
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_020f: Unknown result type (might be due to invalid IL or missing references)
			//IL_022a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0245: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Unknown result type (might be due to invalid IL or missing references)
			//IL_040e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0661: Unknown result type (might be due to invalid IL or missing references)
			//IL_0662: Unknown result type (might be due to invalid IL or missing references)
			//IL_0663: Unknown result type (might be due to invalid IL or missing references)
			//IL_0668: Unknown result type (might be due to invalid IL or missing references)
			//IL_06aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_06cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_06ec: Unknown result type (might be due to invalid IL or missing references)
			//IL_0728: Unknown result type (might be due to invalid IL or missing references)
			bool lava = false;
			if (getGoodWorldGen && genRand.Next(3) == 0)
			{
				lava = true;
			}
			double num = (double)genRand.Next(15, 31) * strengthMultiplier;
			double num2 = genRand.Next(30, 61);
			if (genRand.Next(5) == 0)
			{
				num *= 1.3;
				num2 *= 1.3;
			}
			if (drunkWorldGen)
			{
				num *= 1.3;
				num2 *= 1.3;
			}
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			double num3 = genRand.NextDouble() * 0.002;
			Vector2D val2 = default(Vector2D);
			if (genRand.Next(4) != 0)
			{
				val2.X = (double)genRand.Next(-15, 16) * 0.01;
			}
			else
			{
				val2.X = (double)genRand.Next(-50, 51) * 0.01;
				num3 = genRand.NextDouble() * 0.004 + 0.001;
			}
			val2.Y = (double)genRand.Next(101) * 0.01;
			double num4 = num;
			double num5 = num2;
			while (num > 3.0 && num2 > 0.0)
			{
				num -= (double)genRand.Next(11) * 0.1;
				num2 -= 1.0;
				int num6 = (int)(val.X - num * 4.0);
				int num7 = (int)(val.X + num * 4.0);
				int num8 = (int)(val.Y - num * 3.0);
				int num9 = (int)(val.Y + num * 2.0);
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesX)
				{
					num7 = Main.maxTilesX;
				}
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesY)
				{
					num9 = Main.maxTilesY;
				}
				num4 = num;
				for (int k = num6; k < num7; k++)
				{
					for (int l = num8; l < num9; l++)
					{
						double value = Math.Abs((double)k - val.X) * 0.6;
						double value2 = Math.Abs((double)l - val.Y) * 1.4;
						double value3 = Math.Abs((double)k - val.X) * 0.3;
						double value4 = Math.Abs((double)l - val.Y) * 5.0;
						value = Utils.Lerp(value, value3, num2 / num5);
						value2 = Utils.Lerp(value2, value4, num2 / num5);
						double num10 = Math.Sqrt(value * value + value2 * value2);
						int num11 = j + 5;
						if (num10 < num4 * 0.4)
						{
							if (l >= j)
							{
								if (l <= j + 1)
								{
									if (WillWaterPlacedHereStayPut(k, l))
									{
										Main.tile[k, l].liquid = byte.MaxValue;
										Main.tile[k, l].lava(lava);
									}
								}
								else
								{
									Main.tile[k, l].liquid = byte.MaxValue;
									Main.tile[k, l].lava(lava);
								}
							}
							Main.tile[k, l].active(active: false);
							if (!gen)
							{
								SquareTileFrame(k, l);
							}
							if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
							{
								SpreadGrass(k - 1, l, 59, 60);
								SpreadGrass(k + 1, l, 59, 60);
								SpreadGrass(k, l + 1, 59, 60);
							}
						}
						else if (l > j + 1 && num10 < num4 && Main.tile[k, l].liquid == 0)
						{
							if (Math.Abs((double)k - val.X) * 0.8 < num4 && Main.tile[k, l].wall > 0 && Main.tile[k - 1, l].wall > 0 && Main.tile[k + 1, l].wall > 0 && Main.tile[k, l + 1].wall > 0)
							{
								Main.tile[k, l].active(active: true);
							}
						}
						else
						{
							if (l >= j || num2 != num5 - 1.0 || !((double)l > GenVars.worldSurfaceLow - 20.0) || TileID.Sets.Clouds[Main.tile[k, l].type])
							{
								continue;
							}
							value = (double)Math.Abs(k - i) * 0.7;
							value2 = (double)Math.Abs(l - num11) * 1.35;
							num10 = Math.Sqrt(value * value + value2 * value2);
							double num12 = num4 * 0.4;
							double num13 = (double)Math.Abs(k - i) / (double)(num7 - i);
							num13 = 1.0 - num13;
							num13 *= 2.3;
							num13 *= num13;
							num13 *= num13;
							if (l < num11 && value < num12 + (double)Math.Abs(l - num11) * 0.5 * num13)
							{
								Main.tile[k, l].active(active: false);
								if (Main.tile[k, l].type == 59 || Main.tile[k, l].type == 60)
								{
									SpreadGrass(k - 1, l, 59, 60);
									SpreadGrass(k + 1, l, 59, 60);
									SpreadGrass(k, l + 1, 59, 60);
								}
							}
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-100, 101) * num3;
				val2.Y += (double)genRand.Next(-100, 101) * 0.01;
				if (val2.X > 1.0)
				{
					val2.X = 1.0;
				}
				if (val2.X < -1.0)
				{
					val2.X = -1.0;
				}
				if (val2.Y > 1.0)
				{
					val2.Y = 1.0;
				}
				double num14 = 0.5 * (1.0 - num2 / num5);
				if (val2.Y < num14)
				{
					val2.Y = num14;
				}
			}
		}

		public static void ShroomPatch(int i, int j)
		{
			//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_022b: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_032c: Unknown result type (might be due to invalid IL or missing references)
			//IL_032d: Unknown result type (might be due to invalid IL or missing references)
			//IL_032e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0333: Unknown result type (might be due to invalid IL or missing references)
			//IL_033d: Unknown result type (might be due to invalid IL or missing references)
			//IL_038b: Unknown result type (might be due to invalid IL or missing references)
			//IL_039c: Unknown result type (might be due to invalid IL or missing references)
			//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
			//IL_0401: Unknown result type (might be due to invalid IL or missing references)
			//IL_0422: Unknown result type (might be due to invalid IL or missing references)
			//IL_0443: Unknown result type (might be due to invalid IL or missing references)
			//IL_046c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0484: Unknown result type (might be due to invalid IL or missing references)
			//IL_049d: Unknown result type (might be due to invalid IL or missing references)
			//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(80, 100);
			double num2 = genRand.Next(20, 26);
			double num3 = (double)Main.maxTilesX / 4200.0;
			if (getGoodWorldGen && !Main.remixWorld)
			{
				num3 *= 1.5;
			}
			num *= num3;
			num2 *= num3;
			double num4 = num2 - 1.0;
			double num5 = num;
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = (double)j - num2 * 0.3;
			Vector2D val2 = default(Vector2D);
			val2.X = (double)genRand.Next(-100, 101) * 0.005;
			val2.Y = (double)genRand.Next(-200, -100) * 0.005;
			while (num > 0.0 && num2 > 0.0)
			{
				num -= (double)genRand.Next(3);
				num2 -= 1.0;
				int num6 = (int)(val.X - num * 0.5);
				int num7 = (int)(val.X + num * 0.5);
				int num8 = (int)(val.Y - num * 0.5);
				int num9 = (int)(val.Y + num * 0.5);
				if (num6 < 0)
				{
					num6 = 0;
				}
				if (num7 > Main.maxTilesX)
				{
					num7 = Main.maxTilesX;
				}
				if (num8 < 0)
				{
					num8 = 0;
				}
				if (num9 > Main.maxTilesY)
				{
					num9 = Main.maxTilesY;
				}
				num5 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num6; k < num7; k++)
				{
					for (int l = num8; l < num9; l++)
					{
						double num10 = Math.Abs((double)k - val.X);
						double num11 = Math.Abs(((double)l - val.Y) * 2.3);
						double num12 = Math.Sqrt(num10 * num10 + num11 * num11);
						if (num12 < num5 * 0.8 && Main.tile[k, l].lava())
						{
							Main.tile[k, l].liquid = 0;
						}
						if (num12 < num5 * 0.2 && (double)l < val.Y)
						{
							Main.tile[k, l].active(active: false);
							if (Main.tile[k, l].wall > 0)
							{
								Main.tile[k, l].wall = 80;
							}
						}
						else if (num12 < num5 * 0.4 * (0.95 + genRand.NextDouble() * 0.1))
						{
							Main.tile[k, l].type = 59;
							if (num2 == num4 && (double)l > val.Y)
							{
								Main.tile[k, l].active(active: true);
							}
							if (Main.tile[k, l].wall > 0)
							{
								Main.tile[k, l].wall = 80;
							}
						}
					}
				}
				val += val2;
				val.X += val2.X;
				val2.X += (double)genRand.Next(-100, 110) * 0.005;
				val2.Y -= (double)genRand.Next(110) * 0.005;
				if (val2.X > -0.5 && val2.X < 0.5)
				{
					if (val2.X < 0.0)
					{
						val2.X = -0.5;
					}
					else
					{
						val2.X = 0.5;
					}
				}
				if (val2.X > 0.5)
				{
					val2.X = 0.5;
				}
				if (val2.X < -0.5)
				{
					val2.X = -0.5;
				}
				if (val2.Y > 0.5)
				{
					val2.Y = 0.5;
				}
				if (val2.Y < -0.5)
				{
					val2.Y = -0.5;
				}
				for (int m = 0; m < 2; m++)
				{
					int num13 = (int)val.X + genRand.Next(-20, 20);
					int num14 = (int)val.Y + genRand.Next(0, 20);
					while (!Main.tile[num13, num14].active() && Main.tile[num13, num14].type != 59)
					{
						num13 = (int)val.X + genRand.Next(-20, 20);
						num14 = (int)val.Y + genRand.Next(0, 20);
					}
					int num15 = genRand.Next(10, 20);
					int steps = genRand.Next(10, 20);
					TileRunner(num13, num14, num15, steps, 59, addTile: false, 0.0, 2.0, noYChange: true);
				}
			}
		}

		public static void Cavinator(int i, int j, int steps)
		{
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_0131: Unknown result type (might be due to invalid IL or missing references)
			//IL_0140: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_021d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0246: Unknown result type (might be due to invalid IL or missing references)
			//IL_026f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0290: Unknown result type (might be due to invalid IL or missing references)
			//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(7, 15);
			double num2 = num;
			int num3 = 1;
			if (genRand.Next(2) == 0)
			{
				num3 = -1;
			}
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			int num4 = genRand.Next(20, 40);
			Vector2D val2 = default(Vector2D);
			val2.Y = (double)genRand.Next(10, 20) * 0.01;
			val2.X = num3;
			while (num4 > 0)
			{
				num4--;
				int num5 = (int)(val.X - num * 0.5);
				int num6 = (int)(val.X + num * 0.5);
				int num7 = (int)(val.Y - num * 0.5);
				int num8 = (int)(val.Y + num * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						double num9 = Math.Abs((double)k - val.X);
						double num10 = Math.Abs((double)l - val.Y);
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type] && Main.tile[k, l].type != 53)
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > (double)num3 + 0.5)
				{
					val2.X = (double)num3 + 0.5;
				}
				if (val2.X < (double)num3 - 0.5)
				{
					val2.X = (double)num3 - 0.5;
				}
				if (val2.Y > 2.0)
				{
					val2.Y = 2.0;
				}
				if (val2.Y < 0.0)
				{
					val2.Y = 0.0;
				}
			}
			if (steps > 0 && (double)(int)val.Y < Main.rockLayer + 50.0)
			{
				Cavinator((int)val.X, (int)val.Y, steps - 1);
			}
		}

		public static void CaveOpenater(int i, int j)
		{
			//IL_0081: Unknown result type (might be due to invalid IL or missing references)
			//IL_0088: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_017f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0242: Unknown result type (might be due to invalid IL or missing references)
			//IL_026b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0294: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
			double num = genRand.Next(7, 12);
			double num2 = num;
			int num3 = 1;
			if (genRand.Next(2) == 0)
			{
				num3 = -1;
			}
			if (genRand.Next(10) != 0)
			{
				num3 = ((i < Main.maxTilesX / 2) ? 1 : (-1));
			}
			Vector2D val = default(Vector2D);
			val.X = i;
			val.Y = j;
			int num4 = 100;
			Vector2D val2 = default(Vector2D);
			val2.Y = 0.0;
			val2.X = num3;
			while (num4 > 0)
			{
				Tile tile = Main.tile[(int)val.X, (int)val.Y];
				if (tile.wall == 0 || (tile.active() && !TileID.Sets.CanBeClearedDuringGeneration[tile.type]))
				{
					num4 = 0;
				}
				num4--;
				int num5 = (int)(val.X - num * 0.5);
				int num6 = (int)(val.X + num * 0.5);
				int num7 = (int)(val.Y - num * 0.5);
				int num8 = (int)(val.Y + num * 0.5);
				if (num5 < 0)
				{
					num5 = 0;
				}
				if (num6 > Main.maxTilesX)
				{
					num6 = Main.maxTilesX;
				}
				if (num7 < 0)
				{
					num7 = 0;
				}
				if (num8 > Main.maxTilesY)
				{
					num8 = Main.maxTilesY;
				}
				num2 = num * (double)genRand.Next(80, 120) * 0.01;
				for (int k = num5; k < num6; k++)
				{
					for (int l = num7; l < num8; l++)
					{
						double num9 = Math.Abs((double)k - val.X);
						double num10 = Math.Abs((double)l - val.Y);
						if (Math.Sqrt(num9 * num9 + num10 * num10) < num2 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[Main.tile[k, l].type])
						{
							Main.tile[k, l].active(active: false);
						}
					}
				}
				val += val2;
				val2.X += (double)genRand.Next(-10, 11) * 0.05;
				val2.Y += (double)genRand.Next(-10, 11) * 0.05;
				if (val2.X > (double)num3 + 0.5)
				{
					val2.X = (double)num3 + 0.5;
				}
				if (val2.X < (double)num3 - 0.5)
				{
					val2.X = (double)num3 - 0.5;
				}
				if (val2.Y > 0.0)
				{
					val2.Y = 0.0;
				}
				if (val2.Y < -0.5)
				{
					val2.Y = -0.5;
				}
			}
		}

		public static void DiamondTileFrame(int i, int j)
		{
			TileFrame(i - 1, j);
			TileFrame(i, j - 1);
			TileFrame(i, j + 1);
			TileFrame(i + 1, j);
		}

		public static void SquareTileFrame(int i, int j, bool resetFrame = true)
		{
			TileFrame(i - 1, j - 1);
			TileFrame(i - 1, j);
			TileFrame(i - 1, j + 1);
			TileFrame(i, j - 1);
			TileFrame(i, j, resetFrame);
			TileFrame(i, j + 1);
			TileFrame(i + 1, j - 1);
			TileFrame(i + 1, j);
			TileFrame(i + 1, j + 1);
		}

		public static void SquareWallFrame(int i, int j, bool resetFrame = true)
		{
			Framing.WallFrame(i - 1, j - 1);
			Framing.WallFrame(i - 1, j);
			Framing.WallFrame(i - 1, j + 1);
			Framing.WallFrame(i, j - 1);
			Framing.WallFrame(i, j, resetFrame);
			Framing.WallFrame(i, j + 1);
			Framing.WallFrame(i + 1, j - 1);
			Framing.WallFrame(i + 1, j);
			Framing.WallFrame(i + 1, j + 1);
		}

		public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY)
		{
			int sectionX = Netplay.GetSectionX(startX);
			int sectionY = Netplay.GetSectionY(startY);
			int sectionX2 = Netplay.GetSectionX(endX);
			int sectionY2 = Netplay.GetSectionY(endY);
			for (int i = sectionX; i <= sectionX2; i++)
			{
				for (int j = sectionY; j <= sectionY2; j++)
				{
					if (Main.sectionManager.SectionLoaded(i, j) && !Main.sectionManager.SectionFramed(i, j))
					{
						SectionTileFrame(i, j, i, j);
						if (!Main.sectionManager.AnyUnfinishedSections)
						{
							return;
						}
					}
				}
			}
		}

		public static void RefreshSections(int startX, int startY, int endX, int endY)
		{
			int sectionX = Netplay.GetSectionX(startX);
			int sectionY = Netplay.GetSectionY(startY);
			int sectionX2 = Netplay.GetSectionX(endX);
			int sectionY2 = Netplay.GetSectionY(endY);
			for (int i = sectionX; i <= sectionX2; i++)
			{
				for (int j = sectionY; j <= sectionY2; j++)
				{
					if (Main.sectionManager.SectionNeedsRefresh(i, j))
					{
						RefreshSection(i, j);
					}
				}
			}
		}

		public static void RefreshSection(int sectionX, int sectionY)
		{
			GetSectionBounds(sectionX, sectionY, sectionX, sectionY, out var tileStartX, out var tileEndX, out var tileStartY, out var tileEndY);
			noMapUpdate = true;
			int totalEcho = 0;
			int totalFramed = 0;
			for (int i = tileStartY; i < tileEndY; i += 50)
			{
				for (int j = tileStartX; j < tileEndX; j += 200)
				{
					RefreshStrip(j, i, Math.Min(j + 200, tileEndX), Math.Min(i + 50, tileEndY), ref totalEcho, ref totalFramed);
				}
			}
			noMapUpdate = false;
			Main.sectionManager.SetSectionAsRefreshed(sectionX, sectionY);
		}

		public static void RefreshStrip(int xStart, int yStart, int xEnd, int yEnd, ref int totalEcho, ref int totalFramed)
		{
			int num = xStart - 1;
			int num2 = yStart - 1;
			int num3 = xEnd - xStart;
			int num4 = yEnd - yStart;
			if (num4 > 50 || num3 > 200)
			{
				throw new IndexOutOfRangeException();
			}
			int num5 = 0;
			Vertical64BitStrips vertical64BitStrips = bitStrip;
			for (int i = 1; i <= num3; i++)
			{
				Bits64 value = default(Bits64);
				for (int j = 1; j <= num4; j++)
				{
					Tile tile = Main.tile[num + i, num2 + j];
					if (tile != null && (tile.invisibleBlock() || tile.invisibleWall()))
					{
						num5++;
						value[j] = true;
					}
				}
				vertical64BitStrips[i] = value;
			}
			if (num5 == 0)
			{
				return;
			}
			vertical64BitStrips.Expand3x3();
			for (int k = 0; k < num3 + 2; k++)
			{
				Bits64 bits = vertical64BitStrips[k];
				if (bits.IsEmpty)
				{
					continue;
				}
				for (int l = 0; l < num4 + 2; l++)
				{
					if (bits[l])
					{
						totalFramed++;
						Reframe(num + k, num2 + l);
					}
				}
			}
			vertical64BitStrips.Clear();
			totalEcho += num5;
		}

		public static void Reframe(int x, int y, bool resetFrame = false)
		{
			TileFrame(x, y, resetFrame, noBreak: true);
			Framing.WallFrame(x, y, resetFrame);
		}

		public static void SectionTileFrame(int sectionStartX, int sectionStartY, int sectionEndXInclusive, int sectionEndYInclusive)
		{
			Main.mapTime = Main.mapTimeMax + 10;
			noMapUpdate = true;
			GetSectionBounds(sectionStartX, sectionStartY, sectionEndXInclusive, sectionEndYInclusive, out var tileStartX, out var tileEndX, out var tileStartY, out var tileEndY);
			for (int i = tileStartX - 1; i < tileEndX + 1; i++)
			{
				for (int j = tileStartY - 1; j < tileEndY + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						Main.tile[i, j] = new Tile();
					}
					Reframe(i, j, resetFrame: true);
				}
			}
			for (int k = sectionStartX; k <= sectionEndXInclusive; k++)
			{
				for (int l = sectionStartY; l <= sectionEndYInclusive; l++)
				{
					Main.sectionManager.SetSectionFramed(k, l);
				}
			}
			noMapUpdate = false;
		}

		public static void GetSectionBounds(int sectionStartX, int sectionStartY, int sectionEndXInclusive, int sectionEndYInclusive, out int tileStartX, out int tileEndX, out int tileStartY, out int tileEndY)
		{
			tileStartX = sectionStartX * 200;
			tileEndX = (sectionEndXInclusive + 1) * 200;
			tileStartY = sectionStartY * 150;
			tileEndY = (sectionEndYInclusive + 1) * 150;
			if (tileStartX < 1)
			{
				tileStartX = 1;
			}
			if (tileStartY < 1)
			{
				tileStartY = 1;
			}
			if (tileStartX > Main.maxTilesX - 2)
			{
				tileStartX = Main.maxTilesX - 2;
			}
			if (tileStartY > Main.maxTilesY - 2)
			{
				tileStartY = Main.maxTilesY - 2;
			}
			if (tileEndX > Main.maxTilesX - 2)
			{
				tileEndX = Main.maxTilesX - 2;
			}
			if (tileEndY > Main.maxTilesY - 2)
			{
				tileEndY = Main.maxTilesY - 2;
			}
		}

		public static void RangeFrame(int startX, int startY, int endX, int endY)
		{
			int num = endX + 1;
			int num2 = endY + 1;
			for (int i = startX - 1; i < num + 1; i++)
			{
				for (int j = startY - 1; j < num2 + 1; j++)
				{
					TileFrame(i, j);
					Framing.WallFrame(i, j);
				}
			}
		}

		public static void WaterCheck()
		{
			Liquid.tilesIgnoreWater(ignoreSolids: true);
			Liquid.numLiquid = 0;
			LiquidBuffer.numLiquidBuffer = 0;
			for (int i = 1; i < Main.maxTilesX - 1; i++)
			{
				for (int num = Main.maxTilesY - 2; num > 0; num--)
				{
					Tile tile = Main.tile[i, num];
					tile.checkingLiquid(checkingLiquid: false);
					if (tile.liquid > 0 && tile.nactive() && Main.tileSolid[tile.type] && !Main.tileSolidTop[tile.type])
					{
						tile.liquid = 0;
					}
					else if (tile.liquid > 0)
					{
						if (tile.active())
						{
							if (tile.lava())
							{
								if (TileObjectData.CheckLavaDeath(tile))
								{
									KillTile(i, num);
								}
							}
							else if (TileObjectData.CheckWaterDeath(tile))
							{
								KillTile(i, num);
							}
						}
						Tile tile2 = Main.tile[i, num + 1];
						if ((!tile2.nactive() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type]) && tile2.liquid < byte.MaxValue)
						{
							if (tile2.liquid > 250)
							{
								tile2.liquid = byte.MaxValue;
							}
							else
							{
								Liquid.AddWater(i, num);
							}
						}
						Tile tile3 = Main.tile[i - 1, num];
						Tile tile4 = Main.tile[i + 1, num];
						if ((!tile3.nactive() || !Main.tileSolid[tile3.type] || Main.tileSolidTop[tile3.type]) && tile3.liquid != tile.liquid)
						{
							Liquid.AddWater(i, num);
						}
						else if ((!tile4.nactive() || !Main.tileSolid[tile4.type] || Main.tileSolidTop[tile4.type]) && tile4.liquid != tile.liquid)
						{
							Liquid.AddWater(i, num);
						}
						if (tile.lava())
						{
							if (tile3.liquid > 0 && !tile3.lava())
							{
								Liquid.AddWater(i, num);
							}
							else if (tile4.liquid > 0 && !tile4.lava())
							{
								Liquid.AddWater(i, num);
							}
							else if (Main.tile[i, num - 1].liquid > 0 && !Main.tile[i, num - 1].lava())
							{
								Liquid.AddWater(i, num);
							}
							else if (tile2.liquid > 0 && !tile2.lava())
							{
								Liquid.AddWater(i, num);
							}
						}
					}
				}
			}
			Liquid.tilesIgnoreWater(ignoreSolids: false);
		}

		public static void EveryTileFrame()
		{
			Stopwatch stopwatch = new Stopwatch();
			stopwatch.Start();
			noLiquidCheck = true;
			noTileActions = true;
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				float num = (float)i / (float)Main.maxTilesX;
				Main.statusText = Lang.gen[55].Value + " " + (int)(num * 100f + 1f) + "%";
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					if (Main.tile[i, j].active())
					{
						TileFrame(i, j, resetFrame: true);
					}
					if (Main.tile[i, j].wall > 0)
					{
						Framing.WallFrame(i, j, resetFrame: true);
					}
				}
			}
			noLiquidCheck = false;
			noTileActions = false;
			_ = stopwatch.ElapsedMilliseconds;
		}

		public static void PlantCheck(int x, int y)
		{
			x = Utils.Clamp(x, 1, Main.maxTilesX - 2);
			y = Utils.Clamp(y, 1, Main.maxTilesY - 2);
			for (int i = x - 1; i <= x + 1; i++)
			{
				for (int j = y - 1; j <= y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						return;
					}
				}
			}
			int num = -1;
			int num2 = Main.tile[x, y].type;
			_ = x - 1;
			_ = 0;
			_ = x + 1;
			_ = Main.maxTilesX;
			_ = y - 1;
			_ = 0;
			if (y + 1 >= Main.maxTilesY)
			{
				num = num2;
			}
			if (x - 1 >= 0 && Main.tile[x - 1, y] != null && Main.tile[x - 1, y].nactive())
			{
				_ = Main.tile[x - 1, y].type;
			}
			if (x + 1 < Main.maxTilesX && Main.tile[x + 1, y] != null && Main.tile[x + 1, y].nactive())
			{
				_ = Main.tile[x + 1, y].type;
			}
			if (y - 1 >= 0 && Main.tile[x, y - 1] != null && Main.tile[x, y - 1].nactive())
			{
				_ = Main.tile[x, y - 1].type;
			}
			if (y + 1 < Main.maxTilesY && Main.tile[x, y + 1] != null && Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == 0)
			{
				num = Main.tile[x, y + 1].type;
			}
			if (x - 1 >= 0 && y - 1 >= 0 && Main.tile[x - 1, y - 1] != null && Main.tile[x - 1, y - 1].nactive())
			{
				_ = Main.tile[x - 1, y - 1].type;
			}
			if (x + 1 < Main.maxTilesX && y - 1 >= 0 && Main.tile[x + 1, y - 1] != null && Main.tile[x + 1, y - 1].nactive())
			{
				_ = Main.tile[x + 1, y - 1].type;
			}
			if (x - 1 >= 0 && y + 1 < Main.maxTilesY && Main.tile[x - 1, y + 1] != null && Main.tile[x - 1, y + 1].nactive())
			{
				_ = Main.tile[x - 1, y + 1].type;
			}
			if (x + 1 < Main.maxTilesX && y + 1 < Main.maxTilesY && Main.tile[x + 1, y + 1] != null && Main.tile[x + 1, y + 1].nactive())
			{
				_ = Main.tile[x + 1, y + 1].type;
			}
			if ((num2 != 3 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 73 || num == 2 || num == 477 || num == 78 || num == 380 || num == 579) && (num2 != 24 || num == 23 || num == 661) && (num2 != 61 || num == 60) && (num2 != 74 || num == 60) && (num2 != 71 || num == 70) && (num2 != 110 || num == 109 || num == 492) && (num2 != 113 || num == 109 || num == 492) && (num2 != 201 || num == 199 || num == 662) && (num2 != 637 || num == 633))
			{
				return;
			}
			bool flag = false;
			if (num2 == 3 || num2 == 110 || num2 == 24)
			{
				flag = Main.tile[x, y].frameX == 144;
			}
			if (num2 == 201)
			{
				flag = Main.tile[x, y].frameX == 270;
			}
			if ((num2 == 3 || num2 == 73) && num != 2 && num != 477 && Main.tile[x, y].frameX >= 162)
			{
				Main.tile[x, y].frameX = 126;
			}
			if (num2 == 74 && num != 60 && Main.tile[x, y].frameX >= 162)
			{
				Main.tile[x, y].frameX = 126;
			}
			switch (num)
			{
			case 23:
			case 661:
				num2 = 24;
				if (Main.tile[x, y].frameX >= 162)
				{
					Main.tile[x, y].frameX = 126;
				}
				break;
			case 2:
			case 477:
				num2 = ((num2 != 113) ? 3 : 73);
				break;
			case 109:
			case 492:
				num2 = ((num2 != 73) ? 110 : 113);
				break;
			case 199:
			case 662:
				num2 = 201;
				break;
			case 60:
				num2 = 61;
				while (Main.tile[x, y].frameX > 126)
				{
					Main.tile[x, y].frameX -= 126;
				}
				break;
			case 70:
				num2 = 71;
				while (Main.tile[x, y].frameX > 72)
				{
					Main.tile[x, y].frameX -= 72;
				}
				break;
			}
			if (num2 != Main.tile[x, y].type)
			{
				Main.tile[x, y].type = (ushort)num2;
				if (flag)
				{
					Main.tile[x, y].frameX = 144;
					if (num2 == 201)
					{
						Main.tile[x, y].frameX = 270;
					}
				}
			}
			else
			{
				KillTile(x, y);
			}
		}

		public static bool CanPoundTile(int x, int y)
		{
			if (Main.tile[x, y] == null)
			{
				Main.tile[x, y] = new Tile();
			}
			if (Main.tile[x, y - 1] == null)
			{
				Main.tile[x, y - 1] = new Tile();
			}
			if (Main.tile[x, y + 1] == null)
			{
				Main.tile[x, y + 1] = new Tile();
			}
			switch (Main.tile[x, y].type)
			{
			case 10:
			case 48:
			case 137:
			case 138:
			case 232:
			case 380:
			case 387:
			case 388:
			case 476:
			case 484:
			case 664:
			case 665:
				return false;
			default:
				if (gen)
				{
					if (Main.tile[x, y].type == 190)
					{
						return false;
					}
					if (Main.tile[x, y].type == 30)
					{
						return false;
					}
				}
				if (Main.tile[x, y - 1].active())
				{
					switch (Main.tile[x, y - 1].type)
					{
					case 21:
					case 26:
					case 77:
					case 88:
					case 235:
					case 237:
					case 441:
					case 467:
					case 468:
					case 470:
					case 475:
					case 488:
					case 597:
						return false;
					}
				}
				return CanKillTile(x, y);
			}
		}

		public static bool SlopeTile(int i, int j, int slope = 0, bool noEffects = false)
		{
			if (!CanPoundTile(i, j))
			{
				return false;
			}
			Main.tile[i, j].halfBrick(halfBrick: false);
			Main.tile[i, j].slope((byte)slope);
			if (!gen)
			{
				if (!noEffects)
				{
					KillTile(i, j, fail: true, effectOnly: true);
				}
				SoundEngine.PlaySound(0, i * 16, j * 16);
				SquareTileFrame(i, j);
				if (Main.tile[i, j].slope() == 0)
				{
					Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
					for (int k = 0; k < 255; k++)
					{
						if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
						{
							Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
							Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
						}
					}
				}
			}
			return true;
		}

		public static bool PoundTile(int i, int j)
		{
			if (!CanPoundTile(i, j))
			{
				return false;
			}
			if (!Main.tile[i, j].halfBrick())
			{
				Main.tile[i, j].halfBrick(halfBrick: true);
			}
			else
			{
				Main.tile[i, j].halfBrick(halfBrick: false);
			}
			if (!gen)
			{
				KillTile(i, j, fail: true, effectOnly: true);
				SoundEngine.PlaySound(0, i * 16, j * 16);
				SquareTileFrame(i, j);
				if (!Main.tile[i, j].halfBrick())
				{
					Rectangle rectangle = new Rectangle(i * 16, j * 16, 16, 16);
					for (int k = 0; k < 255; k++)
					{
						if (Main.player[k].active && !Main.player[k].dead && rectangle.Intersects(new Rectangle((int)Main.player[k].position.X, (int)Main.player[k].position.Y, Main.player[k].width, Main.player[k].height)))
						{
							Main.player[k].gfxOffY += Main.player[k].position.Y + (float)Main.player[k].height - (float)rectangle.Y;
							Main.player[k].position.Y = rectangle.Y - Main.player[k].height;
						}
					}
				}
			}
			return true;
		}

		public static void PoundPlatform(int x, int y)
		{
			if (Main.tile[x, y].halfBrick())
			{
				PoundTile(x, y);
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
				}
				return;
			}
			int num = 1;
			int slope = 2;
			if (TileID.Sets.Platforms[Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[Main.tile[x - 1, y + 1].type] || (SolidTile(x + 1, y) && !SolidTile(x - 1, y)))
			{
				num = 2;
				slope = 1;
			}
			if (Main.tile[x, y].slope() == 0)
			{
				SlopeTile(x, y, num);
				int num2 = Main.tile[x, y].slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, x, y, num2);
				}
				return;
			}
			if (Main.tile[x, y].slope() == num)
			{
				SlopeTile(x, y, slope);
				int num3 = Main.tile[x, y].slope();
				if (Main.netMode == 1)
				{
					NetMessage.SendData(17, -1, -1, null, 14, x, y, num3);
				}
				return;
			}
			SlopeTile(x, y);
			int num4 = Main.tile[x, y].slope();
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 14, x, y, num4);
			}
			PoundTile(x, y);
			if (Main.netMode == 1)
			{
				NetMessage.SendData(17, -1, -1, null, 7, x, y, 1f);
			}
		}

		public static int PlatformProperSides(int x, int y, bool acceptNonOpposing = false)
		{
			Tile tile = Main.tile[x, y];
			if (!tile.active() || !TileID.Sets.Platforms[tile.type])
			{
				return 0;
			}
			int num = tile.slope();
			int num2 = -1;
			if (num == 1)
			{
				num2 = 2;
			}
			if (num == 2)
			{
				num2 = 1;
			}
			int num3 = 0;
			int num4 = 1;
			int num5 = 0;
			if (num == 1)
			{
				num5 = 1;
			}
			if (num == 2)
			{
				num5 = -1;
			}
			if (acceptNonOpposing)
			{
				if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
				{
					num3++;
				}
			}
			else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num)
			{
				num3++;
			}
			num4 *= -1;
			num5 *= -1;
			if (acceptNonOpposing)
			{
				if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() != num2)
				{
					num3++;
				}
			}
			else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[Main.tile[x + num4, y + num5].type] && Main.tile[x + num4, y + num5].slope() == num)
			{
				num3++;
			}
			return num3;
		}

		public static bool UpdateMapTile(int i, int j, bool addToList = true)
		{
			bool result = false;
			if (Main.mapEnabled && !noMapUpdate && !gen && !Main.refreshMap && Main.Map[i, j].Light > 0 && Main.Map.UpdateType(i, j) && addToList)
			{
				result = true;
				if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1)
				{
					MapHelper.updateTileX[MapHelper.numUpdateTile] = (short)i;
					MapHelper.updateTileY[MapHelper.numUpdateTile] = (short)j;
					MapHelper.numUpdateTile++;
				}
				else
				{
					Main.refreshMap = true;
				}
			}
			return result;
		}

		public static void TileMergeAttemptFrametest(int i, int j, int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (up == lookfor)
			{
				TileFrame(i, j - 1);
				if (mergeDown)
				{
					up = myType;
				}
			}
			if (down == lookfor)
			{
				TileFrame(i, j + 1);
				if (mergeUp)
				{
					down = myType;
				}
			}
			if (left == lookfor)
			{
				TileFrame(i - 1, j);
				if (mergeRight)
				{
					left = myType;
				}
			}
			if (right == lookfor)
			{
				TileFrame(i + 1, j);
				if (mergeLeft)
				{
					right = myType;
				}
			}
			if (upLeft == lookfor)
			{
				upLeft = myType;
			}
			if (upRight == lookfor)
			{
				upRight = myType;
			}
			if (downLeft == lookfor)
			{
				downLeft = myType;
			}
			if (downRight == lookfor)
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttemptFrametest(int i, int j, int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (up > -1 && lookfor[up])
			{
				TileFrame(i, j - 1);
				if (mergeDown)
				{
					up = myType;
				}
			}
			if (down > -1 && lookfor[down])
			{
				TileFrame(i, j + 1);
				if (mergeUp)
				{
					down = myType;
				}
			}
			if (left > -1 && lookfor[left])
			{
				TileFrame(i - 1, j);
				if (mergeRight)
				{
					left = myType;
				}
			}
			if (right > -1 && lookfor[right])
			{
				TileFrame(i + 1, j);
				if (mergeLeft)
				{
					right = myType;
				}
			}
			if (upLeft > -1 && lookfor[upLeft])
			{
				upLeft = myType;
			}
			if (upRight > -1 && lookfor[upRight])
			{
				upRight = myType;
			}
			if (downLeft > -1 && lookfor[downLeft])
			{
				downLeft = myType;
			}
			if (downRight > -1 && lookfor[downRight])
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right)
		{
			if (lookfor == up)
			{
				up = myType;
			}
			if (lookfor == down)
			{
				down = myType;
			}
			if (lookfor == left)
			{
				left = myType;
			}
			if (lookfor == right)
			{
				right = myType;
			}
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right)
		{
			if (up > -1 && lookfor[up])
			{
				up = myType;
			}
			if (down > -1 && lookfor[down])
			{
				down = myType;
			}
			if (left > -1 && lookfor[left])
			{
				left = myType;
			}
			if (right > -1 && lookfor[right])
			{
				right = myType;
			}
		}

		public static void TileMergeAttempt(int myType, int lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (lookfor == up)
			{
				up = myType;
			}
			if (lookfor == down)
			{
				down = myType;
			}
			if (lookfor == left)
			{
				left = myType;
			}
			if (lookfor == right)
			{
				right = myType;
			}
			if (lookfor == upLeft)
			{
				upLeft = myType;
			}
			if (lookfor == upRight)
			{
				upRight = myType;
			}
			if (lookfor == downLeft)
			{
				downLeft = myType;
			}
			if (lookfor == downRight)
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (up > -1 && lookfor[up])
			{
				up = myType;
			}
			if (down > -1 && lookfor[down])
			{
				down = myType;
			}
			if (left > -1 && lookfor[left])
			{
				left = myType;
			}
			if (right > -1 && lookfor[right])
			{
				right = myType;
			}
			if (upLeft > -1 && lookfor[upLeft])
			{
				upLeft = myType;
			}
			if (upRight > -1 && lookfor[upRight])
			{
				upRight = myType;
			}
			if (downLeft > -1 && lookfor[downLeft])
			{
				downLeft = myType;
			}
			if (downRight > -1 && lookfor[downRight])
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttempt(int myType, bool[] lookfor, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (up > -1 && !exclude[up] && lookfor[up])
			{
				up = myType;
			}
			if (down > -1 && !exclude[down] && lookfor[down])
			{
				down = myType;
			}
			if (left > -1 && !exclude[left] && lookfor[left])
			{
				left = myType;
			}
			if (right > -1 && !exclude[right] && lookfor[right])
			{
				right = myType;
			}
			if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
			{
				upLeft = myType;
			}
			if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
			{
				upRight = myType;
			}
			if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
			{
				downLeft = myType;
			}
			if (downRight > -1 && !exclude[downRight] && lookfor[downRight])
			{
				downRight = myType;
			}
		}

		public static void TileMergeAttemptWeird(int myType, int changeTo, bool[] exclude, ref int up, ref int down, ref int left, ref int right, ref int upLeft, ref int upRight, ref int downLeft, ref int downRight)
		{
			if (up > -1 && !exclude[up] && up != myType)
			{
				up = changeTo;
			}
			if (down > -1 && !exclude[down] && down != myType)
			{
				down = changeTo;
			}
			if (left > -1 && !exclude[left] && left != myType)
			{
				left = changeTo;
			}
			if (right > -1 && !exclude[right] && right != myType)
			{
				right = changeTo;
			}
			if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
			{
				upLeft = changeTo;
			}
			if (upRight > -1 && !exclude[upRight] && upRight != myType)
			{
				upRight = changeTo;
			}
			if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
			{
				downLeft = changeTo;
			}
			if (downRight > -1 && !exclude[downRight] && downRight != myType)
			{
				downRight = changeTo;
			}
		}

		public static int GetTileMossColor(int tileType)
		{
			switch (tileType)
			{
			default:
				return -1;
			case 179:
			case 512:
				return 0;
			case 180:
			case 513:
				return 1;
			case 181:
			case 514:
				return 2;
			case 182:
			case 515:
				return 3;
			case 183:
			case 516:
				return 4;
			case 381:
			case 517:
				return 5;
			case 534:
			case 535:
				return 6;
			case 536:
			case 537:
				return 7;
			case 539:
			case 540:
				return 8;
			case 625:
			case 626:
				return 9;
			case 627:
			case 628:
				return 10;
			}
		}

		public static void CheckFoodPlatter(int x, int y, int type)
		{
			if (Main.tile[x, y] == null || destroyObject || SolidTileAllowBottomSlope(x, y + 1))
			{
				return;
			}
			if (type == 520)
			{
				int num = TEFoodPlatter.Find(x, y);
				if (num != -1 && ((TEFoodPlatter)TileEntity.ByID[num]).item.stack > 0)
				{
					((TEFoodPlatter)TileEntity.ByID[num]).DropItem();
					if (Main.netMode != 2)
					{
						Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
					}
				}
			}
			destroyObject = true;
			if (Main.tile[x, y].type == type)
			{
				KillTile(x, y);
			}
			if (type == 520)
			{
				TEFoodPlatter.Kill(x, y);
			}
			destroyObject = false;
		}

		public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false)
		{
			bool addToList = false;
			try
			{
				if (i > 5 && j > 5 && i < Main.maxTilesX - 5 && j < Main.maxTilesY - 5 && Main.tile[i, j] != null)
				{
					if (SkipFramingBecauseOfGen && !Main.tileFrameImportant[Main.tile[i, j].type])
					{
						return;
					}
					addToList = UpdateMapTile(i, j);
					Tile tile = Main.tile[i, j];
					if (!tile.active())
					{
						tile.halfBrick(halfBrick: false);
						tile.ClearBlockPaintAndCoating();
						tile.slope(0);
					}
					if (tile.liquid > 0 && Main.netMode != 1 && !noLiquidCheck)
					{
						Liquid.AddWater(i, j);
					}
					if (tile.active())
					{
						if (noBreak && Main.tileFrameImportant[tile.type] && tile.type != 4)
						{
							return;
						}
						int num = tile.type;
						if (Main.tileStone[num])
						{
							num = 1;
						}
						int frameX = tile.frameX;
						int frameY = tile.frameY;
						Rectangle rectangle = new Rectangle(-1, -1, 0, 0);
						if (Main.tileFrameImportant[tile.type])
						{
							switch (num)
							{
							case 518:
								CheckLilyPad(i, j);
								break;
							case 519:
								CheckCatTail(i, j);
								break;
							case 549:
								CheckUnderwaterPlant(549, i, j);
								break;
							case 571:
								CheckBamboo(i, j);
								break;
							case 4:
								CheckTorch(i, j);
								break;
							case 442:
								CheckProjectilePressurePad(i, j);
								break;
							case 136:
							{
								Tile tile2 = Main.tile[i, j - 1];
								Tile tile3 = Main.tile[i, j + 1];
								Tile tile4 = Main.tile[i - 1, j];
								Tile tile5 = Main.tile[i + 1, j];
								Tile tile6 = Main.tile[i - 1, j + 1];
								Tile tile7 = Main.tile[i + 1, j + 1];
								Tile tile8 = Main.tile[i - 1, j - 1];
								Tile tile9 = Main.tile[i + 1, j - 1];
								int num20 = -1;
								int num21 = -1;
								int num22 = -1;
								int tree = -1;
								int tree2 = -1;
								int tree3 = -1;
								int tree4 = -1;
								if (tile2 != null && tile2.nactive())
								{
									_ = tile2.type;
								}
								if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
								{
									num20 = tile3.type;
								}
								if (tile4 != null && tile4.nactive())
								{
									num21 = tile4.type;
								}
								if (tile5 != null && tile5.nactive())
								{
									num22 = tile5.type;
								}
								if (tile6 != null && tile6.nactive())
								{
									tree = tile6.type;
								}
								if (tile7 != null && tile7.nactive())
								{
									tree2 = tile7.type;
								}
								if (tile8 != null && tile8.nactive())
								{
									tree3 = tile8.type;
								}
								if (tile9 != null && tile9.nactive())
								{
									tree4 = tile9.type;
								}
								if (num20 >= 0 && Main.tileSolid[num20] && !Main.tileNoAttach[num20] && !tile3.halfBrick() && (tile3.slope() == 0 || tile3.bottomSlope()))
								{
									tile.frameX = 0;
								}
								else if ((num21 >= 0 && Main.tileSolid[num21] && !Main.tileNoAttach[num21] && (tile4.leftSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num21 >= 0 && TileID.Sets.IsBeam[num21]) || (IsTreeType(num21) && IsTreeType(tree3) && IsTreeType(tree)))
								{
									tile.frameX = 18;
								}
								else if ((num22 >= 0 && Main.tileSolid[num22] && !Main.tileNoAttach[num22] && (tile5.rightSlope() || tile5.slope() == 0) && !tile5.halfBrick()) || (num22 >= 0 && TileID.Sets.IsBeam[num22]) || (IsTreeType(num22) && IsTreeType(tree4) && IsTreeType(tree2)))
								{
									tile.frameX = 36;
								}
								else if (tile.wall > 0)
								{
									tile.frameX = 54;
								}
								else
								{
									KillTile(i, j);
								}
								break;
							}
							case 129:
							case 149:
							{
								Tile tile2 = Main.tile[i, j - 1];
								Tile tile3 = Main.tile[i, j + 1];
								Tile tile4 = Main.tile[i - 1, j];
								Tile tile5 = Main.tile[i + 1, j];
								int num23 = -1;
								int num24 = -1;
								int num25 = -1;
								int num26 = -1;
								if (tile2 != null && tile2.nactive() && !tile2.bottomSlope())
								{
									num24 = tile2.type;
								}
								if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
								{
									num23 = tile3.type;
								}
								if (tile4 != null && tile4.nactive() && !tile5.rightSlope())
								{
									num25 = tile4.type;
								}
								if (tile5 != null && tile5.nactive() && !tile5.leftSlope())
								{
									num26 = tile5.type;
								}
								if (num23 >= 0 && Main.tileSolid[num23] && !Main.tileSolidTop[num23])
								{
									tile.frameY = 0;
								}
								else if (num25 >= 0 && Main.tileSolid[num25] && !Main.tileSolidTop[num25])
								{
									tile.frameY = 54;
								}
								else if (num26 >= 0 && Main.tileSolid[num26] && !Main.tileSolidTop[num26])
								{
									tile.frameY = 36;
								}
								else if (num24 >= 0 && Main.tileSolid[num24] && !Main.tileSolidTop[num24])
								{
									tile.frameY = 18;
								}
								else
								{
									KillTile(i, j);
								}
								break;
							}
							default:
								if (num != 461)
								{
									switch (num)
									{
									case 178:
									{
										Tile tile2 = Main.tile[i, j - 1];
										Tile tile3 = Main.tile[i, j + 1];
										Tile tile4 = Main.tile[i - 1, j];
										Tile tile5 = Main.tile[i + 1, j];
										int num15 = -1;
										int num16 = -1;
										int num17 = -1;
										int num18 = -1;
										if (tile2 != null && tile2.nactive() && !tile2.bottomSlope())
										{
											num16 = tile2.type;
										}
										if (tile3 != null && tile3.nactive() && !tile3.halfBrick() && !tile3.topSlope())
										{
											num15 = tile3.type;
										}
										if (tile4 != null && tile4.nactive() && !tile4.halfBrick() && !tile4.rightSlope())
										{
											num17 = tile4.type;
										}
										if (tile5 != null && tile5.nactive() && !tile5.halfBrick() && !tile5.leftSlope())
										{
											num18 = tile5.type;
										}
										if (num17 == 10)
										{
											num17 = -1;
										}
										if (num18 == 10)
										{
											num18 = -1;
										}
										short num19 = (short)(genRand.Next(3) * 18);
										if (num15 >= 0 && Main.tileSolid[num15] && !Main.tileSolidTop[num15])
										{
											if (tile.frameY < 0 || tile.frameY > 36)
											{
												tile.frameY = num19;
											}
										}
										else if (num17 >= 0 && Main.tileSolid[num17] && !Main.tileSolidTop[num17])
										{
											if (tile.frameY < 108 || tile.frameY > 54)
											{
												tile.frameY = (short)(108 + num19);
											}
										}
										else if (num18 >= 0 && Main.tileSolid[num18] && !Main.tileSolidTop[num18])
										{
											if (tile.frameY < 162 || tile.frameY > 198)
											{
												tile.frameY = (short)(162 + num19);
											}
										}
										else if (num16 >= 0 && Main.tileSolid[num16] && !Main.tileSolidTop[num16])
										{
											if (tile.frameY < 54 || tile.frameY > 90)
											{
												tile.frameY = (short)(54 + num19);
											}
										}
										else
										{
											KillTile(i, j);
										}
										break;
									}
									case 184:
									{
										Tile tile2 = Main.tile[i, j - 1];
										Tile tile3 = Main.tile[i, j + 1];
										Tile tile4 = Main.tile[i - 1, j];
										Tile tile5 = Main.tile[i + 1, j];
										int num10 = -1;
										int num11 = -1;
										int num12 = -1;
										int num13 = -1;
										if (tile2 != null && tile2.active() && !tile2.bottomSlope())
										{
											num11 = tile2.type;
										}
										if (tile3 != null && tile3.active() && !tile3.halfBrick() && !tile3.topSlope())
										{
											num10 = tile3.type;
										}
										if (tile4 != null && tile4.active())
										{
											num12 = tile4.type;
										}
										if (tile5 != null && tile5.active())
										{
											num13 = tile5.type;
										}
										short num14 = (short)(genRand.Next(3) * 18);
										if (num10 >= 0 && GetTileMossColor(num10) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num10));
											if (tile.frameY < 0 || tile.frameY > 36)
											{
												tile.frameY = num14;
											}
										}
										else if (num11 >= 0 && GetTileMossColor(num11) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num11));
											if (tile.frameY < 54 || tile.frameY > 90)
											{
												tile.frameY = (short)(54 + num14);
											}
										}
										else if (num12 >= 0 && GetTileMossColor(num12) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num12));
											if (tile.frameY < 108 || tile.frameY > 144)
											{
												tile.frameY = (short)(108 + num14);
											}
										}
										else if (num13 >= 0 && GetTileMossColor(num13) != -1)
										{
											tile.frameX = (short)(22 * GetTileMossColor(num13));
											if (tile.frameY < 162 || tile.frameY > 198)
											{
												tile.frameY = (short)(162 + num14);
											}
										}
										else
										{
											KillTile(i, j);
										}
										break;
									}
									case 529:
									{
										if (!SolidTileAllowBottomSlope(i, j + 1))
										{
											KillTile(i, j);
											break;
										}
										Tile tile3 = Main.tile[i, j + 1];
										_ = Main.tile[i, j].frameY / 34;
										if (tile3 == null || !tile3.active() || (tile3.type >= 0 && tile3.type < 693 && !TileID.Sets.Conversion.Sand[tile3.type]))
										{
											KillTile(i, j);
										}
										break;
									}
									case 3:
									case 24:
									case 61:
									case 71:
									case 73:
									case 74:
									case 110:
									case 113:
									case 201:
									case 637:
										PlantCheck(i, j);
										break;
									case 227:
										CheckDye(i, j);
										break;
									case 579:
										CheckRockGolemHead(i, j);
										break;
									case 12:
									case 31:
									case 639:
										CheckOrb(i, j, num);
										break;
									case 165:
										CheckTight(i, j);
										break;
									case 324:
										if (!SolidTileAllowBottomSlope(i, j + 1))
										{
											KillTile(i, j);
										}
										break;
									case 235:
										Check3x1(i, j, num);
										break;
									case 185:
										CheckPile(i, j);
										break;
									default:
										if (num != 296 && num != 297 && num != 309 && num != 358 && num != 359 && num != 413 && num != 414 && num != 542 && num != 550 && num != 551 && num != 553 && num != 554 && num != 558 && num != 559 && num != 599 && num != 600 && num != 601 && num != 602 && num != 603 && num != 604 && num != 605 && num != 606 && num != 607 && num != 608 && num != 609 && num != 610 && num != 611 && num != 612 && num != 632 && num != 640 && num != 643 && num != 644 && num != 645)
										{
											if (num == 10)
											{
												CheckDoorClosed(i, j, tile, num);
												break;
											}
											if (num == 11)
											{
												CheckDoorOpen(i, j, tile);
												break;
											}
											if (num == 314)
											{
												Minecart.FrameTrack(i, j, pound: false);
												Tile tile2 = Main.tile[i, j - 1];
												Tile tile3 = Main.tile[i, j + 1];
												if (tile2 != null && tile2.type >= 0 && tile2.type < 693 && Main.tileRope[tile2.type])
												{
													TileFrame(i, j - 1);
												}
												if (tile3 != null && tile3.type >= 0 && tile3.type < 693 && Main.tileRope[tile3.type])
												{
													TileFrame(i, j + 1);
												}
												break;
											}
											if (num == 380)
											{
												Tile tile4 = Main.tile[i - 1, j];
												if (tile4 == null)
												{
													break;
												}
												Tile tile5 = Main.tile[i + 1, j];
												if (tile5 == null)
												{
													break;
												}
												Tile tile6 = Main.tile[i - 1, j + 1];
												if (tile6 == null)
												{
													break;
												}
												Tile tile7 = Main.tile[i + 1, j + 1];
												if (tile7 == null)
												{
													break;
												}
												Tile tile8 = Main.tile[i - 1, j - 1];
												if (tile8 == null)
												{
													break;
												}
												Tile tile9 = Main.tile[i + 1, j - 1];
												if (tile9 != null)
												{
													int num2 = -1;
													int num3 = -1;
													if (tile4 != null && tile4.active())
													{
														num3 = (Main.tileStone[tile4.type] ? 1 : tile4.type);
													}
													if (tile5 != null && tile5.active())
													{
														num2 = (Main.tileStone[tile5.type] ? 1 : tile5.type);
													}
													if (num2 >= 0 && !Main.tileSolid[num2])
													{
														num2 = -1;
													}
													if (num3 >= 0 && !Main.tileSolid[num3])
													{
														num3 = -1;
													}
													if (num3 == num && num2 == num)
													{
														rectangle.X = 18;
													}
													else if (num3 == num && num2 != num)
													{
														rectangle.X = 36;
													}
													else if (num3 != num && num2 == num)
													{
														rectangle.X = 0;
													}
													else
													{
														rectangle.X = 54;
													}
													tile.frameX = (short)rectangle.X;
												}
												break;
											}
											if (num >= 0 && TileID.Sets.Platforms[num])
											{
												Tile tile4 = Main.tile[i - 1, j];
												if (tile4 == null)
												{
													break;
												}
												Tile tile5 = Main.tile[i + 1, j];
												if (tile5 == null)
												{
													break;
												}
												Tile tile6 = Main.tile[i - 1, j + 1];
												if (tile6 == null)
												{
													break;
												}
												Tile tile7 = Main.tile[i + 1, j + 1];
												if (tile7 == null)
												{
													break;
												}
												Tile tile8 = Main.tile[i - 1, j - 1];
												if (tile8 == null)
												{
													break;
												}
												Tile tile9 = Main.tile[i + 1, j - 1];
												if (tile9 == null)
												{
													break;
												}
												int num4 = -1;
												int num5 = -1;
												if (tile4 != null && tile4.active())
												{
													num5 = (Main.tileStone[tile4.type] ? 1 : ((!TileID.Sets.Platforms[tile4.type]) ? tile4.type : num));
												}
												if (tile5 != null && tile5.active())
												{
													num4 = (Main.tileStone[tile5.type] ? 1 : ((!TileID.Sets.Platforms[tile5.type]) ? tile5.type : num));
												}
												if (num4 >= 0 && !Main.tileSolid[num4])
												{
													num4 = -1;
												}
												if (num5 >= 0 && !Main.tileSolid[num5])
												{
													num5 = -1;
												}
												if (num5 == num && tile4.halfBrick() != tile.halfBrick())
												{
													num5 = -1;
												}
												if (num4 == num && tile5.halfBrick() != tile.halfBrick())
												{
													num4 = -1;
												}
												if (num5 != -1 && num5 != num && tile.halfBrick())
												{
													num5 = -1;
												}
												if (num4 != -1 && num4 != num && tile.halfBrick())
												{
													num4 = -1;
												}
												if (num5 == -1 && tile8.active() && tile8.type == num && tile8.slope() == 1)
												{
													num5 = num;
												}
												if (num4 == -1 && tile9.active() && tile9.type == num && tile9.slope() == 2)
												{
													num4 = num;
												}
												if (num5 == num && tile4.slope() == 2 && num4 != num)
												{
													num4 = -1;
												}
												if (num4 == num && tile5.slope() == 1 && num5 != num)
												{
													num5 = -1;
												}
												if (tile.slope() == 1)
												{
													if (TileID.Sets.Platforms[tile5.type] && tile5.slope() == 0 && !tile5.halfBrick())
													{
														rectangle.X = 468;
													}
													else if (!tile7.active() && (!TileID.Sets.Platforms[tile7.type] || tile7.slope() == 2))
													{
														if (!tile4.active() && (!TileID.Sets.Platforms[tile8.type] || tile8.slope() != 1))
														{
															rectangle.X = 432;
														}
														else
														{
															rectangle.X = 360;
														}
													}
													else if (!tile4.active() && (!TileID.Sets.Platforms[tile8.type] || tile8.slope() != 1))
													{
														rectangle.X = 396;
													}
													else
													{
														rectangle.X = 180;
													}
												}
												else if (tile.slope() == 2)
												{
													if (TileID.Sets.Platforms[tile4.type] && tile4.slope() == 0 && !tile4.halfBrick())
													{
														rectangle.X = 450;
													}
													else if (!tile6.active() && (!TileID.Sets.Platforms[tile6.type] || tile6.slope() == 1))
													{
														if (!tile5.active() && (!TileID.Sets.Platforms[tile9.type] || tile9.slope() != 2))
														{
															rectangle.X = 414;
														}
														else
														{
															rectangle.X = 342;
														}
													}
													else if (!tile5.active() && (!TileID.Sets.Platforms[tile9.type] || tile9.slope() != 2))
													{
														rectangle.X = 378;
													}
													else
													{
														rectangle.X = 144;
													}
												}
												else if (num5 == num && num4 == num)
												{
													if (tile4.slope() == 2 && tile5.slope() == 1)
													{
														rectangle.X = 252;
													}
													else if (tile4.slope() == 2)
													{
														rectangle.X = 216;
													}
													else if (tile5.slope() == 1)
													{
														rectangle.X = 234;
													}
													else
													{
														rectangle.X = 0;
													}
												}
												else if (num5 == num && num4 == -1)
												{
													if (tile4.slope() == 2)
													{
														rectangle.X = 270;
													}
													else
													{
														rectangle.X = 18;
													}
												}
												else if (num5 == -1 && num4 == num)
												{
													if (tile5.slope() == 1)
													{
														rectangle.X = 288;
													}
													else
													{
														rectangle.X = 36;
													}
												}
												else if (num5 != num && num4 == num)
												{
													rectangle.X = 54;
												}
												else if (num5 == num && num4 != num)
												{
													rectangle.X = 72;
												}
												else if (num5 != num && num5 != -1 && num4 == -1)
												{
													rectangle.X = 108;
												}
												else if (num5 == -1 && num4 != num && num4 != -1)
												{
													rectangle.X = 126;
												}
												else
												{
													rectangle.X = 90;
												}
												tile.frameX = (short)rectangle.X;
												if (Main.tile[i, j - 1] != null && Main.tileRope[Main.tile[i, j - 1].type])
												{
													TileFrame(i, j - 1);
												}
												if (Main.tile[i, j + 1] != null && Main.tileRope[Main.tile[i, j + 1].type])
												{
													TileFrame(i, j + 1);
												}
												break;
											}
											switch (num)
											{
											case 233:
											case 236:
											case 238:
												CheckJunglePlant(i, j, num);
												break;
											case 530:
												CheckOasisPlant(i, j);
												break;
											case 240:
											case 440:
												Check3x3Wall(i, j);
												break;
											case 245:
												Check2x3Wall(i, j);
												break;
											case 246:
												Check3x2Wall(i, j);
												break;
											case 241:
												Check4x3Wall(i, j);
												break;
											case 242:
												Check6x4Wall(i, j);
												break;
											case 464:
											case 466:
												Check5x4(i, j, num);
												break;
											case 334:
												CheckWeaponsRack(i, j);
												break;
											case 471:
												TEWeaponsRack.Framing_CheckTile(i, j);
												break;
											case 34:
											case 454:
												CheckChand(i, j, num);
												break;
											case 547:
											case 623:
												Check2x5(i, j, num);
												break;
											case 548:
											case 614:
												Check3x6(i, j, num);
												break;
											case 613:
												Check3x5(i, j, num);
												break;
											default:
												if (num != 354 && num != 406 && num != 412 && num != 355 && num != 452 && num != 455 && num != 491 && num != 499 && num != 642)
												{
													switch (num)
													{
													case 15:
													case 20:
													case 216:
													case 338:
													case 390:
													case 493:
													case 497:
													case 590:
													case 595:
													case 615:
														Check1x2(i, j, (ushort)num);
														break;
													default:
														if (num < 391 || num > 394)
														{
															switch (num)
															{
															case 405:
															case 486:
															case 488:
															case 532:
															case 533:
															case 544:
															case 552:
															case 555:
															case 556:
															case 582:
															case 619:
															case 629:
															case 647:
															case 648:
															case 651:
																break;
															case 36:
															case 135:
															case 141:
															case 144:
															case 210:
															case 239:
															case 428:
															case 593:
															case 624:
															case 650:
															case 656:
																Check1x1(i, j, num);
																return;
															case 476:
																CheckGolf1x1(i, j, num);
																return;
															case 494:
																CheckGolf1x1(i, j, num);
																return;
															case 419:
															case 420:
															case 423:
															case 424:
															case 429:
															case 445:
																CheckLogicTiles(i, j, num);
																return;
															case 16:
															case 18:
															case 29:
															case 103:
															case 134:
															case 462:
															case 649:
																Check2x1(i, j, (ushort)num);
																return;
															case 13:
															case 33:
															case 49:
															case 50:
															case 78:
															case 174:
															case 372:
															case 646:
																CheckOnTable1x1(i, j, num);
																return;
															default:
																if (TileID.Sets.BasicChest[num])
																{
																	CheckChest(i, j, num);
																	return;
																}
																switch (num)
																{
																case 128:
																	CheckMan(i, j);
																	break;
																case 269:
																	CheckWoman(i, j);
																	break;
																case 470:
																	TEDisplayDoll.Framing_CheckTile(i, j);
																	break;
																case 475:
																	TEHatRack.Framing_CheckTile(i, j);
																	break;
																case 597:
																	TETeleportationPylon.Framing_CheckTile(i, j);
																	break;
																case 27:
																	CheckSunflower(i, j);
																	break;
																case 28:
																case 653:
																	CheckPot(i, j, num);
																	break;
																case 171:
																	CheckXmasTree(i, j);
																	break;
																default:
																	if (!TileID.Sets.BasicChestFake[num] && num != 457)
																	{
																		switch (num)
																		{
																		case 335:
																		case 411:
																		case 490:
																		case 564:
																		case 565:
																		case 594:
																			Check2x2(i, j, num);
																			break;
																		default:
																			if (num < 316 || num > 318)
																			{
																				switch (num)
																				{
																				case 172:
																				case 360:
																				case 505:
																				case 521:
																				case 522:
																				case 523:
																				case 524:
																				case 525:
																				case 526:
																				case 527:
																				case 543:
																				case 568:
																				case 569:
																				case 570:
																				case 580:
																				case 598:
																				case 620:
																				case 652:
																				case 654:
																					break;
																				case 376:
																				case 443:
																				case 444:
																				case 485:
																					CheckSuper(i, j, num);
																					return;
																				case 91:
																					CheckBanner(i, j, (byte)num);
																					return;
																				case 35:
																				case 139:
																					CheckMB(i, j, (byte)num);
																					return;
																				case 386:
																				case 387:
																					CheckTrapDoor(i, j, num);
																					return;
																				case 388:
																				case 389:
																					CheckTallGate(i, j, num);
																					return;
																				case 92:
																				case 93:
																				case 453:
																					Check1xX(i, j, (short)num);
																					return;
																				case 104:
																				case 105:
																				case 207:
																				case 320:
																				case 337:
																				case 349:
																				case 356:
																				case 378:
																				case 410:
																				case 456:
																				case 465:
																				case 480:
																				case 489:
																				case 506:
																				case 509:
																				case 531:
																				case 545:
																				case 560:
																				case 591:
																				case 592:
																				case 657:
																				case 658:
																				case 663:
																					Check2xX(i, j, (ushort)num);
																					return;
																				case 101:
																				case 102:
																				case 463:
																				case 617:
																					Check3x4(i, j, num);
																					return;
																				case 42:
																				case 270:
																				case 271:
																				case 572:
																				case 581:
																				case 660:
																					Check1x2Top(i, j, (ushort)num);
																					return;
																				case 55:
																				case 85:
																				case 395:
																				case 425:
																				case 510:
																				case 511:
																				case 573:
																					CheckSign(i, j, (ushort)num);
																					return;
																				case 520:
																					CheckFoodPlatter(i, j, (ushort)num);
																					return;
																				case 209:
																					CheckCannon(i, j, num);
																					return;
																				case 79:
																				case 90:
																				case 487:
																					Check4x2(i, j, num);
																					return;
																				case 94:
																				case 95:
																				case 97:
																				case 98:
																				case 99:
																				case 100:
																				case 125:
																				case 126:
																				case 173:
																				case 282:
																				case 287:
																				case 319:
																				case 621:
																				case 622:
																					Check2x2(i, j, num);
																					return;
																				case 96:
																					Check2x2Style(i, j, num);
																					return;
																				case 81:
																				{
																					Tile tile2 = Main.tile[i, j - 1];
																					Tile tile3 = Main.tile[i, j + 1];
																					Tile tile4 = Main.tile[i - 1, j];
																					Tile tile5 = Main.tile[i + 1, j];
																					int num8 = -1;
																					int num9 = -1;
																					if (tile2 != null && tile2.active())
																					{
																						num9 = tile2.type;
																					}
																					if (tile3 != null && tile3.active())
																					{
																						num8 = tile3.type;
																					}
																					if (num9 != -1)
																					{
																						KillTile(i, j);
																					}
																					else if (num8 < 0 || !Main.tileSolid[num8] || tile3.halfBrick() || tile3.topSlope())
																					{
																						KillTile(i, j);
																					}
																					return;
																				}
																				default:
																					if (Main.tileAlch[num])
																					{
																						CheckAlch(i, j);
																						return;
																					}
																					switch (num)
																					{
																					case 72:
																					{
																						Tile tile2 = Main.tile[i, j - 1];
																						Tile tile3 = Main.tile[i, j + 1];
																						int num6 = -1;
																						int num7 = -1;
																						if (tile2 != null && tile2.active())
																						{
																							num7 = tile2.type;
																						}
																						if (tile3 != null && tile3.active())
																						{
																							num6 = tile3.type;
																						}
																						if (num6 != num && num6 != 70)
																						{
																							KillTile(i, j);
																						}
																						else if (num7 != num && tile.frameX == 0)
																						{
																							tile.frameNumber((byte)genRand.Next(3));
																							if (tile.frameNumber() == 0)
																							{
																								tile.frameX = 18;
																								tile.frameY = 0;
																							}
																							if (tile.frameNumber() == 1)
																							{
																								tile.frameX = 18;
																								tile.frameY = 18;
																							}
																							if (tile.frameNumber() == 2)
																							{
																								tile.frameX = 18;
																								tile.frameY = 36;
																							}
																						}
																						break;
																					}
																					case 5:
																						CheckTree(i, j);
																						break;
																					case 583:
																					case 584:
																					case 585:
																					case 586:
																					case 587:
																					case 588:
																					case 589:
																						CheckTreeWithSettings(i, j, new CheckTreeSettings
																						{
																							IsGroundValid = GemTreeGroundTest
																						});
																						break;
																					case 596:
																						CheckTreeWithSettings(i, j, new CheckTreeSettings
																						{
																							IsGroundValid = VanityTreeGroundTest
																						});
																						break;
																					case 616:
																						CheckTreeWithSettings(i, j, new CheckTreeSettings
																						{
																							IsGroundValid = VanityTreeGroundTest
																						});
																						break;
																					case 634:
																						CheckTreeWithSettings(i, j, new CheckTreeSettings
																						{
																							IsGroundValid = AshTreeGroundTest
																						});
																						break;
																					case 323:
																						CheckPalmTree(i, j);
																						break;
																					case 567:
																						CheckGnome(i, j);
																						break;
																					case 630:
																					case 631:
																						CheckStinkbugBlocker(i, j);
																						break;
																					}
																					return;
																				}
																			}
																			goto case 132;
																		case 132:
																		case 138:
																		case 142:
																		case 143:
																		case 288:
																		case 289:
																		case 290:
																		case 291:
																		case 292:
																		case 293:
																		case 294:
																		case 295:
																		case 484:
																		case 664:
																		case 665:
																			Check2x2(i, j, num);
																			break;
																		}
																		break;
																	}
																	goto case 254;
																case 254:
																	Check2x2Style(i, j, num);
																	break;
																}
																return;
															}
														}
														goto case 14;
													case 14:
													case 17:
													case 26:
													case 77:
													case 86:
													case 87:
													case 88:
													case 89:
													case 114:
													case 133:
													case 186:
													case 187:
													case 215:
													case 217:
													case 218:
													case 237:
													case 244:
													case 285:
													case 286:
													case 298:
													case 299:
													case 310:
													case 339:
													case 361:
													case 362:
													case 363:
													case 364:
													case 377:
													case 469:
													case 538:
														Check3x2(i, j, (ushort)num);
														break;
													}
													break;
												}
												goto case 106;
											case 106:
											case 212:
											case 219:
											case 220:
											case 228:
											case 231:
											case 243:
											case 247:
											case 283:
											case 300:
											case 301:
											case 302:
											case 303:
											case 304:
											case 305:
											case 306:
											case 307:
											case 308:
												Check3x3(i, j, (ushort)num);
												break;
											}
											break;
										}
										goto case 275;
									case 275:
									case 276:
									case 277:
									case 278:
									case 279:
									case 280:
									case 281:
										Check6x3(i, j, num);
										break;
									}
									break;
								}
								goto case 373;
							case 373:
							case 374:
							case 375:
							{
								Tile tile2 = Main.tile[i, j - 1];
								if (tile2 == null || !tile2.active() || tile2.bottomSlope() || !Main.tileSolid[tile2.type] || Main.tileSolidTop[tile2.type])
								{
									KillTile(i, j);
								}
								break;
							}
							}
							return;
						}
						if (num < 255 || num > 268)
						{
							switch (num)
							{
							case 385:
							case 446:
							case 447:
							case 448:
								break;
							default:
							{
								Tile tile2 = Main.tile[i, j - 1];
								Tile tile3 = Main.tile[i, j + 1];
								Tile tile4 = Main.tile[i - 1, j];
								Tile tile5 = Main.tile[i + 1, j];
								Tile tile6 = Main.tile[i - 1, j + 1];
								Tile tile7 = Main.tile[i + 1, j + 1];
								Tile tile8 = Main.tile[i - 1, j - 1];
								Tile tile9 = Main.tile[i + 1, j - 1];
								int upLeft = -1;
								int up = -1;
								int upRight = -1;
								int left = -1;
								int right = -1;
								int downLeft = -1;
								int down = -1;
								int downRight = -1;
								if (tile4 != null && tile4.active())
								{
									left = (Main.tileStone[tile4.type] ? 1 : tile4.type);
									if (tile4.slope() == 1 || tile4.slope() == 3)
									{
										left = -1;
									}
								}
								if (tile5 != null && tile5.active())
								{
									right = (Main.tileStone[tile5.type] ? 1 : tile5.type);
									if (tile5.slope() == 2 || tile5.slope() == 4)
									{
										right = -1;
									}
								}
								if (tile2 != null && tile2.active())
								{
									up = (Main.tileStone[tile2.type] ? 1 : tile2.type);
									if (tile2.slope() == 3 || tile2.slope() == 4)
									{
										up = -1;
									}
								}
								if (tile3 != null && tile3.active())
								{
									down = (Main.tileStone[tile3.type] ? 1 : tile3.type);
									if (tile3.slope() == 1 || tile3.slope() == 2)
									{
										down = -1;
									}
								}
								if (tile8 != null && tile8.active())
								{
									upLeft = (Main.tileStone[tile8.type] ? 1 : tile8.type);
								}
								if (tile9 != null && tile9.active())
								{
									upRight = (Main.tileStone[tile9.type] ? 1 : tile9.type);
								}
								if (tile6 != null && tile6.active())
								{
									downLeft = (Main.tileStone[tile6.type] ? 1 : tile6.type);
								}
								if (tile7 != null && tile7.active())
								{
									downRight = (Main.tileStone[tile7.type] ? 1 : tile7.type);
								}
								if (tile.slope() == 2)
								{
									up = -1;
									left = -1;
								}
								if (tile.slope() == 1)
								{
									up = -1;
									right = -1;
								}
								if (tile.slope() == 4)
								{
									down = -1;
									left = -1;
								}
								if (tile.slope() == 3)
								{
									down = -1;
									right = -1;
								}
								switch (num)
								{
								case 147:
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								case 161:
								case 163:
								case 164:
								case 200:
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								case 162:
									TileMergeAttempt(num, Main.tileBrick, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									break;
								default:
									if (Main.tileBrick[num])
									{
										switch (num)
										{
										case 60:
										case 70:
										case 661:
										case 662:
											TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 633:
											TileMergeAttempt(num, Main.tileBrick, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										default:
											TileMergeAttempt(num, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										}
									}
									else if (Main.tilePile[num])
									{
										TileMergeAttempt(num, Main.tilePile, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
									break;
								}
								if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && down == 165)
								{
									if (tile3.frameY == 72)
									{
										down = num;
									}
									else if (tile3.frameY == 0)
									{
										down = num;
									}
								}
								if ((num == 1 || Main.tileMoss[num] || num == 117 || num == 25 || num == 203) && up == 165)
								{
									if (tile2.frameY == 90)
									{
										up = num;
									}
									else if (tile2.frameY == 54)
									{
										up = num;
									}
								}
								if (num == 225)
								{
									if (down == 165)
									{
										down = num;
									}
									if (up == 165)
									{
										up = num;
									}
								}
								if ((num == 200 || num == 161 || num == 147 || num == 163 || num == 164) && down == 165)
								{
									down = num;
								}
								if ((tile.slope() == 1 || tile.slope() == 2) && down > -1 && !TileID.Sets.Platforms[down])
								{
									down = num;
								}
								if (up > -1 && (tile2.slope() == 1 || tile2.slope() == 2) && !TileID.Sets.Platforms[up])
								{
									up = num;
								}
								if ((tile.slope() == 3 || tile.slope() == 4) && up > -1 && !TileID.Sets.Platforms[up])
								{
									up = num;
								}
								if (down > -1 && (tile3.slope() == 3 || tile3.slope() == 4) && !TileID.Sets.Platforms[down])
								{
									down = num;
								}
								if (num == 124)
								{
									if (up > -1 && Main.tileSolid[up] && !TileID.Sets.Platforms[up])
									{
										up = num;
									}
									if (down > -1 && Main.tileSolid[down] && !TileID.Sets.Platforms[down])
									{
										down = num;
									}
								}
								if (up > -1 && tile2.halfBrick() && !TileID.Sets.Platforms[up])
								{
									up = num;
								}
								if (left > -1 && tile4.halfBrick())
								{
									if (tile.halfBrick())
									{
										left = num;
									}
									else if (tile4.type != num)
									{
										left = -1;
									}
								}
								if (right > -1 && tile5.halfBrick())
								{
									if (tile.halfBrick())
									{
										right = num;
									}
									else if (tile5.type != num)
									{
										right = -1;
									}
								}
								if (tile.halfBrick())
								{
									if (left != num)
									{
										left = -1;
									}
									if (right != num)
									{
										right = -1;
									}
									up = -1;
								}
								if (tile3 != null && tile3.halfBrick())
								{
									down = -1;
								}
								if (!Main.tileSolid[num])
								{
									switch (num)
									{
									case 49:
										CheckOnTable1x1(i, j, (byte)num);
										return;
									case 80:
										CactusFrame(i, j);
										return;
									}
								}
								mergeUp = false;
								mergeDown = false;
								mergeLeft = false;
								mergeRight = false;
								int num27 = 0;
								if (resetFrame)
								{
									num27 = genRand.Next(0, 3);
									tile.frameNumber((byte)num27);
								}
								else
								{
									num27 = tile.frameNumber();
								}
								if (Main.tileLargeFrames[num] == 1)
								{
									int num28 = j % 4;
									int num29 = i % 3;
									num27 = (new int[4, 3]
									{
										{ 2, 4, 2 },
										{ 1, 3, 1 },
										{ 2, 2, 4 },
										{ 1, 1, 3 }
									})[num28, num29] - 1;
								}
								if (Main.tileLargeFrames[num] == 2)
								{
									int num30 = i % 2;
									int num31 = j % 2;
									num27 = num30 + num31 * 2;
								}
								if (!Main.tileRope[num] && TileID.Sets.BlockMergesWithMergeAllBlock[num])
								{
									TileMergeAttempt(num, Main.tileBlendAll, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								if (Main.tileBlendAll[num])
								{
									TileMergeAttempt(num, TileID.Sets.BlockMergesWithMergeAllBlock, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								if (TileID.Sets.ForcedDirtMerging[num])
								{
									if (up == 0)
									{
										up = num;
									}
									if (down == 0)
									{
										down = num;
									}
									if (left == 0)
									{
										left = num;
									}
									if (right == 0)
									{
										right = num;
									}
									if (upLeft == 0)
									{
										upLeft = num;
									}
									if (upRight == 0)
									{
										upRight = num;
									}
									if (downLeft == 0)
									{
										downLeft = num;
									}
									if (downRight == 0)
									{
										downRight = num;
									}
								}
								if (TileID.Sets.Dirt[num])
								{
									if (up > -1 && Main.tileMergeDirt[up])
									{
										TileFrame(i, j - 1);
										if (mergeDown)
										{
											up = num;
										}
									}
									else if (up == 147)
									{
										TileFrame(i, j - 1);
										if (mergeDown)
										{
											up = num;
										}
									}
									if (down > -1 && Main.tileMergeDirt[down])
									{
										TileFrame(i, j + 1);
										if (mergeUp)
										{
											down = num;
										}
									}
									else if (down == 147)
									{
										TileFrame(i, j + 1);
										if (mergeUp)
										{
											down = num;
										}
									}
									if (left > -1 && Main.tileMergeDirt[left])
									{
										TileFrame(i - 1, j);
										if (mergeRight)
										{
											left = num;
										}
									}
									else if (left == 147)
									{
										TileFrame(i - 1, j);
										if (mergeRight)
										{
											left = num;
										}
									}
									if (right > -1 && Main.tileMergeDirt[right])
									{
										TileFrame(i + 1, j);
										if (mergeLeft)
										{
											right = num;
										}
									}
									else if (right == 147)
									{
										TileFrame(i + 1, j);
										if (mergeLeft)
										{
											right = num;
										}
									}
									bool[] mergesWithDirtInASpecialWay = TileID.Sets.Conversion.MergesWithDirtInASpecialWay;
									if (up > -1 && mergesWithDirtInASpecialWay[up])
									{
										up = num;
									}
									if (down > -1 && mergesWithDirtInASpecialWay[down])
									{
										down = num;
									}
									if (left > -1 && mergesWithDirtInASpecialWay[left])
									{
										left = num;
									}
									if (right > -1 && mergesWithDirtInASpecialWay[right])
									{
										right = num;
									}
									if (upLeft > -1 && Main.tileMergeDirt[upLeft])
									{
										upLeft = num;
									}
									else if (upLeft > -1 && mergesWithDirtInASpecialWay[upLeft])
									{
										upLeft = num;
									}
									if (upRight > -1 && Main.tileMergeDirt[upRight])
									{
										upRight = num;
									}
									else if (upRight > -1 && mergesWithDirtInASpecialWay[upRight])
									{
										upRight = num;
									}
									if (downLeft > -1 && Main.tileMergeDirt[downLeft])
									{
										downLeft = num;
									}
									else if (downLeft > -1 && mergesWithDirtInASpecialWay[downLeft])
									{
										downLeft = num;
									}
									if (downRight > -1 && Main.tileMergeDirt[downRight])
									{
										downRight = num;
									}
									else if (downRight > -1 && mergesWithDirtInASpecialWay[downRight])
									{
										downRight = num;
									}
									TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									TileMergeAttempt(num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									if (up > -1 && TileID.Sets.ForcedDirtMerging[up])
									{
										up = num;
									}
									if (down > -1 && TileID.Sets.ForcedDirtMerging[down])
									{
										down = num;
									}
									if (left > -1 && TileID.Sets.ForcedDirtMerging[left])
									{
										left = num;
									}
									if (right > -1 && TileID.Sets.ForcedDirtMerging[right])
									{
										right = num;
									}
									if (upLeft > -1 && TileID.Sets.ForcedDirtMerging[upLeft])
									{
										upLeft = num;
									}
									if (upRight > -1 && TileID.Sets.ForcedDirtMerging[upRight])
									{
										upRight = num;
									}
									if (downLeft > -1 && TileID.Sets.ForcedDirtMerging[downLeft])
									{
										downLeft = num;
									}
									if (downRight > -1 && TileID.Sets.ForcedDirtMerging[downRight])
									{
										downRight = num;
									}
								}
								else if (Main.tileRope[num])
								{
									if (num != 504 && up != num && IsRope(i, j - 1))
									{
										up = num;
									}
									if (down != num && IsRope(i, j + 1))
									{
										down = num;
									}
									if (num != 504 && up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
									{
										up = num;
									}
									if (down > -1 && Main.tileSolid[down])
									{
										down = num;
									}
									if (num != 504 && up != num)
									{
										if (left > -1 && Main.tileSolid[left])
										{
											left = num;
										}
										if (right > -1 && Main.tileSolid[right])
										{
											right = num;
										}
									}
								}
								else
								{
									switch (num)
									{
									case 53:
										TileMergeAttemptFrametest(i, j, num, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 234:
										TileMergeAttemptFrametest(i, j, num, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 112:
										TileMergeAttemptFrametest(i, j, num, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 116:
										TileMergeAttemptFrametest(i, j, num, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									}
								}
								if (Main.tileMergeDirt[num])
								{
									TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									if (num == 1)
									{
										if ((double)j > Main.rockLayer)
										{
											TileMergeAttemptFrametest(i, j, num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										}
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
								}
								else
								{
									switch (num)
									{
									case 58:
									case 75:
									case 76:
										TileMergeAttempt(-2, TileID.Sets.Ash, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 57:
										TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(num, 633, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 59:
										if ((double)j > Main.rockLayer)
										{
											TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										}
										TileMergeAttempt(num, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.JungleSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										if ((double)j < Main.rockLayer)
										{
											TileMergeAttemptFrametest(i, j, num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										}
										else
										{
											TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right);
										}
										break;
									case 211:
										TileMergeAttempt(59, 60, ref up, ref down, ref left, ref right);
										TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 225:
									case 226:
										TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 60:
										TileMergeAttempt(59, 211, ref up, ref down, ref left, ref right);
										break;
									case 189:
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.MergesWithClouds, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 196:
										TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(num, 460, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 460:
										TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(num, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 147:
										TileMergeAttemptFrametest(i, j, num, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 161:
									case 163:
									case 164:
									case 200:
									case 224:
										TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 162:
										TileMergeAttempt(-2, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 32:
										if (down == 23)
										{
											down = num;
										}
										break;
									case 352:
										if (down == 199)
										{
											down = num;
										}
										break;
									case 69:
										if (down == 60)
										{
											down = num;
										}
										break;
									case 655:
										if (down == 60)
										{
											down = num;
										}
										break;
									case 51:
										TileMergeAttempt(num, TileID.Sets.AllTiles, Main.tileNoAttach, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 192:
										TileMergeAttemptFrametest(i, j, num, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 191:
										TileMergeAttempt(-2, 192, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 384:
										TileMergeAttemptFrametest(i, j, num, 383, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 383:
										TileMergeAttempt(-2, 384, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 407:
										TileMergeAttempt(-2, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 404:
										TileMergeAttempt(-2, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 407, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 397:
										TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 396:
										TileMergeAttempt(-2, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 398:
										TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 400:
										TileMergeAttempt(-2, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 399:
										TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 401:
										TileMergeAttempt(-2, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 402:
										TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttemptFrametest(i, j, num, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 403:
										TileMergeAttempt(-2, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									}
								}
								if (num == 0)
								{
									TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									TileMergeAttempt(num, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else if (Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
								{
									TileMergeAttempt(num, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else if (Main.tileStone[num] || num == 1)
								{
									TileMergeAttempt(num, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else if (num == 38)
								{
									TileMergeAttempt(num, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								if (TileID.Sets.Conversion.Grass[num])
								{
									TileMergeAttempt(num, TileID.Sets.Ore, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else if (TileID.Sets.Ore[num])
								{
									TileMergeAttempt(num, TileID.Sets.Conversion.Grass, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								if (num >= 0 && num < 693 && TileID.Sets.Mud[num])
								{
									TileMergeAttempt(num, TileID.Sets.OreMergesWithMud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								else if (TileID.Sets.OreMergesWithMud[num])
								{
									TileMergeAttempt(num, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								bool flag = false;
								TileMergeCullCache tileMergeCullCache = default(TileMergeCullCache);
								if (!Main.ShouldShowInvisibleWalls())
								{
									bool flag2 = tile.invisibleBlock();
									tileMergeCullCache.CullTop |= tile2 != null && tile2.invisibleBlock() != flag2;
									tileMergeCullCache.CullBottom |= tile3 != null && tile3.invisibleBlock() != flag2;
									tileMergeCullCache.CullLeft |= tile4 != null && tile4.invisibleBlock() != flag2;
									tileMergeCullCache.CullRight |= tile5 != null && tile5.invisibleBlock() != flag2;
									tileMergeCullCache.CullTopLeft |= tile8 != null && tile8.invisibleBlock() != flag2;
									tileMergeCullCache.CullTopRight |= tile9 != null && tile9.invisibleBlock() != flag2;
									tileMergeCullCache.CullBottomLeft |= tile6 != null && tile6.invisibleBlock() != flag2;
									tileMergeCullCache.CullBottomRight |= tile7 != null && tile7.invisibleBlock() != flag2;
								}
								if (num == 2 || num == 23 || num == 661 || num == 662 || num == 60 || num == 477 || num == 492 || num == 70 || num == 109 || num == 199 || Main.tileMoss[num] || TileID.Sets.NeedsGrassFraming[num] || TileID.Sets.tileMossBrick[num])
								{
									flag = true;
									TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									int num32 = TileID.Sets.NeedsGrassFramingDirt[num];
									if (num == 60 || num == 70 || num == 661 || num == 662)
									{
										num32 = 59;
									}
									else if (Main.tileMoss[num])
									{
										num32 = 1;
									}
									else if (TileID.Sets.tileMossBrick[num])
									{
										num32 = 38;
									}
									else
									{
										switch (num)
										{
										case 2:
										case 477:
											TileMergeAttempt(num32, 23, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										case 23:
											TileMergeAttempt(num32, 2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
											break;
										}
									}
									tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									if (up != num && up != num32 && (down == num || down == num32))
									{
										if (left == num32 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 198;
												break;
											}
										}
										else if (left == num && right == num32)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 198;
												break;
											}
										}
									}
									else if (down != num && down != num32 && (up == num || up == num32))
									{
										if (left == num32 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 216;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 216;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 216;
												break;
											}
										}
										else if (left == num && right == num32)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 216;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 216;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 216;
												break;
											}
										}
									}
									else if (left != num && left != num32 && (right == num || right == num32))
									{
										if (up == num32 && down == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 72;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 72;
												rectangle.Y = 180;
												break;
											}
										}
										else if (down == num && up == num32)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 72;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 72;
												rectangle.Y = 126;
												break;
											}
										}
									}
									else if (right != num && right != num32 && (left == num || left == num32))
									{
										if (up == num32 && down == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 90;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 90;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 180;
												break;
											}
										}
										else if (down == num && right == up)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 90;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 90;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 126;
												break;
											}
										}
									}
									else if (up == num && down == num && left == num && right == num)
									{
										if (upLeft != num && upRight != num && downLeft != num && downRight != num)
										{
											if (downRight == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 324;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 324;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 324;
													break;
												}
											}
											else if (upRight == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 342;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 342;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 342;
													break;
												}
											}
											else if (downLeft == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 360;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 360;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 360;
													break;
												}
											}
											else if (upLeft == num32)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 378;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 378;
													break;
												default:
													rectangle.X = 144;
													rectangle.Y = 378;
													break;
												}
											}
											else
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 144;
													rectangle.Y = 234;
													break;
												case 1:
													rectangle.X = 198;
													rectangle.Y = 234;
													break;
												default:
													rectangle.X = 252;
													rectangle.Y = 234;
													break;
												}
											}
										}
										else if (upLeft != num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 306;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 306;
												break;
											default:
												rectangle.X = 72;
												rectangle.Y = 306;
												break;
											}
										}
										else if (upRight != num && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 90;
												rectangle.Y = 306;
												break;
											case 1:
												rectangle.X = 108;
												rectangle.Y = 306;
												break;
											default:
												rectangle.X = 126;
												rectangle.Y = 306;
												break;
											}
										}
										else if (upLeft != num && upRight == num && downLeft == num && downRight == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upLeft == num && upRight != num && downLeft == num && downRight == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upLeft == num && upRight == num && downLeft != num && downRight == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (upLeft == num && upRight == num && downLeft == num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
									}
									else if (up == num && down == num32 && left == num && right == num && upLeft == -1 && upRight == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 18;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 18;
											break;
										}
									}
									else if (up == num32 && down == num && left == num && right == num && downLeft == -1 && downRight == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 36;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 36;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left == num32 && right == num && upRight == -1 && downRight == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 198;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 198;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left == num && right == num32 && upLeft == -1 && downLeft == -1)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 180;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 180;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num32 && left == num && right == num)
									{
										if (upRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
									}
									else if (up == num32 && down == num && left == num && right == num)
									{
										if (downRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
									}
									else if (up == num && down == num && left == num && right == num32)
									{
										if (upLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downLeft != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
									}
									else if (up == num && down == num && left == num32 && right == num)
									{
										if (upRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downRight != -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
									}
									else if ((up == num32 && down == num && left == num && right == num) || (up == num && down == num32 && left == num && right == num) || (up == num && down == num && left == num32 && right == num) || (up == num && down == num && left == num && right == num32))
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 18;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 54;
											rectangle.Y = 18;
											break;
										}
									}
									if ((up == num || up == num32) && (down == num || down == num32) && (left == num || left == num32) && (right == num || right == num32))
									{
										if (upLeft != num && upLeft != num32 && (upRight == num || upRight == num32) && (downLeft == num || downLeft == num32) && (downRight == num || downRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
										}
										else if (upRight != num && upRight != num32 && (upLeft == num || upLeft == num32) && (downLeft == num || downLeft == num32) && (downRight == num || downRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
										}
										else if (downLeft != num && downLeft != num32 && (upLeft == num || upLeft == num32) && (upRight == num || upRight == num32) && (downRight == num || downRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
										}
										else if (downRight != num && downRight != num32 && (upLeft == num || upLeft == num32) && (downLeft == num || downLeft == num32) && (upRight == num || upRight == num32))
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
										}
									}
									if (up != num32 && up != num && down == num && left != num32 && left != num && right == num && downRight != num32 && downRight != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 90;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 108;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 126;
											rectangle.Y = 270;
											break;
										}
									}
									else if (up != num32 && up != num && down == num && left == num && right != num32 && right != num && downLeft != num32 && downLeft != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 270;
											break;
										}
									}
									else if (down != num32 && down != num && up == num && left != num32 && left != num && right == num && upRight != num32 && upRight != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 90;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 108;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 126;
											rectangle.Y = 288;
											break;
										}
									}
									else if (down != num32 && down != num && up == num && left == num && right != num32 && right != num && upLeft != num32 && upLeft != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 288;
											break;
										}
									}
									else if (up != num && up != num32 && down == num && left == num && right == num && downLeft != num && downLeft != num32 && downRight != num && downRight != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 216;
											break;
										case 1:
											rectangle.X = 198;
											rectangle.Y = 216;
											break;
										default:
											rectangle.X = 252;
											rectangle.Y = 216;
											break;
										}
									}
									else if (down != num && down != num32 && up == num && left == num && right == num && upLeft != num && upLeft != num32 && upRight != num && upRight != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 252;
											break;
										case 1:
											rectangle.X = 198;
											rectangle.Y = 252;
											break;
										default:
											rectangle.X = 252;
											rectangle.Y = 252;
											break;
										}
									}
									else if (left != num && left != num32 && down == num && up == num && right == num && upRight != num && upRight != num32 && downRight != num && downRight != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 126;
											rectangle.Y = 234;
											break;
										case 1:
											rectangle.X = 180;
											rectangle.Y = 234;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 234;
											break;
										}
									}
									else if (right != num && right != num32 && down == num && up == num && left == num && upLeft != num && upLeft != num32 && downLeft != num && downLeft != num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 162;
											rectangle.Y = 234;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 234;
											break;
										default:
											rectangle.X = 270;
											rectangle.Y = 234;
											break;
										}
									}
									else if (up != num32 && up != num && (down == num32 || down == num) && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 36;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 270;
											break;
										}
									}
									else if (down != num32 && down != num && (up == num32 || up == num) && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 36;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 288;
											break;
										}
									}
									else if (left != num32 && left != num && (right == num32 || right == num) && up == num32 && down == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 0;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 0;
											rectangle.Y = 306;
											break;
										}
									}
									else if (right != num32 && right != num && (left == num32 || left == num) && up == num32 && down == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 18;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 18;
											rectangle.Y = 306;
											break;
										}
									}
									else if (up == num && down == num32 && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 288;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 288;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 288;
											break;
										}
									}
									else if (up == num32 && down == num && left == num32 && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 270;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 270;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 270;
											break;
										}
									}
									else if (up == num32 && down == num32 && left == num && right == num32)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 198;
											rectangle.Y = 306;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 306;
											break;
										default:
											rectangle.X = 234;
											rectangle.Y = 306;
											break;
										}
									}
									else if (up == num32 && down == num32 && left == num32 && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 144;
											rectangle.Y = 306;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 306;
											break;
										default:
											rectangle.X = 180;
											rectangle.Y = 306;
											break;
										}
									}
									if (up != num && up != num32 && down == num && left == num && right == num)
									{
										if ((downLeft == num32 || downLeft == num) && downRight != num32 && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 324;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 324;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 324;
												break;
											}
										}
										else if ((downRight == num32 || downRight == num) && downLeft != num32 && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 324;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 324;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 324;
												break;
											}
										}
									}
									else if (down != num && down != num32 && up == num && left == num && right == num)
									{
										if ((upLeft == num32 || upLeft == num) && upRight != num32 && upRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 342;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 342;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 342;
												break;
											}
										}
										else if ((upRight == num32 || upRight == num) && upLeft != num32 && upLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 342;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 342;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 342;
												break;
											}
										}
									}
									else if (left != num && left != num32 && up == num && down == num && right == num)
									{
										if ((upRight == num32 || upRight == num) && downRight != num32 && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 360;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 360;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 360;
												break;
											}
										}
										else if ((downRight == num32 || downRight == num) && upRight != num32 && upRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 360;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 360;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 360;
												break;
											}
										}
									}
									else if (right != num && right != num32 && up == num && down == num && left == num)
									{
										if ((upLeft == num32 || upLeft == num) && downLeft != num32 && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 378;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 378;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 378;
												break;
											}
										}
										else if ((downLeft == num32 || downLeft == num) && upLeft != num32 && upLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 378;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 378;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 378;
												break;
											}
										}
									}
									if ((up == num || up == num32) && (down == num || down == num32) && (left == num || left == num32) && (right == num || right == num32) && upLeft != -1 && upRight != -1 && downLeft != -1 && downRight != -1)
									{
										if ((i + j) % 2 == 1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 198;
												break;
											}
										}
										else
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 18;
												rectangle.Y = 18;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 18;
												break;
											}
										}
									}
									switch (num32)
									{
									case 0:
										TileMergeAttempt(-2, TileID.Sets.Dirt, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									case 59:
										TileMergeAttempt(-2, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									default:
										TileMergeAttempt(-2, num32, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										break;
									}
									tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								}
								TileMergeAttempt(num, Main.tileMerge[num], ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
								if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[num] || (num > -1 && TileID.Sets.ChecksForMerge[num])))
								{
									if (!flag)
									{
										flag = true;
										TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
									if (up > -1 && up != num)
									{
										up = -1;
									}
									if (down > -1 && down != num)
									{
										down = -1;
									}
									if (left > -1 && left != num)
									{
										left = -1;
									}
									if (right > -1 && right != num)
									{
										right = -1;
									}
									tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									if (up != -1 && down != -1 && left != -1 && right != -1)
									{
										if (up == -2 && down == num && left == num && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 108;
												break;
											}
											mergeUp = true;
										}
										else if (up == num && down == -2 && left == num && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 90;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 90;
												break;
											}
											mergeDown = true;
										}
										else if (up == num && down == num && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 162;
												rectangle.Y = 126;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 162;
												rectangle.Y = 162;
												break;
											}
											mergeLeft = true;
										}
										else if (up == num && down == num && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 126;
												break;
											case 1:
												rectangle.X = 144;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 162;
												break;
											}
											mergeRight = true;
										}
										else if (up == -2 && down == num && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 162;
												break;
											}
											mergeUp = true;
											mergeLeft = true;
										}
										else if (up == -2 && down == num && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 126;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 162;
												break;
											}
											mergeUp = true;
											mergeRight = true;
										}
										else if (up == num && down == -2 && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 36;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 180;
												break;
											}
											mergeDown = true;
											mergeLeft = true;
										}
										else if (up == num && down == -2 && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 108;
												break;
											case 1:
												rectangle.X = 54;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 180;
												break;
											}
											mergeDown = true;
											mergeRight = true;
										}
										else if (up == num && down == num && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 180;
												rectangle.Y = 126;
												break;
											case 1:
												rectangle.X = 180;
												rectangle.Y = 144;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 162;
												break;
											}
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == -2 && down == -2 && left == num && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 144;
												rectangle.Y = 180;
												break;
											case 1:
												rectangle.X = 162;
												rectangle.Y = 180;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 180;
												break;
											}
											mergeUp = true;
											mergeDown = true;
										}
										else if (up == -2 && down == num && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 198;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 198;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 198;
												rectangle.Y = 126;
												break;
											}
											mergeUp = true;
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == num && down == -2 && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 198;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 198;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 198;
												rectangle.Y = 180;
												break;
											}
											mergeDown = true;
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == -2 && down == -2 && left == num && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 216;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 216;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 216;
												rectangle.Y = 180;
												break;
											}
											mergeUp = true;
											mergeDown = true;
											mergeRight = true;
										}
										else if (up == -2 && down == -2 && left == -2 && right == num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 216;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 216;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 216;
												rectangle.Y = 126;
												break;
											}
											mergeUp = true;
											mergeDown = true;
											mergeLeft = true;
										}
										else if (up == -2 && down == -2 && left == -2 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 198;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 198;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 198;
												break;
											}
											mergeUp = true;
											mergeDown = true;
											mergeLeft = true;
											mergeRight = true;
										}
										else if (up == num && down == num && left == num && right == num)
										{
											if (upLeft == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 18;
													rectangle.Y = 108;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 144;
													break;
												default:
													rectangle.X = 18;
													rectangle.Y = 180;
													break;
												}
											}
											if (upRight == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 108;
													break;
												case 1:
													rectangle.X = 0;
													rectangle.Y = 144;
													break;
												default:
													rectangle.X = 0;
													rectangle.Y = 180;
													break;
												}
											}
											if (downLeft == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 18;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 126;
													break;
												default:
													rectangle.X = 18;
													rectangle.Y = 162;
													break;
												}
											}
											if (downRight == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 0;
													rectangle.Y = 126;
													break;
												default:
													rectangle.X = 0;
													rectangle.Y = 162;
													break;
												}
											}
										}
									}
									else
									{
										if (num != 2 && num != 23 && num != 60 && num != 70 && num != 109 && num != 199 && num != 477 && num != 492 && num != 633 && num != 661 && num != 662)
										{
											if (up == -1 && down == -2 && left == num && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 0;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 0;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 0;
													break;
												}
												mergeDown = true;
											}
											else if (up == -2 && down == -1 && left == num && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 18;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 18;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 18;
													break;
												}
												mergeUp = true;
											}
											else if (up == num && down == num && left == -1 && right == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 36;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 36;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 36;
													break;
												}
												mergeRight = true;
											}
											else if (up == num && down == num && left == -2 && right == -1)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 234;
													rectangle.Y = 54;
													break;
												case 1:
													rectangle.X = 252;
													rectangle.Y = 54;
													break;
												default:
													rectangle.X = 270;
													rectangle.Y = 54;
													break;
												}
												mergeLeft = true;
											}
										}
										if (up != -1 && down != -1 && left == -1 && right == num)
										{
											if (up == -2 && down == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 72;
													rectangle.Y = 144;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 162;
													break;
												default:
													rectangle.X = 72;
													rectangle.Y = 180;
													break;
												}
												mergeUp = true;
											}
											else if (down == -2 && up == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 72;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 108;
													break;
												default:
													rectangle.X = 72;
													rectangle.Y = 126;
													break;
												}
												mergeDown = true;
											}
										}
										else if (up != -1 && down != -1 && left == num && right == -1)
										{
											if (up == -2 && down == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 90;
													rectangle.Y = 144;
													break;
												case 1:
													rectangle.X = 90;
													rectangle.Y = 162;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 180;
													break;
												}
												mergeUp = true;
											}
											else if (down == -2 && up == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 90;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 90;
													rectangle.Y = 108;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 126;
													break;
												}
												mergeDown = true;
											}
										}
										else if (up == -1 && down == num && left != -1 && right != -1)
										{
											if (left == -2 && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 198;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 198;
													break;
												default:
													rectangle.X = 36;
													rectangle.Y = 198;
													break;
												}
												mergeLeft = true;
											}
											else if (right == -2 && left == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 54;
													rectangle.Y = 198;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 198;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 198;
													break;
												}
												mergeRight = true;
											}
										}
										else if (up == num && down == -1 && left != -1 && right != -1)
										{
											if (left == -2 && right == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 216;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 216;
													break;
												default:
													rectangle.X = 36;
													rectangle.Y = 216;
													break;
												}
												mergeLeft = true;
											}
											else if (right == -2 && left == num)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 54;
													rectangle.Y = 216;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 216;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 216;
													break;
												}
												mergeRight = true;
											}
										}
										else if (up != -1 && down != -1 && left == -1 && right == -1)
										{
											if (up == -2 && down == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 108;
													rectangle.Y = 216;
													break;
												case 1:
													rectangle.X = 108;
													rectangle.Y = 234;
													break;
												default:
													rectangle.X = 108;
													rectangle.Y = 252;
													break;
												}
												mergeUp = true;
												mergeDown = true;
											}
											else if (up == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 126;
													rectangle.Y = 144;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 162;
													break;
												default:
													rectangle.X = 126;
													rectangle.Y = 180;
													break;
												}
												mergeUp = true;
											}
											else if (down == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 126;
													rectangle.Y = 90;
													break;
												case 1:
													rectangle.X = 126;
													rectangle.Y = 108;
													break;
												default:
													rectangle.X = 126;
													rectangle.Y = 126;
													break;
												}
												mergeDown = true;
											}
										}
										else if (up == -1 && down == -1 && left != -1 && right != -1)
										{
											if (left == -2 && right == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 162;
													rectangle.Y = 198;
													break;
												case 1:
													rectangle.X = 180;
													rectangle.Y = 198;
													break;
												default:
													rectangle.X = 198;
													rectangle.Y = 198;
													break;
												}
												mergeLeft = true;
												mergeRight = true;
											}
											else if (left == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 0;
													rectangle.Y = 252;
													break;
												case 1:
													rectangle.X = 18;
													rectangle.Y = 252;
													break;
												default:
													rectangle.X = 36;
													rectangle.Y = 252;
													break;
												}
												mergeLeft = true;
											}
											else if (right == -2)
											{
												switch (num27)
												{
												case 0:
													rectangle.X = 54;
													rectangle.Y = 252;
													break;
												case 1:
													rectangle.X = 72;
													rectangle.Y = 252;
													break;
												default:
													rectangle.X = 90;
													rectangle.Y = 252;
													break;
												}
												mergeRight = true;
											}
										}
										else if (up == -2 && down == -1 && left == -1 && right == -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 144;
												break;
											case 1:
												rectangle.X = 108;
												rectangle.Y = 162;
												break;
											default:
												rectangle.X = 108;
												rectangle.Y = 180;
												break;
											}
											mergeUp = true;
										}
										else if (up == -1 && down == -2 && left == -1 && right == -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 90;
												break;
											case 1:
												rectangle.X = 108;
												rectangle.Y = 108;
												break;
											default:
												rectangle.X = 108;
												rectangle.Y = 126;
												break;
											}
											mergeDown = true;
										}
										else if (up == -1 && down == -1 && left == -2 && right == -1)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 0;
												rectangle.Y = 234;
												break;
											case 1:
												rectangle.X = 18;
												rectangle.Y = 234;
												break;
											default:
												rectangle.X = 36;
												rectangle.Y = 234;
												break;
											}
											mergeLeft = true;
										}
										else if (up == -1 && down == -1 && left == -1 && right == -2)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 54;
												rectangle.Y = 234;
												break;
											case 1:
												rectangle.X = 72;
												rectangle.Y = 234;
												break;
											default:
												rectangle.X = 90;
												rectangle.Y = 234;
												break;
											}
											mergeRight = true;
										}
									}
								}
								int num33 = tile.blockType();
								if (TileID.Sets.HasSlopeFrames[num])
								{
									if (num33 == 0)
									{
										bool flag3 = num == up && tile2.topSlope();
										bool flag4 = num == left && tile4.leftSlope();
										bool flag5 = num == right && tile5.rightSlope();
										bool flag6 = num == down && tile3.bottomSlope();
										int num34 = 0;
										int num35 = 0;
										if (flag3.ToInt() + flag4.ToInt() + flag5.ToInt() + flag6.ToInt() > 2)
										{
											int num36 = (tile2.slope() == 1).ToInt() + (tile5.slope() == 1).ToInt() + (tile3.slope() == 4).ToInt() + (tile4.slope() == 4).ToInt();
											int num37 = (tile2.slope() == 2).ToInt() + (tile5.slope() == 3).ToInt() + (tile3.slope() == 3).ToInt() + (tile4.slope() == 2).ToInt();
											if (num36 == num37)
											{
												num34 = 2;
												num35 = 4;
											}
											else if (num36 > num37)
											{
												bool num38 = num == upLeft && tile8.slope() == 0;
												bool flag7 = num == downRight && tile7.slope() == 0;
												if (num38 && flag7)
												{
													num35 = 4;
												}
												else if (flag7)
												{
													num34 = 6;
												}
												else
												{
													num34 = 7;
													num35 = 1;
												}
											}
											else
											{
												bool num39 = num == upRight && tile9.slope() == 0;
												bool flag8 = num == downLeft && tile6.slope() == 0;
												if (num39 && flag8)
												{
													num35 = 4;
													num34 = 1;
												}
												else if (flag8)
												{
													num34 = 7;
												}
												else
												{
													num34 = 6;
													num35 = 1;
												}
											}
											rectangle.X = (18 + num34) * 18;
											rectangle.Y = num35 * 18;
										}
										else
										{
											if (flag3 && flag4 && num == down && num == right)
											{
												num35 = 2;
											}
											else if (flag3 && flag5 && num == down && num == left)
											{
												num34 = 1;
												num35 = 2;
											}
											else if (flag5 && flag6 && num == up && num == left)
											{
												num34 = 1;
												num35 = 3;
											}
											else if (flag6 && flag4 && num == up && num == right)
											{
												num35 = 3;
											}
											if (num34 != 0 || num35 != 0)
											{
												rectangle.X = (18 + num34) * 18;
												rectangle.Y = num35 * 18;
											}
										}
									}
									if (num33 >= 2 && (rectangle.X < 0 || rectangle.Y < 0))
									{
										int num40 = -1;
										int num41 = -1;
										int num42 = -1;
										int num43 = 0;
										int num44 = 0;
										switch (num33)
										{
										case 2:
											num40 = left;
											num41 = down;
											num42 = downLeft;
											num43++;
											break;
										case 3:
											num40 = right;
											num41 = down;
											num42 = downRight;
											break;
										case 4:
											num40 = left;
											num41 = up;
											num42 = upLeft;
											num43++;
											num44++;
											break;
										case 5:
											num40 = right;
											num41 = up;
											num42 = upRight;
											num44++;
											break;
										}
										if (num != num40 || num != num41 || num != num42)
										{
											if (num == num40 && num == num41)
											{
												num43 += 2;
											}
											else if (num == num40)
											{
												num43 += 4;
											}
											else if (num == num41)
											{
												num43 += 4;
												num44 += 2;
											}
											else
											{
												num43 += 2;
												num44 += 2;
											}
										}
										rectangle.X = (18 + num43) * 18;
										rectangle.Y = num44 * 18;
									}
								}
								if (rectangle.X < 0 || rectangle.Y < 0)
								{
									if (!flag)
									{
										flag = true;
										TileMergeAttemptWeird(num, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
									if (num == 2 || num == 23 || num == 60 || num == 70 || num == 109 || num == 199 || num == 477 || num == 492 || num == 633 || num == 661 || num == 662 || Main.tileMoss[num] || TileID.Sets.tileMossBrick[num])
									{
										TileMergeAttempt(num, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
										tileMergeCullCache.Cull(ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
									}
									if (up == num && down == num && left == num && right == num)
									{
										if (upLeft != num && upRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 18;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 18;
												break;
											}
										}
										else if (downLeft != num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 108;
												rectangle.Y = 36;
												break;
											case 1:
												rectangle.X = 126;
												rectangle.Y = 36;
												break;
											default:
												rectangle.X = 144;
												rectangle.Y = 36;
												break;
											}
										}
										else if (upLeft != num && downLeft != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 180;
												rectangle.Y = 0;
												break;
											case 1:
												rectangle.X = 180;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 180;
												rectangle.Y = 36;
												break;
											}
										}
										else if (upRight != num && downRight != num)
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 198;
												rectangle.Y = 0;
												break;
											case 1:
												rectangle.X = 198;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 198;
												rectangle.Y = 36;
												break;
											}
										}
										else
										{
											switch (num27)
											{
											case 0:
												rectangle.X = 18;
												rectangle.Y = 18;
												break;
											case 1:
												rectangle.X = 36;
												rectangle.Y = 18;
												break;
											default:
												rectangle.X = 54;
												rectangle.Y = 18;
												break;
											}
										}
									}
									else if (up != num && down == num && left == num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 0;
											break;
										default:
											rectangle.X = 54;
											rectangle.Y = 0;
											break;
										}
									}
									else if (up == num && down != num && left == num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 36;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 36;
											break;
										default:
											rectangle.X = 54;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 0;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 0;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up == num && down == num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 72;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 72;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down == num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 54;
											break;
										}
									}
									else if (up != num && down == num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 90;
											rectangle.Y = 54;
											break;
										}
									}
									else if (up == num && down != num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 0;
											rectangle.Y = 72;
											break;
										case 1:
											rectangle.X = 36;
											rectangle.Y = 72;
											break;
										default:
											rectangle.X = 72;
											rectangle.Y = 72;
											break;
										}
									}
									else if (up == num && down != num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 18;
											rectangle.Y = 72;
											break;
										case 1:
											rectangle.X = 54;
											rectangle.Y = 72;
											break;
										default:
											rectangle.X = 90;
											rectangle.Y = 72;
											break;
										}
									}
									else if (up == num && down == num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 90;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 90;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 90;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down != num && left == num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 72;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 72;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 72;
											break;
										}
									}
									else if (up != num && down == num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 0;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 0;
											break;
										}
									}
									else if (up == num && down != num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 108;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 126;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 144;
											rectangle.Y = 54;
											break;
										}
									}
									else if (up != num && down != num && left != num && right == num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 162;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 162;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 162;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down != num && left == num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 216;
											rectangle.Y = 0;
											break;
										case 1:
											rectangle.X = 216;
											rectangle.Y = 18;
											break;
										default:
											rectangle.X = 216;
											rectangle.Y = 36;
											break;
										}
									}
									else if (up != num && down != num && left != num && right != num)
									{
										switch (num27)
										{
										case 0:
											rectangle.X = 162;
											rectangle.Y = 54;
											break;
										case 1:
											rectangle.X = 180;
											rectangle.Y = 54;
											break;
										default:
											rectangle.X = 198;
											rectangle.Y = 54;
											break;
										}
									}
								}
								if (rectangle.X <= -1 || rectangle.Y <= -1)
								{
									if (num27 <= 0)
									{
										rectangle.X = 18;
										rectangle.Y = 18;
									}
									else if (num27 == 1)
									{
										rectangle.X = 36;
										rectangle.Y = 18;
									}
									if (num27 >= 2)
									{
										rectangle.X = 54;
										rectangle.Y = 18;
									}
								}
								if (Main.tileLargeFrames[num] == 1 && num27 == 3)
								{
									rectangle.Y += 90;
								}
								if (Main.tileLargeFrames[num] == 2 && num27 == 3)
								{
									rectangle.Y += 90;
								}
								tile.frameX = (short)rectangle.X;
								tile.frameY = (short)rectangle.Y;
								if (TileID.Sets.IsVine[num])
								{
									up = ((tile2 == null) ? num : ((!tile2.nactive()) ? (-1) : ((!tile2.bottomSlope()) ? tile2.type : (-1))));
									if (num != up)
									{
										bool num45 = up == 60 || up == 62;
										bool num46 = up == 109 || up == 115;
										bool flag9 = up == 23 || up == 636 || up == 661;
										bool flag10 = up == 199 || up == 205 || up == 662;
										bool flag11 = up == 2 || up == 52;
										bool flag12 = up == 382;
										bool num47 = up == 70 || up == 528;
										bool num48 = up == 633 || up == 638;
										ushort num49 = 0;
										if (num48)
										{
											num49 = 638;
										}
										if (num47)
										{
											num49 = 528;
										}
										if (num46)
										{
											num49 = 115;
										}
										if (num45)
										{
											num49 = 62;
										}
										if (flag9)
										{
											num49 = 636;
										}
										if (flag10)
										{
											num49 = 205;
										}
										if (flag11 && num != 382)
										{
											num49 = 52;
										}
										if (flag12)
										{
											num49 = 382;
										}
										if (num49 != 0 && num49 != num)
										{
											tile.type = num49;
											SquareTileFrame(i, j);
											return;
										}
									}
									if (up != num)
									{
										bool flag13 = false;
										if (up == -1)
										{
											flag13 = true;
										}
										if (num == 52 && up != 2 && up != 192)
										{
											flag13 = true;
										}
										if (num == 382 && up != 2 && up != 192)
										{
											flag13 = true;
										}
										if (num == 62 && up != 60)
										{
											flag13 = true;
										}
										if (num == 115 && up != 109)
										{
											flag13 = true;
										}
										if (num == 528 && up != 70)
										{
											flag13 = true;
										}
										if (num == 636 && up != 23 && up != 661)
										{
											flag13 = true;
										}
										if (num == 205 && up != 199 && up != 662)
										{
											flag13 = true;
										}
										if (num == 638 && up != 633)
										{
											flag13 = true;
										}
										if (flag13)
										{
											KillTile(i, j);
										}
									}
								}
								bool flag14 = false;
								if (!noTileActions && tile.active() && (num == 53 || num == 112 || num == 116 || num == 123 || num == 234 || num == 224 || num == 495 || num == 330 || num == 331 || num == 332 || num == 333))
								{
									SpawnFallingBlockProjectile(i, j, tile, tile2, tile3, num);
								}
								if ((rectangle.X != frameX && rectangle.Y != frameY && frameX >= 0 && frameY >= 0) || flag14)
								{
									tileReframeCount++;
									if (tileReframeCount < 25)
									{
										bool num50 = mergeUp;
										bool flag15 = mergeDown;
										bool flag16 = mergeLeft;
										bool flag17 = mergeRight;
										TileFrame(i - 1, j);
										TileFrame(i + 1, j);
										TileFrame(i, j - 1);
										TileFrame(i, j + 1);
										mergeUp = num50;
										mergeDown = flag15;
										mergeLeft = flag16;
										mergeRight = flag17;
									}
									tileReframeCount--;
								}
								goto end_IL_0002;
							}
							}
						}
						Framing.SelfFrame8Way(i, j, tile, resetFrame);
						return;
					}
				}
				end_IL_0002:;
			}
			catch
			{
			}
			if (i > 0 && j > 0)
			{
				UpdateMapTile(i, j, addToList);
			}
		}

		private static void StopMergingByInvsibility(ref int currentMerge, Tile block, bool wantedInvisibilityState)
		{
			if (currentMerge > -1 && block.invisibleBlock() != wantedInvisibilityState)
			{
				currentMerge = -1;
			}
		}

		private static bool SpawnFallingBlockProjectile(int i, int j, Tile tileCache, Tile tileTopCache, Tile tileBottomCache, int type)
		{
			if (Main.netMode == 1)
			{
				return false;
			}
			if (tileBottomCache == null)
			{
				return false;
			}
			if (!BlockBelowMakesSandFall(i, j))
			{
				return false;
			}
			if (!AllowsSandfall(tileTopCache))
			{
				return false;
			}
			GetSandfallProjData(type, out var projType, out var dmg);
			tileCache.ClearTile();
			if (Main.netMode == 0)
			{
				int num = Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 8, j * 16 + 8, 0f, 0.41f, projType, dmg, 0f, Main.myPlayer);
				Main.projectile[num].ai[0] = 1f;
				SquareTileFrame(i, j);
			}
			if (Main.netMode == 2)
			{
				bool flag = false;
				for (int k = 0; k < 1000; k++)
				{
					if (Main.projectile[k].active && Main.projectile[k].owner == Main.myPlayer && Main.projectile[k].type == projType && Math.Abs(Main.projectile[k].timeLeft - 3600) < 60 && Main.projectile[k].Distance(new Vector2(i * 16 + 8, j * 16 + 10)) < 4f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					int num2 = Projectile.NewProjectile(GetProjectileSource_TileBreak(i, j), i * 16 + 8, j * 16 + 8, 0f, 2.5f, projType, dmg, 0f, Main.myPlayer);
					Main.projectile[num2].velocity.Y = 0.5f;
					Main.projectile[num2].position.Y += 2f;
					Main.projectile[num2].netUpdate = true;
				}
				SquareTileFrame(i, j);
				NetMessage.SendTileSquare(-1, i, j);
				ExploitDestroyQueue.Enqueue(new Point(i, j));
				ExploitDestroyQueue.Enqueue(new Point(i, j - 1));
			}
			return true;
		}

		public static void CheckTorch(int x, int y)
		{
			for (int i = x - 1; i <= x + 1; i++)
			{
				for (int j = y - 1; j <= y + 1; j++)
				{
					if (Main.tile[i, j] == null)
					{
						return;
					}
				}
			}
			Tile tile = Main.tile[x, y];
			Tile tile2 = Main.tile[x, y - 1];
			Tile tile3 = Main.tile[x, y + 1];
			Tile tile4 = Main.tile[x - 1, y];
			Tile tile5 = Main.tile[x + 1, y];
			Tile tile6 = Main.tile[x - 1, y + 1];
			Tile tile7 = Main.tile[x + 1, y + 1];
			Tile tile8 = Main.tile[x - 1, y - 1];
			Tile tile9 = Main.tile[x + 1, y - 1];
			short num = 0;
			if (tile.frameX >= 66)
			{
				num = 66;
			}
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int tree = -1;
			int tree2 = -1;
			int tree3 = -1;
			int tree4 = -1;
			if (tile2 != null && tile2.active() && !tile2.bottomSlope())
			{
				_ = tile2.type;
			}
			if (tile3 != null && tile3.active() && ((TileID.Sets.Platforms[tile3.type] && TopEdgeCanBeAttachedTo(x, y + 1)) || (!tile3.halfBrick() && !tile3.topSlope())))
			{
				num2 = tile3.type;
			}
			if (tile4 != null && tile4.active() && (tile4.slope() == 0 || (int)tile4.slope() % 2 != 1))
			{
				num3 = tile4.type;
			}
			if (tile5 != null && tile5.active() && (tile5.slope() == 0 || (int)tile5.slope() % 2 != 0))
			{
				num4 = tile5.type;
			}
			if (tile6 != null && tile6.active())
			{
				tree = tile6.type;
			}
			if (tile7 != null && tile7.active())
			{
				tree2 = tile7.type;
			}
			if (tile8 != null && tile8.active())
			{
				tree3 = tile8.type;
			}
			if (tile9 != null && tile9.active())
			{
				tree4 = tile9.type;
			}
			if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || TileID.Sets.Platforms[num2]))
			{
				tile.frameX = num;
			}
			else if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3]) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
			{
				tile.frameX = (short)(22 + num);
			}
			else if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4]) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
			{
				tile.frameX = (short)(44 + num);
			}
			else if (tile.wall > 0)
			{
				tile.frameX = num;
			}
			else
			{
				KillTile(x, y);
			}
		}

		public static void CheckProjectilePressurePad(int i, int j)
		{
			CheckProjectilePressurePad_GetPossiblePlacementDirections(i, j, out var canUp, out var canLeft, out var canRight, out var canDown);
			Tile tile = Main.tile[i, j];
			int num = tile.frameX / 22;
			bool flag = false;
			if (num switch
			{
				0 => !canDown, 
				1 => !canUp, 
				2 => !canLeft, 
				3 => !canRight, 
				_ => true, 
			})
			{
				if (canDown)
				{
					tile.frameX = 0;
				}
				else if (canUp)
				{
					tile.frameX = 22;
				}
				else if (canLeft)
				{
					tile.frameX = 44;
				}
				else if (canRight)
				{
					tile.frameX = 66;
				}
				else
				{
					KillTile(i, j);
				}
			}
		}

		private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(int i, int j, out bool canUp, out bool canLeft, out bool canRight, out bool canDown)
		{
			canUp = false;
			canLeft = false;
			canRight = false;
			canDown = false;
			_ = Main.tile[i, j];
			Tile tile = Main.tile[i, j - 1];
			Tile tile2 = Main.tile[i, j + 1];
			Tile tile3 = Main.tile[i - 1, j];
			Tile tile4 = Main.tile[i + 1, j];
			Tile tile5 = Main.tile[i - 1, j + 1];
			Tile tile6 = Main.tile[i + 1, j + 1];
			Tile tile7 = Main.tile[i - 1, j - 1];
			Tile tile8 = Main.tile[i + 1, j - 1];
			int num = -1;
			int num2 = -1;
			int num3 = -1;
			int num4 = -1;
			int tree = -1;
			int tree2 = -1;
			int tree3 = -1;
			int tree4 = -1;
			if (tile != null && tile.nactive() && !tile.bottomSlope())
			{
				num2 = tile.type;
			}
			if (tile2 != null && tile2.nactive() && !tile2.halfBrick() && !tile2.topSlope())
			{
				num = tile2.type;
			}
			if (tile3 != null && tile3.nactive() && (tile3.slope() == 0 || (int)tile3.slope() % 2 != 1))
			{
				num3 = tile3.type;
			}
			if (tile4 != null && tile4.nactive() && (tile4.slope() == 0 || (int)tile4.slope() % 2 != 0))
			{
				num4 = tile4.type;
			}
			if (tile5 != null && tile5.nactive())
			{
				tree = tile5.type;
			}
			if (tile6 != null && tile6.nactive())
			{
				tree2 = tile6.type;
			}
			if (tile7 != null && tile7.nactive())
			{
				tree3 = tile7.type;
			}
			if (tile8 != null && tile8.nactive())
			{
				tree4 = tile8.type;
			}
			if (num >= 0 && Main.tileSolid[num] && (!Main.tileNoAttach[num] || TileID.Sets.Platforms[num]) && (tile2.bottomSlope() || tile2.slope() == 0) && !tile2.halfBrick())
			{
				canDown = true;
			}
			if (num2 >= 0 && Main.tileSolid[num2] && (!Main.tileNoAttach[num2] || (TileID.Sets.Platforms[num2] && tile.halfBrick())) && (tile.topSlope() || tile.slope() == 0 || tile.halfBrick()))
			{
				canUp = true;
			}
			if ((num3 >= 0 && Main.tileSolid[num3] && !Main.tileNoAttach[num3] && (tile3.leftSlope() || tile3.slope() == 0) && !tile3.halfBrick()) || (num3 >= 0 && TileID.Sets.IsBeam[num3]) || (IsTreeType(num3) && IsTreeType(tree3) && IsTreeType(tree)))
			{
				canLeft = true;
			}
			if ((num4 >= 0 && Main.tileSolid[num4] && !Main.tileNoAttach[num4] && (tile4.rightSlope() || tile4.slope() == 0) && !tile4.halfBrick()) || (num4 >= 0 && TileID.Sets.IsBeam[num4]) || (IsTreeType(num4) && IsTreeType(tree4) && IsTreeType(tree2)))
			{
				canRight = true;
			}
		}

		public static bool IsTreeType(int tree)
		{
			if (tree >= 0)
			{
				return TileID.Sets.IsATreeTrunk[tree];
			}
			return false;
		}

		public static int CanPlaceProjectilePressurePad(int x, int y, int type = 442, int style = 0, int direction = 0, int alternate = 0)
		{
			CheckProjectilePressurePad_GetPossiblePlacementDirections(x, y, out var canUp, out var canLeft, out var canRight, out var canDown);
			if (!canUp && !canDown && !canLeft && !canRight)
			{
				return -1;
			}
			switch (alternate)
			{
			case 0:
				if (!canDown)
				{
					return -1;
				}
				break;
			case 1:
				if (!canUp)
				{
					return -1;
				}
				break;
			case 2:
				if (!canLeft)
				{
					return -1;
				}
				break;
			case 3:
				if (!canRight)
				{
					return -1;
				}
				break;
			}
			return style;
		}

		private static void CheckDoorOpen(int i, int j, Tile tileCache)
		{
			if (destroyObject)
			{
				return;
			}
			int num = 0;
			int num2 = i;
			int num3 = j;
			short frameX = tileCache.frameX;
			int frameY = tileCache.frameY;
			int num4 = frameY / 54;
			num4 += tileCache.frameX / 72 * 36;
			num3 = j - frameY % 54 / 18;
			bool flag = false;
			switch (frameX % 72)
			{
			case 0:
				num2 = i;
				num = 1;
				break;
			case 18:
				num2 = i - 1;
				num = 1;
				break;
			case 36:
				num2 = i + 1;
				num = -1;
				break;
			case 54:
				num2 = i;
				num = -1;
				break;
			}
			Tile tile = Main.tile[num2, num3 - 1];
			Tile tile2 = Main.tile[num2, num3 + 3];
			if (tile == null)
			{
				tile = new Tile();
				Main.tile[num2, num3 - 1] = tile;
			}
			if (tile2 == null)
			{
				tile2 = new Tile();
				Main.tile[num2, num3 + 3] = tile2;
			}
			if (!SolidTile(tile) || !SolidTile(tile2))
			{
				flag = true;
				destroyObject = true;
				DropDoorItem(i, j, num4);
			}
			int num5 = num2;
			if (num == -1)
			{
				num5 = num2 - 1;
			}
			for (int k = num5; k < num5 + 2; k++)
			{
				for (int l = num3; l < num3 + 3; l++)
				{
					if (!flag)
					{
						Tile tile3 = Main.tile[k, l];
						if (!tile3.active() || tile3.type != 11)
						{
							destroyObject = true;
							DropDoorItem(i, j, num4);
							flag = true;
							k = num5;
							l = num3;
						}
					}
					if (flag)
					{
						KillTile(k, l);
					}
				}
			}
			destroyObject = false;
		}

		private static void CheckDoorClosed(int i, int j, Tile tileCache, int type)
		{
			if (!destroyObject)
			{
				int num = j;
				bool flag = false;
				int frameY = tileCache.frameY;
				int num2 = frameY / 54;
				num2 += tileCache.frameX / 54 * 36;
				num = j - frameY % 54 / 18;
				Tile tile = Main.tile[i, num - 1];
				Tile tile2 = Main.tile[i, num];
				Tile tile3 = Main.tile[i, num + 1];
				Tile tile4 = Main.tile[i, num + 2];
				Tile tile5 = Main.tile[i, num + 3];
				if (tile == null)
				{
					tile = new Tile();
					Main.tile[i, num - 1] = tile;
				}
				if (tile2 == null)
				{
					tile2 = new Tile();
					Main.tile[i, num] = tile2;
				}
				if (tile3 == null)
				{
					tile3 = new Tile();
					Main.tile[i, num + 1] = tile3;
				}
				if (tile4 == null)
				{
					tile4 = new Tile();
					Main.tile[i, num + 2] = tile4;
				}
				if (tile5 == null)
				{
					tile5 = new Tile();
					Main.tile[i, num + 3] = tile5;
				}
				if (!SolidTile(tile))
				{
					flag = true;
				}
				if (!SolidTile(tile5))
				{
					flag = true;
				}
				if (!tile2.active() || tile2.type != type)
				{
					flag = true;
				}
				if (!tile3.active() || tile3.type != type)
				{
					flag = true;
				}
				if (!tile4.active() || tile4.type != type)
				{
					flag = true;
				}
				if (flag)
				{
					destroyObject = true;
					KillTile(i, num);
					KillTile(i, num + 1);
					KillTile(i, num + 2);
					DropDoorItem(i, j, num2);
				}
				destroyObject = false;
			}
		}

		private static void GetSandfallProjData(int type, out int projType, out int dmg)
		{
			dmg = 10;
			switch (type)
			{
			case 112:
				projType = 56;
				break;
			case 59:
				projType = 39;
				break;
			case 116:
				projType = 67;
				break;
			case 123:
				projType = 71;
				break;
			case 224:
				projType = 179;
				break;
			case 234:
				projType = 241;
				break;
			case 330:
				projType = 411;
				dmg = 0;
				break;
			case 331:
				projType = 412;
				dmg = 0;
				break;
			case 332:
				projType = 413;
				dmg = 0;
				break;
			case 333:
				projType = 414;
				dmg = 0;
				break;
			case 495:
				projType = 812;
				break;
			default:
				projType = 31;
				break;
			}
		}

		public static bool BlockBelowMakesSandConvertIntoHardenedSand(int i, int j)
		{
			bool result = false;
			if (j >= Main.maxTilesY - 1)
			{
				return false;
			}
			Tile tile = Main.tile[i, j + 1];
			if (tile == null)
			{
				return false;
			}
			if (!tile.nactive())
			{
				result = true;
			}
			else if (tile.type >= 0 && tile.type < 693 && !Main.tileSolid[tile.type])
			{
				result = true;
			}
			return result;
		}

		public static bool BlockBelowMakesSandFall(int i, int j)
		{
			bool result = false;
			if (j >= Main.maxTilesY - 1)
			{
				return false;
			}
			Tile tile = Main.tile[i, j + 1];
			if (tile == null)
			{
				return false;
			}
			if (!tile.nactive())
			{
				result = true;
			}
			else if (!Main.tile[i, j + 2].nactive() && (!tile.active() || !Main.tileSolid[tile.type]))
			{
				result = true;
			}
			else if (tile.active() && tile.type == 165)
			{
				result = true;
			}
			return result;
		}

		public static bool AllowsSandfall(Tile tileTopCache)
		{
			bool result = true;
			if (tileTopCache.active() && (TileID.Sets.BasicChest[tileTopCache.type] || TileID.Sets.BasicChestFake[tileTopCache.type] || tileTopCache.type == 323 || tileTopCache.type == 88 || tileTopCache.type == 80 || tileTopCache.type == 77 || tileTopCache.type == 26 || tileTopCache.type == 475 || tileTopCache.type == 470 || tileTopCache.type == 597))
			{
				result = false;
			}
			return result;
		}

		public static void TriggerLunarApocalypse()
		{
			List<int> list = new List<int> { 517, 422, 507, 493 };
			int[] array = new int[4];
			for (int i = 0; i < 4; i++)
			{
				array[i] = list[Main.rand.Next(list.Count)];
				list.Remove(array[i]);
			}
			int num = Main.maxTilesX / 5;
			int num2 = (int)Main.worldSurface;
			for (int j = 0; j < 4; j++)
			{
				int num3 = num * (1 + j);
				bool flag = false;
				for (int k = 0; k < 30; k++)
				{
					int num4 = Main.rand.Next(-100, 101);
					if (Main.remixWorld && Main.getGoodWorld)
					{
						int num5 = Main.rand.Next((int)Main.worldSurface, Main.maxTilesY - 350);
						if (!PlayerLOS(num3 + num4 - 10, num5) && !PlayerLOS(num3 + num4 + 10, num5) && !PlayerLOS(num3 + num4 - 10, num5 - 20) && !PlayerLOS(num3 + num4 + 10, num5 - 20))
						{
							int num6 = NPC.NewNPC(new EntitySource_WorldEvent(), (num3 + num4) * 16, num5 * 16, array[j]);
							if (Main.netMode == 2 && num6 < 200)
							{
								NetMessage.SendData(23, -1, -1, null, num6);
							}
							flag = true;
							break;
						}
						continue;
					}
					for (int num7 = num2; num7 > 100; num7--)
					{
						if (!Collision.SolidTiles(num3 + num4 - 10, num3 + num4 + 10, num7 - 20, num7 + 15) && !PlayerLOS(num3 + num4 - 10, num7) && !PlayerLOS(num3 + num4 + 10, num7) && !PlayerLOS(num3 + num4 - 10, num7 - 20) && !PlayerLOS(num3 + num4 + 10, num7 - 20))
						{
							int num8 = NPC.NewNPC(new EntitySource_WorldEvent(), (num3 + num4) * 16, num7 * 16, array[j]);
							if (Main.netMode == 2 && num8 < 200)
							{
								NetMessage.SendData(23, -1, -1, null, num8);
							}
							flag = true;
							break;
						}
					}
					if (flag)
					{
						break;
					}
				}
				if (!flag)
				{
					NPC.NewNPC(new EntitySource_WorldEvent(), num3 * 16, (num2 - 40) * 16, array[j]);
				}
			}
			NPC.TowerActiveVortex = (NPC.TowerActiveNebula = (NPC.TowerActiveSolar = (NPC.TowerActiveStardust = true)));
			NPC.LunarApocalypseIsUp = true;
			NPC.ShieldStrengthTowerSolar = (NPC.ShieldStrengthTowerVortex = (NPC.ShieldStrengthTowerNebula = (NPC.ShieldStrengthTowerStardust = NPC.ShieldStrengthTowerMax)));
			NetMessage.SendData(101);
			MessageLunarApocalypse();
		}

		public static void UpdateLunarApocalypse()
		{
			if (!NPC.LunarApocalypseIsUp)
			{
				return;
			}
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			bool flag5 = false;
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active)
				{
					switch (Main.npc[i].type)
					{
					case 398:
						flag = true;
						break;
					case 517:
						flag2 = true;
						break;
					case 422:
						flag3 = true;
						break;
					case 507:
						flag4 = true;
						break;
					case 493:
						flag5 = true;
						break;
					}
				}
			}
			if (!flag2)
			{
				NPC.TowerActiveSolar = false;
			}
			if (!flag3)
			{
				NPC.TowerActiveVortex = false;
			}
			if (!flag4)
			{
				NPC.TowerActiveNebula = false;
			}
			if (!flag5)
			{
				NPC.TowerActiveStardust = false;
			}
			if (!NPC.TowerActiveSolar && !NPC.TowerActiveVortex && !NPC.TowerActiveNebula && !NPC.TowerActiveStardust && !flag)
			{
				StartImpendingDoom(3600);
			}
		}

		public static void StartImpendingDoom(int countdownTime)
		{
			NPC.LunarApocalypseIsUp = false;
			NPC.MaxMoonLordCountdown = countdownTime;
			NPC.MoonLordCountdown = NPC.MaxMoonLordCountdown;
			NetMessage.SendData(103);
			BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, 255, 130);
			if (Main.netMode != 1)
			{
				GetRidOfCultists();
			}
		}

		public static void GetRidOfCultists()
		{
			for (int i = 0; i < 200; i++)
			{
				if (Main.npc[i].active && (Main.npc[i].type == 437 || Main.npc[i].type == 438 || Main.npc[i].type == 379))
				{
					Main.npc[i].active = false;
					if (Main.netMode != 1)
					{
						NetMessage.SendData(23, -1, -1, null, i);
					}
				}
			}
		}

		public static void MessageLunarApocalypse()
		{
			if (NPC.LunarApocalypseIsUp)
			{
				int num = 0;
				if (!NPC.TowerActiveSolar)
				{
					num++;
				}
				if (!NPC.TowerActiveVortex)
				{
					num++;
				}
				if (!NPC.TowerActiveNebula)
				{
					num++;
				}
				if (!NPC.TowerActiveStardust)
				{
					num++;
				}
				BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, 255);
			}
		}

		public static void BroadcastText(NetworkText text, Vector4 color)
		{
			BroadcastText(text, new Color(color));
		}

		public static void BroadcastText(NetworkText text, Vector3 color)
		{
			BroadcastText(text, new Color(color));
		}

		public static void BroadcastText(NetworkText text, int r, int g, int b)
		{
			BroadcastText(text, new Color(r, g, b));
		}

		public static void BroadcastText(NetworkText text, byte r, byte g, byte b)
		{
			BroadcastText(text, new Color(r, g, b));
		}

		public static void BroadcastText(NetworkText text, Color color)
		{
			if (Main.netMode == 0)
			{
				Main.NewText(text.ToString(), color.R, color.G, color.B);
			}
			else if (Main.netMode == 2)
			{
				ChatHelper.BroadcastChatMessage(text, color);
			}
		}

		public static bool CanCutTile(int x, int y, TileCuttingContext context)
		{
			if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].type != 78 && Main.tile[x, y + 1].type != 380 && Main.tile[x, y + 1].type != 579)
			{
				if (Main.tile[x, y].type == 254)
				{
					return Main.tile[x, y].frameX >= 144;
				}
				return true;
			}
			return false;
		}

		public static bool InAPlaceWithWind(Vector2 position, int width, int height)
		{
			Point point = position.ToTileCoordinates();
			Point point2 = (position + new Vector2(width, height)).ToTileCoordinates();
			return InAPlaceWithWind(point.X, point.Y, 1 + point2.X - point.X, 1 + point2.Y - point.Y);
		}

		public static bool DoesWindBlowAtThisHeight(int tileY)
		{
			bool flag = (double)tileY < Main.worldSurface;
			if (Main.remixWorld)
			{
				flag = !flag;
			}
			return flag;
		}

		public static bool InAPlaceWithWind(int x, int y, int width, int height)
		{
			if (!DoesWindBlowAtThisHeight(y))
			{
				return false;
			}
			for (int i = 0; i < width; i++)
			{
				for (int j = 0; j < height; j++)
				{
					Tile tile = Main.tile[x + i, y + j];
					if (tile == null)
					{
						return false;
					}
					if (tile.liquid > 0 || (tile.wall > 0 && !WallID.Sets.AllowsWind[tile.wall]))
					{
						return false;
					}
				}
			}
			return true;
		}

		public static int[] CountTileTypesInWorld(params int[] oreTypes)
		{
			int[] array = new int[oreTypes.Length];
			for (int i = 0; i < Main.maxTilesX; i++)
			{
				for (int j = 0; j < Main.maxTilesY; j++)
				{
					Tile tile = Main.tile[i, j];
					if (!tile.active())
					{
						continue;
					}
					for (int k = 0; k < oreTypes.Length; k++)
					{
						if (oreTypes[k] == tile.type)
						{
							array[k]++;
							break;
						}
					}
				}
			}
			return array;
		}
	}
}
